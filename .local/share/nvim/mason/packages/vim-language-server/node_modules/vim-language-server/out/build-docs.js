/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 68:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/*
colors.js

Copyright (c) 2010

Marak Squires
Alexis Sellier (cloudhead)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var isHeadless = false;

if (typeof module !== 'undefined') {
  isHeadless = true;
}

if (!isHeadless) {
  var exports = {};
  var module = {};
  var colors = exports;
  exports.mode = "browser";
} else {
  exports.mode = "console";
}

//
// Prototypes the string object to have additional method calls that add terminal colors
//
var addProperty = function (color, func) {
  exports[color] = function (str) {
    return func.apply(str);
  };
  String.prototype.__defineGetter__(color, func);
};

function stylize(str, style) {

  var styles;

  if (exports.mode === 'console') {
    styles = {
      //styles
      'bold'      : ['\x1B[1m',  '\x1B[22m'],
      'italic'    : ['\x1B[3m',  '\x1B[23m'],
      'underline' : ['\x1B[4m',  '\x1B[24m'],
      'inverse'   : ['\x1B[7m',  '\x1B[27m'],
      'strikethrough' : ['\x1B[9m',  '\x1B[29m'],
      //text colors
      //grayscale
      'white'     : ['\x1B[37m', '\x1B[39m'],
      'grey'      : ['\x1B[90m', '\x1B[39m'],
      'black'     : ['\x1B[30m', '\x1B[39m'],
      //colors
      'blue'      : ['\x1B[34m', '\x1B[39m'],
      'cyan'      : ['\x1B[36m', '\x1B[39m'],
      'green'     : ['\x1B[32m', '\x1B[39m'],
      'magenta'   : ['\x1B[35m', '\x1B[39m'],
      'red'       : ['\x1B[31m', '\x1B[39m'],
      'yellow'    : ['\x1B[33m', '\x1B[39m'],
      //background colors
      //grayscale
      'whiteBG'     : ['\x1B[47m', '\x1B[49m'],
      'greyBG'      : ['\x1B[49;5;8m', '\x1B[49m'],
      'blackBG'     : ['\x1B[40m', '\x1B[49m'],
      //colors
      'blueBG'      : ['\x1B[44m', '\x1B[49m'],
      'cyanBG'      : ['\x1B[46m', '\x1B[49m'],
      'greenBG'     : ['\x1B[42m', '\x1B[49m'],
      'magentaBG'   : ['\x1B[45m', '\x1B[49m'],
      'redBG'       : ['\x1B[41m', '\x1B[49m'],
      'yellowBG'    : ['\x1B[43m', '\x1B[49m']
    };
  } else if (exports.mode === 'browser') {
    styles = {
      //styles
      'bold'      : ['<b>',  '</b>'],
      'italic'    : ['<i>',  '</i>'],
      'underline' : ['<u>',  '</u>'],
      'inverse'   : ['<span style="background-color:black;color:white;">',  '</span>'],
      'strikethrough' : ['<del>',  '</del>'],
      //text colors
      //grayscale
      'white'     : ['<span style="color:white;">',   '</span>'],
      'grey'      : ['<span style="color:gray;">',    '</span>'],
      'black'     : ['<span style="color:black;">',   '</span>'],
      //colors
      'blue'      : ['<span style="color:blue;">',    '</span>'],
      'cyan'      : ['<span style="color:cyan;">',    '</span>'],
      'green'     : ['<span style="color:green;">',   '</span>'],
      'magenta'   : ['<span style="color:magenta;">', '</span>'],
      'red'       : ['<span style="color:red;">',     '</span>'],
      'yellow'    : ['<span style="color:yellow;">',  '</span>'],
      //background colors
      //grayscale
      'whiteBG'     : ['<span style="background-color:white;">',   '</span>'],
      'greyBG'      : ['<span style="background-color:gray;">',    '</span>'],
      'blackBG'     : ['<span style="background-color:black;">',   '</span>'],
      //colors
      'blueBG'      : ['<span style="background-color:blue;">',    '</span>'],
      'cyanBG'      : ['<span style="background-color:cyan;">',    '</span>'],
      'greenBG'     : ['<span style="background-color:green;">',   '</span>'],
      'magentaBG'   : ['<span style="background-color:magenta;">', '</span>'],
      'redBG'       : ['<span style="background-color:red;">',     '</span>'],
      'yellowBG'    : ['<span style="background-color:yellow;">',  '</span>']
    };
  } else if (exports.mode === 'none') {
    return str + '';
  } else {
    console.log('unsupported mode, try "browser", "console" or "none"');
  }
  return styles[style][0] + str + styles[style][1];
}

function applyTheme(theme) {

  //
  // Remark: This is a list of methods that exist
  // on String that you should not overwrite.
  //
  var stringPrototypeBlacklist = [
    '__defineGetter__', '__defineSetter__', '__lookupGetter__', '__lookupSetter__', 'charAt', 'constructor',
    'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf', 'charCodeAt',
    'indexOf', 'lastIndexof', 'length', 'localeCompare', 'match', 'replace', 'search', 'slice', 'split', 'substring',
    'toLocaleLowerCase', 'toLocaleUpperCase', 'toLowerCase', 'toUpperCase', 'trim', 'trimLeft', 'trimRight'
  ];

  Object.keys(theme).forEach(function (prop) {
    if (stringPrototypeBlacklist.indexOf(prop) !== -1) {
      console.log('warn: '.red + ('String.prototype' + prop).magenta + ' is probably something you don\'t want to override. Ignoring style name');
    }
    else {
      if (typeof(theme[prop]) === 'string') {
        addProperty(prop, function () {
          return exports[theme[prop]](this);
        });
      }
      else {
        addProperty(prop, function () {
          var ret = this;
          for (var t = 0; t < theme[prop].length; t++) {
            ret = exports[theme[prop][t]](ret);
          }
          return ret;
        });
      }
    }
  });
}


//
// Iterate through all default styles and colors
//
var x = ['bold', 'underline', 'strikethrough', 'italic', 'inverse', 'grey', 'black', 'yellow', 'red', 'green', 'blue', 'white', 'cyan', 'magenta', 'greyBG', 'blackBG', 'yellowBG', 'redBG', 'greenBG', 'blueBG', 'whiteBG', 'cyanBG', 'magentaBG'];
x.forEach(function (style) {

  // __defineGetter__ at the least works in more browsers
  // http://robertnyman.com/javascript/javascript-getters-setters.html
  // Object.defineProperty only works in Chrome
  addProperty(style, function () {
    return stylize(this, style);
  });
});

function sequencer(map) {
  return function () {
    if (!isHeadless) {
      return this.replace(/( )/, '$1');
    }
    var exploded = this.split(""), i = 0;
    exploded = exploded.map(map);
    return exploded.join("");
  };
}

var rainbowMap = (function () {
  var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta']; //RoY G BiV
  return function (letter, i, exploded) {
    if (letter === " ") {
      return letter;
    } else {
      return stylize(letter, rainbowColors[i++ % rainbowColors.length]);
    }
  };
})();

exports.themes = {};

exports.addSequencer = function (name, map) {
  addProperty(name, sequencer(map));
};

exports.addSequencer('rainbow', rainbowMap);
exports.addSequencer('zebra', function (letter, i, exploded) {
  return i % 2 === 0 ? letter : letter.inverse;
});

exports.setTheme = function (theme) {
  if (typeof theme === 'string') {
    try {
      exports.themes[theme] = __webpack_require__(69)(theme);
      applyTheme(exports.themes[theme]);
      return exports.themes[theme];
    } catch (err) {
      console.log(err);
      return err;
    }
  } else {
    applyTheme(theme);
  }
};


addProperty('stripColors', function () {
  return ("" + this).replace(/\x1B\[\d+m/g, '');
});

// please no
function zalgo(text, options) {
  var soul = {
    "up" : [
      '̍', '̎', '̄', '̅',
      '̿', '̑', '̆', '̐',
      '͒', '͗', '͑', '̇',
      '̈', '̊', '͂', '̓',
      '̈', '͊', '͋', '͌',
      '̃', '̂', '̌', '͐',
      '̀', '́', '̋', '̏',
      '̒', '̓', '̔', '̽',
      '̉', 'ͣ', 'ͤ', 'ͥ',
      'ͦ', 'ͧ', 'ͨ', 'ͩ',
      'ͪ', 'ͫ', 'ͬ', 'ͭ',
      'ͮ', 'ͯ', '̾', '͛',
      '͆', '̚'
    ],
    "down" : [
      '̖', '̗', '̘', '̙',
      '̜', '̝', '̞', '̟',
      '̠', '̤', '̥', '̦',
      '̩', '̪', '̫', '̬',
      '̭', '̮', '̯', '̰',
      '̱', '̲', '̳', '̹',
      '̺', '̻', '̼', 'ͅ',
      '͇', '͈', '͉', '͍',
      '͎', '͓', '͔', '͕',
      '͖', '͙', '͚', '̣'
    ],
    "mid" : [
      '̕', '̛', '̀', '́',
      '͘', '̡', '̢', '̧',
      '̨', '̴', '̵', '̶',
      '͜', '͝', '͞',
      '͟', '͠', '͢', '̸',
      '̷', '͡', ' ҉'
    ]
  },
  all = [].concat(soul.up, soul.down, soul.mid),
  zalgo = {};

  function randomNumber(range) {
    var r = Math.floor(Math.random() * range);
    return r;
  }

  function is_char(character) {
    var bool = false;
    all.filter(function (i) {
      bool = (i === character);
    });
    return bool;
  }

  function heComes(text, options) {
    var result = '', counts, l;
    options = options || {};
    options["up"] = options["up"] || true;
    options["mid"] = options["mid"] || true;
    options["down"] = options["down"] || true;
    options["size"] = options["size"] || "maxi";
    text = text.split('');
    for (l in text) {
      if (is_char(l)) {
        continue;
      }
      result = result + text[l];
      counts = {"up" : 0, "down" : 0, "mid" : 0};
      switch (options.size) {
      case 'mini':
        counts.up = randomNumber(8);
        counts.min = randomNumber(2);
        counts.down = randomNumber(8);
        break;
      case 'maxi':
        counts.up = randomNumber(16) + 3;
        counts.min = randomNumber(4) + 1;
        counts.down = randomNumber(64) + 3;
        break;
      default:
        counts.up = randomNumber(8) + 1;
        counts.mid = randomNumber(6) / 2;
        counts.down = randomNumber(8) + 1;
        break;
      }

      var arr = ["up", "mid", "down"];
      for (var d in arr) {
        var index = arr[d];
        for (var i = 0 ; i <= counts[index]; i++) {
          if (options[index]) {
            result = result + soul[index][randomNumber(soul[index].length)];
          }
        }
      }
    }
    return result;
  }
  return heComes(text);
}


// don't summon zalgo
addProperty('zalgo', function () {
  return zalgo(this);
});


/***/ }),

/***/ 69:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 69;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 67:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs   = __webpack_require__(60),
  Path   = __webpack_require__(23),
  util   = __webpack_require__(10),
  colors = __webpack_require__(68),
  EE     = __webpack_require__(70).EventEmitter,
  fsExists = fs.exists ? fs.exists : Path.exists,
  fsExistsSync = fs.existsSync ? fs.existsSync : Path.existsSync;

module.exports = function(dir, iterator, options, callback){
  return FindUp(dir, iterator, options, callback);
};

function FindUp(dir, iterator, options, callback){
  if (!(this instanceof FindUp)) {
    return new FindUp(dir, iterator, options, callback);
  }
  if(typeof options === 'function'){
    callback = options;
    options = {};
  }
  options = options || {};

  EE.call(this);
  this.found = false;
  this.stopPlease = false;
  var self = this;

  if(typeof iterator === 'string'){
    var file = iterator;
    iterator = function(dir, cb){
      return fsExists(Path.join(dir, file), cb);
    };
  }

  if(callback) {
    this.on('found', function(dir){
      if(options.verbose) console.log(('found '+ dir ).green);
      callback(null, dir);
      self.stop();
    });

    this.on('end', function(){
      if(options.verbose) console.log('end'.grey);
      if(!self.found) callback(new Error('not found'));
    });

    this.on('error', function(err){
      if(options.verbose) console.log('error'.red, err);
      callback(err);
    });
  }

  this._find(dir, iterator, options, callback);
}
util.inherits(FindUp, EE);

FindUp.prototype._find = function(dir, iterator, options, callback){
  var self = this;

  iterator(dir, function(exists){
    if(options.verbose) console.log(('traverse '+ dir).grey);
    if(exists) {
      self.found = true;
      self.emit('found', dir);
    }

    var parentDir = Path.join(dir, '..');
    if (self.stopPlease) return self.emit('end');
    if (dir === parentDir) return self.emit('end');
    if(dir.indexOf('../../') !== -1 ) return self.emit('error', new Error(dir + ' is not correct.'));
    self._find(parentDir, iterator, options, callback);
  });
};

FindUp.prototype.stop = function(){
  this.stopPlease = true;
};

module.exports.FindUp = FindUp;

module.exports.sync = function(dir, iteratorSync){
  if(typeof iteratorSync === 'string'){
    var file = iteratorSync;
    iteratorSync = function(dir){
      return fsExistsSync(Path.join(dir, file));
    };
  }
  var initialDir = dir;
  while(dir !== Path.join(dir, '..')){
    if(dir.indexOf('../../') !== -1 ) throw new Error(initialDir + ' is not correct.');
    if(iteratorSync(dir)) return dir;
    dir = Path.join(dir, '..');
  }
  throw new Error('not found');
};


/***/ }),

/***/ 64:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.projectRootPatterns = exports.sortTexts = void 0;
exports.sortTexts = {
    one: "00001",
    two: "00002",
    three: "00003",
    four: "00004",
};
exports.projectRootPatterns = [".git", "autoload", "plugin"];


/***/ }),

/***/ 72:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.notIdentifierPattern = exports.expandPattern = exports.featurePattern = exports.commandPattern = exports.notFunctionPattern = exports.optionPattern = exports.builtinVariablePattern = exports.funcArgIdentifierPattern = exports.localIdentifierPattern = exports.scriptIdentifierPattern = exports.normalIdentifierPattern = exports.globalIdentifierPattern = exports.autocmdPattern = exports.highlightValuePattern = exports.highlightPattern = exports.highlightLinkPattern = exports.mapCommandPattern = exports.colorschemePattern = exports.wordNextPattern = exports.wordPrePattern = exports.builtinFunctionPattern = exports.keywordPattern = exports.commentPattern = exports.errorLinePattern = void 0;
exports.errorLinePattern = /[^:]+:\s*(.+?):\s*line\s*([0-9]+)\s*col\s*([0-9]+)/;
exports.commentPattern = /^[ \t]*("|')/;
exports.keywordPattern = /[\w#&$<>.:]/;
exports.builtinFunctionPattern = /^((<SID>|\b(v|g|b|s|l|a):)?[\w#&]+)[ \t]*\([^)]*\)/;
exports.wordPrePattern = /^.*?(((<SID>|\b(v|g|b|s|l|a):)?[\w#&$.]+)|(<SID>|<SID|<SI|<S|<|\b(v|g|b|s|l|a):))$/;
exports.wordNextPattern = /^((SID>|ID>|D>|>|<SID>|\b(v|g|b|s|l|a):)?[\w#&$.]+|(:[\w#&$.]+)).*?(\r\n|\r|\n)?$/;
exports.colorschemePattern = /\bcolorscheme[ \t]+\w*$/;
exports.mapCommandPattern = /^([ \t]*(\[ \t]*)?)\w*map[ \t]+/;
exports.highlightLinkPattern = /^[ \t]*(hi|highlight)[ \t]+link([ \t]+[^ \t]+)*[ \t]*$/;
exports.highlightPattern = /^[ \t]*(hi|highlight)([ \t]+[^ \t]+)*[ \t]*$/;
exports.highlightValuePattern = /^[ \t]*(hi|highlight)([ \t]+[^ \t]+)*[ \t]+([^ \t=]+)=[^ \t=]*$/;
exports.autocmdPattern = /^[ \t]*(au|autocmd)!?[ \t]+([^ \t,]+,)*[^ \t,]*$/;
exports.globalIdentifierPattern = /^((g|b):\w+(\.\w+)*|(\w+#)+\w*)$/;
exports.normalIdentifierPattern = /^([a-zA-Z_]\w*(\.\w+)*)$/;
exports.scriptIdentifierPattern = /^((s:|<SID>)\w+(\.\w+)*)$/;
exports.localIdentifierPattern = /^(l:\w+(\.\w+)*)$/;
exports.funcArgIdentifierPattern = /^(a:\w+(\.\w+)*)$/;
exports.builtinVariablePattern = [
    /\bv:\w*$/,
];
exports.optionPattern = [
    /(^|[ \t]+)&\w*$/,
    /(^|[ \t]+)set(l|local|g|global)?[ \t]+\w+$/,
];
exports.notFunctionPattern = [
    /^[ \t]*\\$/,
    /^[ \t]*\w+$/,
    /^[ \t]*"/,
    /(let|set|colorscheme)[ \t][^ \t]*$/,
    /[^([,\\ \t\w#>]\w*$/,
    /^[ \t]*(hi|highlight)([ \t]+link)?([ \t]+[^ \t]+)*[ \t]*$/,
    exports.autocmdPattern,
];
exports.commandPattern = [
    /(^|[ \t]):\w+$/,
    /^[ \t]*\w+$/,
    /:?silent!?[ \t]\w+/,
];
exports.featurePattern = [
    /\bhas\([ \t]*["']\w*/,
];
exports.expandPattern = [
    /\bexpand\(['"]<\w*$/,
    /\bexpand\([ \t]*['"]\w*$/,
];
exports.notIdentifierPattern = [
    exports.commentPattern,
    /("|'):\w*$/,
    /^[ \t]*\\$/,
    /^[ \t]*call[ \t]+[^ \t()]*$/,
    /('|"|#|&|\$|<)\w*$/,
];


/***/ }),

/***/ 66:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.delay = exports.getRealPath = exports.isSymbolLink = exports.removeSnippets = exports.handleParse = exports.getWordFromPosition = exports.markupSnippets = exports.findProjectRoot = exports.pcb = exports.executeFile = exports.isSomeMatchPattern = void 0;
var child_process_1 = __webpack_require__(61);
var findup_1 = __importDefault(__webpack_require__(67));
var fs_1 = __importDefault(__webpack_require__(60));
var path_1 = __importDefault(__webpack_require__(23));
var vscode_languageserver_1 = __webpack_require__(2);
var vimparser_1 = __webpack_require__(71);
var patterns_1 = __webpack_require__(72);
var config_1 = __importDefault(__webpack_require__(73));
// FIXME vimlparser missing update builtin_commands
if (vimparser_1.VimLParser.prototype) {
    (_a = vimparser_1.VimLParser.prototype.builtin_commands) === null || _a === void 0 ? void 0 : _a.push({
        name: 'balt',
        minlen: 4,
        flags: 'NEEDARG|FILE1|EDITCMD|TRLBAR|CMDWIN',
        parser: 'parse_cmd_common'
    });
}
function isSomeMatchPattern(patterns, line) {
    return patterns.some(function (p) { return p.test(line); });
}
exports.isSomeMatchPattern = isSomeMatchPattern;
function executeFile(input, command, args, option) {
    return new Promise(function (resolve, reject) {
        var stdout = "";
        var stderr = "";
        var error;
        var isPassAsText = false;
        args = (args || []).map(function (arg) {
            if (/%text/.test(arg)) {
                isPassAsText = true;
                return arg.replace(/%text/g, input.toString());
            }
            return arg;
        });
        var cp = child_process_1.spawn(command, args, option);
        cp.stdout.on("data", function (data) {
            stdout += data;
        });
        cp.stderr.on("data", function (data) {
            stderr += data;
        });
        cp.on("error", function (err) {
            error = err;
            reject(error);
        });
        cp.on("close", function (code) {
            if (!error) {
                resolve({ code: code, stdout: stdout, stderr: stderr });
            }
        });
        // error will occur when cp get error
        if (!isPassAsText) {
            input.pipe(cp.stdin).on("error", function () { return; });
        }
    });
}
exports.executeFile = executeFile;
// cover cb type async function to promise
function pcb(cb) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return new Promise(function (resolve) {
            cb.apply(void 0, __spreadArray(__spreadArray([], args), [function () {
                    var params = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        params[_i] = arguments[_i];
                    }
                    resolve(params);
                }]));
        });
    };
}
exports.pcb = pcb;
// find work dirname by root patterns
function findProjectRoot(filePath, rootPatterns) {
    return __awaiter(this, void 0, void 0, function () {
        var dirname, patterns, dirCandidate, _i, patterns_2, pattern, _a, err, dir;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    dirname = path_1.default.dirname(filePath);
                    patterns = [].concat(rootPatterns);
                    dirCandidate = "";
                    _i = 0, patterns_2 = patterns;
                    _b.label = 1;
                case 1:
                    if (!(_i < patterns_2.length)) return [3 /*break*/, 4];
                    pattern = patterns_2[_i];
                    return [4 /*yield*/, pcb(findup_1.default)(dirname, pattern)];
                case 2:
                    _a = _b.sent(), err = _a[0], dir = _a[1];
                    if (!err && dir && dir !== "/" && dir.length > dirCandidate.length) {
                        dirCandidate = dir;
                    }
                    _b.label = 3;
                case 3:
                    _i++;
                    return [3 /*break*/, 1];
                case 4:
                    if (dirCandidate.length) {
                        return [2 /*return*/, dirCandidate];
                    }
                    return [2 /*return*/, dirname];
            }
        });
    });
}
exports.findProjectRoot = findProjectRoot;
function markupSnippets(snippets) {
    return [
        "```vim",
        snippets.replace(/\$\{[0-9]+(:([^}]+))?\}/g, "$2"),
        "```",
    ].join("\n");
}
exports.markupSnippets = markupSnippets;
function getWordFromPosition(doc, position) {
    if (!doc) {
        return;
    }
    // invalid character which less than 0
    if (position.character < 0) {
        return;
    }
    var character = doc.getText(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(position.line, position.character), vscode_languageserver_1.Position.create(position.line, position.character + 1)));
    // not keyword position
    if (!character || !patterns_1.keywordPattern.test(character)) {
        return;
    }
    var currentLine = doc.getText(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(position.line, 0), vscode_languageserver_1.Position.create(position.line + 1, 0)));
    // comment line
    if (patterns_1.commentPattern.test(currentLine)) {
        return;
    }
    var preSegment = currentLine.slice(0, position.character);
    var nextSegment = currentLine.slice(position.character);
    var wordLeft = preSegment.match(patterns_1.wordPrePattern);
    var wordRight = nextSegment.match(patterns_1.wordNextPattern);
    var word = "" + (wordLeft && wordLeft[1] || "") + (wordRight && wordRight[1] || "");
    return {
        word: word,
        left: wordLeft && wordLeft[1] || "",
        right: wordRight && wordRight[1] || "",
        wordLeft: wordLeft && wordLeft[1]
            ? preSegment.replace(new RegExp(wordLeft[1] + "$"), word)
            : "" + preSegment + word,
        wordRight: wordRight && wordRight[1]
            ? nextSegment.replace(new RegExp("^" + wordRight[1]), word)
            : "" + word + nextSegment,
    };
}
exports.getWordFromPosition = getWordFromPosition;
// parse vim buffer
function handleParse(textDoc) {
    return __awaiter(this, void 0, void 0, function () {
        var text, tokens, node;
        return __generator(this, function (_a) {
            text = textDoc instanceof Object ? textDoc.getText() : textDoc;
            tokens = new vimparser_1.StringReader(text.split(/\r\n|\r|\n/));
            try {
                node = new vimparser_1.VimLParser(config_1.default.isNeovim).parse(tokens);
                return [2 /*return*/, [node, ""]];
            }
            catch (error) {
                return [2 /*return*/, [null, error]];
            }
            return [2 /*return*/];
        });
    });
}
exports.handleParse = handleParse;
// remove snippets of completionItem
function removeSnippets(completionItems) {
    if (completionItems === void 0) { completionItems = []; }
    return completionItems.map(function (item) {
        if (item.insertTextFormat === vscode_languageserver_1.InsertTextFormat.Snippet) {
            return __assign(__assign({}, item), { insertText: item.label, insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText });
        }
        return item;
    });
}
exports.removeSnippets = removeSnippets;
var isSymbolLink = function (filePath) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        return [2 /*return*/, new Promise(function (resolve) {
                fs_1.default.lstat(filePath, function (err, stats) {
                    resolve({
                        err: err,
                        stats: stats && stats.isSymbolicLink(),
                    });
                });
            })];
    });
}); };
exports.isSymbolLink = isSymbolLink;
var getRealPath = function (filePath) { return __awaiter(void 0, void 0, void 0, function () {
    var _a, err, stats;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0: return [4 /*yield*/, exports.isSymbolLink(filePath)];
            case 1:
                _a = _b.sent(), err = _a.err, stats = _a.stats;
                if (!err && stats) {
                    return [2 /*return*/, new Promise(function (resolve) {
                            fs_1.default.realpath(filePath, function (error, realPath) {
                                if (error) {
                                    return resolve(filePath);
                                }
                                resolve(realPath);
                            });
                        })];
                }
                return [2 /*return*/, filePath];
        }
    });
}); };
exports.getRealPath = getRealPath;
var delay = function (ms) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, new Promise(function (res) {
                    setTimeout(function () {
                        res();
                    }, ms);
                })];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    });
}); };
exports.delay = delay;


/***/ }),

/***/ 391:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
/*
 * vim builtin completion items
 *
 * 1. functions
 * 2. options
 * 3. variables
 * 4. commands
 * 5. has features
 * 6. expand Keyword
 */
var fs_1 = __webpack_require__(60);
var path_1 = __webpack_require__(23);
var vscode_languageserver_1 = __webpack_require__(2);
var constant_1 = __webpack_require__(64);
var util_1 = __webpack_require__(66);
var EVAL_PATH = "/doc/eval.txt";
var OPTIONS_PATH = "/doc/options.txt";
var INDEX_PATH = "/doc/index.txt";
var API_PATH = "/doc/api.txt";
var AUTOCMD_PATH = "/doc/autocmd.txt";
var POPUP_PATH = "/doc/popup.txt";
var CHANNEL_PATH = "/doc/channel.txt";
var TEXTPROP_PATH = "/doc/textprop.txt";
var TERMINAL_PATH = "/doc/terminal.txt";
var TESTING_PATH = "/doc/testing.txt";
var Server = /** @class */ (function () {
    function Server(config) {
        this.config = config;
        // completion items
        this.vimPredefinedVariablesItems = [];
        this.vimOptionItems = [];
        this.vimBuiltinFunctionItems = [];
        this.vimCommandItems = [];
        this.vimFeatureItems = [];
        this.vimExpandKeywordItems = [];
        this.vimAutocmdItems = [];
        // documents
        this.vimBuiltFunctionDocuments = {};
        this.vimOptionDocuments = {};
        this.vimPredefinedVariableDocuments = {};
        this.vimCommandDocuments = {};
        this.vimFeatureDocuments = {};
        this.expandKeywordDocuments = {};
        // signature help
        this.vimBuiltFunctionSignatureHelp = {};
        // raw docs
        this.text = {};
    }
    Server.prototype.build = function () {
        return __awaiter(this, void 0, void 0, function () {
            var vimruntime, paths, index, p, _a, err, data;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        vimruntime = this.config.vimruntime;
                        if (!vimruntime) return [3 /*break*/, 5];
                        paths = [
                            EVAL_PATH,
                            OPTIONS_PATH,
                            INDEX_PATH,
                            API_PATH,
                            AUTOCMD_PATH,
                            POPUP_PATH,
                            CHANNEL_PATH,
                            TEXTPROP_PATH,
                            TERMINAL_PATH,
                            TESTING_PATH,
                        ];
                        index = 0;
                        _b.label = 1;
                    case 1:
                        if (!(index < paths.length)) return [3 /*break*/, 4];
                        p = path_1.join(vimruntime, paths[index]);
                        return [4 /*yield*/, util_1.pcb(fs_1.readFile)(p, "utf-8")];
                    case 2:
                        _a = _b.sent(), err = _a[0], data = _a[1];
                        if (err) {
                            // tslint:disable-next-line: no-console
                            console.error("[vimls]: read " + p + " error: " + err.message);
                        }
                        this.text[paths[index]] = (data && data.toString().split("\n")) || [];
                        _b.label = 3;
                    case 3:
                        index++;
                        return [3 /*break*/, 1];
                    case 4:
                        this.resolveVimPredefinedVariables();
                        this.resolveVimOptions();
                        this.resolveBuiltinFunctions();
                        this.resolveBuiltinFunctionsDocument();
                        this.resolveBuiltinVimPopupFunctionsDocument();
                        this.resolveBuiltinVimChannelFunctionsDocument();
                        this.resolveBuiltinVimJobFunctionsDocument();
                        this.resolveBuiltinVimTextpropFunctionsDocument();
                        this.resolveBuiltinVimTerminalFunctionsDocument();
                        this.resolveBuiltinVimTestingFunctionsDocument();
                        this.resolveBuiltinNvimFunctions();
                        this.resolveExpandKeywords();
                        this.resolveVimCommands();
                        this.resolveVimFeatures();
                        this.resolveVimAutocmds();
                        _b.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    Server.prototype.serialize = function () {
        var str = JSON.stringify({
            completionItems: {
                commands: this.vimCommandItems,
                functions: this.vimBuiltinFunctionItems,
                variables: this.vimPredefinedVariablesItems,
                options: this.vimOptionItems,
                features: this.vimFeatureItems,
                expandKeywords: this.vimExpandKeywordItems,
                autocmds: this.vimAutocmdItems,
            },
            signatureHelp: this.vimBuiltFunctionSignatureHelp,
            documents: {
                commands: this.vimCommandDocuments,
                functions: this.vimBuiltFunctionDocuments,
                variables: this.vimPredefinedVariableDocuments,
                options: this.vimOptionDocuments,
                features: this.vimFeatureDocuments,
                expandKeywords: this.expandKeywordDocuments,
            },
        }, null, 2);
        fs_1.writeFileSync("./src/docs/builtin-docs.json", str, "utf-8");
    };
    Server.prototype.formatFunctionSnippets = function (fname, snippets) {
        if (snippets === "") {
            return fname + "(${0})";
        }
        var idx = 0;
        if (/^\[.+\]/.test(snippets)) {
            return fname + "(${1})${0}";
        }
        var str = snippets.split("[")[0].trim().replace(/\{?(\w+)\}?/g, function (m, g1) {
            return "${" + (idx += 1) + ":" + g1 + "}";
        });
        return fname + "(" + str + ")${0}";
    };
    // get vim predefined variables from vim document eval.txt
    Server.prototype.resolveVimPredefinedVariables = function () {
        var evalText = this.text[EVAL_PATH] || [];
        var isMatchLine = false;
        var completionItem;
        for (var _i = 0, evalText_1 = evalText; _i < evalText_1.length; _i++) {
            var line = evalText_1[_i];
            if (!isMatchLine) {
                if (/\*vim-variable\*/.test(line)) {
                    isMatchLine = true;
                }
                continue;
            }
            else {
                var m = line.match(/^(v:[^ \t]+)[ \t]+([^ ].*)$/);
                if (m) {
                    if (completionItem) {
                        this.vimPredefinedVariablesItems.push(completionItem);
                        this.vimPredefinedVariableDocuments[completionItem.label].pop();
                        completionItem = undefined;
                    }
                    var label = m[1];
                    completionItem = {
                        label: label,
                        kind: vscode_languageserver_1.CompletionItemKind.Variable,
                        sortText: constant_1.sortTexts.four,
                        insertText: label.slice(2),
                        insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
                    };
                    if (!this.vimPredefinedVariableDocuments[label]) {
                        this.vimPredefinedVariableDocuments[label] = [];
                    }
                    this.vimPredefinedVariableDocuments[label].push(m[2]);
                }
                else if (/^\s*$/.test(line) && completionItem) {
                    this.vimPredefinedVariablesItems.push(completionItem);
                    completionItem = undefined;
                }
                else if (completionItem) {
                    this.vimPredefinedVariableDocuments[completionItem.label].push(line);
                }
                else if (/===============/.test(line)) {
                    break;
                }
            }
        }
    };
    // get vim options from vim document options.txt
    Server.prototype.resolveVimOptions = function () {
        var optionsText = this.text[OPTIONS_PATH] || [];
        var isMatchLine = false;
        var completionItem;
        for (var _i = 0, optionsText_1 = optionsText; _i < optionsText_1.length; _i++) {
            var line = optionsText_1[_i];
            if (!isMatchLine) {
                if (/\*'aleph'\*/.test(line)) {
                    isMatchLine = true;
                }
                continue;
            }
            else {
                var m = line.match(/^'([^']+)'[ \t]+('[^']+')?[ \t]+([^ \t].*)$/);
                if (m) {
                    var label = m[1];
                    completionItem = {
                        label: label,
                        kind: vscode_languageserver_1.CompletionItemKind.Property,
                        detail: m[3].trim().split(/[ \t]/)[0],
                        documentation: "",
                        sortText: "00004",
                        insertText: m[1],
                        insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
                    };
                    if (!this.vimOptionDocuments[label]) {
                        this.vimOptionDocuments[label] = [];
                    }
                    this.vimOptionDocuments[label].push(m[3]);
                }
                else if (/^\s*$/.test(line) && completionItem) {
                    this.vimOptionItems.push(completionItem);
                    completionItem = undefined;
                }
                else if (completionItem) {
                    this.vimOptionDocuments[completionItem.label].push(line);
                }
            }
        }
    };
    // get vim builtin function from document eval.txt
    Server.prototype.resolveBuiltinFunctions = function () {
        var evalText = this.text[EVAL_PATH] || [];
        var isMatchLine = false;
        var completionItem;
        for (var _i = 0, evalText_2 = evalText; _i < evalText_2.length; _i++) {
            var line = evalText_2[_i];
            if (!isMatchLine) {
                if (/\*functions\*/.test(line)) {
                    isMatchLine = true;
                }
                continue;
            }
            else {
                var m = line.match(/^((\w+)\(([^)]*)\))[ \t]*([^ \t].*)?$/);
                if (m) {
                    if (completionItem) {
                        this.vimBuiltinFunctionItems.push(completionItem);
                    }
                    var label = m[2];
                    completionItem = {
                        label: label,
                        kind: vscode_languageserver_1.CompletionItemKind.Function,
                        detail: (m[4] || "").split(/[ \t]/)[0],
                        sortText: "00004",
                        insertText: this.formatFunctionSnippets(m[2], m[3]),
                        insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
                    };
                    this.vimBuiltFunctionSignatureHelp[label] = [
                        m[3],
                        (m[4] || "").split(/[ \t]/)[0],
                    ];
                }
                else if (/^[ \t]*$/.test(line)) {
                    if (completionItem) {
                        this.vimBuiltinFunctionItems.push(completionItem);
                        completionItem = undefined;
                        break;
                    }
                }
                else if (completionItem) {
                    if (completionItem.detail === "") {
                        completionItem.detail = line.trim().split(/[ \t]/)[0];
                        if (this.vimBuiltFunctionSignatureHelp[completionItem.label]) {
                            this.vimBuiltFunctionSignatureHelp[completionItem.label][1] = line.trim().split(/[ \t]/)[0];
                        }
                    }
                }
            }
        }
    };
    Server.prototype.resolveBuiltinFunctionsDocument = function () {
        var evalText = this.text[EVAL_PATH] || [];
        var isMatchLine = false;
        var label = "";
        for (var idx = 0; idx < evalText.length; idx++) {
            var line = evalText[idx];
            if (!isMatchLine) {
                if (/\*abs\(\)\*/.test(line)) {
                    isMatchLine = true;
                    idx -= 1;
                }
                continue;
            }
            else {
                var m = line.match(/^((\w+)\(([^)]*)\))[ \t]*([^ \t].*)?$/);
                if (m) {
                    if (label) {
                        this.vimBuiltFunctionDocuments[label].pop();
                    }
                    label = m[2];
                    if (!this.vimBuiltFunctionDocuments[label]) {
                        this.vimBuiltFunctionDocuments[label] = [];
                    }
                }
                else if (/^[ \t]*\*string-match\*[ \t]*$/.test(line)) {
                    if (label) {
                        this.vimBuiltFunctionDocuments[label].pop();
                    }
                    break;
                }
                else if (label) {
                    this.vimBuiltFunctionDocuments[label].push(line);
                }
            }
        }
    };
    Server.prototype.resolveBuiltinVimPopupFunctionsDocument = function () {
        var popupText = this.text[POPUP_PATH] || [];
        var isMatchLine = false;
        var label = "";
        for (var idx = 0; idx < popupText.length; idx++) {
            var line = popupText[idx];
            if (!isMatchLine) {
                if (/^DETAILS\s+\*popup-function-details\*/.test(line)) {
                    isMatchLine = true;
                    idx += 1;
                }
                continue;
            }
            else {
                var m = line.match(/^((\w+)\(([^)]*)\))[ \t]*([^ \t].*)?$/);
                if (m) {
                    if (label) {
                        this.vimBuiltFunctionDocuments[label].pop();
                    }
                    label = m[2];
                    if (!this.vimBuiltFunctionDocuments[label]) {
                        this.vimBuiltFunctionDocuments[label] = [];
                    }
                }
                else if (/^=+$/.test(line)) {
                    if (label) {
                        this.vimBuiltFunctionDocuments[label].pop();
                    }
                    break;
                }
                else if (label) {
                    this.vimBuiltFunctionDocuments[label].push(line);
                }
            }
        }
    };
    Server.prototype.resolveBuiltinVimChannelFunctionsDocument = function () {
        var channelText = this.text[CHANNEL_PATH] || [];
        var isMatchLine = false;
        var label = "";
        for (var idx = 0; idx < channelText.length; idx++) {
            var line = channelText[idx];
            if (!isMatchLine) {
                if (/^8\.\sChannel\sfunctions\sdetails\s+\*channel-functions-details\*/.test(line)) {
                    isMatchLine = true;
                    idx += 1;
                }
                continue;
            }
            else {
                var m = line.match(/^((\w+)\(([^)]*)\))[ \t]*([^ \t].*)?$/);
                if (m) {
                    if (label) {
                        this.vimBuiltFunctionDocuments[label].pop();
                    }
                    label = m[2];
                    if (!this.vimBuiltFunctionDocuments[label]) {
                        this.vimBuiltFunctionDocuments[label] = [];
                    }
                }
                else if (/^=+$/.test(line)) {
                    if (label) {
                        this.vimBuiltFunctionDocuments[label].pop();
                    }
                    break;
                }
                else if (label) {
                    this.vimBuiltFunctionDocuments[label].push(line);
                }
            }
        }
    };
    Server.prototype.resolveBuiltinVimJobFunctionsDocument = function () {
        var channelText = this.text[CHANNEL_PATH] || [];
        var isMatchLine = false;
        var label = "";
        for (var idx = 0; idx < channelText.length; idx++) {
            var line = channelText[idx];
            if (!isMatchLine) {
                if (/^11\.\sJob\sfunctions\s+\*job-functions-details\*/.test(line)) {
                    isMatchLine = true;
                    idx += 1;
                }
                continue;
            }
            else {
                var m = line.match(/^((\w+)\(([^)]*)\))[ \t]*([^ \t].*)?$/);
                if (m) {
                    if (label) {
                        this.vimBuiltFunctionDocuments[label].pop();
                    }
                    label = m[2];
                    if (!this.vimBuiltFunctionDocuments[label]) {
                        this.vimBuiltFunctionDocuments[label] = [];
                    }
                }
                else if (/^=+$/.test(line)) {
                    if (label) {
                        this.vimBuiltFunctionDocuments[label].pop();
                    }
                    break;
                }
                else if (label) {
                    this.vimBuiltFunctionDocuments[label].push(line);
                }
            }
        }
    };
    Server.prototype.resolveBuiltinVimTextpropFunctionsDocument = function () {
        var textpropText = this.text[TEXTPROP_PATH] || [];
        var isMatchLine = false;
        var label = "";
        // tslint:disable-next-line: prefer-for-of
        for (var idx = 0; idx < textpropText.length; idx++) {
            var line = textpropText[idx];
            if (!isMatchLine) {
                if (/^\s+\*prop_add\(\)\*\s\*E965/.test(line)) {
                    isMatchLine = true;
                }
                continue;
            }
            else {
                var m = line.match(/^((\w+)\(([^)]*)\))[ \t]*([^ \t].*)?$/);
                if (m) {
                    if (label) {
                        this.vimBuiltFunctionDocuments[label].pop();
                    }
                    label = m[2];
                    if (!this.vimBuiltFunctionDocuments[label]) {
                        this.vimBuiltFunctionDocuments[label] = [];
                    }
                }
                else if (/^=+$/.test(line)) {
                    if (label) {
                        this.vimBuiltFunctionDocuments[label].pop();
                    }
                    break;
                }
                else if (label) {
                    this.vimBuiltFunctionDocuments[label].push(line);
                }
            }
        }
    };
    Server.prototype.resolveBuiltinVimTerminalFunctionsDocument = function () {
        var terminalText = this.text[TERMINAL_PATH] || [];
        var isMatchLine = false;
        var label = "";
        // tslint:disable-next-line: prefer-for-of
        for (var idx = 0; idx < terminalText.length; idx++) {
            var line = terminalText[idx];
            if (!isMatchLine) {
                if (/^\s+\*term_dumpdiff\(\)/.test(line)) {
                    isMatchLine = true;
                }
                continue;
            }
            else {
                var m = line.match(/^((\w+)\(([^)]*)\))[ \t]*([^ \t].*)?$/);
                if (m) {
                    if (label) {
                        this.vimBuiltFunctionDocuments[label].pop();
                    }
                    label = m[2];
                    if (!this.vimBuiltFunctionDocuments[label]) {
                        this.vimBuiltFunctionDocuments[label] = [];
                    }
                }
                else if (/^=+$/.test(line)) {
                    if (label) {
                        this.vimBuiltFunctionDocuments[label].pop();
                    }
                    break;
                }
                else if (label) {
                    this.vimBuiltFunctionDocuments[label].push(line);
                }
            }
        }
    };
    Server.prototype.resolveBuiltinVimTestingFunctionsDocument = function () {
        var testingText = this.text[TESTING_PATH] || [];
        var isMatchLine = false;
        var label = "";
        // tslint:disable-next-line: prefer-for-of
        for (var idx = 0; idx < testingText.length; idx++) {
            var line = testingText[idx];
            if (!isMatchLine) {
                if (/^2\.\sTest\sfunctions\s+\*test-functions-details\*/.test(line)) {
                    isMatchLine = true;
                    idx += 1;
                }
                continue;
            }
            else {
                var m = line.match(/^((\w+)\(([^)]*)\))[ \t]*([^ \t].*)?$/);
                if (m) {
                    if (label) {
                        this.vimBuiltFunctionDocuments[label].pop();
                    }
                    label = m[2];
                    if (!this.vimBuiltFunctionDocuments[label]) {
                        this.vimBuiltFunctionDocuments[label] = [];
                    }
                }
                else if (/^=+$/.test(line)) {
                    if (label) {
                        this.vimBuiltFunctionDocuments[label].pop();
                    }
                    break;
                }
                else if (label) {
                    this.vimBuiltFunctionDocuments[label].push(line);
                }
            }
        }
    };
    Server.prototype.resolveBuiltinNvimFunctions = function () {
        var evalText = this.text[API_PATH] || [];
        var completionItem;
        var pattern = /^((nvim_\w+)\(([^)]*)\))[ \t]*/m;
        for (var idx = 0; idx < evalText.length; idx++) {
            var line = evalText[idx];
            var m = line.match(pattern);
            if (!m && evalText[idx + 1]) {
                m = [line, evalText[idx + 1].trim()].join(" ").match(pattern);
                if (m) {
                    idx++;
                }
            }
            if (m) {
                if (completionItem) {
                    this.vimBuiltinFunctionItems.push(completionItem);
                    if (this.vimBuiltFunctionDocuments[completionItem.label]) {
                        this.vimBuiltFunctionDocuments[completionItem.label].pop();
                    }
                }
                var label = m[2];
                completionItem = {
                    label: label,
                    kind: vscode_languageserver_1.CompletionItemKind.Function,
                    detail: "",
                    documentation: "",
                    sortText: "00004",
                    insertText: this.formatFunctionSnippets(m[2], m[3]),
                    insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
                };
                if (!this.vimBuiltFunctionDocuments[label]) {
                    this.vimBuiltFunctionDocuments[label] = [];
                }
                this.vimBuiltFunctionSignatureHelp[label] = [
                    m[3],
                    "",
                ];
            }
            else if (/^(================|[ \t]*vim:tw=78:ts=8:ft=help:norl:)/.test(line)) {
                if (completionItem) {
                    this.vimBuiltinFunctionItems.push(completionItem);
                    if (this.vimBuiltFunctionDocuments[completionItem.label]) {
                        this.vimBuiltFunctionDocuments[completionItem.label].pop();
                    }
                    completionItem = undefined;
                }
            }
            else if (completionItem && !/^[ \t]\*nvim(_\w+)+\(\)\*\s*$/.test(line)) {
                this.vimBuiltFunctionDocuments[completionItem.label].push(line);
            }
        }
    };
    Server.prototype.resolveVimCommands = function () {
        var indexText = this.text[INDEX_PATH] || [];
        var isMatchLine = false;
        var completionItem;
        for (var _i = 0, indexText_1 = indexText; _i < indexText_1.length; _i++) {
            var line = indexText_1[_i];
            if (!isMatchLine) {
                if (/\*ex-cmd-index\*/.test(line)) {
                    isMatchLine = true;
                }
                continue;
            }
            else {
                var m = line.match(/^\|?:([^ \t]+?)\|?[ \t]+:([^ \t]+)[ \t]+([^ \t].*)$/);
                if (m) {
                    if (completionItem) {
                        this.vimCommandItems.push(completionItem);
                    }
                    var label = m[1];
                    completionItem = {
                        label: m[1],
                        kind: vscode_languageserver_1.CompletionItemKind.Operator,
                        detail: m[2],
                        documentation: m[3],
                        sortText: "00004",
                        insertText: m[1],
                        insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
                    };
                    if (!this.vimCommandDocuments[label]) {
                        this.vimCommandDocuments[label] = [];
                    }
                    this.vimCommandDocuments[label].push(m[3]);
                }
                else if (/^[ \t]*$/.test(line)) {
                    if (completionItem) {
                        this.vimCommandItems.push(completionItem);
                        completionItem = undefined;
                        break;
                    }
                }
                else if (completionItem) {
                    completionItem.documentation += " " + line.trim();
                    this.vimCommandDocuments[completionItem.label].push(line);
                }
            }
        }
    };
    Server.prototype.resolveVimFeatures = function () {
        var text = this.text[EVAL_PATH] || [];
        var isMatchLine = false;
        var completionItem;
        var features = [];
        for (var idx = 0; idx < text.length; idx++) {
            var line = text[idx];
            if (!isMatchLine) {
                if (/^[ \t]*acl[ \t]/.test(line)) {
                    isMatchLine = true;
                    idx -= 1;
                }
                continue;
            }
            else {
                var m = line.match(/^[ \t]*\*?([^ \t]+?)\*?[ \t]+([^ \t].*)$/);
                if (m) {
                    if (completionItem) {
                        features.push(completionItem);
                    }
                    var label = m[1];
                    completionItem = {
                        label: m[1],
                        kind: vscode_languageserver_1.CompletionItemKind.EnumMember,
                        documentation: "",
                        sortText: "00004",
                        insertText: m[1],
                        insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
                    };
                    if (!this.vimFeatureDocuments[label]) {
                        this.vimFeatureDocuments[label] = [];
                    }
                    this.vimFeatureDocuments[label].push(m[2]);
                }
                else if (/^[ \t]*$/.test(line)) {
                    if (completionItem) {
                        features.push(completionItem);
                        break;
                    }
                }
                else if (completionItem) {
                    this.vimFeatureDocuments[completionItem.label].push(line);
                }
            }
        }
        this.vimFeatureItems = features;
    };
    Server.prototype.resolveVimAutocmds = function () {
        var text = this.text[AUTOCMD_PATH] || [];
        var isMatchLine = false;
        for (var idx = 0; idx < text.length; idx++) {
            var line = text[idx];
            if (!isMatchLine) {
                if (/^\|BufNewFile\|/.test(line)) {
                    isMatchLine = true;
                    idx -= 1;
                }
                continue;
            }
            else {
                var m = line.match(/^\|([^ \t]+)\|[ \t]+([^ \t].*)$/);
                if (m) {
                    this.vimAutocmdItems.push({
                        label: m[1],
                        kind: vscode_languageserver_1.CompletionItemKind.EnumMember,
                        documentation: m[2],
                        sortText: "00004",
                        insertText: m[1],
                        insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
                    });
                    if (m[1] === "Signal") {
                        break;
                    }
                }
            }
        }
    };
    Server.prototype.resolveExpandKeywords = function () {
        var _this = this;
        this.vimExpandKeywordItems = [
            "<cfile>,file name under the cursor",
            "<afile>,autocmd file name",
            "<abuf>,autocmd buffer number (as a String!)",
            "<amatch>,autocmd matched name",
            "<sfile>,sourced script file or function name",
            "<slnum>,sourced script file line number",
            "<cword>,word under the cursor",
            "<cWORD>,WORD under the cursor",
            "<client>,the {clientid} of the last received message `server2client()`",
        ].map(function (line) {
            var item = line.split(",");
            _this.expandKeywordDocuments[item[0]] = [
                item[1],
            ];
            return {
                label: item[0],
                kind: vscode_languageserver_1.CompletionItemKind.Keyword,
                documentation: item[1],
                sortText: "00004",
                insertText: item[0],
                insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
            };
        });
    };
    return Server;
}());
function main() {
    return __awaiter(this, void 0, void 0, function () {
        var servers, idx, server;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    servers = [];
                    idx = 2;
                    _a.label = 1;
                case 1:
                    if (!(idx < process.argv.length)) return [3 /*break*/, 4];
                    servers.push(new Server({
                        vimruntime: process.argv[idx],
                    }));
                    return [4 /*yield*/, servers[servers.length - 1].build()];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3:
                    idx++;
                    return [3 /*break*/, 1];
                case 4:
                    server = servers.reduce(function (pre, next) {
                        // merge functions
                        next.vimBuiltinFunctionItems.forEach(function (item) {
                            var label = item.label;
                            if (!pre.vimBuiltFunctionDocuments[label]) {
                                pre.vimBuiltinFunctionItems.push(item);
                                pre.vimBuiltFunctionDocuments[label] = next.vimBuiltFunctionDocuments[label];
                            }
                        });
                        // merge commands
                        next.vimCommandItems.forEach(function (item) {
                            var label = item.label;
                            if (!pre.vimCommandDocuments[label]) {
                                pre.vimCommandItems.push(item);
                                pre.vimCommandDocuments[label] = next.vimCommandDocuments[label];
                            }
                        });
                        // merge options
                        next.vimOptionItems.forEach(function (item) {
                            var label = item.label;
                            if (!pre.vimOptionDocuments[label]) {
                                pre.vimOptionItems.push(item);
                                pre.vimOptionDocuments[label] = next.vimOptionDocuments[label];
                            }
                        });
                        // merge variables
                        next.vimPredefinedVariablesItems.forEach(function (item) {
                            var label = item.label;
                            if (!pre.vimPredefinedVariableDocuments[label]) {
                                pre.vimPredefinedVariablesItems.push(item);
                                pre.vimPredefinedVariableDocuments[label] = next.vimPredefinedVariableDocuments[label];
                            }
                        });
                        // merge features
                        next.vimFeatureItems.forEach(function (item) {
                            var label = item.label;
                            if (!pre.vimFeatureDocuments[label]) {
                                pre.vimFeatureItems.push(item);
                                pre.vimFeatureDocuments[label] = next.vimFeatureDocuments[label];
                            }
                        });
                        // merge expand key words
                        next.vimExpandKeywordItems.forEach(function (item) {
                            var label = item.label;
                            if (!pre.expandKeywordDocuments[label]) {
                                pre.vimExpandKeywordItems.push(item);
                                pre.expandKeywordDocuments[label] = next.expandKeywordDocuments[label];
                            }
                        });
                        // merge autocmd
                        next.vimAutocmdItems.forEach(function (item) {
                            var label = item.label;
                            if (!pre.vimAutocmdItems.some(function (n) { return n.label === label; })) {
                                pre.vimAutocmdItems.push(item);
                            }
                        });
                        // merge signature help
                        pre.vimBuiltFunctionSignatureHelp = __assign(__assign({}, next.vimBuiltFunctionSignatureHelp), pre.vimBuiltFunctionSignatureHelp);
                        return pre;
                    });
                    server.serialize();
                    return [2 /*return*/];
            }
        });
    });
}
main();


/***/ }),

/***/ 73:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var constant_1 = __webpack_require__(64);
var conf;
exports.default = {
    init: function (config) {
        conf = config;
    },
    changeByKey: function (key, value) {
        if (conf) {
            conf[key] = value;
        }
    },
    get isNeovim() {
        return conf && conf.isNeovim || false;
    },
    get iskeyword() {
        return conf && conf.iskeyword || "";
    },
    get vimruntime() {
        return conf && conf.vimruntime || "";
    },
    get runtimepath() {
        return conf && conf.runtimepath || [];
    },
    get diagnostic() {
        return conf && conf.diagnostic || {
            enable: true,
        };
    },
    get snippetSupport() {
        return conf && conf.snippetSupport || false;
    },
    get suggest() {
        return conf && conf.suggest || {
            fromRuntimepath: false,
            fromVimruntime: true,
        };
    },
    get indexes() {
        var defaults = {
            runtimepath: true,
            gap: 100,
            count: 1,
            projectRootPatterns: constant_1.projectRootPatterns,
        };
        if (!conf || !conf.indexes) {
            return defaults;
        }
        if (conf.indexes.gap !== undefined) {
            defaults.gap = conf.indexes.gap;
        }
        if (conf.indexes.count !== undefined) {
            defaults.count = conf.indexes.count;
        }
        if (conf.indexes.projectRootPatterns !== undefined
            && Array.isArray(conf.indexes.projectRootPatterns)
            && conf.indexes.projectRootPatterns.length) {
            defaults.projectRootPatterns = conf.indexes.projectRootPatterns;
        }
        return defaults;
    },
    get capabilities() {
        return conf && conf.capabilities;
    }
};


/***/ }),

/***/ 13:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../../typings/thenable.d.ts" />
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.Trace = exports.ProgressType = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.RAL = void 0;
exports.CancellationStrategy = void 0;
const messages_1 = __webpack_require__(14);
Object.defineProperty(exports, "RequestType", ({ enumerable: true, get: function () { return messages_1.RequestType; } }));
Object.defineProperty(exports, "RequestType0", ({ enumerable: true, get: function () { return messages_1.RequestType0; } }));
Object.defineProperty(exports, "RequestType1", ({ enumerable: true, get: function () { return messages_1.RequestType1; } }));
Object.defineProperty(exports, "RequestType2", ({ enumerable: true, get: function () { return messages_1.RequestType2; } }));
Object.defineProperty(exports, "RequestType3", ({ enumerable: true, get: function () { return messages_1.RequestType3; } }));
Object.defineProperty(exports, "RequestType4", ({ enumerable: true, get: function () { return messages_1.RequestType4; } }));
Object.defineProperty(exports, "RequestType5", ({ enumerable: true, get: function () { return messages_1.RequestType5; } }));
Object.defineProperty(exports, "RequestType6", ({ enumerable: true, get: function () { return messages_1.RequestType6; } }));
Object.defineProperty(exports, "RequestType7", ({ enumerable: true, get: function () { return messages_1.RequestType7; } }));
Object.defineProperty(exports, "RequestType8", ({ enumerable: true, get: function () { return messages_1.RequestType8; } }));
Object.defineProperty(exports, "RequestType9", ({ enumerable: true, get: function () { return messages_1.RequestType9; } }));
Object.defineProperty(exports, "ResponseError", ({ enumerable: true, get: function () { return messages_1.ResponseError; } }));
Object.defineProperty(exports, "ErrorCodes", ({ enumerable: true, get: function () { return messages_1.ErrorCodes; } }));
Object.defineProperty(exports, "NotificationType", ({ enumerable: true, get: function () { return messages_1.NotificationType; } }));
Object.defineProperty(exports, "NotificationType0", ({ enumerable: true, get: function () { return messages_1.NotificationType0; } }));
Object.defineProperty(exports, "NotificationType1", ({ enumerable: true, get: function () { return messages_1.NotificationType1; } }));
Object.defineProperty(exports, "NotificationType2", ({ enumerable: true, get: function () { return messages_1.NotificationType2; } }));
Object.defineProperty(exports, "NotificationType3", ({ enumerable: true, get: function () { return messages_1.NotificationType3; } }));
Object.defineProperty(exports, "NotificationType4", ({ enumerable: true, get: function () { return messages_1.NotificationType4; } }));
Object.defineProperty(exports, "NotificationType5", ({ enumerable: true, get: function () { return messages_1.NotificationType5; } }));
Object.defineProperty(exports, "NotificationType6", ({ enumerable: true, get: function () { return messages_1.NotificationType6; } }));
Object.defineProperty(exports, "NotificationType7", ({ enumerable: true, get: function () { return messages_1.NotificationType7; } }));
Object.defineProperty(exports, "NotificationType8", ({ enumerable: true, get: function () { return messages_1.NotificationType8; } }));
Object.defineProperty(exports, "NotificationType9", ({ enumerable: true, get: function () { return messages_1.NotificationType9; } }));
Object.defineProperty(exports, "ParameterStructures", ({ enumerable: true, get: function () { return messages_1.ParameterStructures; } }));
const disposable_1 = __webpack_require__(11);
Object.defineProperty(exports, "Disposable", ({ enumerable: true, get: function () { return disposable_1.Disposable; } }));
const events_1 = __webpack_require__(16);
Object.defineProperty(exports, "Event", ({ enumerable: true, get: function () { return events_1.Event; } }));
Object.defineProperty(exports, "Emitter", ({ enumerable: true, get: function () { return events_1.Emitter; } }));
const cancellation_1 = __webpack_require__(17);
Object.defineProperty(exports, "CancellationTokenSource", ({ enumerable: true, get: function () { return cancellation_1.CancellationTokenSource; } }));
Object.defineProperty(exports, "CancellationToken", ({ enumerable: true, get: function () { return cancellation_1.CancellationToken; } }));
const messageReader_1 = __webpack_require__(18);
Object.defineProperty(exports, "MessageReader", ({ enumerable: true, get: function () { return messageReader_1.MessageReader; } }));
Object.defineProperty(exports, "AbstractMessageReader", ({ enumerable: true, get: function () { return messageReader_1.AbstractMessageReader; } }));
Object.defineProperty(exports, "ReadableStreamMessageReader", ({ enumerable: true, get: function () { return messageReader_1.ReadableStreamMessageReader; } }));
const messageWriter_1 = __webpack_require__(19);
Object.defineProperty(exports, "MessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.MessageWriter; } }));
Object.defineProperty(exports, "AbstractMessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.AbstractMessageWriter; } }));
Object.defineProperty(exports, "WriteableStreamMessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.WriteableStreamMessageWriter; } }));
const connection_1 = __webpack_require__(21);
Object.defineProperty(exports, "ConnectionStrategy", ({ enumerable: true, get: function () { return connection_1.ConnectionStrategy; } }));
Object.defineProperty(exports, "ConnectionOptions", ({ enumerable: true, get: function () { return connection_1.ConnectionOptions; } }));
Object.defineProperty(exports, "NullLogger", ({ enumerable: true, get: function () { return connection_1.NullLogger; } }));
Object.defineProperty(exports, "createMessageConnection", ({ enumerable: true, get: function () { return connection_1.createMessageConnection; } }));
Object.defineProperty(exports, "ProgressType", ({ enumerable: true, get: function () { return connection_1.ProgressType; } }));
Object.defineProperty(exports, "Trace", ({ enumerable: true, get: function () { return connection_1.Trace; } }));
Object.defineProperty(exports, "TraceFormat", ({ enumerable: true, get: function () { return connection_1.TraceFormat; } }));
Object.defineProperty(exports, "SetTraceNotification", ({ enumerable: true, get: function () { return connection_1.SetTraceNotification; } }));
Object.defineProperty(exports, "LogTraceNotification", ({ enumerable: true, get: function () { return connection_1.LogTraceNotification; } }));
Object.defineProperty(exports, "ConnectionErrors", ({ enumerable: true, get: function () { return connection_1.ConnectionErrors; } }));
Object.defineProperty(exports, "ConnectionError", ({ enumerable: true, get: function () { return connection_1.ConnectionError; } }));
Object.defineProperty(exports, "CancellationReceiverStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationReceiverStrategy; } }));
Object.defineProperty(exports, "CancellationSenderStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationSenderStrategy; } }));
Object.defineProperty(exports, "CancellationStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationStrategy; } }));
const ral_1 = __webpack_require__(9);
exports.RAL = ral_1.default;
//# sourceMappingURL=api.js.map

/***/ }),

/***/ 17:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CancellationTokenSource = exports.CancellationToken = void 0;
const ral_1 = __webpack_require__(9);
const Is = __webpack_require__(15);
const events_1 = __webpack_require__(16);
var CancellationToken;
(function (CancellationToken) {
    CancellationToken.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
    });
    CancellationToken.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
    });
    function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken.None
            || candidate === CancellationToken.Cancelled
            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));
    }
    CancellationToken.is = is;
})(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
const shortcutEvent = Object.freeze(function (callback, context) {
    const handle = ral_1.default().timer.setTimeout(callback.bind(context), 0);
    return { dispose() { ral_1.default().timer.clearTimeout(handle); } };
});
class MutableToken {
    constructor() {
        this._isCancelled = false;
    }
    cancel() {
        if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
                this._emitter.fire(undefined);
                this.dispose();
            }
        }
    }
    get isCancellationRequested() {
        return this._isCancelled;
    }
    get onCancellationRequested() {
        if (this._isCancelled) {
            return shortcutEvent;
        }
        if (!this._emitter) {
            this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
    }
    dispose() {
        if (this._emitter) {
            this._emitter.dispose();
            this._emitter = undefined;
        }
    }
}
class CancellationTokenSource {
    get token() {
        if (!this._token) {
            // be lazy and create the token only when
            // actually needed
            this._token = new MutableToken();
        }
        return this._token;
    }
    cancel() {
        if (!this._token) {
            // save an object by returning the default
            // cancelled token when cancellation happens
            // before someone asks for the token
            this._token = CancellationToken.Cancelled;
        }
        else {
            this._token.cancel();
        }
    }
    dispose() {
        if (!this._token) {
            // ensure to initialize with an empty token if we had none
            this._token = CancellationToken.None;
        }
        else if (this._token instanceof MutableToken) {
            // actually dispose
            this._token.dispose();
        }
    }
}
exports.CancellationTokenSource = CancellationTokenSource;
//# sourceMappingURL=cancellation.js.map

/***/ }),

/***/ 21:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessageConnection = exports.ConnectionOptions = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.Trace = exports.NullLogger = exports.ProgressType = void 0;
const ral_1 = __webpack_require__(9);
const Is = __webpack_require__(15);
const messages_1 = __webpack_require__(14);
const linkedMap_1 = __webpack_require__(22);
const events_1 = __webpack_require__(16);
const cancellation_1 = __webpack_require__(17);
var CancelNotification;
(function (CancelNotification) {
    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
})(CancelNotification || (CancelNotification = {}));
var ProgressNotification;
(function (ProgressNotification) {
    ProgressNotification.type = new messages_1.NotificationType('$/progress');
})(ProgressNotification || (ProgressNotification = {}));
class ProgressType {
    constructor() {
    }
}
exports.ProgressType = ProgressType;
var StarRequestHandler;
(function (StarRequestHandler) {
    function is(value) {
        return Is.func(value);
    }
    StarRequestHandler.is = is;
})(StarRequestHandler || (StarRequestHandler = {}));
exports.NullLogger = Object.freeze({
    error: () => { },
    warn: () => { },
    info: () => { },
    log: () => { }
});
var Trace;
(function (Trace) {
    Trace[Trace["Off"] = 0] = "Off";
    Trace[Trace["Messages"] = 1] = "Messages";
    Trace[Trace["Verbose"] = 2] = "Verbose";
})(Trace = exports.Trace || (exports.Trace = {}));
(function (Trace) {
    function fromString(value) {
        if (!Is.string(value)) {
            return Trace.Off;
        }
        value = value.toLowerCase();
        switch (value) {
            case 'off':
                return Trace.Off;
            case 'messages':
                return Trace.Messages;
            case 'verbose':
                return Trace.Verbose;
            default:
                return Trace.Off;
        }
    }
    Trace.fromString = fromString;
    function toString(value) {
        switch (value) {
            case Trace.Off:
                return 'off';
            case Trace.Messages:
                return 'messages';
            case Trace.Verbose:
                return 'verbose';
            default:
                return 'off';
        }
    }
    Trace.toString = toString;
})(Trace = exports.Trace || (exports.Trace = {}));
var TraceFormat;
(function (TraceFormat) {
    TraceFormat["Text"] = "text";
    TraceFormat["JSON"] = "json";
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
(function (TraceFormat) {
    function fromString(value) {
        value = value.toLowerCase();
        if (value === 'json') {
            return TraceFormat.JSON;
        }
        else {
            return TraceFormat.Text;
        }
    }
    TraceFormat.fromString = fromString;
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
var SetTraceNotification;
(function (SetTraceNotification) {
    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
})(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));
var LogTraceNotification;
(function (LogTraceNotification) {
    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
})(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));
var ConnectionErrors;
(function (ConnectionErrors) {
    /**
     * The connection is closed.
     */
    ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
    /**
     * The connection got disposed.
     */
    ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
    /**
     * The connection is already in listening mode.
     */
    ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
})(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));
class ConnectionError extends Error {
    constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
    }
}
exports.ConnectionError = ConnectionError;
var ConnectionStrategy;
(function (ConnectionStrategy) {
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
    }
    ConnectionStrategy.is = is;
})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));
var CancellationReceiverStrategy;
(function (CancellationReceiverStrategy) {
    CancellationReceiverStrategy.Message = Object.freeze({
        createCancellationTokenSource(_) {
            return new cancellation_1.CancellationTokenSource();
        }
    });
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.createCancellationTokenSource);
    }
    CancellationReceiverStrategy.is = is;
})(CancellationReceiverStrategy = exports.CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = {}));
var CancellationSenderStrategy;
(function (CancellationSenderStrategy) {
    CancellationSenderStrategy.Message = Object.freeze({
        sendCancellation(conn, id) {
            conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) { }
    });
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
    }
    CancellationSenderStrategy.is = is;
})(CancellationSenderStrategy = exports.CancellationSenderStrategy || (exports.CancellationSenderStrategy = {}));
var CancellationStrategy;
(function (CancellationStrategy) {
    CancellationStrategy.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
    });
    function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
    }
    CancellationStrategy.is = is;
})(CancellationStrategy = exports.CancellationStrategy || (exports.CancellationStrategy = {}));
var ConnectionOptions;
(function (ConnectionOptions) {
    function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
    }
    ConnectionOptions.is = is;
})(ConnectionOptions = exports.ConnectionOptions || (exports.ConnectionOptions = {}));
var ConnectionState;
(function (ConnectionState) {
    ConnectionState[ConnectionState["New"] = 1] = "New";
    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
})(ConnectionState || (ConnectionState = {}));
function createMessageConnection(messageReader, messageWriter, _logger, options) {
    const logger = _logger !== undefined ? _logger : exports.NullLogger;
    let sequenceNumber = 0;
    let notificationSquenceNumber = 0;
    let unknownResponseSquenceNumber = 0;
    const version = '2.0';
    let starRequestHandler = undefined;
    const requestHandlers = Object.create(null);
    let starNotificationHandler = undefined;
    const notificationHandlers = Object.create(null);
    const progressHandlers = new Map();
    let timer;
    let messageQueue = new linkedMap_1.LinkedMap();
    let responsePromises = Object.create(null);
    let requestTokens = Object.create(null);
    let trace = Trace.Off;
    let traceFormat = TraceFormat.Text;
    let tracer;
    let state = ConnectionState.New;
    const errorEmitter = new events_1.Emitter();
    const closeEmitter = new events_1.Emitter();
    const unhandledNotificationEmitter = new events_1.Emitter();
    const unhandledProgressEmitter = new events_1.Emitter();
    const disposeEmitter = new events_1.Emitter();
    const cancellationStrategy = (options && options.cancellationStrategy) ? options.cancellationStrategy : CancellationStrategy.Message;
    function createRequestQueueKey(id) {
        if (id === null) {
            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return 'req-' + id.toString();
    }
    function createResponseQueueKey(id) {
        if (id === null) {
            return 'res-unknown-' + (++unknownResponseSquenceNumber).toString();
        }
        else {
            return 'res-' + id.toString();
        }
    }
    function createNotificationQueueKey() {
        return 'not-' + (++notificationSquenceNumber).toString();
    }
    function addMessageToQueue(queue, message) {
        if (messages_1.isRequestMessage(message)) {
            queue.set(createRequestQueueKey(message.id), message);
        }
        else if (messages_1.isResponseMessage(message)) {
            queue.set(createResponseQueueKey(message.id), message);
        }
        else {
            queue.set(createNotificationQueueKey(), message);
        }
    }
    function cancelUndispatched(_message) {
        return undefined;
    }
    function isListening() {
        return state === ConnectionState.Listening;
    }
    function isClosed() {
        return state === ConnectionState.Closed;
    }
    function isDisposed() {
        return state === ConnectionState.Disposed;
    }
    function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(undefined);
        }
        // If the connection is disposed don't sent close events.
    }
    function readErrorHandler(error) {
        errorEmitter.fire([error, undefined, undefined]);
    }
    function writeErrorHandler(data) {
        errorEmitter.fire(data);
    }
    messageReader.onClose(closeHandler);
    messageReader.onError(readErrorHandler);
    messageWriter.onClose(closeHandler);
    messageWriter.onError(writeErrorHandler);
    function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
            return;
        }
        timer = ral_1.default().timer.setImmediate(() => {
            timer = undefined;
            processMessageQueue();
        });
    }
    function processMessageQueue() {
        if (messageQueue.size === 0) {
            return;
        }
        const message = messageQueue.shift();
        try {
            if (messages_1.isRequestMessage(message)) {
                handleRequest(message);
            }
            else if (messages_1.isNotificationMessage(message)) {
                handleNotification(message);
            }
            else if (messages_1.isResponseMessage(message)) {
                handleResponse(message);
            }
            else {
                handleInvalidMessage(message);
            }
        }
        finally {
            triggerMessageQueue();
        }
    }
    const callback = (message) => {
        try {
            // We have received a cancellation message. Check if the message is still in the queue
            // and cancel it if allowed to do so.
            if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
                const key = createRequestQueueKey(message.params.id);
                const toCancel = messageQueue.get(key);
                if (messages_1.isRequestMessage(toCancel)) {
                    const strategy = options === null || options === void 0 ? void 0 : options.connectionStrategy;
                    const response = (strategy && strategy.cancelUndispatched) ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                    if (response && (response.error !== undefined || response.result !== undefined)) {
                        messageQueue.delete(key);
                        response.id = toCancel.id;
                        traceSendingResponse(response, message.method, Date.now());
                        messageWriter.write(response);
                        return;
                    }
                }
            }
            addMessageToQueue(messageQueue, message);
        }
        finally {
            triggerMessageQueue();
        }
    };
    function handleRequest(requestMessage) {
        if (isDisposed()) {
            // we return here silently since we fired an event when the
            // connection got disposed.
            return;
        }
        function reply(resultOrError, method, startTime) {
            const message = {
                jsonrpc: version,
                id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
                message.error = resultOrError.toJson();
            }
            else {
                message.result = resultOrError === undefined ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        function replyError(error, method, startTime) {
            const message = {
                jsonrpc: version,
                id: requestMessage.id,
                error: error.toJson()
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        function replySuccess(result, method, startTime) {
            // The JSON RPC defines that a response must either have a result or an error
            // So we can't treat undefined as a valid response result.
            if (result === undefined) {
                result = null;
            }
            const message = {
                jsonrpc: version,
                id: requestMessage.id,
                result: result
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers[requestMessage.method];
        let type;
        let requestHandler;
        if (element) {
            type = element.type;
            requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
            const tokenKey = String(requestMessage.id);
            const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
            requestTokens[tokenKey] = cancellationSource;
            try {
                let handlerResult;
                if (requestHandler) {
                    if (requestMessage.params === undefined) {
                        if (type !== undefined && type.numberOfParams !== 0) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but recevied none.`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(cancellationSource.token);
                    }
                    else if (Array.isArray(requestMessage.params)) {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                    }
                    else {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                    }
                }
                else if (starRequestHandler) {
                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                }
                const promise = handlerResult;
                if (!handlerResult) {
                    delete requestTokens[tokenKey];
                    replySuccess(handlerResult, requestMessage.method, startTime);
                }
                else if (promise.then) {
                    promise.then((resultOrError) => {
                        delete requestTokens[tokenKey];
                        reply(resultOrError, requestMessage.method, startTime);
                    }, error => {
                        delete requestTokens[tokenKey];
                        if (error instanceof messages_1.ResponseError) {
                            replyError(error, requestMessage.method, startTime);
                        }
                        else if (error && Is.string(error.message)) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                        }
                        else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                        }
                    });
                }
                else {
                    delete requestTokens[tokenKey];
                    reply(handlerResult, requestMessage.method, startTime);
                }
            }
            catch (error) {
                delete requestTokens[tokenKey];
                if (error instanceof messages_1.ResponseError) {
                    reply(error, requestMessage.method, startTime);
                }
                else if (error && Is.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                }
                else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
            }
        }
        else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
    }
    function handleResponse(responseMessage) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        if (responseMessage.id === null) {
            if (responseMessage.error) {
                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
            }
            else {
                logger.error(`Received response message without id. No further error information provided.`);
            }
        }
        else {
            const key = String(responseMessage.id);
            const responsePromise = responsePromises[key];
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise) {
                delete responsePromises[key];
                try {
                    if (responseMessage.error) {
                        const error = responseMessage.error;
                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                    }
                    else if (responseMessage.result !== undefined) {
                        responsePromise.resolve(responseMessage.result);
                    }
                    else {
                        throw new Error('Should never happen.');
                    }
                }
                catch (error) {
                    if (error.message) {
                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                    }
                    else {
                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                    }
                }
            }
        }
    }
    function handleNotification(message) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        let type = undefined;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
            notificationHandler = (params) => {
                const id = params.id;
                const source = requestTokens[String(id)];
                if (source) {
                    source.cancel();
                }
            };
        }
        else {
            const element = notificationHandlers[message.method];
            if (element) {
                notificationHandler = element.handler;
                type = element.type;
            }
        }
        if (notificationHandler || starNotificationHandler) {
            try {
                traceReceivedNotification(message);
                if (notificationHandler) {
                    if (message.params === undefined) {
                        if (type !== undefined) {
                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but recevied none.`);
                            }
                        }
                        notificationHandler();
                    }
                    else if (Array.isArray(message.params)) {
                        if (type !== undefined) {
                            if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                                logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                            }
                            if (type.numberOfParams !== message.params.length) {
                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${message.params.length} argumennts`);
                            }
                        }
                        notificationHandler(...message.params);
                    }
                    else {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                        }
                        notificationHandler(message.params);
                    }
                }
                else if (starNotificationHandler) {
                    starNotificationHandler(message.method, message.params);
                }
            }
            catch (error) {
                if (error.message) {
                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                }
                else {
                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                }
            }
        }
        else {
            unhandledNotificationEmitter.fire(message);
        }
    }
    function handleInvalidMessage(message) {
        if (!message) {
            logger.error('Received empty message.');
            return;
        }
        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
        // Test whether we find an id to reject the promise
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
            const key = String(responseMessage.id);
            const responseHandler = responsePromises[key];
            if (responseHandler) {
                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
            }
        }
    }
    function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose && message.params) {
                data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('send-request', message);
        }
    }
    function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.params) {
                    data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('send-notification', message);
        }
    }
    function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.error && message.error.data) {
                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${JSON.stringify(message.result, null, 4)}\n\n`;
                    }
                    else if (message.error === undefined) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        }
        else {
            logLSPMessage('send-response', message);
        }
    }
    function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose && message.params) {
                data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('receive-request', message);
        }
    }
    function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.params) {
                    data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('receive-notification', message);
        }
    }
    function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.error && message.error.data) {
                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${JSON.stringify(message.result, null, 4)}\n\n`;
                    }
                    else if (message.error === undefined) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            if (responsePromise) {
                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            }
            else {
                tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
        }
        else {
            logLSPMessage('receive-response', message);
        }
    }
    function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
            return;
        }
        const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
        };
        tracer.log(lspMessage);
    }
    function throwIfClosedOrDisposed() {
        if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
        }
        if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
        }
    }
    function throwIfListening() {
        if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
        }
    }
    function throwIfNotListening() {
        if (!isListening()) {
            throw new Error('Call listen() first.');
        }
    }
    function undefinedToNull(param) {
        if (param === undefined) {
            return null;
        }
        else {
            return param;
        }
    }
    function nullToUndefined(param) {
        if (param === null) {
            return undefined;
        }
        else {
            return param;
        }
    }
    function isNamedParam(param) {
        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
    }
    function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
            case messages_1.ParameterStructures.auto:
                if (isNamedParam(param)) {
                    return nullToUndefined(param);
                }
                else {
                    return [undefinedToNull(param)];
                }
                break;
            case messages_1.ParameterStructures.byName:
                if (!isNamedParam(param)) {
                    throw new Error(`Recevied parameters by name but param is not an object literal.`);
                }
                return nullToUndefined(param);
            case messages_1.ParameterStructures.byPosition:
                return [undefinedToNull(param)];
            default:
                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
    }
    function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
            case 0:
                result = undefined;
                break;
            case 1:
                result = computeSingleParam(type.parameterStructures, params[0]);
                break;
            default:
                result = [];
                for (let i = 0; i < params.length && i < numberOfParams; i++) {
                    result.push(undefinedToNull(params[i]));
                }
                if (params.length < numberOfParams) {
                    for (let i = params.length; i < numberOfParams; i++) {
                        result.push(null);
                    }
                }
                break;
        }
        return result;
    }
    const connection = {
        sendNotification: (type, ...args) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is.string(type)) {
                method = type;
                const first = args[0];
                let paramStart = 0;
                let parameterStructures = messages_1.ParameterStructures.auto;
                if (messages_1.ParameterStructures.is(first)) {
                    paramStart = 1;
                    parameterStructures = first;
                }
                let paramEnd = args.length;
                const numberOfParams = paramEnd - paramStart;
                switch (numberOfParams) {
                    case 0:
                        messageParams = undefined;
                        break;
                    case 1:
                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                        break;
                    default:
                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                            throw new Error(`Recevied ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                        }
                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
                        break;
                }
            }
            else {
                const params = args;
                method = type.method;
                messageParams = computeMessageParams(type, params);
            }
            const notificationMessage = {
                jsonrpc: version,
                method: method,
                params: messageParams
            };
            traceSendingNotification(notificationMessage);
            messageWriter.write(notificationMessage);
        },
        onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            let method;
            if (Is.func(type)) {
                starNotificationHandler = type;
            }
            else if (handler) {
                if (Is.string(type)) {
                    method = type;
                    notificationHandlers[type] = { type: undefined, handler };
                }
                else {
                    method = type.method;
                    notificationHandlers[type.method] = { type, handler };
                }
            }
            return {
                dispose: () => {
                    if (method !== undefined) {
                        delete notificationHandlers[method];
                    }
                    else {
                        starNotificationHandler = undefined;
                    }
                }
            };
        },
        onProgress: (_type, token, handler) => {
            if (progressHandlers.has(token)) {
                throw new Error(`Progress handler for token ${token} already registered`);
            }
            progressHandlers.set(token, handler);
            return {
                dispose: () => {
                    progressHandlers.delete(token);
                }
            };
        },
        sendProgress: (_type, token, value) => {
            connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = undefined;
            if (Is.string(type)) {
                method = type;
                const first = args[0];
                const last = args[args.length - 1];
                let paramStart = 0;
                let parameterStructures = messages_1.ParameterStructures.auto;
                if (messages_1.ParameterStructures.is(first)) {
                    paramStart = 1;
                    parameterStructures = first;
                }
                let paramEnd = args.length;
                if (cancellation_1.CancellationToken.is(last)) {
                    paramEnd = paramEnd - 1;
                    token = last;
                }
                const numberOfParams = paramEnd - paramStart;
                switch (numberOfParams) {
                    case 0:
                        messageParams = undefined;
                        break;
                    case 1:
                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                        break;
                    default:
                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                            throw new Error(`Recevied ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                        }
                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
                        break;
                }
            }
            else {
                const params = args;
                method = type.method;
                messageParams = computeMessageParams(type, params);
                const numberOfParams = type.numberOfParams;
                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
            }
            const id = sequenceNumber++;
            let disposable;
            if (token) {
                disposable = token.onCancellationRequested(() => {
                    cancellationStrategy.sender.sendCancellation(connection, id);
                });
            }
            const result = new Promise((resolve, reject) => {
                const requestMessage = {
                    jsonrpc: version,
                    id: id,
                    method: method,
                    params: messageParams
                };
                const resolveWithCleanup = (r) => {
                    resolve(r);
                    cancellationStrategy.sender.cleanup(id);
                    disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
                };
                const rejectWithCleanup = (r) => {
                    reject(r);
                    cancellationStrategy.sender.cleanup(id);
                    disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
                };
                let responsePromise = { method: method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
                traceSendingRequest(requestMessage);
                try {
                    messageWriter.write(requestMessage);
                }
                catch (e) {
                    // Writing the message failed. So we need to reject the promise.
                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : 'Unknown reason'));
                    responsePromise = null;
                }
                if (responsePromise) {
                    responsePromises[String(id)] = responsePromise;
                }
            });
            return result;
        },
        onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            let method = null;
            if (StarRequestHandler.is(type)) {
                method = undefined;
                starRequestHandler = type;
            }
            else if (Is.string(type)) {
                method = null;
                if (handler !== undefined) {
                    method = type;
                    requestHandlers[type] = { handler: handler, type: undefined };
                }
            }
            else {
                if (handler !== undefined) {
                    method = type.method;
                    requestHandlers[type.method] = { type, handler };
                }
            }
            return {
                dispose: () => {
                    if (method === null) {
                        return;
                    }
                    if (method !== undefined) {
                        delete requestHandlers[method];
                    }
                    else {
                        starRequestHandler = undefined;
                    }
                }
            };
        },
        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== undefined) {
                if (Is.boolean(sendNotificationOrTraceOptions)) {
                    _sendNotification = sendNotificationOrTraceOptions;
                }
                else {
                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
                tracer = undefined;
            }
            else {
                tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
                connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
            messageWriter.end();
        },
        dispose: () => {
            if (isDisposed()) {
                return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(undefined);
            const error = new Error('Connection got disposed.');
            Object.keys(responsePromises).forEach((key) => {
                responsePromises[key].reject(error);
            });
            responsePromises = Object.create(null);
            requestTokens = Object.create(null);
            messageQueue = new linkedMap_1.LinkedMap();
            // Test for backwards compatibility
            if (Is.func(messageWriter.dispose)) {
                messageWriter.dispose();
            }
            if (Is.func(messageReader.dispose)) {
                messageReader.dispose();
            }
        },
        listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader.listen(callback);
        },
        inspect: () => {
            // eslint-disable-next-line no-console
            ral_1.default().console.log('inspect');
        }
    };
    connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        tracer.log(params.message, trace === Trace.Verbose ? params.verbose : undefined);
    });
    connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
            handler(params.value);
        }
        else {
            unhandledProgressEmitter.fire(params);
        }
    });
    return connection;
}
exports.createMessageConnection = createMessageConnection;
//# sourceMappingURL=connection.js.map

/***/ }),

/***/ 11:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Disposable = void 0;
var Disposable;
(function (Disposable) {
    function create(func) {
        return {
            dispose: func
        };
    }
    Disposable.create = create;
})(Disposable = exports.Disposable || (exports.Disposable = {}));
//# sourceMappingURL=disposable.js.map

/***/ }),

/***/ 16:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Emitter = exports.Event = void 0;
const ral_1 = __webpack_require__(9);
var Event;
(function (Event) {
    const _disposable = { dispose() { } };
    Event.None = function () { return _disposable; };
})(Event = exports.Event || (exports.Event = {}));
class CallbackList {
    add(callback, context = null, bucket) {
        if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
        }
    }
    remove(callback, context = null) {
        if (!this._callbacks) {
            return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
                if (this._contexts[i] === context) {
                    // callback & context match => remove it
                    this._callbacks.splice(i, 1);
                    this._contexts.splice(i, 1);
                    return;
                }
                else {
                    foundCallbackWithDifferentContext = true;
                }
            }
        }
        if (foundCallbackWithDifferentContext) {
            throw new Error('When adding a listener with a context, you should remove it with the same context');
        }
    }
    invoke(...args) {
        if (!this._callbacks) {
            return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
            try {
                ret.push(callbacks[i].apply(contexts[i], args));
            }
            catch (e) {
                // eslint-disable-next-line no-console
                ral_1.default().console.error(e);
            }
        }
        return ret;
    }
    isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
        this._callbacks = undefined;
        this._contexts = undefined;
    }
}
class Emitter {
    constructor(_options) {
        this._options = _options;
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
        if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
                if (!this._callbacks) {
                    this._callbacks = new CallbackList();
                }
                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                    this._options.onFirstListenerAdd(this);
                }
                this._callbacks.add(listener, thisArgs);
                const result = {
                    dispose: () => {
                        if (!this._callbacks) {
                            // disposable is disposed after emitter is disposed.
                            return;
                        }
                        this._callbacks.remove(listener, thisArgs);
                        result.dispose = Emitter._noop;
                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                            this._options.onLastListenerRemove(this);
                        }
                    }
                };
                if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        }
        return this._event;
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
        if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
        }
    }
    dispose() {
        if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = undefined;
        }
    }
}
exports.Emitter = Emitter;
Emitter._noop = function () { };
//# sourceMappingURL=events.js.map

/***/ }),

/***/ 15:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
//# sourceMappingURL=is.js.map

/***/ }),

/***/ 22:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
var Touch;
(function (Touch) {
    Touch.None = 0;
    Touch.First = 1;
    Touch.AsOld = Touch.First;
    Touch.Last = 2;
    Touch.AsNew = Touch.Last;
})(Touch = exports.Touch || (exports.Touch = {}));
class LinkedMap {
    constructor() {
        this[Symbol.toStringTag] = 'LinkedMap';
        this._map = new Map();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        this._state = 0;
    }
    clear() {
        this._map.clear();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        this._state++;
    }
    isEmpty() {
        return !this._head && !this._tail;
    }
    get size() {
        return this._size;
    }
    get first() {
        var _a;
        return (_a = this._head) === null || _a === void 0 ? void 0 : _a.value;
    }
    get last() {
        var _a;
        return (_a = this._tail) === null || _a === void 0 ? void 0 : _a.value;
    }
    has(key) {
        return this._map.has(key);
    }
    get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        if (touch !== Touch.None) {
            this.touch(item, touch);
        }
        return item.value;
    }
    set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
            item.value = value;
            if (touch !== Touch.None) {
                this.touch(item, touch);
            }
        }
        else {
            item = { key, value, next: undefined, previous: undefined };
            switch (touch) {
                case Touch.None:
                    this.addItemLast(item);
                    break;
                case Touch.First:
                    this.addItemFirst(item);
                    break;
                case Touch.Last:
                    this.addItemLast(item);
                    break;
                default:
                    this.addItemLast(item);
                    break;
            }
            this._map.set(key, item);
            this._size++;
        }
        return this;
    }
    delete(key) {
        return !!this.remove(key);
    }
    remove(key) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    shift() {
        if (!this._head && !this._tail) {
            return undefined;
        }
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
            if (thisArg) {
                callbackfn.bind(thisArg)(current.value, current.key, this);
            }
            else {
                callbackfn(current.value, current.key, this);
            }
            if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
            }
            current = current.next;
        }
    }
    keys() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]() {
                return iterator;
            },
            next() {
                if (map._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: current.key, done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    values() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]() {
                return iterator;
            },
            next() {
                if (map._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: current.value, done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    entries() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]() {
                return iterator;
            },
            next() {
                if (map._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: [current.key, current.value], done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    trimOld(newSize) {
        if (newSize >= this.size) {
            return;
        }
        if (newSize === 0) {
            this.clear();
            return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
            this._map.delete(current.key);
            current = current.next;
            currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
            current.previous = undefined;
        }
        this._state++;
    }
    addItemFirst(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._tail = item;
        }
        else if (!this._head) {
            throw new Error('Invalid list');
        }
        else {
            item.next = this._head;
            this._head.previous = item;
        }
        this._head = item;
        this._state++;
    }
    addItemLast(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._head = item;
        }
        else if (!this._tail) {
            throw new Error('Invalid list');
        }
        else {
            item.previous = this._tail;
            this._tail.next = item;
        }
        this._tail = item;
        this._state++;
    }
    removeItem(item) {
        if (item === this._head && item === this._tail) {
            this._head = undefined;
            this._tail = undefined;
        }
        else if (item === this._head) {
            // This can only happend if size === 1 which is handle
            // by the case above.
            if (!item.next) {
                throw new Error('Invalid list');
            }
            item.next.previous = undefined;
            this._head = item.next;
        }
        else if (item === this._tail) {
            // This can only happend if size === 1 which is handle
            // by the case above.
            if (!item.previous) {
                throw new Error('Invalid list');
            }
            item.previous.next = undefined;
            this._tail = item.previous;
        }
        else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
                throw new Error('Invalid list');
            }
            next.previous = previous;
            previous.next = next;
        }
        item.next = undefined;
        item.previous = undefined;
        this._state++;
    }
    touch(item, touch) {
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        if ((touch !== Touch.First && touch !== Touch.Last)) {
            return;
        }
        if (touch === Touch.First) {
            if (item === this._head) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item
            if (item === this._tail) {
                // previous must be defined since item was not head but is tail
                // So there are more than on item in the map
                previous.next = undefined;
                this._tail = previous;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            // Insert the node at head
            item.previous = undefined;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
            this._state++;
        }
        else if (touch === Touch.Last) {
            if (item === this._tail) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item.
            if (item === this._head) {
                // next must be defined since item was not tail but is head
                // So there are more than on item in the map
                next.previous = undefined;
                this._head = next;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            item.next = undefined;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
            this._state++;
        }
    }
    toJSON() {
        const data = [];
        this.forEach((value, key) => {
            data.push([key, value]);
        });
        return data;
    }
    fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
            this.set(key, value);
        }
    }
}
exports.LinkedMap = LinkedMap;
class LRUCache extends LinkedMap {
    constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
    }
    get limit() {
        return this._limit;
    }
    set limit(limit) {
        this._limit = limit;
        this.checkTrim();
    }
    get ratio() {
        return this._ratio;
    }
    set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
    }
    get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
    }
    peek(key) {
        return super.get(key, Touch.None);
    }
    set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
    }
    checkTrim() {
        if (this.size > this._limit) {
            this.trimOld(Math.round(this._limit * this._ratio));
        }
    }
}
exports.LRUCache = LRUCache;
//# sourceMappingURL=linkedMap.js.map

/***/ }),

/***/ 12:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractMessageBuffer = void 0;
const CR = 13;
const LF = 10;
const CRLF = '\r\n';
class AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
    }
    get encoding() {
        return this._encoding;
    }
    append(chunk) {
        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
    }
    tryReadHeaders() {
        if (this._chunks.length === 0) {
            return undefined;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row: while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column: while (offset < chunk.length) {
                const value = chunk[offset];
                switch (value) {
                    case CR:
                        switch (state) {
                            case 0:
                                state = 1;
                                break;
                            case 2:
                                state = 3;
                                break;
                            default:
                                state = 0;
                        }
                        break;
                    case LF:
                        switch (state) {
                            case 1:
                                state = 2;
                                break;
                            case 3:
                                state = 4;
                                offset++;
                                break row;
                            default:
                                state = 0;
                        }
                        break;
                    default:
                        state = 0;
                }
                offset++;
            }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
        }
        if (state !== 4) {
            return undefined;
        }
        // The buffer contains the two CRLF at the end. So we will
        // have two empty lines after the split at the end as well.
        const buffer = this._read(chunkBytesRead + offset);
        const result = new Map();
        const headers = this.toString(buffer, 'ascii').split(CRLF);
        if (headers.length < 2) {
            return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
            const header = headers[i];
            const index = header.indexOf(':');
            if (index === -1) {
                throw new Error('Message header must separate key and value using :');
            }
            const key = header.substr(0, index);
            const value = header.substr(index + 1).trim();
            result.set(key, value);
        }
        return result;
    }
    tryReadBody(length) {
        if (this._totalLength < length) {
            return undefined;
        }
        return this._read(length);
    }
    get numberOfBytes() {
        return this._totalLength;
    }
    _read(byteCount) {
        if (byteCount === 0) {
            return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
            throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
            // super fast path, precisely first chunk must be returned
            const chunk = this._chunks[0];
            this._chunks.shift();
            this._totalLength -= byteCount;
            return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
            // fast path, the reading is entirely within the first chunk
            const chunk = this._chunks[0];
            const result = this.asNative(chunk, byteCount);
            this._chunks[0] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            return result;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
            const chunk = this._chunks[chunkIndex];
            if (chunk.byteLength > byteCount) {
                // this chunk will survive
                const chunkPart = chunk.slice(0, byteCount);
                result.set(chunkPart, resultOffset);
                resultOffset += byteCount;
                this._chunks[chunkIndex] = chunk.slice(byteCount);
                this._totalLength -= byteCount;
                byteCount -= byteCount;
            }
            else {
                // this chunk will be entirely read
                result.set(chunk, resultOffset);
                resultOffset += chunk.byteLength;
                this._chunks.shift();
                this._totalLength -= chunk.byteLength;
                byteCount -= chunk.byteLength;
            }
        }
        return result;
    }
}
exports.AbstractMessageBuffer = AbstractMessageBuffer;
//# sourceMappingURL=messageBuffer.js.map

/***/ }),

/***/ 18:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
const ral_1 = __webpack_require__(9);
const Is = __webpack_require__(15);
const events_1 = __webpack_require__(16);
var MessageReader;
(function (MessageReader) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&
            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
    }
    MessageReader.is = is;
})(MessageReader = exports.MessageReader || (exports.MessageReader = {}));
class AbstractMessageReader {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error) {
        this.errorEmitter.fire(this.asError(error));
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    get onPartialMessage() {
        return this.partialMessageEmitter.event;
    }
    firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageReader = AbstractMessageReader;
var ResolvedMessageReaderOptions;
(function (ResolvedMessageReaderOptions) {
    function fromOptions(options) {
        var _a;
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = new Map();
        if (options === undefined || typeof options === 'string') {
            charset = options !== null && options !== void 0 ? options : 'utf-8';
        }
        else {
            charset = (_a = options.charset) !== null && _a !== void 0 ? _a : 'utf-8';
            if (options.contentDecoder !== undefined) {
                contentDecoder = options.contentDecoder;
                contentDecoders.set(contentDecoder.name, contentDecoder);
            }
            if (options.contentDecoders !== undefined) {
                for (const decoder of options.contentDecoders) {
                    contentDecoders.set(decoder.name, decoder);
                }
            }
            if (options.contentTypeDecoder !== undefined) {
                contentTypeDecoder = options.contentTypeDecoder;
                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
            }
            if (options.contentTypeDecoders !== undefined) {
                for (const decoder of options.contentTypeDecoders) {
                    contentTypeDecoders.set(decoder.name, decoder);
                }
            }
        }
        if (contentTypeDecoder === undefined) {
            contentTypeDecoder = ral_1.default().applicationJson.decoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
    }
    ResolvedMessageReaderOptions.fromOptions = fromOptions;
})(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
class ReadableStreamMessageReader extends AbstractMessageReader {
    constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = ral_1.default().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 10000;
        this.nextMessageLength = -1;
        this.messageToken = 0;
    }
    set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
    }
    get partialMessageTimeout() {
        return this._partialMessageTimeout;
    }
    listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = undefined;
        this.callback = callback;
        const result = this.readable.onData((data) => {
            this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
    }
    onData(data) {
        this.buffer.append(data);
        while (true) {
            if (this.nextMessageLength === -1) {
                const headers = this.buffer.tryReadHeaders();
                if (!headers) {
                    return;
                }
                const contentLength = headers.get('Content-Length');
                if (!contentLength) {
                    throw new Error('Header must provide a Content-Length property.');
                }
                const length = parseInt(contentLength);
                if (isNaN(length)) {
                    throw new Error('Content-Length value must be a number.');
                }
                this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === undefined) {
                /** We haven't received the full message yet. */
                this.setPartialMessageTimer();
                return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            let p;
            if (this.options.contentDecoder !== undefined) {
                p = this.options.contentDecoder.decode(body);
            }
            else {
                p = Promise.resolve(body);
            }
            p.then((value) => {
                this.options.contentTypeDecoder.decode(value, this.options).then((msg) => {
                    this.callback(msg);
                }, (error) => {
                    this.fireError(error);
                });
            }, (error) => {
                this.fireError(error);
            });
        }
    }
    clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
            ral_1.default().timer.clearTimeout(this.partialMessageTimer);
            this.partialMessageTimer = undefined;
        }
    }
    setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
            return;
        }
        this.partialMessageTimer = ral_1.default().timer.setTimeout((token, timeout) => {
            this.partialMessageTimer = undefined;
            if (token === this.messageToken) {
                this.firePartialMessage({ messageToken: token, waitingTime: timeout });
                this.setPartialMessageTimer();
            }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
    }
}
exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
//# sourceMappingURL=messageReader.js.map

/***/ }),

/***/ 19:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
const ral_1 = __webpack_require__(9);
const Is = __webpack_require__(15);
const semaphore_1 = __webpack_require__(20);
const events_1 = __webpack_require__(16);
const ContentLength = 'Content-Length: ';
const CRLF = '\r\n';
var MessageWriter;
(function (MessageWriter) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&
            Is.func(candidate.onError) && Is.func(candidate.write);
    }
    MessageWriter.is = is;
})(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));
class AbstractMessageWriter {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageWriter = AbstractMessageWriter;
var ResolvedMessageWriterOptions;
(function (ResolvedMessageWriterOptions) {
    function fromOptions(options) {
        var _a, _b;
        if (options === undefined || typeof options === 'string') {
            return { charset: options !== null && options !== void 0 ? options : 'utf-8', contentTypeEncoder: ral_1.default().applicationJson.encoder };
        }
        else {
            return { charset: (_a = options.charset) !== null && _a !== void 0 ? _a : 'utf-8', contentEncoder: options.contentEncoder, contentTypeEncoder: (_b = options.contentTypeEncoder) !== null && _b !== void 0 ? _b : ral_1.default().applicationJson.encoder };
        }
    }
    ResolvedMessageWriterOptions.fromOptions = fromOptions;
})(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
class WriteableStreamMessageWriter extends AbstractMessageWriter {
    constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
    }
    async write(msg) {
        return this.writeSemaphore.lock(async () => {
            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
                if (this.options.contentEncoder !== undefined) {
                    return this.options.contentEncoder.encode(buffer);
                }
                else {
                    return buffer;
                }
            });
            return payload.then((buffer) => {
                const headers = [];
                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
                headers.push(CRLF);
                return this.doWrite(msg, headers, buffer);
            }, (error) => {
                this.fireError(error);
                throw error;
            });
        });
    }
    async doWrite(msg, headers, data) {
        try {
            await this.writable.write(headers.join(''), 'ascii');
            return this.writable.write(data);
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
        this.writable.end();
    }
}
exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
//# sourceMappingURL=messageWriter.js.map

/***/ }),

/***/ 14:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isResponseMessage = exports.isNotificationMessage = exports.isRequestMessage = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
const is = __webpack_require__(15);
/**
 * Predefined error codes.
 */
var ErrorCodes;
(function (ErrorCodes) {
    // Defined by JSON RPC
    ErrorCodes.ParseError = -32700;
    ErrorCodes.InvalidRequest = -32600;
    ErrorCodes.MethodNotFound = -32601;
    ErrorCodes.InvalidParams = -32602;
    ErrorCodes.InternalError = -32603;
    /**
     * This is the start range of JSON RPC reserved error codes.
     * It doesn't denote a real error code. No application error codes should
     * be defined between the start and end range. For backwards
     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
     * are left in the range.
     *
     * @since 3.16.0
    */
    ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
    /** @deprecated use  jsonrpcReservedErrorRangeStart */
    ErrorCodes.serverErrorStart = ErrorCodes.jsonrpcReservedErrorRangeStart;
    ErrorCodes.MessageWriteError = -32099;
    ErrorCodes.MessageReadError = -32098;
    ErrorCodes.ServerNotInitialized = -32002;
    ErrorCodes.UnknownErrorCode = -32001;
    /**
     * This is the end range of JSON RPC reserved error codes.
     * It doesn't denote a real error code.
     *
     * @since 3.16.0
    */
    ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
    /** @deprecated use  jsonrpcReservedErrorRangeEnd */
    ErrorCodes.serverErrorEnd = ErrorCodes.jsonrpcReservedErrorRangeEnd;
})(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
/**
 * An error object return in a response in case a request
 * has failed.
 */
class ResponseError extends Error {
    constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
    }
    toJson() {
        return {
            code: this.code,
            message: this.message,
            data: this.data,
        };
    }
}
exports.ResponseError = ResponseError;
class ParameterStructures {
    constructor(kind) {
        this.kind = kind;
    }
    static is(value) {
        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
    }
    toString() {
        return this.kind;
    }
}
exports.ParameterStructures = ParameterStructures;
/**
 * The parameter structure is automatically inferred on the number of parameters
 * and the parameter type in case of a single param.
 */
ParameterStructures.auto = new ParameterStructures('auto');
/**
 * Forces `byPosition` parameter structure. This is useful if you have a single
 * parameter which has a literal type.
 */
ParameterStructures.byPosition = new ParameterStructures('byPosition');
/**
 * Forces `byName` parameter structure. This is only useful when having a single
 * parameter. The library will report errors if used with a different number of
 * parameters.
 */
ParameterStructures.byName = new ParameterStructures('byName');
/**
 * An abstract implementation of a MessageType.
 */
class AbstractMessageSignature {
    constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
    }
    get parameterStructures() {
        return ParameterStructures.auto;
    }
}
exports.AbstractMessageSignature = AbstractMessageSignature;
/**
 * Classes to type request response pairs
 */
class RequestType0 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 0);
    }
}
exports.RequestType0 = RequestType0;
class RequestType extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.RequestType = RequestType;
class RequestType1 extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.RequestType1 = RequestType1;
class RequestType2 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 2);
    }
}
exports.RequestType2 = RequestType2;
class RequestType3 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 3);
    }
}
exports.RequestType3 = RequestType3;
class RequestType4 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 4);
    }
}
exports.RequestType4 = RequestType4;
class RequestType5 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 5);
    }
}
exports.RequestType5 = RequestType5;
class RequestType6 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 6);
    }
}
exports.RequestType6 = RequestType6;
class RequestType7 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 7);
    }
}
exports.RequestType7 = RequestType7;
class RequestType8 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 8);
    }
}
exports.RequestType8 = RequestType8;
class RequestType9 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 9);
    }
}
exports.RequestType9 = RequestType9;
class NotificationType extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.NotificationType = NotificationType;
class NotificationType0 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 0);
    }
}
exports.NotificationType0 = NotificationType0;
class NotificationType1 extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.NotificationType1 = NotificationType1;
class NotificationType2 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 2);
    }
}
exports.NotificationType2 = NotificationType2;
class NotificationType3 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 3);
    }
}
exports.NotificationType3 = NotificationType3;
class NotificationType4 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 4);
    }
}
exports.NotificationType4 = NotificationType4;
class NotificationType5 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 5);
    }
}
exports.NotificationType5 = NotificationType5;
class NotificationType6 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 6);
    }
}
exports.NotificationType6 = NotificationType6;
class NotificationType7 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 7);
    }
}
exports.NotificationType7 = NotificationType7;
class NotificationType8 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 8);
    }
}
exports.NotificationType8 = NotificationType8;
class NotificationType9 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 9);
    }
}
exports.NotificationType9 = NotificationType9;
/**
 * Tests if the given message is a request message
 */
function isRequestMessage(message) {
    const candidate = message;
    return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
}
exports.isRequestMessage = isRequestMessage;
/**
 * Tests if the given message is a notification message
 */
function isNotificationMessage(message) {
    const candidate = message;
    return candidate && is.string(candidate.method) && message.id === void 0;
}
exports.isNotificationMessage = isNotificationMessage;
/**
 * Tests if the given message is a response message
 */
function isResponseMessage(message) {
    const candidate = message;
    return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
}
exports.isResponseMessage = isResponseMessage;
//# sourceMappingURL=messages.js.map

/***/ }),

/***/ 9:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
let _ral;
function RAL() {
    if (_ral === undefined) {
        throw new Error(`No runtime abstraction layer installed`);
    }
    return _ral;
}
(function (RAL) {
    function install(ral) {
        if (ral === undefined) {
            throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
    }
    RAL.install = install;
})(RAL || (RAL = {}));
exports.default = RAL;
//# sourceMappingURL=ral.js.map

/***/ }),

/***/ 20:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Semaphore = void 0;
const ral_1 = __webpack_require__(9);
class Semaphore {
    constructor(capacity = 1) {
        if (capacity <= 0) {
            throw new Error('Capacity must be greater than 0');
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
    }
    lock(thunk) {
        return new Promise((resolve, reject) => {
            this._waiting.push({ thunk, resolve, reject });
            this.runNext();
        });
    }
    get active() {
        return this._active;
    }
    runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        ral_1.default().timer.setImmediate(() => this.doRunNext());
    }
    doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
        }
        try {
            const result = next.thunk();
            if (result instanceof Promise) {
                result.then((value) => {
                    this._active--;
                    next.resolve(value);
                    this.runNext();
                }, (err) => {
                    this._active--;
                    next.reject(err);
                    this.runNext();
                });
            }
            else {
                this._active--;
                next.resolve(result);
                this.runNext();
            }
        }
        catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
        }
    }
}
exports.Semaphore = Semaphore;
//# sourceMappingURL=semaphore.js.map

/***/ }),

/***/ 7:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessageConnection = exports.createServerSocketTransport = exports.createClientSocketTransport = exports.createServerPipeTransport = exports.createClientPipeTransport = exports.generateRandomPipeName = exports.StreamMessageWriter = exports.StreamMessageReader = exports.SocketMessageWriter = exports.SocketMessageReader = exports.IPCMessageWriter = exports.IPCMessageReader = void 0;
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */
const ril_1 = __webpack_require__(8);
// Install the node runtime abstract.
ril_1.default.install();
const api_1 = __webpack_require__(13);
const path = __webpack_require__(23);
const os = __webpack_require__(24);
const crypto_1 = __webpack_require__(25);
const net_1 = __webpack_require__(26);
__exportStar(__webpack_require__(13), exports);
class IPCMessageReader extends api_1.AbstractMessageReader {
    constructor(process) {
        super();
        this.process = process;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose());
    }
    listen(callback) {
        this.process.on('message', callback);
        return api_1.Disposable.create(() => this.process.off('message', callback));
    }
}
exports.IPCMessageReader = IPCMessageReader;
class IPCMessageWriter extends api_1.AbstractMessageWriter {
    constructor(process) {
        super();
        this.process = process;
        this.errorCount = 0;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose);
    }
    write(msg) {
        try {
            if (typeof this.process.send === 'function') {
                this.process.send(msg, undefined, undefined, (error) => {
                    if (error) {
                        this.errorCount++;
                        this.handleError(error, msg);
                    }
                    else {
                        this.errorCount = 0;
                    }
                });
            }
            return Promise.resolve();
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
    }
}
exports.IPCMessageWriter = IPCMessageWriter;
class SocketMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(socket, encoding = 'utf-8') {
        super(ril_1.default().stream.asReadableStream(socket), encoding);
    }
}
exports.SocketMessageReader = SocketMessageReader;
class SocketMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(socket, options) {
        super(ril_1.default().stream.asWritableStream(socket), options);
        this.socket = socket;
    }
    dispose() {
        super.dispose();
        this.socket.destroy();
    }
}
exports.SocketMessageWriter = SocketMessageWriter;
class StreamMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(readble, encoding) {
        super(ril_1.default().stream.asReadableStream(readble), encoding);
    }
}
exports.StreamMessageReader = StreamMessageReader;
class StreamMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(writable, options) {
        super(ril_1.default().stream.asWritableStream(writable), options);
    }
}
exports.StreamMessageWriter = StreamMessageWriter;
const XDG_RUNTIME_DIR = process.env['XDG_RUNTIME_DIR'];
const safeIpcPathLengths = new Map([
    ['linux', 107],
    ['darwin', 103]
]);
function generateRandomPipeName() {
    const randomSuffix = crypto_1.randomBytes(21).toString('hex');
    if (process.platform === 'win32') {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
    }
    let result;
    if (XDG_RUNTIME_DIR) {
        result = path.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
    }
    else {
        result = path.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
    }
    const limit = safeIpcPathLengths.get(process.platform);
    if (limit !== undefined && result.length >= limit) {
        ril_1.default().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
    }
    return result;
}
exports.generateRandomPipeName = generateRandomPipeName;
function createClientPipeTransport(pipeName, encoding = 'utf-8') {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        let server = net_1.createServer((socket) => {
            server.close();
            connectResolve([
                new SocketMessageReader(socket, encoding),
                new SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(pipeName, () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientPipeTransport = createClientPipeTransport;
function createServerPipeTransport(pipeName, encoding = 'utf-8') {
    const socket = net_1.createConnection(pipeName);
    return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerPipeTransport = createServerPipeTransport;
function createClientSocketTransport(port, encoding = 'utf-8') {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        const server = net_1.createServer((socket) => {
            server.close();
            connectResolve([
                new SocketMessageReader(socket, encoding),
                new SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(port, '127.0.0.1', () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientSocketTransport = createClientSocketTransport;
function createServerSocketTransport(port, encoding = 'utf-8') {
    const socket = net_1.createConnection(port, '127.0.0.1');
    return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerSocketTransport = createServerSocketTransport;
function isReadableStream(value) {
    const candidate = value;
    return candidate.read !== undefined && candidate.addListener !== undefined;
}
function isWritableStream(value) {
    const candidate = value;
    return candidate.write !== undefined && candidate.addListener !== undefined;
}
function createMessageConnection(input, output, logger, options) {
    if (!logger) {
        logger = api_1.NullLogger;
    }
    const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
    const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
    if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return api_1.createMessageConnection(reader, writer, logger, options);
}
exports.createMessageConnection = createMessageConnection;
//# sourceMappingURL=main.js.map

/***/ }),

/***/ 8:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ral_1 = __webpack_require__(9);
const util_1 = __webpack_require__(10);
const disposable_1 = __webpack_require__(11);
const messageBuffer_1 = __webpack_require__(12);
class MessageBuffer extends messageBuffer_1.AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        super(encoding);
    }
    emptyBuffer() {
        return MessageBuffer.emptyBuffer;
    }
    fromString(value, encoding) {
        return Buffer.from(value, encoding);
    }
    toString(value, encoding) {
        if (value instanceof Buffer) {
            return value.toString(encoding);
        }
        else {
            return new util_1.TextDecoder(encoding).decode(value);
        }
    }
    asNative(buffer, length) {
        if (length === undefined) {
            return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        }
        else {
            return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
    }
    allocNative(length) {
        return Buffer.allocUnsafe(length);
    }
}
MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
class ReadableStreamWrapper {
    constructor(stream) {
        this.stream = stream;
    }
    onClose(listener) {
        this.stream.on('close', listener);
        return disposable_1.Disposable.create(() => this.stream.off('close', listener));
    }
    onError(listener) {
        this.stream.on('error', listener);
        return disposable_1.Disposable.create(() => this.stream.off('error', listener));
    }
    onEnd(listener) {
        this.stream.on('end', listener);
        return disposable_1.Disposable.create(() => this.stream.off('end', listener));
    }
    onData(listener) {
        this.stream.on('data', listener);
        return disposable_1.Disposable.create(() => this.stream.off('data', listener));
    }
}
class WritableStreamWrapper {
    constructor(stream) {
        this.stream = stream;
    }
    onClose(listener) {
        this.stream.on('close', listener);
        return disposable_1.Disposable.create(() => this.stream.off('close', listener));
    }
    onError(listener) {
        this.stream.on('error', listener);
        return disposable_1.Disposable.create(() => this.stream.off('error', listener));
    }
    onEnd(listener) {
        this.stream.on('end', listener);
        return disposable_1.Disposable.create(() => this.stream.off('end', listener));
    }
    write(data, encoding) {
        return new Promise((resolve, reject) => {
            const callback = (error) => {
                if (error === undefined || error === null) {
                    resolve();
                }
                else {
                    reject(error);
                }
            };
            if (typeof data === 'string') {
                this.stream.write(data, encoding, callback);
            }
            else {
                this.stream.write(data, callback);
            }
        });
    }
    end() {
        this.stream.end();
    }
}
const _ril = Object.freeze({
    messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
    }),
    applicationJson: Object.freeze({
        encoder: Object.freeze({
            name: 'application/json',
            encode: (msg, options) => {
                try {
                    return Promise.resolve(Buffer.from(JSON.stringify(msg, undefined, 0), options.charset));
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
        }),
        decoder: Object.freeze({
            name: 'application/json',
            decode: (buffer, options) => {
                try {
                    if (buffer instanceof Buffer) {
                        return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
                    }
                    else {
                        return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
        })
    }),
    stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
    }),
    console: console,
    timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
            return setTimeout(callback, ms, ...args);
        },
        clearTimeout(handle) {
            clearTimeout(handle);
        },
        setImmediate(callback, ...args) {
            return setImmediate(callback, ...args);
        },
        clearImmediate(handle) {
            clearImmediate(handle);
        }
    })
});
function RIL() {
    return _ril;
}
(function (RIL) {
    function install() {
        ral_1.default.install(_ril);
    }
    RIL.install = install;
})(RIL || (RIL = {}));
exports.default = RIL;
//# sourceMappingURL=ril.js.map

/***/ }),

/***/ 6:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(7);

/***/ }),

/***/ 27:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LSPErrorCodes = exports.createProtocolConnection = void 0;
__exportStar(__webpack_require__(7), exports);
__exportStar(__webpack_require__(28), exports);
__exportStar(__webpack_require__(29), exports);
__exportStar(__webpack_require__(30), exports);
var connection_1 = __webpack_require__(47);
Object.defineProperty(exports, "createProtocolConnection", ({ enumerable: true, get: function () { return connection_1.createProtocolConnection; } }));
var LSPErrorCodes;
(function (LSPErrorCodes) {
    /**
    * This is the start range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */
    LSPErrorCodes.lspReservedErrorRangeStart = -32899;
    LSPErrorCodes.ContentModified = -32801;
    LSPErrorCodes.RequestCancelled = -32800;
    /**
    * This is the end range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */
    LSPErrorCodes.lspReservedErrorRangeEnd = -32800;
})(LSPErrorCodes = exports.LSPErrorCodes || (exports.LSPErrorCodes = {}));
//# sourceMappingURL=api.js.map

/***/ }),

/***/ 47:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createProtocolConnection = void 0;
const vscode_jsonrpc_1 = __webpack_require__(7);
function createProtocolConnection(input, output, logger, options) {
    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return vscode_jsonrpc_1.createMessageConnection(input, output, logger, options);
}
exports.createProtocolConnection = createProtocolConnection;
//# sourceMappingURL=connection.js.map

/***/ }),

/***/ 29:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtocolNotificationType = exports.ProtocolNotificationType0 = exports.ProtocolRequestType = exports.ProtocolRequestType0 = exports.RegistrationType = void 0;
const vscode_jsonrpc_1 = __webpack_require__(7);
class RegistrationType {
    constructor(method) {
        this.method = method;
    }
}
exports.RegistrationType = RegistrationType;
class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolRequestType0 = ProtocolRequestType0;
class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
    constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
    }
}
exports.ProtocolRequestType = ProtocolRequestType;
class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolNotificationType0 = ProtocolNotificationType0;
class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
    constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
    }
}
exports.ProtocolNotificationType = ProtocolNotificationType;
// let x: ProtocolNotificationType<number, { value: number}>;
// let y: ProtocolNotificationType<string, { value: number}>;
// x = y;
//# sourceMappingURL=messages.js.map

/***/ }),

/***/ 41:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = void 0;
const messages_1 = __webpack_require__(29);
/**
 * A request to result a `CallHierarchyItem` in a document at a given position.
 * Can be used as an input to a incoming or outgoing call hierarchy.
 *
 * @since 3.16.0
 */
var CallHierarchyPrepareRequest;
(function (CallHierarchyPrepareRequest) {
    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
})(CallHierarchyPrepareRequest = exports.CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = {}));
/**
 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */
var CallHierarchyIncomingCallsRequest;
(function (CallHierarchyIncomingCallsRequest) {
    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
})(CallHierarchyIncomingCallsRequest = exports.CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = {}));
/**
 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */
var CallHierarchyOutgoingCallsRequest;
(function (CallHierarchyOutgoingCallsRequest) {
    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
})(CallHierarchyOutgoingCallsRequest = exports.CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = {}));
//# sourceMappingURL=protocol.callHierarchy.js.map

/***/ }),

/***/ 36:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorPresentationRequest = exports.DocumentColorRequest = void 0;
const messages_1 = __webpack_require__(29);
/**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type [DocumentColorParams](#DocumentColorParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */
var DocumentColorRequest;
(function (DocumentColorRequest) {
    DocumentColorRequest.method = 'textDocument/documentColor';
    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
})(DocumentColorRequest = exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));
/**
 * A request to list all presentation for a color. The request's
 * parameter is of type [ColorPresentationParams](#ColorPresentationParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */
var ColorPresentationRequest;
(function (ColorPresentationRequest) {
    ColorPresentationRequest.type = new messages_1.ProtocolRequestType('textDocument/colorPresentation');
})(ColorPresentationRequest = exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));
//# sourceMappingURL=protocol.colorProvider.js.map

/***/ }),

/***/ 35:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigurationRequest = void 0;
const messages_1 = __webpack_require__(29);
/**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */
var ConfigurationRequest;
(function (ConfigurationRequest) {
    ConfigurationRequest.type = new messages_1.ProtocolRequestType('workspace/configuration');
})(ConfigurationRequest = exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));
//# sourceMappingURL=protocol.configuration.js.map

/***/ }),

/***/ 38:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeclarationRequest = void 0;
const messages_1 = __webpack_require__(29);
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Declaration](#Declaration)
 * or a typed array of [DeclarationLink](#DeclarationLink) or a Thenable that resolves
 * to such.
 */
var DeclarationRequest;
(function (DeclarationRequest) {
    DeclarationRequest.method = 'textDocument/declaration';
    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
})(DeclarationRequest = exports.DeclarationRequest || (exports.DeclarationRequest = {}));
//# sourceMappingURL=protocol.declaration.js.map

/***/ }),

/***/ 45:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = void 0;
const messages_1 = __webpack_require__(29);
/**
 * A pattern kind describing if a glob pattern matches a file a folder or
 * both.
 *
 * @since 3.16.0
 */
var FileOperationPatternKind;
(function (FileOperationPatternKind) {
    /**
     * The pattern matches a file only.
     */
    FileOperationPatternKind.file = 'file';
    /**
     * The pattern matches a folder only.
     */
    FileOperationPatternKind.folder = 'folder';
})(FileOperationPatternKind = exports.FileOperationPatternKind || (exports.FileOperationPatternKind = {}));
/**
 * The will create files request is sent from the client to the server before files are actually
 * created as long as the creation is triggered from within the client.
 *
 * @since 3.16.0
 */
var WillCreateFilesRequest;
(function (WillCreateFilesRequest) {
    WillCreateFilesRequest.method = 'workspace/willCreateFiles';
    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);
})(WillCreateFilesRequest = exports.WillCreateFilesRequest || (exports.WillCreateFilesRequest = {}));
/**
 * The did create files notification is sent from the client to the server when
 * files were created from within the client.
 *
 * @since 3.16.0
 */
var DidCreateFilesNotification;
(function (DidCreateFilesNotification) {
    DidCreateFilesNotification.method = 'workspace/didCreateFiles';
    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);
})(DidCreateFilesNotification = exports.DidCreateFilesNotification || (exports.DidCreateFilesNotification = {}));
/**
 * The will rename files request is sent from the client to the server before files are actually
 * renamed as long as the rename is triggered from within the client.
 *
 * @since 3.16.0
 */
var WillRenameFilesRequest;
(function (WillRenameFilesRequest) {
    WillRenameFilesRequest.method = 'workspace/willRenameFiles';
    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);
})(WillRenameFilesRequest = exports.WillRenameFilesRequest || (exports.WillRenameFilesRequest = {}));
/**
 * The did rename files notification is sent from the client to the server when
 * files were renamed from within the client.
 *
 * @since 3.16.0
 */
var DidRenameFilesNotification;
(function (DidRenameFilesNotification) {
    DidRenameFilesNotification.method = 'workspace/didRenameFiles';
    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);
})(DidRenameFilesNotification = exports.DidRenameFilesNotification || (exports.DidRenameFilesNotification = {}));
/**
 * The will delete files request is sent from the client to the server before files are actually
 * deleted as long as the deletion is triggered from within the client.
 *
 * @since 3.16.0
 */
var DidDeleteFilesNotification;
(function (DidDeleteFilesNotification) {
    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';
    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);
})(DidDeleteFilesNotification = exports.DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = {}));
/**
 * The did delete files notification is sent from the client to the server when
 * files were deleted from within the client.
 *
 * @since 3.16.0
 */
var WillDeleteFilesRequest;
(function (WillDeleteFilesRequest) {
    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';
    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);
})(WillDeleteFilesRequest = exports.WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = {}));
//# sourceMappingURL=protocol.fileOperations.js.map

/***/ }),

/***/ 37:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FoldingRangeRequest = exports.FoldingRangeKind = void 0;
const messages_1 = __webpack_require__(29);
/**
 * Enum of known range kinds
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind["Comment"] = "comment";
    /**
     * Folding range for a imports or includes
     */
    FoldingRangeKind["Imports"] = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind["Region"] = "region";
})(FoldingRangeKind = exports.FoldingRangeKind || (exports.FoldingRangeKind = {}));
/**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type [FoldingRangeParams](#FoldingRangeParams), the
 * response is of type [FoldingRangeList](#FoldingRangeList) or a Thenable
 * that resolves to such.
 */
var FoldingRangeRequest;
(function (FoldingRangeRequest) {
    FoldingRangeRequest.method = 'textDocument/foldingRange';
    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
})(FoldingRangeRequest = exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));
//# sourceMappingURL=protocol.foldingRange.js.map

/***/ }),

/***/ 32:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImplementationRequest = void 0;
const messages_1 = __webpack_require__(29);
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
var ImplementationRequest;
(function (ImplementationRequest) {
    ImplementationRequest.method = 'textDocument/implementation';
    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
})(ImplementationRequest = exports.ImplementationRequest || (exports.ImplementationRequest = {}));
//# sourceMappingURL=protocol.implementation.js.map

/***/ }),

/***/ 30:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeError = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.DocumentFilter = void 0;
exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.SemanticTokens = exports.SemanticTokenModifiers = exports.SemanticTokenTypes = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = void 0;
const Is = __webpack_require__(31);
const messages_1 = __webpack_require__(29);
const protocol_implementation_1 = __webpack_require__(32);
Object.defineProperty(exports, "ImplementationRequest", ({ enumerable: true, get: function () { return protocol_implementation_1.ImplementationRequest; } }));
const protocol_typeDefinition_1 = __webpack_require__(33);
Object.defineProperty(exports, "TypeDefinitionRequest", ({ enumerable: true, get: function () { return protocol_typeDefinition_1.TypeDefinitionRequest; } }));
const protocol_workspaceFolders_1 = __webpack_require__(34);
Object.defineProperty(exports, "WorkspaceFoldersRequest", ({ enumerable: true, get: function () { return protocol_workspaceFolders_1.WorkspaceFoldersRequest; } }));
Object.defineProperty(exports, "DidChangeWorkspaceFoldersNotification", ({ enumerable: true, get: function () { return protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification; } }));
const protocol_configuration_1 = __webpack_require__(35);
Object.defineProperty(exports, "ConfigurationRequest", ({ enumerable: true, get: function () { return protocol_configuration_1.ConfigurationRequest; } }));
const protocol_colorProvider_1 = __webpack_require__(36);
Object.defineProperty(exports, "DocumentColorRequest", ({ enumerable: true, get: function () { return protocol_colorProvider_1.DocumentColorRequest; } }));
Object.defineProperty(exports, "ColorPresentationRequest", ({ enumerable: true, get: function () { return protocol_colorProvider_1.ColorPresentationRequest; } }));
const protocol_foldingRange_1 = __webpack_require__(37);
Object.defineProperty(exports, "FoldingRangeRequest", ({ enumerable: true, get: function () { return protocol_foldingRange_1.FoldingRangeRequest; } }));
const protocol_declaration_1 = __webpack_require__(38);
Object.defineProperty(exports, "DeclarationRequest", ({ enumerable: true, get: function () { return protocol_declaration_1.DeclarationRequest; } }));
const protocol_selectionRange_1 = __webpack_require__(39);
Object.defineProperty(exports, "SelectionRangeRequest", ({ enumerable: true, get: function () { return protocol_selectionRange_1.SelectionRangeRequest; } }));
const protocol_progress_1 = __webpack_require__(40);
Object.defineProperty(exports, "WorkDoneProgress", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgress; } }));
Object.defineProperty(exports, "WorkDoneProgressCreateRequest", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCreateRequest; } }));
Object.defineProperty(exports, "WorkDoneProgressCancelNotification", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCancelNotification; } }));
const protocol_callHierarchy_1 = __webpack_require__(41);
Object.defineProperty(exports, "CallHierarchyIncomingCallsRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest; } }));
Object.defineProperty(exports, "CallHierarchyOutgoingCallsRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest; } }));
Object.defineProperty(exports, "CallHierarchyPrepareRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyPrepareRequest; } }));
const protocol_semanticTokens_1 = __webpack_require__(42);
Object.defineProperty(exports, "SemanticTokenTypes", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokenTypes; } }));
Object.defineProperty(exports, "SemanticTokenModifiers", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokenModifiers; } }));
Object.defineProperty(exports, "SemanticTokens", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokens; } }));
Object.defineProperty(exports, "TokenFormat", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.TokenFormat; } }));
Object.defineProperty(exports, "SemanticTokensRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRequest; } }));
Object.defineProperty(exports, "SemanticTokensDeltaRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensDeltaRequest; } }));
Object.defineProperty(exports, "SemanticTokensRangeRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRangeRequest; } }));
Object.defineProperty(exports, "SemanticTokensRefreshRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRefreshRequest; } }));
Object.defineProperty(exports, "SemanticTokensRegistrationType", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRegistrationType; } }));
const protocol_showDocument_1 = __webpack_require__(43);
Object.defineProperty(exports, "ShowDocumentRequest", ({ enumerable: true, get: function () { return protocol_showDocument_1.ShowDocumentRequest; } }));
const protocol_linkedEditingRange_1 = __webpack_require__(44);
Object.defineProperty(exports, "LinkedEditingRangeRequest", ({ enumerable: true, get: function () { return protocol_linkedEditingRange_1.LinkedEditingRangeRequest; } }));
const protocol_fileOperations_1 = __webpack_require__(45);
Object.defineProperty(exports, "FileOperationPatternKind", ({ enumerable: true, get: function () { return protocol_fileOperations_1.FileOperationPatternKind; } }));
Object.defineProperty(exports, "DidCreateFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidCreateFilesNotification; } }));
Object.defineProperty(exports, "WillCreateFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillCreateFilesRequest; } }));
Object.defineProperty(exports, "DidRenameFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidRenameFilesNotification; } }));
Object.defineProperty(exports, "WillRenameFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillRenameFilesRequest; } }));
Object.defineProperty(exports, "DidDeleteFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidDeleteFilesNotification; } }));
Object.defineProperty(exports, "WillDeleteFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillDeleteFilesRequest; } }));
const protocol_moniker_1 = __webpack_require__(46);
Object.defineProperty(exports, "UniquenessLevel", ({ enumerable: true, get: function () { return protocol_moniker_1.UniquenessLevel; } }));
Object.defineProperty(exports, "MonikerKind", ({ enumerable: true, get: function () { return protocol_moniker_1.MonikerKind; } }));
Object.defineProperty(exports, "MonikerRequest", ({ enumerable: true, get: function () { return protocol_moniker_1.MonikerRequest; } }));
// @ts-ignore: to avoid inlining LocationLink as dynamic import
let __noDynamicImport;
/**
 * The DocumentFilter namespace provides helper functions to work with
 * [DocumentFilter](#DocumentFilter) literals.
 */
var DocumentFilter;
(function (DocumentFilter) {
    function is(value) {
        const candidate = value;
        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
    }
    DocumentFilter.is = is;
})(DocumentFilter = exports.DocumentFilter || (exports.DocumentFilter = {}));
/**
 * The DocumentSelector namespace provides helper functions to work with
 * [DocumentSelector](#DocumentSelector)s.
 */
var DocumentSelector;
(function (DocumentSelector) {
    function is(value) {
        if (!Array.isArray(value)) {
            return false;
        }
        for (let elem of value) {
            if (!Is.string(elem) && !DocumentFilter.is(elem)) {
                return false;
            }
        }
        return true;
    }
    DocumentSelector.is = is;
})(DocumentSelector = exports.DocumentSelector || (exports.DocumentSelector = {}));
/**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */
var RegistrationRequest;
(function (RegistrationRequest) {
    RegistrationRequest.type = new messages_1.ProtocolRequestType('client/registerCapability');
})(RegistrationRequest = exports.RegistrationRequest || (exports.RegistrationRequest = {}));
/**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */
var UnregistrationRequest;
(function (UnregistrationRequest) {
    UnregistrationRequest.type = new messages_1.ProtocolRequestType('client/unregisterCapability');
})(UnregistrationRequest = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));
var ResourceOperationKind;
(function (ResourceOperationKind) {
    /**
     * Supports creating new files and folders.
     */
    ResourceOperationKind.Create = 'create';
    /**
     * Supports renaming existing files and folders.
     */
    ResourceOperationKind.Rename = 'rename';
    /**
     * Supports deleting existing files and folders.
     */
    ResourceOperationKind.Delete = 'delete';
})(ResourceOperationKind = exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));
var FailureHandlingKind;
(function (FailureHandlingKind) {
    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */
    FailureHandlingKind.Abort = 'abort';
    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */
    FailureHandlingKind.Transactional = 'transactional';
    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling strategy is abort.
     */
    FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */
    FailureHandlingKind.Undo = 'undo';
})(FailureHandlingKind = exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));
/**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * [StaticRegistrationOptions](#StaticRegistrationOptions) literals.
 */
var StaticRegistrationOptions;
(function (StaticRegistrationOptions) {
    function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
    }
    StaticRegistrationOptions.hasId = hasId;
})(StaticRegistrationOptions = exports.StaticRegistrationOptions || (exports.StaticRegistrationOptions = {}));
/**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * [TextDocumentRegistrationOptions](#TextDocumentRegistrationOptions) literals.
 */
var TextDocumentRegistrationOptions;
(function (TextDocumentRegistrationOptions) {
    function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
    }
    TextDocumentRegistrationOptions.is = is;
})(TextDocumentRegistrationOptions = exports.TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = {}));
/**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * [WorkDoneProgressOptions](#WorkDoneProgressOptions) literals.
 */
var WorkDoneProgressOptions;
(function (WorkDoneProgressOptions) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
    }
    WorkDoneProgressOptions.is = is;
    function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
    }
    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
})(WorkDoneProgressOptions = exports.WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = {}));
/**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type [InitializeParams](#InitializeParams)
 * the response if of type [InitializeResult](#InitializeResult) of a Thenable that
 * resolves to such.
 */
var InitializeRequest;
(function (InitializeRequest) {
    InitializeRequest.type = new messages_1.ProtocolRequestType('initialize');
})(InitializeRequest = exports.InitializeRequest || (exports.InitializeRequest = {}));
/**
 * Known error codes for an `InitializeError`;
 */
var InitializeError;
(function (InitializeError) {
    /**
     * If the protocol version provided by the client can't be handled by the server.
     * @deprecated This initialize error got replaced by client capabilities. There is
     * no version handshake in version 3.0x
     */
    InitializeError.unknownProtocolVersion = 1;
})(InitializeError = exports.InitializeError || (exports.InitializeError = {}));
/**
 * The initialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */
var InitializedNotification;
(function (InitializedNotification) {
    InitializedNotification.type = new messages_1.ProtocolNotificationType('initialized');
})(InitializedNotification = exports.InitializedNotification || (exports.InitializedNotification = {}));
//---- Shutdown Method ----
/**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */
var ShutdownRequest;
(function (ShutdownRequest) {
    ShutdownRequest.type = new messages_1.ProtocolRequestType0('shutdown');
})(ShutdownRequest = exports.ShutdownRequest || (exports.ShutdownRequest = {}));
//---- Exit Notification ----
/**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */
var ExitNotification;
(function (ExitNotification) {
    ExitNotification.type = new messages_1.ProtocolNotificationType0('exit');
})(ExitNotification = exports.ExitNotification || (exports.ExitNotification = {}));
/**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */
var DidChangeConfigurationNotification;
(function (DidChangeConfigurationNotification) {
    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeConfiguration');
})(DidChangeConfigurationNotification = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));
//---- Message show and log notifications ----
/**
 * The message type
 */
var MessageType;
(function (MessageType) {
    /**
     * An error message.
     */
    MessageType.Error = 1;
    /**
     * A warning message.
     */
    MessageType.Warning = 2;
    /**
     * An information message.
     */
    MessageType.Info = 3;
    /**
     * A log message.
     */
    MessageType.Log = 4;
})(MessageType = exports.MessageType || (exports.MessageType = {}));
/**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */
var ShowMessageNotification;
(function (ShowMessageNotification) {
    ShowMessageNotification.type = new messages_1.ProtocolNotificationType('window/showMessage');
})(ShowMessageNotification = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));
/**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */
var ShowMessageRequest;
(function (ShowMessageRequest) {
    ShowMessageRequest.type = new messages_1.ProtocolRequestType('window/showMessageRequest');
})(ShowMessageRequest = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));
/**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */
var LogMessageNotification;
(function (LogMessageNotification) {
    LogMessageNotification.type = new messages_1.ProtocolNotificationType('window/logMessage');
})(LogMessageNotification = exports.LogMessageNotification || (exports.LogMessageNotification = {}));
//---- Telemetry notification
/**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */
var TelemetryEventNotification;
(function (TelemetryEventNotification) {
    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType('telemetry/event');
})(TelemetryEventNotification = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));
/**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */
var TextDocumentSyncKind;
(function (TextDocumentSyncKind) {
    /**
     * Documents should not be synced at all.
     */
    TextDocumentSyncKind.None = 0;
    /**
     * Documents are synced by always sending the full content
     * of the document.
     */
    TextDocumentSyncKind.Full = 1;
    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */
    TextDocumentSyncKind.Incremental = 2;
})(TextDocumentSyncKind = exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));
/**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */
var DidOpenTextDocumentNotification;
(function (DidOpenTextDocumentNotification) {
    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
})(DidOpenTextDocumentNotification = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));
var TextDocumentContentChangeEvent;
(function (TextDocumentContentChangeEvent) {
    /**
     * Checks whether the information describes a delta event.
     */
    function isIncremental(event) {
        let candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range !== undefined &&
            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
    }
    TextDocumentContentChangeEvent.isIncremental = isIncremental;
    /**
     * Checks whether the information describes a full replacement event.
     */
    function isFull(event) {
        let candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
    }
    TextDocumentContentChangeEvent.isFull = isFull;
})(TextDocumentContentChangeEvent = exports.TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = {}));
/**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */
var DidChangeTextDocumentNotification;
(function (DidChangeTextDocumentNotification) {
    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
})(DidChangeTextDocumentNotification = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));
/**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */
var DidCloseTextDocumentNotification;
(function (DidCloseTextDocumentNotification) {
    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
})(DidCloseTextDocumentNotification = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));
/**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */
var DidSaveTextDocumentNotification;
(function (DidSaveTextDocumentNotification) {
    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
})(DidSaveTextDocumentNotification = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));
/**
 * Represents reasons why a text document is saved.
 */
var TextDocumentSaveReason;
(function (TextDocumentSaveReason) {
    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */
    TextDocumentSaveReason.Manual = 1;
    /**
     * Automatic after a delay.
     */
    TextDocumentSaveReason.AfterDelay = 2;
    /**
     * When the editor lost focus.
     */
    TextDocumentSaveReason.FocusOut = 3;
})(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
/**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */
var WillSaveTextDocumentNotification;
(function (WillSaveTextDocumentNotification) {
    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
})(WillSaveTextDocumentNotification = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));
/**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */
var WillSaveTextDocumentWaitUntilRequest;
(function (WillSaveTextDocumentWaitUntilRequest) {
    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
})(WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));
/**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */
var DidChangeWatchedFilesNotification;
(function (DidChangeWatchedFilesNotification) {
    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeWatchedFiles');
})(DidChangeWatchedFilesNotification = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));
/**
 * The file event type
 */
var FileChangeType;
(function (FileChangeType) {
    /**
     * The file got created.
     */
    FileChangeType.Created = 1;
    /**
     * The file got changed.
     */
    FileChangeType.Changed = 2;
    /**
     * The file got deleted.
     */
    FileChangeType.Deleted = 3;
})(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
var WatchKind;
(function (WatchKind) {
    /**
     * Interested in create events.
     */
    WatchKind.Create = 1;
    /**
     * Interested in change events
     */
    WatchKind.Change = 2;
    /**
     * Interested in delete events
     */
    WatchKind.Delete = 4;
})(WatchKind = exports.WatchKind || (exports.WatchKind = {}));
/**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */
var PublishDiagnosticsNotification;
(function (PublishDiagnosticsNotification) {
    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType('textDocument/publishDiagnostics');
})(PublishDiagnosticsNotification = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));
/**
 * How a completion was triggered
 */
var CompletionTriggerKind;
(function (CompletionTriggerKind) {
    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */
    CompletionTriggerKind.Invoked = 1;
    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */
    CompletionTriggerKind.TriggerCharacter = 2;
    /**
     * Completion was re-triggered as current completion list is incomplete
     */
    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
})(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
/**
 * Request to request completion at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response
 * is of type [CompletionItem[]](#CompletionItem) or [CompletionList](#CompletionList)
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the [`detail`](#CompletionItem.detail)
 * and [`documentation`](#CompletionItem.documentation) properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */
var CompletionRequest;
(function (CompletionRequest) {
    CompletionRequest.method = 'textDocument/completion';
    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
})(CompletionRequest = exports.CompletionRequest || (exports.CompletionRequest = {}));
/**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type [CompletionItem](#CompletionItem) the response
 * is of type [CompletionItem](#CompletionItem) or a Thenable that resolves to such.
 */
var CompletionResolveRequest;
(function (CompletionResolveRequest) {
    CompletionResolveRequest.method = 'completionItem/resolve';
    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
})(CompletionResolveRequest = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));
/**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response is of
 * type [Hover](#Hover) or a Thenable that resolves to such.
 */
var HoverRequest;
(function (HoverRequest) {
    HoverRequest.method = 'textDocument/hover';
    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
})(HoverRequest = exports.HoverRequest || (exports.HoverRequest = {}));
/**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */
var SignatureHelpTriggerKind;
(function (SignatureHelpTriggerKind) {
    /**
     * Signature help was invoked manually by the user or by a command.
     */
    SignatureHelpTriggerKind.Invoked = 1;
    /**
     * Signature help was triggered by a trigger character.
     */
    SignatureHelpTriggerKind.TriggerCharacter = 2;
    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */
    SignatureHelpTriggerKind.ContentChange = 3;
})(SignatureHelpTriggerKind = exports.SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = {}));
var SignatureHelpRequest;
(function (SignatureHelpRequest) {
    SignatureHelpRequest.method = 'textDocument/signatureHelp';
    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
})(SignatureHelpRequest = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));
/**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the response is of either type [Definition](#Definition)
 * or a typed array of [DefinitionLink](#DefinitionLink) or a Thenable that resolves
 * to such.
 */
var DefinitionRequest;
(function (DefinitionRequest) {
    DefinitionRequest.method = 'textDocument/definition';
    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
})(DefinitionRequest = exports.DefinitionRequest || (exports.DefinitionRequest = {}));
/**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type [ReferenceParams](#ReferenceParams) the response is of type
 * [Location[]](#Location) or a Thenable that resolves to such.
 */
var ReferencesRequest;
(function (ReferencesRequest) {
    ReferencesRequest.method = 'textDocument/references';
    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
})(ReferencesRequest = exports.ReferencesRequest || (exports.ReferencesRequest = {}));
/**
 * Request to resolve a [DocumentHighlight](#DocumentHighlight) for a given
 * text document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]
 * (#DocumentHighlight) or a Thenable that resolves to such.
 */
var DocumentHighlightRequest;
(function (DocumentHighlightRequest) {
    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
})(DocumentHighlightRequest = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));
/**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type [TextDocumentIdentifier](#TextDocumentIdentifier) the
 * response is of type [SymbolInformation[]](#SymbolInformation) or a Thenable
 * that resolves to such.
 */
var DocumentSymbolRequest;
(function (DocumentSymbolRequest) {
    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
})(DocumentSymbolRequest = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));
/**
 * A request to provide commands for the given text document and range.
 */
var CodeActionRequest;
(function (CodeActionRequest) {
    CodeActionRequest.method = 'textDocument/codeAction';
    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
})(CodeActionRequest = exports.CodeActionRequest || (exports.CodeActionRequest = {}));
/**
 * Request to resolve additional information for a given code action.The request's
 * parameter is of type [CodeAction](#CodeAction) the response
 * is of type [CodeAction](#CodeAction) or a Thenable that resolves to such.
 */
var CodeActionResolveRequest;
(function (CodeActionResolveRequest) {
    CodeActionResolveRequest.method = 'codeAction/resolve';
    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);
})(CodeActionResolveRequest = exports.CodeActionResolveRequest || (exports.CodeActionResolveRequest = {}));
/**
 * A request to list project-wide symbols matching the query string given
 * by the [WorkspaceSymbolParams](#WorkspaceSymbolParams). The response is
 * of type [SymbolInformation[]](#SymbolInformation) or a Thenable that
 * resolves to such.
 */
var WorkspaceSymbolRequest;
(function (WorkspaceSymbolRequest) {
    WorkspaceSymbolRequest.method = 'workspace/symbol';
    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
})(WorkspaceSymbolRequest = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));
/**
 * A request to provide code lens for the given text document.
 */
var CodeLensRequest;
(function (CodeLensRequest) {
    CodeLensRequest.method = 'textDocument/codeLens';
    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);
})(CodeLensRequest = exports.CodeLensRequest || (exports.CodeLensRequest = {}));
/**
 * A request to resolve a command for a given code lens.
 */
var CodeLensResolveRequest;
(function (CodeLensResolveRequest) {
    CodeLensResolveRequest.method = 'codeLens/resolve';
    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);
})(CodeLensResolveRequest = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));
/**
 * A request to refresh all code actions
 *
 * @since 3.16.0
 */
var CodeLensRefreshRequest;
(function (CodeLensRefreshRequest) {
    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;
    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);
})(CodeLensRefreshRequest = exports.CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = {}));
/**
 * A request to provide document links
 */
var DocumentLinkRequest;
(function (DocumentLinkRequest) {
    DocumentLinkRequest.method = 'textDocument/documentLink';
    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
})(DocumentLinkRequest = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));
/**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type [DocumentLink](#DocumentLink) the response
 * is of type [DocumentLink](#DocumentLink) or a Thenable that resolves to such.
 */
var DocumentLinkResolveRequest;
(function (DocumentLinkResolveRequest) {
    DocumentLinkResolveRequest.method = 'documentLink/resolve';
    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);
})(DocumentLinkResolveRequest = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));
/**
 * A request to to format a whole document.
 */
var DocumentFormattingRequest;
(function (DocumentFormattingRequest) {
    DocumentFormattingRequest.method = 'textDocument/formatting';
    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
})(DocumentFormattingRequest = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));
/**
 * A request to to format a range in a document.
 */
var DocumentRangeFormattingRequest;
(function (DocumentRangeFormattingRequest) {
    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
})(DocumentRangeFormattingRequest = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));
/**
 * A request to format a document on type.
 */
var DocumentOnTypeFormattingRequest;
(function (DocumentOnTypeFormattingRequest) {
    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
})(DocumentOnTypeFormattingRequest = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));
//---- Rename ----------------------------------------------
var PrepareSupportDefaultBehavior;
(function (PrepareSupportDefaultBehavior) {
    /**
     * The client's default behavior is to select the identifier
     * according the to language's syntax rule.
     */
    PrepareSupportDefaultBehavior.Identifier = 1;
})(PrepareSupportDefaultBehavior = exports.PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = {}));
/**
 * A request to rename a symbol.
 */
var RenameRequest;
(function (RenameRequest) {
    RenameRequest.method = 'textDocument/rename';
    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
})(RenameRequest = exports.RenameRequest || (exports.RenameRequest = {}));
/**
 * A request to test and perform the setup necessary for a rename.
 *
 * @since 3.16 - support for default behavior
 */
var PrepareRenameRequest;
(function (PrepareRenameRequest) {
    PrepareRenameRequest.method = 'textDocument/prepareRename';
    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
})(PrepareRenameRequest = exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));
/**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */
var ExecuteCommandRequest;
(function (ExecuteCommandRequest) {
    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType('workspace/executeCommand');
})(ExecuteCommandRequest = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));
/**
 * A request sent from the server to the client to modified certain resources.
 */
var ApplyWorkspaceEditRequest;
(function (ApplyWorkspaceEditRequest) {
    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
})(ApplyWorkspaceEditRequest = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));
//# sourceMappingURL=protocol.js.map

/***/ }),

/***/ 44:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinkedEditingRangeRequest = void 0;
const messages_1 = __webpack_require__(29);
/**
 * A request to provide ranges that can be edited together.
 *
 * @since 3.16.0
 */
var LinkedEditingRangeRequest;
(function (LinkedEditingRangeRequest) {
    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';
    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);
})(LinkedEditingRangeRequest = exports.LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = {}));
//# sourceMappingURL=protocol.linkedEditingRange.js.map

/***/ }),

/***/ 46:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = void 0;
const messages_1 = __webpack_require__(29);
/**
 * Moniker uniqueness level to define scope of the moniker.
 *
 * @since 3.16.0
 */
var UniquenessLevel;
(function (UniquenessLevel) {
    /**
     * The moniker is only unique inside a document
     */
    UniquenessLevel["document"] = "document";
    /**
     * The moniker is unique inside a project for which a dump got created
     */
    UniquenessLevel["project"] = "project";
    /**
     * The moniker is unique inside the group to which a project belongs
     */
    UniquenessLevel["group"] = "group";
    /**
     * The moniker is unique inside the moniker scheme.
     */
    UniquenessLevel["scheme"] = "scheme";
    /**
     * The moniker is globally unique
     */
    UniquenessLevel["global"] = "global";
})(UniquenessLevel = exports.UniquenessLevel || (exports.UniquenessLevel = {}));
/**
 * The moniker kind.
 *
 * @since 3.16.0
 */
var MonikerKind;
(function (MonikerKind) {
    /**
     * The moniker represent a symbol that is imported into a project
     */
    MonikerKind["import"] = "import";
    /**
     * The moniker represents a symbol that is exported from a project
     */
    MonikerKind["export"] = "export";
    /**
     * The moniker represents a symbol that is local to a project (e.g. a local
     * variable of a function, a class not visible outside the project, ...)
     */
    MonikerKind["local"] = "local";
})(MonikerKind = exports.MonikerKind || (exports.MonikerKind = {}));
/**
 * A request to get the moniker of a symbol at a given text document position.
 * The request parameter is of type [TextDocumentPositionParams](#TextDocumentPositionParams).
 * The response is of type [Moniker[]](#Moniker[]) or `null`.
 */
var MonikerRequest;
(function (MonikerRequest) {
    MonikerRequest.method = 'textDocument/moniker';
    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);
})(MonikerRequest = exports.MonikerRequest || (exports.MonikerRequest = {}));
//# sourceMappingURL=protocol.moniker.js.map

/***/ }),

/***/ 40:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = void 0;
const vscode_jsonrpc_1 = __webpack_require__(7);
const messages_1 = __webpack_require__(29);
var WorkDoneProgress;
(function (WorkDoneProgress) {
    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
    function is(value) {
        return value === WorkDoneProgress.type;
    }
    WorkDoneProgress.is = is;
})(WorkDoneProgress = exports.WorkDoneProgress || (exports.WorkDoneProgress = {}));
/**
 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
 * reporting from the server.
 */
var WorkDoneProgressCreateRequest;
(function (WorkDoneProgressCreateRequest) {
    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType('window/workDoneProgress/create');
})(WorkDoneProgressCreateRequest = exports.WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = {}));
/**
 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
 * initiated on the server side.
 */
var WorkDoneProgressCancelNotification;
(function (WorkDoneProgressCancelNotification) {
    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType('window/workDoneProgress/cancel');
})(WorkDoneProgressCancelNotification = exports.WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = {}));
//# sourceMappingURL=protocol.progress.js.map

/***/ }),

/***/ 39:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionRangeRequest = void 0;
const messages_1 = __webpack_require__(29);
/**
 * A request to provide selection ranges in a document. The request's
 * parameter is of type [SelectionRangeParams](#SelectionRangeParams), the
 * response is of type [SelectionRange[]](#SelectionRange[]) or a Thenable
 * that resolves to such.
 */
var SelectionRangeRequest;
(function (SelectionRangeRequest) {
    SelectionRangeRequest.method = 'textDocument/selectionRange';
    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
})(SelectionRangeRequest = exports.SelectionRangeRequest || (exports.SelectionRangeRequest = {}));
//# sourceMappingURL=protocol.selectionRange.js.map

/***/ }),

/***/ 42:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = exports.SemanticTokens = exports.SemanticTokenModifiers = exports.SemanticTokenTypes = void 0;
const messages_1 = __webpack_require__(29);
/**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */
var SemanticTokenTypes;
(function (SemanticTokenTypes) {
    SemanticTokenTypes["namespace"] = "namespace";
    /**
     * Represents a generic type. Acts as a fallback for types which can't be mapped to
     * a specific type like class or enum.
     */
    SemanticTokenTypes["type"] = "type";
    SemanticTokenTypes["class"] = "class";
    SemanticTokenTypes["enum"] = "enum";
    SemanticTokenTypes["interface"] = "interface";
    SemanticTokenTypes["struct"] = "struct";
    SemanticTokenTypes["typeParameter"] = "typeParameter";
    SemanticTokenTypes["parameter"] = "parameter";
    SemanticTokenTypes["variable"] = "variable";
    SemanticTokenTypes["property"] = "property";
    SemanticTokenTypes["enumMember"] = "enumMember";
    SemanticTokenTypes["event"] = "event";
    SemanticTokenTypes["function"] = "function";
    SemanticTokenTypes["method"] = "method";
    SemanticTokenTypes["macro"] = "macro";
    SemanticTokenTypes["keyword"] = "keyword";
    SemanticTokenTypes["modifier"] = "modifier";
    SemanticTokenTypes["comment"] = "comment";
    SemanticTokenTypes["string"] = "string";
    SemanticTokenTypes["number"] = "number";
    SemanticTokenTypes["regexp"] = "regexp";
    SemanticTokenTypes["operator"] = "operator";
})(SemanticTokenTypes = exports.SemanticTokenTypes || (exports.SemanticTokenTypes = {}));
/**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */
var SemanticTokenModifiers;
(function (SemanticTokenModifiers) {
    SemanticTokenModifiers["declaration"] = "declaration";
    SemanticTokenModifiers["definition"] = "definition";
    SemanticTokenModifiers["readonly"] = "readonly";
    SemanticTokenModifiers["static"] = "static";
    SemanticTokenModifiers["deprecated"] = "deprecated";
    SemanticTokenModifiers["abstract"] = "abstract";
    SemanticTokenModifiers["async"] = "async";
    SemanticTokenModifiers["modification"] = "modification";
    SemanticTokenModifiers["documentation"] = "documentation";
    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
})(SemanticTokenModifiers = exports.SemanticTokenModifiers || (exports.SemanticTokenModifiers = {}));
/**
 * @since 3.16.0
 */
var SemanticTokens;
(function (SemanticTokens) {
    function is(value) {
        const candidate = value;
        return candidate !== undefined && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&
            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
    }
    SemanticTokens.is = is;
})(SemanticTokens = exports.SemanticTokens || (exports.SemanticTokens = {}));
//------- 'textDocument/semanticTokens' -----
var TokenFormat;
(function (TokenFormat) {
    TokenFormat.Relative = 'relative';
})(TokenFormat = exports.TokenFormat || (exports.TokenFormat = {}));
var SemanticTokensRegistrationType;
(function (SemanticTokensRegistrationType) {
    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';
    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);
})(SemanticTokensRegistrationType = exports.SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRequest;
(function (SemanticTokensRequest) {
    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';
    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
})(SemanticTokensRequest = exports.SemanticTokensRequest || (exports.SemanticTokensRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensDeltaRequest;
(function (SemanticTokensDeltaRequest) {
    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';
    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);
})(SemanticTokensDeltaRequest = exports.SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRangeRequest;
(function (SemanticTokensRangeRequest) {
    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
})(SemanticTokensRangeRequest = exports.SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRefreshRequest;
(function (SemanticTokensRefreshRequest) {
    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;
    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);
})(SemanticTokensRefreshRequest = exports.SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = {}));
//# sourceMappingURL=protocol.semanticTokens.js.map

/***/ }),

/***/ 43:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShowDocumentRequest = void 0;
const messages_1 = __webpack_require__(29);
/**
 * A request to show a document. This request might open an
 * external program depending on the value of the URI to open.
 * For example a request to open `https://code.visualstudio.com/`
 * will very likely open the URI in a WEB browser.
 *
 * @since 3.16.0
*/
var ShowDocumentRequest;
(function (ShowDocumentRequest) {
    ShowDocumentRequest.method = 'window/showDocument';
    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);
})(ShowDocumentRequest = exports.ShowDocumentRequest || (exports.ShowDocumentRequest = {}));
//# sourceMappingURL=protocol.showDocument.js.map

/***/ }),

/***/ 33:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeDefinitionRequest = void 0;
const messages_1 = __webpack_require__(29);
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
var TypeDefinitionRequest;
(function (TypeDefinitionRequest) {
    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
})(TypeDefinitionRequest = exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));
//# sourceMappingURL=protocol.typeDefinition.js.map

/***/ }),

/***/ 34:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = void 0;
const messages_1 = __webpack_require__(29);
/**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */
var WorkspaceFoldersRequest;
(function (WorkspaceFoldersRequest) {
    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0('workspace/workspaceFolders');
})(WorkspaceFoldersRequest = exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));
/**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */
var DidChangeWorkspaceFoldersNotification;
(function (DidChangeWorkspaceFoldersNotification) {
    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeWorkspaceFolders');
})(DidChangeWorkspaceFoldersNotification = exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));
//# sourceMappingURL=protocol.workspaceFolders.js.map

/***/ }),

/***/ 31:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.objectLiteral = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function objectLiteral(value) {
    // Strictly speaking class instances pass this check as well. Since the LSP
    // doesn't use classes we ignore this for now. If we do we need to add something
    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
    return value !== null && typeof value === 'object';
}
exports.objectLiteral = objectLiteral;
//# sourceMappingURL=is.js.map

/***/ }),

/***/ 5:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createProtocolConnection = void 0;
const node_1 = __webpack_require__(6);
__exportStar(__webpack_require__(6), exports);
__exportStar(__webpack_require__(27), exports);
function createProtocolConnection(input, output, logger, options) {
    return node_1.createMessageConnection(input, output, logger, options);
}
exports.createProtocolConnection = createProtocolConnection;
//# sourceMappingURL=main.js.map

/***/ }),

/***/ 62:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(5);

/***/ }),

/***/ 28:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "integer": () => (/* binding */ integer),
/* harmony export */   "uinteger": () => (/* binding */ uinteger),
/* harmony export */   "Position": () => (/* binding */ Position),
/* harmony export */   "Range": () => (/* binding */ Range),
/* harmony export */   "Location": () => (/* binding */ Location),
/* harmony export */   "LocationLink": () => (/* binding */ LocationLink),
/* harmony export */   "Color": () => (/* binding */ Color),
/* harmony export */   "ColorInformation": () => (/* binding */ ColorInformation),
/* harmony export */   "ColorPresentation": () => (/* binding */ ColorPresentation),
/* harmony export */   "FoldingRangeKind": () => (/* binding */ FoldingRangeKind),
/* harmony export */   "FoldingRange": () => (/* binding */ FoldingRange),
/* harmony export */   "DiagnosticRelatedInformation": () => (/* binding */ DiagnosticRelatedInformation),
/* harmony export */   "DiagnosticSeverity": () => (/* binding */ DiagnosticSeverity),
/* harmony export */   "DiagnosticTag": () => (/* binding */ DiagnosticTag),
/* harmony export */   "CodeDescription": () => (/* binding */ CodeDescription),
/* harmony export */   "Diagnostic": () => (/* binding */ Diagnostic),
/* harmony export */   "Command": () => (/* binding */ Command),
/* harmony export */   "TextEdit": () => (/* binding */ TextEdit),
/* harmony export */   "ChangeAnnotation": () => (/* binding */ ChangeAnnotation),
/* harmony export */   "ChangeAnnotationIdentifier": () => (/* binding */ ChangeAnnotationIdentifier),
/* harmony export */   "AnnotatedTextEdit": () => (/* binding */ AnnotatedTextEdit),
/* harmony export */   "TextDocumentEdit": () => (/* binding */ TextDocumentEdit),
/* harmony export */   "CreateFile": () => (/* binding */ CreateFile),
/* harmony export */   "RenameFile": () => (/* binding */ RenameFile),
/* harmony export */   "DeleteFile": () => (/* binding */ DeleteFile),
/* harmony export */   "WorkspaceEdit": () => (/* binding */ WorkspaceEdit),
/* harmony export */   "WorkspaceChange": () => (/* binding */ WorkspaceChange),
/* harmony export */   "TextDocumentIdentifier": () => (/* binding */ TextDocumentIdentifier),
/* harmony export */   "VersionedTextDocumentIdentifier": () => (/* binding */ VersionedTextDocumentIdentifier),
/* harmony export */   "OptionalVersionedTextDocumentIdentifier": () => (/* binding */ OptionalVersionedTextDocumentIdentifier),
/* harmony export */   "TextDocumentItem": () => (/* binding */ TextDocumentItem),
/* harmony export */   "MarkupKind": () => (/* binding */ MarkupKind),
/* harmony export */   "MarkupContent": () => (/* binding */ MarkupContent),
/* harmony export */   "CompletionItemKind": () => (/* binding */ CompletionItemKind),
/* harmony export */   "InsertTextFormat": () => (/* binding */ InsertTextFormat),
/* harmony export */   "CompletionItemTag": () => (/* binding */ CompletionItemTag),
/* harmony export */   "InsertReplaceEdit": () => (/* binding */ InsertReplaceEdit),
/* harmony export */   "InsertTextMode": () => (/* binding */ InsertTextMode),
/* harmony export */   "CompletionItem": () => (/* binding */ CompletionItem),
/* harmony export */   "CompletionList": () => (/* binding */ CompletionList),
/* harmony export */   "MarkedString": () => (/* binding */ MarkedString),
/* harmony export */   "Hover": () => (/* binding */ Hover),
/* harmony export */   "ParameterInformation": () => (/* binding */ ParameterInformation),
/* harmony export */   "SignatureInformation": () => (/* binding */ SignatureInformation),
/* harmony export */   "DocumentHighlightKind": () => (/* binding */ DocumentHighlightKind),
/* harmony export */   "DocumentHighlight": () => (/* binding */ DocumentHighlight),
/* harmony export */   "SymbolKind": () => (/* binding */ SymbolKind),
/* harmony export */   "SymbolTag": () => (/* binding */ SymbolTag),
/* harmony export */   "SymbolInformation": () => (/* binding */ SymbolInformation),
/* harmony export */   "DocumentSymbol": () => (/* binding */ DocumentSymbol),
/* harmony export */   "CodeActionKind": () => (/* binding */ CodeActionKind),
/* harmony export */   "CodeActionContext": () => (/* binding */ CodeActionContext),
/* harmony export */   "CodeAction": () => (/* binding */ CodeAction),
/* harmony export */   "CodeLens": () => (/* binding */ CodeLens),
/* harmony export */   "FormattingOptions": () => (/* binding */ FormattingOptions),
/* harmony export */   "DocumentLink": () => (/* binding */ DocumentLink),
/* harmony export */   "SelectionRange": () => (/* binding */ SelectionRange),
/* harmony export */   "EOL": () => (/* binding */ EOL),
/* harmony export */   "TextDocument": () => (/* binding */ TextDocument)
/* harmony export */ });
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var integer;
(function (integer) {
    integer.MIN_VALUE = -2147483648;
    integer.MAX_VALUE = 2147483647;
})(integer || (integer = {}));
var uinteger;
(function (uinteger) {
    uinteger.MIN_VALUE = 0;
    uinteger.MAX_VALUE = 2147483647;
})(uinteger || (uinteger = {}));
/**
 * The Position namespace provides helper functions to work with
 * [Position](#Position) literals.
 */
var Position;
(function (Position) {
    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */
    function create(line, character) {
        if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
        }
        if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
        }
        return { line: line, character: character };
    }
    Position.create = create;
    /**
     * Checks whether the given literal conforms to the [Position](#Position) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
    }
    Position.is = is;
})(Position || (Position = {}));
/**
 * The Range namespace provides helper functions to work with
 * [Range](#Range) literals.
 */
var Range;
(function (Range) {
    function create(one, two, three, four) {
        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
        }
        else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
        }
        else {
            throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
        }
    }
    Range.create = create;
    /**
     * Checks whether the given literal conforms to the [Range](#Range) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
    }
    Range.is = is;
})(Range || (Range = {}));
/**
 * The Location namespace provides helper functions to work with
 * [Location](#Location) literals.
 */
var Location;
(function (Location) {
    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */
    function create(uri, range) {
        return { uri: uri, range: range };
    }
    Location.create = create;
    /**
     * Checks whether the given literal conforms to the [Location](#Location) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
    }
    Location.is = is;
})(Location || (Location = {}));
/**
 * The LocationLink namespace provides helper functions to work with
 * [LocationLink](#LocationLink) literals.
 */
var LocationLink;
(function (LocationLink) {
    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };
    }
    LocationLink.create = create;
    /**
     * Checks whether the given literal conforms to the [LocationLink](#LocationLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)
            && (Range.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange))
            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
    }
    LocationLink.is = is;
})(LocationLink || (LocationLink = {}));
/**
 * The Color namespace provides helper functions to work with
 * [Color](#Color) literals.
 */
var Color;
(function (Color) {
    /**
     * Creates a new Color literal.
     */
    function create(red, green, blue, alpha) {
        return {
            red: red,
            green: green,
            blue: blue,
            alpha: alpha,
        };
    }
    Color.create = create;
    /**
     * Checks whether the given literal conforms to the [Color](#Color) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.numberRange(candidate.red, 0, 1)
            && Is.numberRange(candidate.green, 0, 1)
            && Is.numberRange(candidate.blue, 0, 1)
            && Is.numberRange(candidate.alpha, 0, 1);
    }
    Color.is = is;
})(Color || (Color = {}));
/**
 * The ColorInformation namespace provides helper functions to work with
 * [ColorInformation](#ColorInformation) literals.
 */
var ColorInformation;
(function (ColorInformation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(range, color) {
        return {
            range: range,
            color: color,
        };
    }
    ColorInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Range.is(candidate.range) && Color.is(candidate.color);
    }
    ColorInformation.is = is;
})(ColorInformation || (ColorInformation = {}));
/**
 * The Color namespace provides helper functions to work with
 * [ColorPresentation](#ColorPresentation) literals.
 */
var ColorPresentation;
(function (ColorPresentation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(label, textEdit, additionalTextEdits) {
        return {
            label: label,
            textEdit: textEdit,
            additionalTextEdits: additionalTextEdits,
        };
    }
    ColorPresentation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate.label)
            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))
            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
    }
    ColorPresentation.is = is;
})(ColorPresentation || (ColorPresentation = {}));
/**
 * Enum of known range kinds
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind["Comment"] = "comment";
    /**
     * Folding range for a imports or includes
     */
    FoldingRangeKind["Imports"] = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind["Region"] = "region";
})(FoldingRangeKind || (FoldingRangeKind = {}));
/**
 * The folding range namespace provides helper functions to work with
 * [FoldingRange](#FoldingRange) literals.
 */
var FoldingRange;
(function (FoldingRange) {
    /**
     * Creates a new FoldingRange literal.
     */
    function create(startLine, endLine, startCharacter, endCharacter, kind) {
        var result = {
            startLine: startLine,
            endLine: endLine
        };
        if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
            result.kind = kind;
        }
        return result;
    }
    FoldingRange.create = create;
    /**
     * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)
            && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))
            && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))
            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
    }
    FoldingRange.is = is;
})(FoldingRange || (FoldingRange = {}));
/**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.
 */
var DiagnosticRelatedInformation;
(function (DiagnosticRelatedInformation) {
    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */
    function create(location, message) {
        return {
            location: location,
            message: message
        };
    }
    DiagnosticRelatedInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
    }
    DiagnosticRelatedInformation.is = is;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
/**
 * The diagnostic's severity.
 */
var DiagnosticSeverity;
(function (DiagnosticSeverity) {
    /**
     * Reports an error.
     */
    DiagnosticSeverity.Error = 1;
    /**
     * Reports a warning.
     */
    DiagnosticSeverity.Warning = 2;
    /**
     * Reports an information.
     */
    DiagnosticSeverity.Information = 3;
    /**
     * Reports a hint.
     */
    DiagnosticSeverity.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
/**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */
var DiagnosticTag;
(function (DiagnosticTag) {
    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */
    DiagnosticTag.Unnecessary = 1;
    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */
    DiagnosticTag.Deprecated = 2;
})(DiagnosticTag || (DiagnosticTag = {}));
/**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */
var CodeDescription;
(function (CodeDescription) {
    function is(value) {
        var candidate = value;
        return candidate !== undefined && candidate !== null && Is.string(candidate.href);
    }
    CodeDescription.is = is;
})(CodeDescription || (CodeDescription = {}));
/**
 * The Diagnostic namespace provides helper functions to work with
 * [Diagnostic](#Diagnostic) literals.
 */
var Diagnostic;
(function (Diagnostic) {
    /**
     * Creates a new Diagnostic literal.
     */
    function create(range, message, severity, code, source, relatedInformation) {
        var result = { range: range, message: message };
        if (Is.defined(severity)) {
            result.severity = severity;
        }
        if (Is.defined(code)) {
            result.code = code;
        }
        if (Is.defined(source)) {
            result.source = source;
        }
        if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
        }
        return result;
    }
    Diagnostic.create = create;
    /**
     * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.
     */
    function is(value) {
        var _a;
        var candidate = value;
        return Is.defined(candidate)
            && Range.is(candidate.range)
            && Is.string(candidate.message)
            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))
            && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))
            && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))
            && (Is.string(candidate.source) || Is.undefined(candidate.source))
            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic.is = is;
})(Diagnostic || (Diagnostic = {}));
/**
 * The Command namespace provides helper functions to work with
 * [Command](#Command) literals.
 */
var Command;
(function (Command) {
    /**
     * Creates a new Command literal.
     */
    function create(title, command) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var result = { title: title, command: command };
        if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
        }
        return result;
    }
    Command.create = create;
    /**
     * Checks whether the given literal conforms to the [Command](#Command) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
    }
    Command.is = is;
})(Command || (Command = {}));
/**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */
var TextEdit;
(function (TextEdit) {
    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */
    function replace(range, newText) {
        return { range: range, newText: newText };
    }
    TextEdit.replace = replace;
    /**
     * Creates a insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */
    function insert(position, newText) {
        return { range: { start: position, end: position }, newText: newText };
    }
    TextEdit.insert = insert;
    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */
    function del(range) {
        return { range: range, newText: '' };
    }
    TextEdit.del = del;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate)
            && Is.string(candidate.newText)
            && Range.is(candidate.range);
    }
    TextEdit.is = is;
})(TextEdit || (TextEdit = {}));
var ChangeAnnotation;
(function (ChangeAnnotation) {
    function create(label, needsConfirmation, description) {
        var result = { label: label };
        if (needsConfirmation !== undefined) {
            result.needsConfirmation = needsConfirmation;
        }
        if (description !== undefined) {
            result.description = description;
        }
        return result;
    }
    ChangeAnnotation.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && Is.objectLiteral(candidate) && Is.string(candidate.label) &&
            (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&
            (Is.string(candidate.description) || candidate.description === undefined);
    }
    ChangeAnnotation.is = is;
})(ChangeAnnotation || (ChangeAnnotation = {}));
var ChangeAnnotationIdentifier;
(function (ChangeAnnotationIdentifier) {
    function is(value) {
        var candidate = value;
        return typeof candidate === 'string';
    }
    ChangeAnnotationIdentifier.is = is;
})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
var AnnotatedTextEdit;
(function (AnnotatedTextEdit) {
    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */
    function replace(range, newText, annotation) {
        return { range: range, newText: newText, annotationId: annotation };
    }
    AnnotatedTextEdit.replace = replace;
    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */
    function insert(position, newText, annotation) {
        return { range: { start: position, end: position }, newText: newText, annotationId: annotation };
    }
    AnnotatedTextEdit.insert = insert;
    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */
    function del(range, annotation) {
        return { range: range, newText: '', annotationId: annotation };
    }
    AnnotatedTextEdit.del = del;
    function is(value) {
        var candidate = value;
        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    AnnotatedTextEdit.is = is;
})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
/**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */
var TextDocumentEdit;
(function (TextDocumentEdit) {
    /**
     * Creates a new `TextDocumentEdit`
     */
    function create(textDocument, edits) {
        return { textDocument: textDocument, edits: edits };
    }
    TextDocumentEdit.create = create;
    function is(value) {
        var candidate = value;
        return Is.defined(candidate)
            && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)
            && Array.isArray(candidate.edits);
    }
    TextDocumentEdit.is = is;
})(TextDocumentEdit || (TextDocumentEdit = {}));
var CreateFile;
(function (CreateFile) {
    function create(uri, options, annotation) {
        var result = {
            kind: 'create',
            uri: uri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    CreateFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    CreateFile.is = is;
})(CreateFile || (CreateFile = {}));
var RenameFile;
(function (RenameFile) {
    function create(oldUri, newUri, options, annotation) {
        var result = {
            kind: 'rename',
            oldUri: oldUri,
            newUri: newUri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    RenameFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    RenameFile.is = is;
})(RenameFile || (RenameFile = {}));
var DeleteFile;
(function (DeleteFile) {
    function create(uri, options, annotation) {
        var result = {
            kind: 'delete',
            uri: uri
        };
        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    DeleteFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    DeleteFile.is = is;
})(DeleteFile || (DeleteFile = {}));
var WorkspaceEdit;
(function (WorkspaceEdit) {
    function is(value) {
        var candidate = value;
        return candidate &&
            (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&
            (candidate.documentChanges === undefined || candidate.documentChanges.every(function (change) {
                if (Is.string(change.kind)) {
                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                }
                else {
                    return TextDocumentEdit.is(change);
                }
            }));
    }
    WorkspaceEdit.is = is;
})(WorkspaceEdit || (WorkspaceEdit = {}));
var TextEditChangeImpl = /** @class */ (function () {
    function TextEditChangeImpl(edits, changeAnnotations) {
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
    }
    TextEditChangeImpl.prototype.insert = function (position, newText, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.insert(position, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.insert(position, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.insert(position, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.replace = function (range, newText, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.replace(range, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.replace(range, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.replace(range, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.delete = function (range, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.del(range);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.del(range, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.del(range, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.add = function (edit) {
        this.edits.push(edit);
    };
    TextEditChangeImpl.prototype.all = function () {
        return this.edits;
    };
    TextEditChangeImpl.prototype.clear = function () {
        this.edits.splice(0, this.edits.length);
    };
    TextEditChangeImpl.prototype.assertChangeAnnotations = function (value) {
        if (value === undefined) {
            throw new Error("Text edit change is not configured to manage change annotations.");
        }
    };
    return TextEditChangeImpl;
}());
/**
 * A helper class
 */
var ChangeAnnotations = /** @class */ (function () {
    function ChangeAnnotations(annotations) {
        this._annotations = annotations === undefined ? Object.create(null) : annotations;
        this._counter = 0;
        this._size = 0;
    }
    ChangeAnnotations.prototype.all = function () {
        return this._annotations;
    };
    Object.defineProperty(ChangeAnnotations.prototype, "size", {
        get: function () {
            return this._size;
        },
        enumerable: false,
        configurable: true
    });
    ChangeAnnotations.prototype.manage = function (idOrAnnotation, annotation) {
        var id;
        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
            id = idOrAnnotation;
        }
        else {
            id = this.nextId();
            annotation = idOrAnnotation;
        }
        if (this._annotations[id] !== undefined) {
            throw new Error("Id " + id + " is already in use.");
        }
        if (annotation === undefined) {
            throw new Error("No annotation provided for id " + id);
        }
        this._annotations[id] = annotation;
        this._size++;
        return id;
    };
    ChangeAnnotations.prototype.nextId = function () {
        this._counter++;
        return this._counter.toString();
    };
    return ChangeAnnotations;
}());
/**
 * A workspace change helps constructing changes to a workspace.
 */
var WorkspaceChange = /** @class */ (function () {
    function WorkspaceChange(workspaceEdit) {
        var _this = this;
        this._textEditChanges = Object.create(null);
        if (workspaceEdit !== undefined) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function (change) {
                    if (TextDocumentEdit.is(change)) {
                        var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                        _this._textEditChanges[change.textDocument.uri] = textEditChange;
                    }
                });
            }
            else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function (key) {
                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                    _this._textEditChanges[key] = textEditChange;
                });
            }
        }
        else {
            this._workspaceEdit = {};
        }
    }
    Object.defineProperty(WorkspaceChange.prototype, "edit", {
        /**
         * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal
         * use to be returned from a workspace edit operation like rename.
         */
        get: function () {
            this.initDocumentChanges();
            if (this._changeAnnotations !== undefined) {
                if (this._changeAnnotations.size === 0) {
                    this._workspaceEdit.changeAnnotations = undefined;
                }
                else {
                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
            }
            return this._workspaceEdit;
        },
        enumerable: false,
        configurable: true
    });
    WorkspaceChange.prototype.getTextEditChange = function (key) {
        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === undefined) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
            var textDocument = { uri: key.uri, version: key.version };
            var result = this._textEditChanges[textDocument.uri];
            if (!result) {
                var edits = [];
                var textDocumentEdit = {
                    textDocument: textDocument,
                    edits: edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
            }
            return result;
        }
        else {
            this.initChanges();
            if (this._workspaceEdit.changes === undefined) {
                throw new Error('Workspace edit is not configured for normal text edit changes.');
            }
            var result = this._textEditChanges[key];
            if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
            }
            return result;
        }
    };
    WorkspaceChange.prototype.initDocumentChanges = function () {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._changeAnnotations = new ChangeAnnotations();
            this._workspaceEdit.documentChanges = [];
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
    };
    WorkspaceChange.prototype.initChanges = function () {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._workspaceEdit.changes = Object.create(null);
        }
    };
    WorkspaceChange.prototype.createFile = function (uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = CreateFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = CreateFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = RenameFile.create(oldUri, newUri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = RenameFile.create(oldUri, newUri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    WorkspaceChange.prototype.deleteFile = function (uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = DeleteFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = DeleteFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    return WorkspaceChange;
}());

/**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.
 */
var TextDocumentIdentifier;
(function (TextDocumentIdentifier) {
    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */
    function create(uri) {
        return { uri: uri };
    }
    TextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
    }
    TextDocumentIdentifier.is = is;
})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
/**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.
 */
var VersionedTextDocumentIdentifier;
(function (VersionedTextDocumentIdentifier) {
    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param uri The document's text.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    VersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
    }
    VersionedTextDocumentIdentifier.is = is;
})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
/**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) literals.
 */
var OptionalVersionedTextDocumentIdentifier;
(function (OptionalVersionedTextDocumentIdentifier) {
    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param uri The document's text.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    OptionalVersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
    }
    OptionalVersionedTextDocumentIdentifier.is = is;
})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
/**
 * The TextDocumentItem namespace provides helper functions to work with
 * [TextDocumentItem](#TextDocumentItem) literals.
 */
var TextDocumentItem;
(function (TextDocumentItem) {
    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */
    function create(uri, languageId, version, text) {
        return { uri: uri, languageId: languageId, version: version, text: text };
    }
    TextDocumentItem.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
    }
    TextDocumentItem.is = is;
})(TextDocumentItem || (TextDocumentItem = {}));
/**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */
var MarkupKind;
(function (MarkupKind) {
    /**
     * Plain text is supported as a content format
     */
    MarkupKind.PlainText = 'plaintext';
    /**
     * Markdown is supported as a content format
     */
    MarkupKind.Markdown = 'markdown';
})(MarkupKind || (MarkupKind = {}));
(function (MarkupKind) {
    /**
     * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.
     */
    function is(value) {
        var candidate = value;
        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
    }
    MarkupKind.is = is;
})(MarkupKind || (MarkupKind = {}));
var MarkupContent;
(function (MarkupContent) {
    /**
     * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
    }
    MarkupContent.is = is;
})(MarkupContent || (MarkupContent = {}));
/**
 * The kind of a completion entry.
 */
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind.Text = 1;
    CompletionItemKind.Method = 2;
    CompletionItemKind.Function = 3;
    CompletionItemKind.Constructor = 4;
    CompletionItemKind.Field = 5;
    CompletionItemKind.Variable = 6;
    CompletionItemKind.Class = 7;
    CompletionItemKind.Interface = 8;
    CompletionItemKind.Module = 9;
    CompletionItemKind.Property = 10;
    CompletionItemKind.Unit = 11;
    CompletionItemKind.Value = 12;
    CompletionItemKind.Enum = 13;
    CompletionItemKind.Keyword = 14;
    CompletionItemKind.Snippet = 15;
    CompletionItemKind.Color = 16;
    CompletionItemKind.File = 17;
    CompletionItemKind.Reference = 18;
    CompletionItemKind.Folder = 19;
    CompletionItemKind.EnumMember = 20;
    CompletionItemKind.Constant = 21;
    CompletionItemKind.Struct = 22;
    CompletionItemKind.Event = 23;
    CompletionItemKind.Operator = 24;
    CompletionItemKind.TypeParameter = 25;
})(CompletionItemKind || (CompletionItemKind = {}));
/**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */
var InsertTextFormat;
(function (InsertTextFormat) {
    /**
     * The primary text to be inserted is treated as a plain string.
     */
    InsertTextFormat.PlainText = 1;
    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */
    InsertTextFormat.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
/**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */
var CompletionItemTag;
(function (CompletionItemTag) {
    /**
     * Render a completion as obsolete, usually using a strike-out.
     */
    CompletionItemTag.Deprecated = 1;
})(CompletionItemTag || (CompletionItemTag = {}));
/**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */
var InsertReplaceEdit;
(function (InsertReplaceEdit) {
    /**
     * Creates a new insert / replace edit
     */
    function create(newText, insert, replace) {
        return { newText: newText, insert: insert, replace: replace };
    }
    InsertReplaceEdit.create = create;
    /**
     * Checks whether the given literal conforms to the [InsertReplaceEdit](#InsertReplaceEdit) interface.
     */
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
    }
    InsertReplaceEdit.is = is;
})(InsertReplaceEdit || (InsertReplaceEdit = {}));
/**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */
var InsertTextMode;
(function (InsertTextMode) {
    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */
    InsertTextMode.asIs = 1;
    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */
    InsertTextMode.adjustIndentation = 2;
})(InsertTextMode || (InsertTextMode = {}));
/**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */
var CompletionItem;
(function (CompletionItem) {
    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */
    function create(label) {
        return { label: label };
    }
    CompletionItem.create = create;
})(CompletionItem || (CompletionItem = {}));
/**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */
var CompletionList;
(function (CompletionList) {
    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */
    function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
    }
    CompletionList.create = create;
})(CompletionList || (CompletionList = {}));
var MarkedString;
(function (MarkedString) {
    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */
    function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
    }
    MarkedString.fromPlainText = fromPlainText;
    /**
     * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));
    }
    MarkedString.is = is;
})(MarkedString || (MarkedString = {}));
var Hover;
(function (Hover) {
    /**
     * Checks whether the given value conforms to the [Hover](#Hover) interface.
     */
    function is(value) {
        var candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||
            MarkedString.is(candidate.contents) ||
            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));
    }
    Hover.is = is;
})(Hover || (Hover = {}));
/**
 * The ParameterInformation namespace provides helper functions to work with
 * [ParameterInformation](#ParameterInformation) literals.
 */
var ParameterInformation;
(function (ParameterInformation) {
    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */
    function create(label, documentation) {
        return documentation ? { label: label, documentation: documentation } : { label: label };
    }
    ParameterInformation.create = create;
})(ParameterInformation || (ParameterInformation = {}));
/**
 * The SignatureInformation namespace provides helper functions to work with
 * [SignatureInformation](#SignatureInformation) literals.
 */
var SignatureInformation;
(function (SignatureInformation) {
    function create(label, documentation) {
        var parameters = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
        }
        var result = { label: label };
        if (Is.defined(documentation)) {
            result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
            result.parameters = parameters;
        }
        else {
            result.parameters = [];
        }
        return result;
    }
    SignatureInformation.create = create;
})(SignatureInformation || (SignatureInformation = {}));
/**
 * A document highlight kind.
 */
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind.Text = 1;
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind.Read = 2;
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind.Write = 3;
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
/**
 * DocumentHighlight namespace to provide helper functions to work with
 * [DocumentHighlight](#DocumentHighlight) literals.
 */
var DocumentHighlight;
(function (DocumentHighlight) {
    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     */
    function create(range, kind) {
        var result = { range: range };
        if (Is.number(kind)) {
            result.kind = kind;
        }
        return result;
    }
    DocumentHighlight.create = create;
})(DocumentHighlight || (DocumentHighlight = {}));
/**
 * A symbol kind.
 */
var SymbolKind;
(function (SymbolKind) {
    SymbolKind.File = 1;
    SymbolKind.Module = 2;
    SymbolKind.Namespace = 3;
    SymbolKind.Package = 4;
    SymbolKind.Class = 5;
    SymbolKind.Method = 6;
    SymbolKind.Property = 7;
    SymbolKind.Field = 8;
    SymbolKind.Constructor = 9;
    SymbolKind.Enum = 10;
    SymbolKind.Interface = 11;
    SymbolKind.Function = 12;
    SymbolKind.Variable = 13;
    SymbolKind.Constant = 14;
    SymbolKind.String = 15;
    SymbolKind.Number = 16;
    SymbolKind.Boolean = 17;
    SymbolKind.Array = 18;
    SymbolKind.Object = 19;
    SymbolKind.Key = 20;
    SymbolKind.Null = 21;
    SymbolKind.EnumMember = 22;
    SymbolKind.Struct = 23;
    SymbolKind.Event = 24;
    SymbolKind.Operator = 25;
    SymbolKind.TypeParameter = 26;
})(SymbolKind || (SymbolKind = {}));
/**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 * @since 3.16
 */
var SymbolTag;
(function (SymbolTag) {
    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */
    SymbolTag.Deprecated = 1;
})(SymbolTag || (SymbolTag = {}));
var SymbolInformation;
(function (SymbolInformation) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol, defaults to the current document.
     * @param containerName The name of the symbol containing the symbol.
     */
    function create(name, kind, range, uri, containerName) {
        var result = {
            name: name,
            kind: kind,
            location: { uri: uri, range: range }
        };
        if (containerName) {
            result.containerName = containerName;
        }
        return result;
    }
    SymbolInformation.create = create;
})(SymbolInformation || (SymbolInformation = {}));
var DocumentSymbol;
(function (DocumentSymbol) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */
    function create(name, detail, kind, range, selectionRange, children) {
        var result = {
            name: name,
            detail: detail,
            kind: kind,
            range: range,
            selectionRange: selectionRange
        };
        if (children !== undefined) {
            result.children = children;
        }
        return result;
    }
    DocumentSymbol.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.
     */
    function is(value) {
        var candidate = value;
        return candidate &&
            Is.string(candidate.name) && Is.number(candidate.kind) &&
            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&
            (candidate.detail === undefined || Is.string(candidate.detail)) &&
            (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&
            (candidate.children === undefined || Array.isArray(candidate.children)) &&
            (candidate.tags === undefined || Array.isArray(candidate.tags));
    }
    DocumentSymbol.is = is;
})(DocumentSymbol || (DocumentSymbol = {}));
/**
 * A set of predefined code action kinds
 */
var CodeActionKind;
(function (CodeActionKind) {
    /**
     * Empty kind.
     */
    CodeActionKind.Empty = '';
    /**
     * Base kind for quickfix actions: 'quickfix'
     */
    CodeActionKind.QuickFix = 'quickfix';
    /**
     * Base kind for refactoring actions: 'refactor'
     */
    CodeActionKind.Refactor = 'refactor';
    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */
    CodeActionKind.RefactorExtract = 'refactor.extract';
    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */
    CodeActionKind.RefactorInline = 'refactor.inline';
    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */
    CodeActionKind.RefactorRewrite = 'refactor.rewrite';
    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */
    CodeActionKind.Source = 'source';
    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */
    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */
    CodeActionKind.SourceFixAll = 'source.fixAll';
})(CodeActionKind || (CodeActionKind = {}));
/**
 * The CodeActionContext namespace provides helper functions to work with
 * [CodeActionContext](#CodeActionContext) literals.
 */
var CodeActionContext;
(function (CodeActionContext) {
    /**
     * Creates a new CodeActionContext literal.
     */
    function create(diagnostics, only) {
        var result = { diagnostics: diagnostics };
        if (only !== undefined && only !== null) {
            result.only = only;
        }
        return result;
    }
    CodeActionContext.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string));
    }
    CodeActionContext.is = is;
})(CodeActionContext || (CodeActionContext = {}));
var CodeAction;
(function (CodeAction) {
    function create(title, kindOrCommandOrEdit, kind) {
        var result = { title: title };
        var checkKind = true;
        if (typeof kindOrCommandOrEdit === 'string') {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
        }
        else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
        }
        else {
            result.edit = kindOrCommandOrEdit;
        }
        if (checkKind && kind !== undefined) {
            result.kind = kind;
        }
        return result;
    }
    CodeAction.create = create;
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.title) &&
            (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&
            (candidate.kind === undefined || Is.string(candidate.kind)) &&
            (candidate.edit !== undefined || candidate.command !== undefined) &&
            (candidate.command === undefined || Command.is(candidate.command)) &&
            (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&
            (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
    }
    CodeAction.is = is;
})(CodeAction || (CodeAction = {}));
/**
 * The CodeLens namespace provides helper functions to work with
 * [CodeLens](#CodeLens) literals.
 */
var CodeLens;
(function (CodeLens) {
    /**
     * Creates a new CodeLens literal.
     */
    function create(range, data) {
        var result = { range: range };
        if (Is.defined(data)) {
            result.data = data;
        }
        return result;
    }
    CodeLens.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
    }
    CodeLens.is = is;
})(CodeLens || (CodeLens = {}));
/**
 * The FormattingOptions namespace provides helper functions to work with
 * [FormattingOptions](#FormattingOptions) literals.
 */
var FormattingOptions;
(function (FormattingOptions) {
    /**
     * Creates a new FormattingOptions literal.
     */
    function create(tabSize, insertSpaces) {
        return { tabSize: tabSize, insertSpaces: insertSpaces };
    }
    FormattingOptions.create = create;
    /**
     * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
    }
    FormattingOptions.is = is;
})(FormattingOptions || (FormattingOptions = {}));
/**
 * The DocumentLink namespace provides helper functions to work with
 * [DocumentLink](#DocumentLink) literals.
 */
var DocumentLink;
(function (DocumentLink) {
    /**
     * Creates a new DocumentLink literal.
     */
    function create(range, target, data) {
        return { range: range, target: target, data: data };
    }
    DocumentLink.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
    }
    DocumentLink.is = is;
})(DocumentLink || (DocumentLink = {}));
/**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */
var SelectionRange;
(function (SelectionRange) {
    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */
    function create(range, parent) {
        return { range: range, parent: parent };
    }
    SelectionRange.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
    }
    SelectionRange.is = is;
})(SelectionRange || (SelectionRange = {}));
var EOL = ['\n', '\r\n', '\r'];
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)
            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
    }
    TextDocument.is = is;
    function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort(edits, function (a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            }
            else {
                throw new Error('Overlapping edit');
            }
            lastModifiedOffset = startOffset;
        }
        return text;
    }
    TextDocument.applyEdits = applyEdits;
    function mergeSort(data, compare) {
        if (data.length <= 1) {
            // sorted
            return data;
        }
        var p = (data.length / 2) | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort(left, compare);
        mergeSort(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
                // smaller_equal -> take left to preserve order
                data[i++] = left[leftIdx++];
            }
            else {
                // greater -> take right
                data[i++] = right[rightIdx++];
            }
        }
        while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
        }
        return data;
    }
})(TextDocument || (TextDocument = {}));
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var FullTextDocument = /** @class */ (function () {
    function FullTextDocument(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    Object.defineProperty(FullTextDocument.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "languageId", {
        get: function () {
            return this._languageId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: false,
        configurable: true
    });
    FullTextDocument.prototype.getText = function (range) {
        if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    };
    FullTextDocument.prototype.update = function (event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = undefined;
    };
    FullTextDocument.prototype.getLineOffsets = function () {
        if (this._lineOffsets === undefined) {
            var lineOffsets = [];
            var text = this._content;
            var isLineStart = true;
            for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                    lineOffsets.push(i);
                    isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = (ch === '\r' || ch === '\n');
                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                    i++;
                }
            }
            if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
    };
    FullTextDocument.prototype.positionAt = function (offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
            return Position.create(0, offset);
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        var line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
    };
    FullTextDocument.prototype.offsetAt = function (position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
        get: function () {
            return this.getLineOffsets().length;
        },
        enumerable: false,
        configurable: true
    });
    return FullTextDocument;
}());
var Is;
(function (Is) {
    var toString = Object.prototype.toString;
    function defined(value) {
        return typeof value !== 'undefined';
    }
    Is.defined = defined;
    function undefined(value) {
        return typeof value === 'undefined';
    }
    Is.undefined = undefined;
    function boolean(value) {
        return value === true || value === false;
    }
    Is.boolean = boolean;
    function string(value) {
        return toString.call(value) === '[object String]';
    }
    Is.string = string;
    function number(value) {
        return toString.call(value) === '[object Number]';
    }
    Is.number = number;
    function numberRange(value, min, max) {
        return toString.call(value) === '[object Number]' && min <= value && value <= max;
    }
    Is.numberRange = numberRange;
    function integer(value) {
        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
    }
    Is.integer = integer;
    function uinteger(value) {
        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
    }
    Is.uinteger = uinteger;
    function func(value) {
        return toString.call(value) === '[object Function]';
    }
    Is.func = func;
    function objectLiteral(value) {
        // Strictly speaking class instances pass this check as well. Since the LSP
        // doesn't use classes we ignore this for now. If we do we need to add something
        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
        return value !== null && typeof value === 'object';
    }
    Is.objectLiteral = objectLiteral;
    function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
    }
    Is.typedArray = typedArray;
})(Is || (Is = {}));


/***/ }),

/***/ 63:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProposedFeatures = exports.SemanticTokensBuilder = void 0;
const semanticTokens_1 = __webpack_require__(53);
Object.defineProperty(exports, "SemanticTokensBuilder", ({ enumerable: true, get: function () { return semanticTokens_1.SemanticTokensBuilder; } }));
__exportStar(__webpack_require__(5), exports);
__exportStar(__webpack_require__(4), exports);
var ProposedFeatures;
(function (ProposedFeatures) {
    ProposedFeatures.all = {
        __brand: 'features'
    };
})(ProposedFeatures = exports.ProposedFeatures || (exports.ProposedFeatures = {}));
//# sourceMappingURL=api.js.map

/***/ }),

/***/ 52:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallHierarchyFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(5);
const CallHierarchyFeature = (Base) => {
    return class extends Base {
        get callHierarchy() {
            return {
                onPrepare: (handler) => {
                    this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);
                    });
                },
                onIncomingCalls: (handler) => {
                    const type = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
                onOutgoingCalls: (handler) => {
                    const type = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                }
            };
        }
    };
};
exports.CallHierarchyFeature = CallHierarchyFeature;
//# sourceMappingURL=callHierarchy.js.map

/***/ }),

/***/ 50:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigurationFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(5);
const Is = __webpack_require__(3);
const ConfigurationFeature = (Base) => {
    return class extends Base {
        getConfiguration(arg) {
            if (!arg) {
                return this._getConfiguration({});
            }
            else if (Is.string(arg)) {
                return this._getConfiguration({ section: arg });
            }
            else {
                return this._getConfiguration(arg);
            }
        }
        _getConfiguration(arg) {
            let params = {
                items: Array.isArray(arg) ? arg : [arg]
            };
            return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
                return Array.isArray(arg) ? result : result[0];
            });
        }
    };
};
exports.ConfigurationFeature = ConfigurationFeature;
//# sourceMappingURL=configuration.js.map

/***/ }),

/***/ 55:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileOperationsFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(5);
const FileOperationsFeature = (Base) => {
    return class extends Base {
        onDidCreateFiles(handler) {
            this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {
                handler(params);
            });
        }
        onDidRenameFiles(handler) {
            this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {
                handler(params);
            });
        }
        onDidDeleteFiles(handler) {
            this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {
                handler(params);
            });
        }
        onWillCreateFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {
                return handler(params, cancel);
            });
        }
        onWillRenameFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {
                return handler(params, cancel);
            });
        }
        onWillDeleteFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {
                return handler(params, cancel);
            });
        }
    };
};
exports.FileOperationsFeature = FileOperationsFeature;
//# sourceMappingURL=fileOperations.js.map

/***/ }),

/***/ 56:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinkedEditingRangeFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(5);
const LinkedEditingRangeFeature = (Base) => {
    return class extends Base {
        onLinkedEditingRange(handler) {
            this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);
            });
        }
    };
};
exports.LinkedEditingRangeFeature = LinkedEditingRangeFeature;
//# sourceMappingURL=linkedEditingRange.js.map

/***/ }),

/***/ 57:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonikerFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(5);
const MonikerFeature = (Base) => {
    return class extends Base {
        get moniker() {
            return {
                on: (handler) => {
                    const type = vscode_languageserver_protocol_1.MonikerRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
            };
        }
    };
};
exports.MonikerFeature = MonikerFeature;
//# sourceMappingURL=moniker.js.map

/***/ }),

/***/ 49:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.attachPartialResult = exports.ProgressFeature = exports.attachWorkDone = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(5);
const uuid_1 = __webpack_require__(48);
class WorkDoneProgressReporterImpl {
    constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
        WorkDoneProgressReporterImpl.Instances.set(this._token, this);
    }
    begin(title, percentage, message, cancellable) {
        let param = {
            kind: 'begin',
            title,
            percentage,
            message,
            cancellable
        };
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
    }
    report(arg0, arg1) {
        let param = {
            kind: 'report'
        };
        if (typeof arg0 === 'number') {
            param.percentage = arg0;
            if (arg1 !== undefined) {
                param.message = arg1;
            }
        }
        else {
            param.message = arg0;
        }
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
    }
    done() {
        WorkDoneProgressReporterImpl.Instances.delete(this._token);
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: 'end' });
    }
}
WorkDoneProgressReporterImpl.Instances = new Map();
class WorkDoneProgressServerReporterImpl extends WorkDoneProgressReporterImpl {
    constructor(connection, token) {
        super(connection, token);
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
    }
    get token() {
        return this._source.token;
    }
    done() {
        this._source.dispose();
        super.done();
    }
    cancel() {
        this._source.cancel();
    }
}
class NullProgressReporter {
    constructor() {
    }
    begin() {
    }
    report() {
    }
    done() {
    }
}
class NullProgressServerReporter extends NullProgressReporter {
    constructor() {
        super();
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
    }
    get token() {
        return this._source.token;
    }
    done() {
        this._source.dispose();
    }
    cancel() {
        this._source.cancel();
    }
}
function attachWorkDone(connection, params) {
    if (params === undefined || params.workDoneToken === undefined) {
        return new NullProgressReporter();
    }
    const token = params.workDoneToken;
    delete params.workDoneToken;
    return new WorkDoneProgressReporterImpl(connection, token);
}
exports.attachWorkDone = attachWorkDone;
const ProgressFeature = (Base) => {
    return class extends Base {
        constructor() {
            super();
            this._progressSupported = false;
        }
        initialize(capabilities) {
            var _a;
            if (((_a = capabilities === null || capabilities === void 0 ? void 0 : capabilities.window) === null || _a === void 0 ? void 0 : _a.workDoneProgress) === true) {
                this._progressSupported = true;
                this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
                    let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
                    if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
                        progress.cancel();
                    }
                });
            }
        }
        attachWorkDoneProgress(token) {
            if (token === undefined) {
                return new NullProgressReporter();
            }
            else {
                return new WorkDoneProgressReporterImpl(this.connection, token);
            }
        }
        createWorkDoneProgress() {
            if (this._progressSupported) {
                const token = uuid_1.generateUuid();
                return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {
                    const result = new WorkDoneProgressServerReporterImpl(this.connection, token);
                    return result;
                });
            }
            else {
                return Promise.resolve(new NullProgressServerReporter());
            }
        }
    };
};
exports.ProgressFeature = ProgressFeature;
var ResultProgress;
(function (ResultProgress) {
    ResultProgress.type = new vscode_languageserver_protocol_1.ProgressType();
})(ResultProgress || (ResultProgress = {}));
class ResultProgressReporterImpl {
    constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
    }
    report(data) {
        this._connection.sendProgress(ResultProgress.type, this._token, data);
    }
}
function attachPartialResult(connection, params) {
    if (params === undefined || params.partialResultToken === undefined) {
        return undefined;
    }
    const token = params.partialResultToken;
    delete params.partialResultToken;
    return new ResultProgressReporterImpl(connection, token);
}
exports.attachPartialResult = attachPartialResult;
//# sourceMappingURL=progress.js.map

/***/ }),

/***/ 53:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SemanticTokensBuilder = exports.SemanticTokensFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(5);
const SemanticTokensFeature = (Base) => {
    return class extends Base {
        get semanticTokens() {
            return {
                on: (handler) => {
                    const type = vscode_languageserver_protocol_1.SemanticTokensRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
                onDelta: (handler) => {
                    const type = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
                onRange: (handler) => {
                    const type = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                }
            };
        }
    };
};
exports.SemanticTokensFeature = SemanticTokensFeature;
class SemanticTokensBuilder {
    constructor() {
        this._prevData = undefined;
        this.initialize();
    }
    initialize() {
        this._id = Date.now();
        this._prevLine = 0;
        this._prevChar = 0;
        this._data = [];
        this._dataLen = 0;
    }
    push(line, char, length, tokenType, tokenModifiers) {
        let pushLine = line;
        let pushChar = char;
        if (this._dataLen > 0) {
            pushLine -= this._prevLine;
            if (pushLine === 0) {
                pushChar -= this._prevChar;
            }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
    }
    get id() {
        return this._id.toString();
    }
    previousResult(id) {
        if (this.id === id) {
            this._prevData = this._data;
        }
        this.initialize();
    }
    build() {
        this._prevData = undefined;
        return {
            resultId: this.id,
            data: this._data
        };
    }
    canBuildEdits() {
        return this._prevData !== undefined;
    }
    buildEdits() {
        if (this._prevData !== undefined) {
            const prevDataLength = this._prevData.length;
            const dataLength = this._data.length;
            let startIndex = 0;
            while (startIndex < dataLength && startIndex < prevDataLength && this._prevData[startIndex] === this._data[startIndex]) {
                startIndex++;
            }
            if (startIndex < dataLength && startIndex < prevDataLength) {
                // Find end index
                let endIndex = 0;
                while (endIndex < dataLength && endIndex < prevDataLength && this._prevData[prevDataLength - 1 - endIndex] === this._data[dataLength - 1 - endIndex]) {
                    endIndex++;
                }
                const newData = this._data.slice(startIndex, dataLength - endIndex);
                const result = {
                    resultId: this.id,
                    edits: [
                        { start: startIndex, deleteCount: prevDataLength - endIndex - startIndex, data: newData }
                    ]
                };
                return result;
            }
            else if (startIndex < dataLength) {
                return { resultId: this.id, edits: [
                        { start: startIndex, deleteCount: 0, data: this._data.slice(startIndex) }
                    ] };
            }
            else if (startIndex < prevDataLength) {
                return { resultId: this.id, edits: [
                        { start: startIndex, deleteCount: prevDataLength - startIndex }
                    ] };
            }
            else {
                return { resultId: this.id, edits: [] };
            }
        }
        else {
            return this.build();
        }
    }
}
exports.SemanticTokensBuilder = SemanticTokensBuilder;
//# sourceMappingURL=semanticTokens.js.map

/***/ }),

/***/ 4:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createConnection = exports.combineFeatures = exports.combineLanguagesFeatures = exports.combineWorkspaceFeatures = exports.combineWindowFeatures = exports.combineClientFeatures = exports.combineTracerFeatures = exports.combineTelemetryFeatures = exports.combineConsoleFeatures = exports._LanguagesImpl = exports.BulkUnregistration = exports.BulkRegistration = exports.ErrorMessageTracker = exports.TextDocuments = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(5);
const Is = __webpack_require__(3);
const UUID = __webpack_require__(48);
const progress_1 = __webpack_require__(49);
const configuration_1 = __webpack_require__(50);
const workspaceFolders_1 = __webpack_require__(51);
const callHierarchy_1 = __webpack_require__(52);
const semanticTokens_1 = __webpack_require__(53);
const showDocument_1 = __webpack_require__(54);
const fileOperations_1 = __webpack_require__(55);
const linkedEditingRange_1 = __webpack_require__(56);
const moniker_1 = __webpack_require__(57);
function null2Undefined(value) {
    if (value === null) {
        return undefined;
    }
    return value;
}
/**
 * A manager for simple text documents
 */
class TextDocuments {
    /**
     * Create a new text document manager.
     */
    constructor(configuration) {
        this._documents = Object.create(null);
        this._configuration = configuration;
        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been opened or the content changes.
     */
    get onDidChangeContent() {
        return this._onDidChangeContent.event;
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been opened.
     */
    get onDidOpen() {
        return this._onDidOpen.event;
    }
    /**
     * An event that fires when a text document managed by this manager
     * will be saved.
     */
    get onWillSave() {
        return this._onWillSave.event;
    }
    /**
     * Sets a handler that will be called if a participant wants to provide
     * edits during a text document save.
     */
    onWillSaveWaitUntil(handler) {
        this._willSaveWaitUntil = handler;
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been saved.
     */
    get onDidSave() {
        return this._onDidSave.event;
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been closed.
     */
    get onDidClose() {
        return this._onDidClose.event;
    }
    /**
     * Returns the document for the given URI. Returns undefined if
     * the document is not managed by this instance.
     *
     * @param uri The text document's URI to retrieve.
     * @return the text document or `undefined`.
     */
    get(uri) {
        return this._documents[uri];
    }
    /**
     * Returns all text documents managed by this instance.
     *
     * @return all text documents.
     */
    all() {
        return Object.keys(this._documents).map(key => this._documents[key]);
    }
    /**
     * Returns the URIs of all text documents managed by this instance.
     *
     * @return the URI's of all text documents.
     */
    keys() {
        return Object.keys(this._documents);
    }
    /**
     * Listens for `low level` notification on the given connection to
     * update the text documents managed by this instance.
     *
     * Please note that the connection only provides handlers not an event model. Therefore
     * listening on a connection will overwrite the following handlers on a connection:
     * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,
     * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.
     *
     * Use the corresponding events on the TextDocuments instance instead.
     *
     * @param connection The connection to listen on.
     */
    listen(connection) {
        connection.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Full;
        connection.onDidOpenTextDocument((event) => {
            let td = event.textDocument;
            let document = this._configuration.create(td.uri, td.languageId, td.version, td.text);
            this._documents[td.uri] = document;
            let toFire = Object.freeze({ document });
            this._onDidOpen.fire(toFire);
            this._onDidChangeContent.fire(toFire);
        });
        connection.onDidChangeTextDocument((event) => {
            let td = event.textDocument;
            let changes = event.contentChanges;
            if (changes.length === 0) {
                return;
            }
            let document = this._documents[td.uri];
            const { version } = td;
            if (version === null || version === undefined) {
                throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
            }
            document = this._configuration.update(document, changes, version);
            this._documents[td.uri] = document;
            this._onDidChangeContent.fire(Object.freeze({ document }));
        });
        connection.onDidCloseTextDocument((event) => {
            let document = this._documents[event.textDocument.uri];
            if (document) {
                delete this._documents[event.textDocument.uri];
                this._onDidClose.fire(Object.freeze({ document }));
            }
        });
        connection.onWillSaveTextDocument((event) => {
            let document = this._documents[event.textDocument.uri];
            if (document) {
                this._onWillSave.fire(Object.freeze({ document, reason: event.reason }));
            }
        });
        connection.onWillSaveTextDocumentWaitUntil((event, token) => {
            let document = this._documents[event.textDocument.uri];
            if (document && this._willSaveWaitUntil) {
                return this._willSaveWaitUntil(Object.freeze({ document, reason: event.reason }), token);
            }
            else {
                return [];
            }
        });
        connection.onDidSaveTextDocument((event) => {
            let document = this._documents[event.textDocument.uri];
            if (document) {
                this._onDidSave.fire(Object.freeze({ document }));
            }
        });
    }
}
exports.TextDocuments = TextDocuments;
/**
 * Helps tracking error message. Equal occurrences of the same
 * message are only stored once. This class is for example
 * useful if text documents are validated in a loop and equal
 * error message should be folded into one.
 */
class ErrorMessageTracker {
    constructor() {
        this._messages = Object.create(null);
    }
    /**
     * Add a message to the tracker.
     *
     * @param message The message to add.
     */
    add(message) {
        let count = this._messages[message];
        if (!count) {
            count = 0;
        }
        count++;
        this._messages[message] = count;
    }
    /**
     * Send all tracked messages to the connection's window.
     *
     * @param connection The connection established between client and server.
     */
    sendErrors(connection) {
        Object.keys(this._messages).forEach(message => {
            connection.window.showErrorMessage(message);
        });
    }
}
exports.ErrorMessageTracker = ErrorMessageTracker;
class RemoteConsoleImpl {
    constructor() {
    }
    rawAttach(connection) {
        this._rawConnection = connection;
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    fillServerCapabilities(_capabilities) {
    }
    initialize(_capabilities) {
    }
    error(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
    }
    warn(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
    }
    info(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
    }
    log(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
    }
    send(type, message) {
        if (this._rawConnection) {
            this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message });
        }
    }
}
class _RemoteWindowImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    showErrorMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
    showWarningMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
    showInformationMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
}
const RemoteWindowImpl = showDocument_1.ShowDocumentFeature(progress_1.ProgressFeature(_RemoteWindowImpl));
var BulkRegistration;
(function (BulkRegistration) {
    /**
     * Creates a new bulk registration.
     * @return an empty bulk registration.
     */
    function create() {
        return new BulkRegistrationImpl();
    }
    BulkRegistration.create = create;
})(BulkRegistration = exports.BulkRegistration || (exports.BulkRegistration = {}));
class BulkRegistrationImpl {
    constructor() {
        this._registrations = [];
        this._registered = new Set();
    }
    add(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        if (this._registered.has(method)) {
            throw new Error(`${method} is already added to this registration`);
        }
        const id = UUID.generateUuid();
        this._registrations.push({
            id: id,
            method: method,
            registerOptions: registerOptions || {}
        });
        this._registered.add(method);
    }
    asRegistrationParams() {
        return {
            registrations: this._registrations
        };
    }
}
var BulkUnregistration;
(function (BulkUnregistration) {
    function create() {
        return new BulkUnregistrationImpl(undefined, []);
    }
    BulkUnregistration.create = create;
})(BulkUnregistration = exports.BulkUnregistration || (exports.BulkUnregistration = {}));
class BulkUnregistrationImpl {
    constructor(_connection, unregistrations) {
        this._connection = _connection;
        this._unregistrations = new Map();
        unregistrations.forEach(unregistration => {
            this._unregistrations.set(unregistration.method, unregistration);
        });
    }
    get isAttached() {
        return !!this._connection;
    }
    attach(connection) {
        this._connection = connection;
    }
    add(unregistration) {
        this._unregistrations.set(unregistration.method, unregistration);
    }
    dispose() {
        let unregistrations = [];
        for (let unregistration of this._unregistrations.values()) {
            unregistrations.push(unregistration);
        }
        let params = {
            unregisterations: unregistrations
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(undefined, (_error) => {
            this._connection.console.info(`Bulk unregistration failed.`);
        });
    }
    disposeSingle(arg) {
        const method = Is.string(arg) ? arg : arg.method;
        const unregistration = this._unregistrations.get(method);
        if (!unregistration) {
            return false;
        }
        let params = {
            unregisterations: [unregistration]
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
            this._unregistrations.delete(method);
        }, (_error) => {
            this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
        });
        return true;
    }
}
class RemoteClientImpl {
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
            return this.registerMany(typeOrRegistrations);
        }
        else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
            return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
        }
        else {
            return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
        }
    }
    registerSingle1(unregistration, type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
            registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        if (!unregistration.isAttached) {
            unregistration.attach(this.connection);
        }
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
            unregistration.add({ id: id, method: method });
            return unregistration;
        }, (_error) => {
            this.connection.console.info(`Registering request handler for ${method} failed.`);
            return Promise.reject(_error);
        });
    }
    registerSingle2(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
            registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
            return vscode_languageserver_protocol_1.Disposable.create(() => {
                this.unregisterSingle(id, method);
            });
        }, (_error) => {
            this.connection.console.info(`Registering request handler for ${method} failed.`);
            return Promise.reject(_error);
        });
    }
    unregisterSingle(id, method) {
        let params = {
            unregisterations: [{ id, method }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(undefined, (_error) => {
            this.connection.console.info(`Un-registering request handler for ${id} failed.`);
        });
    }
    registerMany(registrations) {
        let params = registrations.asRegistrationParams();
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
            return new BulkUnregistrationImpl(this._connection, params.registrations.map(registration => { return { id: registration.id, method: registration.method }; }));
        }, (_error) => {
            this.connection.console.info(`Bulk registration failed.`);
            return Promise.reject(_error);
        });
    }
}
class _RemoteWorkspaceImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    applyEdit(paramOrEdit) {
        function isApplyWorkspaceEditParams(value) {
            return value && !!value.edit;
        }
        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
    }
}
const RemoteWorkspaceImpl = fileOperations_1.FileOperationsFeature(workspaceFolders_1.WorkspaceFoldersFeature(configuration_1.ConfigurationFeature(_RemoteWorkspaceImpl)));
class TracerImpl {
    constructor() {
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    set trace(value) {
        this._trace = value;
    }
    log(message, verbose) {
        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
            return;
        }
        this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
            message: message,
            verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : undefined
        });
    }
}
class TelemetryImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    logEvent(data) {
        this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data);
    }
}
class _LanguagesImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    attachWorkDoneProgress(params) {
        return progress_1.attachWorkDone(this.connection, params);
    }
    attachPartialResultProgress(_type, params) {
        return progress_1.attachPartialResult(this.connection, params);
    }
}
exports._LanguagesImpl = _LanguagesImpl;
const LanguagesImpl = moniker_1.MonikerFeature(linkedEditingRange_1.LinkedEditingRangeFeature(semanticTokens_1.SemanticTokensFeature(callHierarchy_1.CallHierarchyFeature(_LanguagesImpl))));
function combineConsoleFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineConsoleFeatures = combineConsoleFeatures;
function combineTelemetryFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineTelemetryFeatures = combineTelemetryFeatures;
function combineTracerFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineTracerFeatures = combineTracerFeatures;
function combineClientFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineClientFeatures = combineClientFeatures;
function combineWindowFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineWindowFeatures = combineWindowFeatures;
function combineWorkspaceFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineWorkspaceFeatures = combineWorkspaceFeatures;
function combineLanguagesFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineLanguagesFeatures = combineLanguagesFeatures;
function combineFeatures(one, two) {
    function combine(one, two, func) {
        if (one && two) {
            return func(one, two);
        }
        else if (one) {
            return one;
        }
        else {
            return two;
        }
    }
    let result = {
        __brand: 'features',
        console: combine(one.console, two.console, combineConsoleFeatures),
        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
        client: combine(one.client, two.client, combineClientFeatures),
        window: combine(one.window, two.window, combineWindowFeatures),
        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures)
    };
    return result;
}
exports.combineFeatures = combineFeatures;
function createConnection(connectionFactory, watchDog, factories) {
    const logger = (factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl());
    const connection = connectionFactory(logger);
    logger.rawAttach(connection);
    const tracer = (factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl());
    const telemetry = (factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl());
    const client = (factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl());
    const remoteWindow = (factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl());
    const workspace = (factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl());
    const languages = (factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl());
    const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages];
    function asPromise(value) {
        if (value instanceof Promise) {
            return value;
        }
        else if (Is.thenable(value)) {
            return new Promise((resolve, reject) => {
                value.then((resolved) => resolve(resolved), (error) => reject(error));
            });
        }
        else {
            return Promise.resolve(value);
        }
    }
    let shutdownHandler = undefined;
    let initializeHandler = undefined;
    let exitHandler = undefined;
    let protocolConnection = {
        listen: () => connection.listen(),
        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection.onRequest(type, handler),
        sendNotification: (type, param) => {
            const method = Is.string(type) ? type : type.method;
            if (arguments.length === 1) {
                connection.sendNotification(method);
            }
            else {
                connection.sendNotification(method, param);
            }
        },
        onNotification: (type, handler) => connection.onNotification(type, handler),
        onProgress: connection.onProgress,
        sendProgress: connection.sendProgress,
        onInitialize: (handler) => initializeHandler = handler,
        onInitialized: (handler) => connection.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
        onShutdown: (handler) => shutdownHandler = handler,
        onExit: (handler) => exitHandler = handler,
        get console() { return logger; },
        get telemetry() { return telemetry; },
        get tracer() { return tracer; },
        get client() { return client; },
        get window() { return remoteWindow; },
        get workspace() { return workspace; },
        get languages() { return languages; },
        onDidChangeConfiguration: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
        onDidChangeWatchedFiles: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
        __textDocumentSync: undefined,
        onDidOpenTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
        onDidChangeTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
        onDidCloseTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
        onWillSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
        onWillSaveTextDocumentWaitUntil: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
        onDidSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
        sendDiagnostics: (params) => connection.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
        onHover: (handler) => connection.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
        }),
        onCompletion: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCompletionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
        onSignatureHelp: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
        }),
        onDeclaration: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onTypeDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onImplementation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onReferences: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDocumentHighlight: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDocumentSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onWorkspaceSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCodeAction: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCodeActionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onCodeLens: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCodeLensResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onDocumentFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
        }),
        onDocumentRangeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
        }),
        onDocumentOnTypeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onRenameRequest: (handler) => connection.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
        }),
        onPrepareRename: (handler) => connection.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onDocumentLinks: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDocumentLinkResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onDocumentColor: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onColorPresentation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onFoldingRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onSelectionRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onExecuteCommand: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
        }),
        dispose: () => connection.dispose()
    };
    for (let remote of allRemotes) {
        remote.attach(protocolConnection);
    }
    connection.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
        watchDog.initialize(params);
        if (Is.string(params.trace)) {
            tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
        }
        for (let remote of allRemotes) {
            remote.initialize(params.capabilities);
        }
        if (initializeHandler) {
            let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, progress_1.attachWorkDone(connection, params), undefined);
            return asPromise(result).then((value) => {
                if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
                    return value;
                }
                let result = value;
                if (!result) {
                    result = { capabilities: {} };
                }
                let capabilities = result.capabilities;
                if (!capabilities) {
                    capabilities = {};
                    result.capabilities = capabilities;
                }
                if (capabilities.textDocumentSync === undefined || capabilities.textDocumentSync === null) {
                    capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
                }
                else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {
                    capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
                }
                for (let remote of allRemotes) {
                    remote.fillServerCapabilities(capabilities);
                }
                return result;
            });
        }
        else {
            let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
            for (let remote of allRemotes) {
                remote.fillServerCapabilities(result.capabilities);
            }
            return result;
        }
    });
    connection.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
        watchDog.shutdownReceived = true;
        if (shutdownHandler) {
            return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
        }
        else {
            return undefined;
        }
    });
    connection.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
        try {
            if (exitHandler) {
                exitHandler();
            }
        }
        finally {
            if (watchDog.shutdownReceived) {
                watchDog.exit(0);
            }
            else {
                watchDog.exit(1);
            }
        }
    });
    connection.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
    });
    return protocolConnection;
}
exports.createConnection = createConnection;
//# sourceMappingURL=server.js.map

/***/ }),

/***/ 54:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShowDocumentFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(5);
const ShowDocumentFeature = (Base) => {
    return class extends Base {
        showDocument(params) {
            return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);
        }
    };
};
exports.ShowDocumentFeature = ShowDocumentFeature;
//# sourceMappingURL=showDocument.js.map

/***/ }),

/***/ 3:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.thenable = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function thenable(value) {
    return value && func(value.then);
}
exports.thenable = thenable;
//# sourceMappingURL=is.js.map

/***/ }),

/***/ 48:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateUuid = exports.parse = exports.isUUID = exports.v4 = exports.empty = void 0;
class ValueUUID {
    constructor(_value) {
        this._value = _value;
        // empty
    }
    asHex() {
        return this._value;
    }
    equals(other) {
        return this.asHex() === other.asHex();
    }
}
class V4UUID extends ValueUUID {
    constructor() {
        super([
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            '4',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._oneOf(V4UUID._timeHighBits),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
        ].join(''));
    }
    static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
    }
    static _randomHex() {
        return V4UUID._oneOf(V4UUID._chars);
    }
}
V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
/**
 * An empty UUID that contains only zeros.
 */
exports.empty = new ValueUUID('00000000-0000-0000-0000-000000000000');
function v4() {
    return new V4UUID();
}
exports.v4 = v4;
const _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function isUUID(value) {
    return _UUIDPattern.test(value);
}
exports.isUUID = isUUID;
/**
 * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
 * @param value A uuid string.
 */
function parse(value) {
    if (!isUUID(value)) {
        throw new Error('invalid uuid');
    }
    return new ValueUUID(value);
}
exports.parse = parse;
function generateUuid() {
    return v4().asHex();
}
exports.generateUuid = generateUuid;
//# sourceMappingURL=uuid.js.map

/***/ }),

/***/ 51:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceFoldersFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(5);
const WorkspaceFoldersFeature = (Base) => {
    return class extends Base {
        initialize(capabilities) {
            let workspaceCapabilities = capabilities.workspace;
            if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
                this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
                this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
                    this._onDidChangeWorkspaceFolders.fire(params.event);
                });
            }
        }
        getWorkspaceFolders() {
            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
        }
        get onDidChangeWorkspaceFolders() {
            if (!this._onDidChangeWorkspaceFolders) {
                throw new Error('Client doesn\'t support sending workspace folder change events.');
            }
            if (!this._unregistration) {
                this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
            }
            return this._onDidChangeWorkspaceFolders.event;
        }
    };
};
exports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
//# sourceMappingURL=workspaceFolders.js.map

/***/ }),

/***/ 58:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveModulePath = exports.FileSystem = exports.resolveGlobalYarnPath = exports.resolveGlobalNodePath = exports.resolve = exports.uriToFilePath = void 0;
const url = __webpack_require__(59);
const path = __webpack_require__(23);
const fs = __webpack_require__(60);
const child_process_1 = __webpack_require__(61);
/**
 * @deprecated Use the `vscode-uri` npm module which provides a more
 * complete implementation of handling VS Code URIs.
 */
function uriToFilePath(uri) {
    let parsed = url.parse(uri);
    if (parsed.protocol !== 'file:' || !parsed.path) {
        return undefined;
    }
    let segments = parsed.path.split('/');
    for (var i = 0, len = segments.length; i < len; i++) {
        segments[i] = decodeURIComponent(segments[i]);
    }
    if (process.platform === 'win32' && segments.length > 1) {
        let first = segments[0];
        let second = segments[1];
        // Do we have a drive letter and we started with a / which is the
        // case if the first segement is empty (see split above)
        if (first.length === 0 && second.length > 1 && second[1] === ':') {
            // Remove first slash
            segments.shift();
        }
    }
    return path.normalize(segments.join('/'));
}
exports.uriToFilePath = uriToFilePath;
function isWindows() {
    return process.platform === 'win32';
}
function resolve(moduleName, nodePath, cwd, tracer) {
    const nodePathKey = 'NODE_PATH';
    const app = [
        'var p = process;',
        'p.on(\'message\',function(m){',
        'if(m.c===\'e\'){',
        'p.exit(0);',
        '}',
        'else if(m.c===\'rs\'){',
        'try{',
        'var r=require.resolve(m.a);',
        'p.send({c:\'r\',s:true,r:r});',
        '}',
        'catch(err){',
        'p.send({c:\'r\',s:false});',
        '}',
        '}',
        '});'
    ].join('');
    return new Promise((resolve, reject) => {
        let env = process.env;
        let newEnv = Object.create(null);
        Object.keys(env).forEach(key => newEnv[key] = env[key]);
        if (nodePath && fs.existsSync(nodePath) /* see issue 545 */) {
            if (newEnv[nodePathKey]) {
                newEnv[nodePathKey] = nodePath + path.delimiter + newEnv[nodePathKey];
            }
            else {
                newEnv[nodePathKey] = nodePath;
            }
            if (tracer) {
                tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);
            }
        }
        newEnv['ELECTRON_RUN_AS_NODE'] = '1';
        try {
            let cp = child_process_1.fork('', [], {
                cwd: cwd,
                env: newEnv,
                execArgv: ['-e', app]
            });
            if (cp.pid === void 0) {
                reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));
                return;
            }
            cp.on('error', (error) => {
                reject(error);
            });
            cp.on('message', (message) => {
                if (message.c === 'r') {
                    cp.send({ c: 'e' });
                    if (message.s) {
                        resolve(message.r);
                    }
                    else {
                        reject(new Error(`Failed to resolve module: ${moduleName}`));
                    }
                }
            });
            let message = {
                c: 'rs',
                a: moduleName
            };
            cp.send(message);
        }
        catch (error) {
            reject(error);
        }
    });
}
exports.resolve = resolve;
/**
 * Resolve the global npm package path.
 * @deprecated Since this depends on the used package manager and their version the best is that servers
 * implement this themselves since they know best what kind of package managers to support.
 * @param tracer the tracer to use
 */
function resolveGlobalNodePath(tracer) {
    let npmCommand = 'npm';
    const env = Object.create(null);
    Object.keys(process.env).forEach(key => env[key] = process.env[key]);
    env['NO_UPDATE_NOTIFIER'] = 'true';
    const options = {
        encoding: 'utf8',
        env
    };
    if (isWindows()) {
        npmCommand = 'npm.cmd';
        options.shell = true;
    }
    let handler = () => { };
    try {
        process.on('SIGPIPE', handler);
        let stdout = child_process_1.spawnSync(npmCommand, ['config', 'get', 'prefix'], options).stdout;
        if (!stdout) {
            if (tracer) {
                tracer(`'npm config get prefix' didn't return a value.`);
            }
            return undefined;
        }
        let prefix = stdout.trim();
        if (tracer) {
            tracer(`'npm config get prefix' value is: ${prefix}`);
        }
        if (prefix.length > 0) {
            if (isWindows()) {
                return path.join(prefix, 'node_modules');
            }
            else {
                return path.join(prefix, 'lib', 'node_modules');
            }
        }
        return undefined;
    }
    catch (err) {
        return undefined;
    }
    finally {
        process.removeListener('SIGPIPE', handler);
    }
}
exports.resolveGlobalNodePath = resolveGlobalNodePath;
/*
 * Resolve the global yarn pakage path.
 * @deprecated Since this depends on the used package manager and their version the best is that servers
 * implement this themselves since they know best what kind of package managers to support.
 * @param tracer the tracer to use
 */
function resolveGlobalYarnPath(tracer) {
    let yarnCommand = 'yarn';
    let options = {
        encoding: 'utf8'
    };
    if (isWindows()) {
        yarnCommand = 'yarn.cmd';
        options.shell = true;
    }
    let handler = () => { };
    try {
        process.on('SIGPIPE', handler);
        let results = child_process_1.spawnSync(yarnCommand, ['global', 'dir', '--json'], options);
        let stdout = results.stdout;
        if (!stdout) {
            if (tracer) {
                tracer(`'yarn global dir' didn't return a value.`);
                if (results.stderr) {
                    tracer(results.stderr);
                }
            }
            return undefined;
        }
        let lines = stdout.trim().split(/\r?\n/);
        for (let line of lines) {
            try {
                let yarn = JSON.parse(line);
                if (yarn.type === 'log') {
                    return path.join(yarn.data, 'node_modules');
                }
            }
            catch (e) {
                // Do nothing. Ignore the line
            }
        }
        return undefined;
    }
    catch (err) {
        return undefined;
    }
    finally {
        process.removeListener('SIGPIPE', handler);
    }
}
exports.resolveGlobalYarnPath = resolveGlobalYarnPath;
var FileSystem;
(function (FileSystem) {
    let _isCaseSensitive = undefined;
    function isCaseSensitive() {
        if (_isCaseSensitive !== void 0) {
            return _isCaseSensitive;
        }
        if (process.platform === 'win32') {
            _isCaseSensitive = false;
        }
        else {
            // convert current file name to upper case / lower case and check if file exists
            // (guards against cases when name is already all uppercase or lowercase)
            _isCaseSensitive = !fs.existsSync(__filename.toUpperCase()) || !fs.existsSync(__filename.toLowerCase());
        }
        return _isCaseSensitive;
    }
    FileSystem.isCaseSensitive = isCaseSensitive;
    function isParent(parent, child) {
        if (isCaseSensitive()) {
            return path.normalize(child).indexOf(path.normalize(parent)) === 0;
        }
        else {
            return path.normalize(child).toLowerCase().indexOf(path.normalize(parent).toLowerCase()) === 0;
        }
    }
    FileSystem.isParent = isParent;
})(FileSystem = exports.FileSystem || (exports.FileSystem = {}));
function resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {
    if (nodePath) {
        if (!path.isAbsolute(nodePath)) {
            nodePath = path.join(workspaceRoot, nodePath);
        }
        return resolve(moduleName, nodePath, nodePath, tracer).then((value) => {
            if (FileSystem.isParent(nodePath, value)) {
                return value;
            }
            else {
                return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));
            }
        }).then(undefined, (_error) => {
            return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
        });
    }
    else {
        return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
    }
}
exports.resolveModulePath = resolveModulePath;
//# sourceMappingURL=files.js.map

/***/ }),

/***/ 2:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../../typings/thenable.d.ts" />
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createConnection = exports.Files = void 0;
const Is = __webpack_require__(3);
const server_1 = __webpack_require__(4);
const fm = __webpack_require__(58);
const node_1 = __webpack_require__(62);
__exportStar(__webpack_require__(62), exports);
__exportStar(__webpack_require__(63), exports);
var Files;
(function (Files) {
    Files.uriToFilePath = fm.uriToFilePath;
    Files.resolveGlobalNodePath = fm.resolveGlobalNodePath;
    Files.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;
    Files.resolve = fm.resolve;
    Files.resolveModulePath = fm.resolveModulePath;
})(Files = exports.Files || (exports.Files = {}));
let _protocolConnection;
function endProtocolConnection() {
    if (_protocolConnection === undefined) {
        return;
    }
    try {
        _protocolConnection.end();
    }
    catch (_err) {
        // Ignore. The client process could have already
        // did and we can't send an end into the connection.
    }
}
let _shutdownReceived = false;
let exitTimer = undefined;
function setupExitTimer() {
    const argName = '--clientProcessId';
    function runTimer(value) {
        try {
            let processId = parseInt(value);
            if (!isNaN(processId)) {
                exitTimer = setInterval(() => {
                    try {
                        process.kill(processId, 0);
                    }
                    catch (ex) {
                        // Parent process doesn't exist anymore. Exit the server.
                        endProtocolConnection();
                        process.exit(_shutdownReceived ? 0 : 1);
                    }
                }, 3000);
            }
        }
        catch (e) {
            // Ignore errors;
        }
    }
    for (let i = 2; i < process.argv.length; i++) {
        let arg = process.argv[i];
        if (arg === argName && i + 1 < process.argv.length) {
            runTimer(process.argv[i + 1]);
            return;
        }
        else {
            let args = arg.split('=');
            if (args[0] === argName) {
                runTimer(args[1]);
            }
        }
    }
}
setupExitTimer();
const watchDog = {
    initialize: (params) => {
        const processId = params.processId;
        if (Is.number(processId) && exitTimer === undefined) {
            // We received a parent process id. Set up a timer to periodically check
            // if the parent is still alive.
            setInterval(() => {
                try {
                    process.kill(processId, 0);
                }
                catch (ex) {
                    // Parent process doesn't exist anymore. Exit the server.
                    process.exit(_shutdownReceived ? 0 : 1);
                }
            }, 3000);
        }
    },
    get shutdownReceived() {
        return _shutdownReceived;
    },
    set shutdownReceived(value) {
        _shutdownReceived = value;
    },
    exit: (code) => {
        endProtocolConnection();
        process.exit(code);
    }
};
function createConnection(arg1, arg2, arg3, arg4) {
    let factories;
    let input;
    let output;
    let options;
    if (arg1 !== void 0 && arg1.__brand === 'features') {
        factories = arg1;
        arg1 = arg2;
        arg2 = arg3;
        arg3 = arg4;
    }
    if (node_1.ConnectionStrategy.is(arg1) || node_1.ConnectionOptions.is(arg1)) {
        options = arg1;
    }
    else {
        input = arg1;
        output = arg2;
        options = arg3;
    }
    return _createConnection(input, output, options, factories);
}
exports.createConnection = createConnection;
function _createConnection(input, output, options, factories) {
    if (!input && !output && process.argv.length > 2) {
        let port = void 0;
        let pipeName = void 0;
        let argv = process.argv.slice(2);
        for (let i = 0; i < argv.length; i++) {
            let arg = argv[i];
            if (arg === '--node-ipc') {
                input = new node_1.IPCMessageReader(process);
                output = new node_1.IPCMessageWriter(process);
                break;
            }
            else if (arg === '--stdio') {
                input = process.stdin;
                output = process.stdout;
                break;
            }
            else if (arg === '--socket') {
                port = parseInt(argv[i + 1]);
                break;
            }
            else if (arg === '--pipe') {
                pipeName = argv[i + 1];
                break;
            }
            else {
                var args = arg.split('=');
                if (args[0] === '--socket') {
                    port = parseInt(args[1]);
                    break;
                }
                else if (args[0] === '--pipe') {
                    pipeName = args[1];
                    break;
                }
            }
        }
        if (port) {
            let transport = node_1.createServerSocketTransport(port);
            input = transport[0];
            output = transport[1];
        }
        else if (pipeName) {
            let transport = node_1.createServerPipeTransport(pipeName);
            input = transport[0];
            output = transport[1];
        }
    }
    var commandLineMessage = 'Use arguments of createConnection or set command line parameters: \'--node-ipc\', \'--stdio\' or \'--socket={number}\'';
    if (!input) {
        throw new Error('Connection input stream is not set. ' + commandLineMessage);
    }
    if (!output) {
        throw new Error('Connection output stream is not set. ' + commandLineMessage);
    }
    // Backwards compatibility
    if (Is.func(input.read) && Is.func(input.on)) {
        let inputStream = input;
        inputStream.on('end', () => {
            endProtocolConnection();
            process.exit(_shutdownReceived ? 0 : 1);
        });
        inputStream.on('close', () => {
            endProtocolConnection();
            process.exit(_shutdownReceived ? 0 : 1);
        });
    }
    const connectionFactory = (logger) => {
        const result = node_1.createProtocolConnection(input, output, logger, options);
        return result;
    };
    return server_1.createConnection(connectionFactory, watchDog, factories);
}
//# sourceMappingURL=main.js.map

/***/ }),

/***/ 71:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
//!/usr/bin/env nodejs
// usage: nodejs vimlparser.js [--neovim] foo.vim

var fs = __webpack_require__(60);
var util = __webpack_require__(10);

function main() {
    var neovim = false;
    var fpath = ''
    var args = process.argv;
    if (args.length == 4) {
        if (args[2] == '--neovim') {
            neovim = true;
        }
        fpath = args[3];
    } else if (args.length == 3) {
        neovim = false;
        fpath = args[2]
    }
    var r = new StringReader(viml_readfile(fpath));
    var p = new VimLParser(neovim);
    var c = new Compiler();
    try {
        var lines = c.compile(p.parse(r));
        for (var i in lines) {
            process.stdout.write(lines[i] + "\n");
        }
    } catch (e) {
        process.stdout.write(e + '\n');
    }
}

var pat_vim2js = {
  "[0-9a-zA-Z]" : "[0-9a-zA-Z]",
  "[@*!=><&~#]" : "[@*!=><&~#]",
  "\\<ARGOPT\\>" : "\\bARGOPT\\b",
  "\\<BANG\\>" : "\\bBANG\\b",
  "\\<EDITCMD\\>" : "\\bEDITCMD\\b",
  "\\<NOTRLCOM\\>" : "\\bNOTRLCOM\\b",
  "\\<TRLBAR\\>" : "\\bTRLBAR\\b",
  "\\<USECTRLV\\>" : "\\bUSECTRLV\\b",
  "\\<USERCMD\\>" : "\\bUSERCMD\\b",
  "\\<\\(XFILE\\|FILES\\|FILE1\\)\\>" : "\\b(XFILE|FILES|FILE1)\\b",
  "\\S" : "\\S",
  "\\a" : "[A-Za-z]",
  "\\d" : "\\d",
  "\\h" : "[A-Za-z_]",
  "\\s" : "\\s",
  "\\v^d%[elete][lp]$" : "^d(elete|elet|ele|el|e)[lp]$",
  "\\v^s%(c[^sr][^i][^p]|g|i[^mlg]|I|r[^e])" : "^s(c[^sr][^i][^p]|g|i[^mlg]|I|r[^e])",
  "\\w" : "[0-9A-Za-z_]",
  "\\w\\|[:#]" : "[0-9A-Za-z_]|[:#]",
  "\\x" : "[0-9A-Fa-f]",
  "^++" : "^\+\+",
  "^++bad=\\(keep\\|drop\\|.\\)\\>" : "^\\+\\+bad=(keep|drop|.)\\b",
  "^++bad=drop" : "^\\+\\+bad=drop",
  "^++bad=keep" : "^\\+\\+bad=keep",
  "^++bin\\>" : "^\\+\\+bin\\b",
  "^++edit\\>" : "^\\+\\+edit\\b",
  "^++enc=\\S" : "^\\+\\+enc=\\S",
  "^++encoding=\\S" : "^\\+\\+encoding=\\S",
  "^++ff=\\(dos\\|unix\\|mac\\)\\>" : "^\\+\\+ff=(dos|unix|mac)\\b",
  "^++fileformat=\\(dos\\|unix\\|mac\\)\\>" : "^\\+\\+fileformat=(dos|unix|mac)\\b",
  "^++nobin\\>" : "^\\+\\+nobin\\b",
  "^[A-Z]" : "^[A-Z]",
  "^\\$\\w\\+" : "^\\$[0-9A-Za-z_]+",
  "^\\(!\\|global\\|vglobal\\)$" : "^(!|global|vglobal)$",
  "^\\(WHILE\\|FOR\\)$" : "^(WHILE|FOR)$",
  "^\\(vimgrep\\|vimgrepadd\\|lvimgrep\\|lvimgrepadd\\)$" : "^(vimgrep|vimgrepadd|lvimgrep|lvimgrepadd)$",
  "^\\d" : "^\\d",
  "^\\h" : "^[A-Za-z_]",
  "^\\s" : "^\\s",
  "^\\s*\\\\" : "^\\s*\\\\",
  "^[ \\t]$" : "^[ \\t]$",
  "^[A-Za-z]$" : "^[A-Za-z]$",
  "^[0-9A-Za-z]$" : "^[0-9A-Za-z]$",
  "^[0-9]$" : "^[0-9]$",
  "^[0-9A-Fa-f]$" : "^[0-9A-Fa-f]$",
  "^[0-9A-Za-z_]$" : "^[0-9A-Za-z_]$",
  "^[A-Za-z_]$" : "^[A-Za-z_]$",
  "^[0-9A-Za-z_:#]$" : "^[0-9A-Za-z_:#]$",
  "^[A-Za-z_][0-9A-Za-z_]*$" : "^[A-Za-z_][0-9A-Za-z_]*$",
  "^[A-Z]$" : "^[A-Z]$",
  "^[a-z]$" : "^[a-z]$",
  "^[vgslabwt]:$\\|^\\([vgslabwt]:\\)\\?[A-Za-z_][0-9A-Za-z_#]*$" : "^[vgslabwt]:$|^([vgslabwt]:)?[A-Za-z_][0-9A-Za-z_#]*$",
  "^[0-7]$" : "^[0-7]$",
  "^[0-9A-Fa-f][0-9A-Fa-f]$" : "^[0-9A-Fa-f][0-9A-Fa-f]$",
  "^\\.[0-9A-Fa-f]$" : "^\\.[0-9A-Fa-f]$",
  "^[0-9A-Fa-f][^0-9A-Fa-f]$" : "^[0-9A-Fa-f][^0-9A-Fa-f]$",
}

function viml_add(lst, item) {
    lst.push(item);
}

function viml_call(func, args) {
    return func.apply(null, args);
}

function viml_char2nr(c) {
  return c.charCodeAt(0);
}

function viml_empty(obj) {
    return obj.length == 0;
}

function viml_equalci(a, b) {
    return a.toLowerCase() == b.toLowerCase();
}

function viml_eqreg(s, reg) {
    var mx = new RegExp(pat_vim2js[reg]);
    return mx.exec(s) != null;
}

function viml_eqregh(s, reg) {
    var mx = new RegExp(pat_vim2js[reg]);
    return mx.exec(s) != null;
}

function viml_eqregq(s, reg) {
    var mx = new RegExp(pat_vim2js[reg], "i");
    return mx.exec(s) != null;
}

function viml_escape(s, chars) {
    var r = '';
    for (var i = 0; i < s.length; ++i) {
        if (chars.indexOf(s.charAt(i)) != -1) {
            r = r + "\\" + s.charAt(i);
        } else {
            r = r + s.charAt(i);
        }
    }
    return r;
}

function viml_extend(obj, item) {
    obj.push.apply(obj, item);
}

function viml_insert(lst, item) {
    var idx = arguments.length >= 3 ? arguments[2] : 0;
    lst.splice(0, 0, item);
}

function viml_join(lst, sep) {
    return lst.join(sep);
}

function viml_keys(obj) {
    return Object.keys(obj);
}

function viml_len(obj) {
    if (typeof obj === 'string') {
      var len = 0;
      for (var i = 0; i < obj.length; i++) {
          var c = obj.charCodeAt(i);
          len += c < 128 ? 1 : ((c > 127) && (c < 2048)) ? 2 : 3;
      }
      return len;
    }
    return obj.length;
}

function viml_printf() {
    var a000 = Array.prototype.slice.call(arguments, 0);
    if (a000.length == 1) {
        return a000[0];
    } else {
        return util.format.apply(null, a000);
    }
}

function viml_range(start) {
    var end = arguments.length >= 2 ? arguments[1] : null;
    if (end == null) {
        var x = [];
        for (var i = 0; i < start; ++i) {
            x.push(i);
        }
        return x;
    } else {
        var x = []
        for (var i = start; i <= end; ++i) {
            x.push(i);
        }
        return x;
    }
}

function viml_readfile(path) {
    // FIXME: newline?
    return fs.readFileSync(path, 'utf-8').split(/\r\n|\r|\n/);
}

function viml_remove(lst, idx) {
    lst.splice(idx, 1);
}

function viml_split(s, sep) {
    if (sep == "\\zs") {
        return s.split("");
    }
    throw "NotImplemented";
}

function viml_str2nr(s) {
    var base = arguments.length >= 2 ? arguments[1] : 10;
    return parseInt(s, base);
}

function viml_string(obj) {
    return obj.toString();
}

function viml_has_key(obj, key) {
    return obj[key] !== undefined;
}

function viml_stridx(a, b) {
    return a.indexOf(b);
}

var NIL = [];
var TRUE = 1;
var FALSE = 0;
var NODE_TOPLEVEL = 1;
var NODE_COMMENT = 2;
var NODE_EXCMD = 3;
var NODE_FUNCTION = 4;
var NODE_ENDFUNCTION = 5;
var NODE_DELFUNCTION = 6;
var NODE_RETURN = 7;
var NODE_EXCALL = 8;
var NODE_LET = 9;
var NODE_UNLET = 10;
var NODE_LOCKVAR = 11;
var NODE_UNLOCKVAR = 12;
var NODE_IF = 13;
var NODE_ELSEIF = 14;
var NODE_ELSE = 15;
var NODE_ENDIF = 16;
var NODE_WHILE = 17;
var NODE_ENDWHILE = 18;
var NODE_FOR = 19;
var NODE_ENDFOR = 20;
var NODE_CONTINUE = 21;
var NODE_BREAK = 22;
var NODE_TRY = 23;
var NODE_CATCH = 24;
var NODE_FINALLY = 25;
var NODE_ENDTRY = 26;
var NODE_THROW = 27;
var NODE_ECHO = 28;
var NODE_ECHON = 29;
var NODE_ECHOHL = 30;
var NODE_ECHOMSG = 31;
var NODE_ECHOERR = 32;
var NODE_EXECUTE = 33;
var NODE_TERNARY = 34;
var NODE_OR = 35;
var NODE_AND = 36;
var NODE_EQUAL = 37;
var NODE_EQUALCI = 38;
var NODE_EQUALCS = 39;
var NODE_NEQUAL = 40;
var NODE_NEQUALCI = 41;
var NODE_NEQUALCS = 42;
var NODE_GREATER = 43;
var NODE_GREATERCI = 44;
var NODE_GREATERCS = 45;
var NODE_GEQUAL = 46;
var NODE_GEQUALCI = 47;
var NODE_GEQUALCS = 48;
var NODE_SMALLER = 49;
var NODE_SMALLERCI = 50;
var NODE_SMALLERCS = 51;
var NODE_SEQUAL = 52;
var NODE_SEQUALCI = 53;
var NODE_SEQUALCS = 54;
var NODE_MATCH = 55;
var NODE_MATCHCI = 56;
var NODE_MATCHCS = 57;
var NODE_NOMATCH = 58;
var NODE_NOMATCHCI = 59;
var NODE_NOMATCHCS = 60;
var NODE_IS = 61;
var NODE_ISCI = 62;
var NODE_ISCS = 63;
var NODE_ISNOT = 64;
var NODE_ISNOTCI = 65;
var NODE_ISNOTCS = 66;
var NODE_ADD = 67;
var NODE_SUBTRACT = 68;
var NODE_CONCAT = 69;
var NODE_MULTIPLY = 70;
var NODE_DIVIDE = 71;
var NODE_REMAINDER = 72;
var NODE_NOT = 73;
var NODE_MINUS = 74;
var NODE_PLUS = 75;
var NODE_SUBSCRIPT = 76;
var NODE_SLICE = 77;
var NODE_CALL = 78;
var NODE_DOT = 79;
var NODE_NUMBER = 80;
var NODE_STRING = 81;
var NODE_LIST = 82;
var NODE_DICT = 83;
var NODE_OPTION = 85;
var NODE_IDENTIFIER = 86;
var NODE_CURLYNAME = 87;
var NODE_ENV = 88;
var NODE_REG = 89;
var NODE_CURLYNAMEPART = 90;
var NODE_CURLYNAMEEXPR = 91;
var NODE_LAMBDA = 92;
var NODE_BLOB = 93;
var NODE_CONST = 94;
var NODE_EVAL = 95;
var NODE_HEREDOC = 96;
var NODE_METHOD = 97;
var NODE_ECHOCONSOLE = 98;
var TOKEN_EOF = 1;
var TOKEN_EOL = 2;
var TOKEN_SPACE = 3;
var TOKEN_OROR = 4;
var TOKEN_ANDAND = 5;
var TOKEN_EQEQ = 6;
var TOKEN_EQEQCI = 7;
var TOKEN_EQEQCS = 8;
var TOKEN_NEQ = 9;
var TOKEN_NEQCI = 10;
var TOKEN_NEQCS = 11;
var TOKEN_GT = 12;
var TOKEN_GTCI = 13;
var TOKEN_GTCS = 14;
var TOKEN_GTEQ = 15;
var TOKEN_GTEQCI = 16;
var TOKEN_GTEQCS = 17;
var TOKEN_LT = 18;
var TOKEN_LTCI = 19;
var TOKEN_LTCS = 20;
var TOKEN_LTEQ = 21;
var TOKEN_LTEQCI = 22;
var TOKEN_LTEQCS = 23;
var TOKEN_MATCH = 24;
var TOKEN_MATCHCI = 25;
var TOKEN_MATCHCS = 26;
var TOKEN_NOMATCH = 27;
var TOKEN_NOMATCHCI = 28;
var TOKEN_NOMATCHCS = 29;
var TOKEN_IS = 30;
var TOKEN_ISCI = 31;
var TOKEN_ISCS = 32;
var TOKEN_ISNOT = 33;
var TOKEN_ISNOTCI = 34;
var TOKEN_ISNOTCS = 35;
var TOKEN_PLUS = 36;
var TOKEN_MINUS = 37;
var TOKEN_DOT = 38;
var TOKEN_STAR = 39;
var TOKEN_SLASH = 40;
var TOKEN_PERCENT = 41;
var TOKEN_NOT = 42;
var TOKEN_QUESTION = 43;
var TOKEN_COLON = 44;
var TOKEN_POPEN = 45;
var TOKEN_PCLOSE = 46;
var TOKEN_SQOPEN = 47;
var TOKEN_SQCLOSE = 48;
var TOKEN_COPEN = 49;
var TOKEN_CCLOSE = 50;
var TOKEN_COMMA = 51;
var TOKEN_NUMBER = 52;
var TOKEN_SQUOTE = 53;
var TOKEN_DQUOTE = 54;
var TOKEN_OPTION = 55;
var TOKEN_IDENTIFIER = 56;
var TOKEN_ENV = 57;
var TOKEN_REG = 58;
var TOKEN_EQ = 59;
var TOKEN_OR = 60;
var TOKEN_SEMICOLON = 61;
var TOKEN_BACKTICK = 62;
var TOKEN_DOTDOTDOT = 63;
var TOKEN_SHARP = 64;
var TOKEN_ARROW = 65;
var TOKEN_BLOB = 66;
var TOKEN_LITCOPEN = 67;
var TOKEN_DOTDOT = 68;
var TOKEN_HEREDOC = 69;
var MAX_FUNC_ARGS = 20;
function isalpha(c) {
    return viml_eqregh(c, "^[A-Za-z]$");
}

function isalnum(c) {
    return viml_eqregh(c, "^[0-9A-Za-z]$");
}

function isdigit(c) {
    return viml_eqregh(c, "^[0-9]$");
}

function isodigit(c) {
    return viml_eqregh(c, "^[0-7]$");
}

function isxdigit(c) {
    return viml_eqregh(c, "^[0-9A-Fa-f]$");
}

function iswordc(c) {
    return viml_eqregh(c, "^[0-9A-Za-z_]$");
}

function iswordc1(c) {
    return viml_eqregh(c, "^[A-Za-z_]$");
}

function iswhite(c) {
    return viml_eqregh(c, "^[ \\t]$");
}

function isnamec(c) {
    return viml_eqregh(c, "^[0-9A-Za-z_:#]$");
}

function isnamec1(c) {
    return viml_eqregh(c, "^[A-Za-z_]$");
}

function isargname(s) {
    return viml_eqregh(s, "^[A-Za-z_][0-9A-Za-z_]*$");
}

function isvarname(s) {
    return viml_eqregh(s, "^[vgslabwt]:$\\|^\\([vgslabwt]:\\)\\?[A-Za-z_][0-9A-Za-z_#]*$");
}

// FIXME:
function isidc(c) {
    return viml_eqregh(c, "^[0-9A-Za-z_]$");
}

function isupper(c) {
    return viml_eqregh(c, "^[A-Z]$");
}

function islower(c) {
    return viml_eqregh(c, "^[a-z]$");
}

function ExArg() {
    var ea = {};
    ea.forceit = FALSE;
    ea.addr_count = 0;
    ea.line1 = 0;
    ea.line2 = 0;
    ea.flags = 0;
    ea.do_ecmd_cmd = "";
    ea.do_ecmd_lnum = 0;
    ea.append = 0;
    ea.usefilter = FALSE;
    ea.amount = 0;
    ea.regname = 0;
    ea.force_bin = 0;
    ea.read_edit = 0;
    ea.force_ff = 0;
    ea.force_enc = 0;
    ea.bad_char = 0;
    ea.linepos = {};
    ea.cmdpos = [];
    ea.argpos = [];
    ea.cmd = {};
    ea.modifiers = [];
    ea.range = [];
    ea.argopt = {};
    ea.argcmd = {};
    return ea;
}

// struct node {
//   int     type
//   pos     pos
//   node    left
//   node    right
//   node    cond
//   node    rest
//   node[]  list
//   node[]  rlist
//   node[]  default_args
//   node[]  body
//   string  op
//   string  str
//   int     depth
//   variant value
// }
// TOPLEVEL .body
// COMMENT .str
// EXCMD .ea .str
// FUNCTION .ea .body .left .rlist .default_args .attr .endfunction
// ENDFUNCTION .ea
// DELFUNCTION .ea .left
// RETURN .ea .left
// EXCALL .ea .left
// LET .ea .op .left .list .rest .right
// CONST .ea .op .left .list .rest .right
// UNLET .ea .list
// LOCKVAR .ea .depth .list
// UNLOCKVAR .ea .depth .list
// IF .ea .body .cond .elseif .else .endif
// ELSEIF .ea .body .cond
// ELSE .ea .body
// ENDIF .ea
// WHILE .ea .body .cond .endwhile
// ENDWHILE .ea
// FOR .ea .body .left .list .rest .right .endfor
// ENDFOR .ea
// CONTINUE .ea
// BREAK .ea
// TRY .ea .body .catch .finally .endtry
// CATCH .ea .body .pattern
// FINALLY .ea .body
// ENDTRY .ea
// THROW .ea .left
// EVAL .ea .left
// ECHO .ea .list
// ECHON .ea .list
// ECHOHL .ea .str
// ECHOMSG .ea .list
// ECHOERR .ea .list
// EXECUTE .ea .list
// TERNARY .cond .left .right
// OR .left .right
// AND .left .right
// EQUAL .left .right
// EQUALCI .left .right
// EQUALCS .left .right
// NEQUAL .left .right
// NEQUALCI .left .right
// NEQUALCS .left .right
// GREATER .left .right
// GREATERCI .left .right
// GREATERCS .left .right
// GEQUAL .left .right
// GEQUALCI .left .right
// GEQUALCS .left .right
// SMALLER .left .right
// SMALLERCI .left .right
// SMALLERCS .left .right
// SEQUAL .left .right
// SEQUALCI .left .right
// SEQUALCS .left .right
// MATCH .left .right
// MATCHCI .left .right
// MATCHCS .left .right
// NOMATCH .left .right
// NOMATCHCI .left .right
// NOMATCHCS .left .right
// IS .left .right
// ISCI .left .right
// ISCS .left .right
// ISNOT .left .right
// ISNOTCI .left .right
// ISNOTCS .left .right
// ADD .left .right
// SUBTRACT .left .right
// CONCAT .left .right
// MULTIPLY .left .right
// DIVIDE .left .right
// REMAINDER .left .right
// NOT .left
// MINUS .left
// PLUS .left
// SUBSCRIPT .left .right
// SLICE .left .rlist
// METHOD .left .right
// CALL .left .rlist
// DOT .left .right
// NUMBER .value
// STRING .value
// LIST .value
// DICT .value
// BLOB .value
// NESTING .left
// OPTION .value
// IDENTIFIER .value
// CURLYNAME .value
// ENV .value
// REG .value
// CURLYNAMEPART .value
// CURLYNAMEEXPR .value
// LAMBDA .rlist .left
// HEREDOC .rlist .op .body
function Node(type) {
    return {"type":type};
}

function Err(msg, pos) {
    return viml_printf("vimlparser: %s: line %d col %d", msg, pos.lnum, pos.col);
}

function VimLParser() { this.__init__.apply(this, arguments); }
VimLParser.prototype.__init__ = function() {
    var a000 = Array.prototype.slice.call(arguments, 0);
    if (viml_len(a000) > 0) {
        this.neovim = a000[0];
    }
    else {
        this.neovim = 0;
    }
    this.find_command_cache = {};
}

VimLParser.prototype.push_context = function(node) {
    viml_insert(this.context, node);
}

VimLParser.prototype.pop_context = function() {
    viml_remove(this.context, 0);
}

VimLParser.prototype.find_context = function(type) {
    var i = 0;
    var __c3 = this.context;
    for (var __i3 = 0; __i3 < __c3.length; ++__i3) {
        var node = __c3[__i3];
        if (node.type == type) {
            return i;
        }
        i += 1;
    }
    return -1;
}

VimLParser.prototype.add_node = function(node) {
    viml_add(this.context[0].body, node);
}

VimLParser.prototype.check_missing_endfunction = function(ends, pos) {
    if (this.context[0].type == NODE_FUNCTION) {
        throw Err(viml_printf("E126: Missing :endfunction:    %s", ends), pos);
    }
}

VimLParser.prototype.check_missing_endif = function(ends, pos) {
    if (this.context[0].type == NODE_IF || this.context[0].type == NODE_ELSEIF || this.context[0].type == NODE_ELSE) {
        throw Err(viml_printf("E171: Missing :endif:    %s", ends), pos);
    }
}

VimLParser.prototype.check_missing_endtry = function(ends, pos) {
    if (this.context[0].type == NODE_TRY || this.context[0].type == NODE_CATCH || this.context[0].type == NODE_FINALLY) {
        throw Err(viml_printf("E600: Missing :endtry:    %s", ends), pos);
    }
}

VimLParser.prototype.check_missing_endwhile = function(ends, pos) {
    if (this.context[0].type == NODE_WHILE) {
        throw Err(viml_printf("E170: Missing :endwhile:    %s", ends), pos);
    }
}

VimLParser.prototype.check_missing_endfor = function(ends, pos) {
    if (this.context[0].type == NODE_FOR) {
        throw Err(viml_printf("E170: Missing :endfor:    %s", ends), pos);
    }
}

VimLParser.prototype.parse = function(reader) {
    this.reader = reader;
    this.context = [];
    var toplevel = Node(NODE_TOPLEVEL);
    toplevel.pos = this.reader.getpos();
    toplevel.body = [];
    this.push_context(toplevel);
    while (this.reader.peek() != "<EOF>") {
        this.parse_one_cmd();
    }
    this.check_missing_endfunction("TOPLEVEL", this.reader.getpos());
    this.check_missing_endif("TOPLEVEL", this.reader.getpos());
    this.check_missing_endtry("TOPLEVEL", this.reader.getpos());
    this.check_missing_endwhile("TOPLEVEL", this.reader.getpos());
    this.check_missing_endfor("TOPLEVEL", this.reader.getpos());
    this.pop_context();
    return toplevel;
}

VimLParser.prototype.parse_one_cmd = function() {
    this.ea = ExArg();
    if (this.reader.peekn(2) == "#!") {
        this.parse_hashbang();
        this.reader.get();
        return;
    }
    this.reader.skip_white_and_colon();
    if (this.reader.peekn(1) == "") {
        this.reader.get();
        return;
    }
    if (this.reader.peekn(1) == "\"") {
        this.parse_comment();
        this.reader.get();
        return;
    }
    this.ea.linepos = this.reader.getpos();
    this.parse_command_modifiers();
    this.parse_range();
    this.parse_command();
    this.parse_trail();
}

// FIXME:
VimLParser.prototype.parse_command_modifiers = function() {
    var modifiers = [];
    while (TRUE) {
        var pos = this.reader.tell();
        var d = "";
        if (isdigit(this.reader.peekn(1))) {
            var d = this.reader.read_digit();
            this.reader.skip_white();
        }
        var k = this.reader.read_alpha();
        var c = this.reader.peekn(1);
        this.reader.skip_white();
        if (viml_stridx("aboveleft", k) == 0 && viml_len(k) >= 3) {
            // abo\%[veleft]
            viml_add(modifiers, {"name":"aboveleft"});
        }
        else if (viml_stridx("belowright", k) == 0 && viml_len(k) >= 3) {
            // bel\%[owright]
            viml_add(modifiers, {"name":"belowright"});
        }
        else if (viml_stridx("browse", k) == 0 && viml_len(k) >= 3) {
            // bro\%[wse]
            viml_add(modifiers, {"name":"browse"});
        }
        else if (viml_stridx("botright", k) == 0 && viml_len(k) >= 2) {
            // bo\%[tright]
            viml_add(modifiers, {"name":"botright"});
        }
        else if (viml_stridx("confirm", k) == 0 && viml_len(k) >= 4) {
            // conf\%[irm]
            viml_add(modifiers, {"name":"confirm"});
        }
        else if (viml_stridx("keepmarks", k) == 0 && viml_len(k) >= 3) {
            // kee\%[pmarks]
            viml_add(modifiers, {"name":"keepmarks"});
        }
        else if (viml_stridx("keepalt", k) == 0 && viml_len(k) >= 5) {
            // keepa\%[lt]
            viml_add(modifiers, {"name":"keepalt"});
        }
        else if (viml_stridx("keepjumps", k) == 0 && viml_len(k) >= 5) {
            // keepj\%[umps]
            viml_add(modifiers, {"name":"keepjumps"});
        }
        else if (viml_stridx("keeppatterns", k) == 0 && viml_len(k) >= 5) {
            // keepp\%[atterns]
            viml_add(modifiers, {"name":"keeppatterns"});
        }
        else if (viml_stridx("hide", k) == 0 && viml_len(k) >= 3) {
            // hid\%[e]
            if (this.ends_excmds(c)) {
                break;
            }
            viml_add(modifiers, {"name":"hide"});
        }
        else if (viml_stridx("lockmarks", k) == 0 && viml_len(k) >= 3) {
            // loc\%[kmarks]
            viml_add(modifiers, {"name":"lockmarks"});
        }
        else if (viml_stridx("leftabove", k) == 0 && viml_len(k) >= 5) {
            // lefta\%[bove]
            viml_add(modifiers, {"name":"leftabove"});
        }
        else if (viml_stridx("noautocmd", k) == 0 && viml_len(k) >= 3) {
            // noa\%[utocmd]
            viml_add(modifiers, {"name":"noautocmd"});
        }
        else if (viml_stridx("noswapfile", k) == 0 && viml_len(k) >= 3) {
            // :nos\%[wapfile]
            viml_add(modifiers, {"name":"noswapfile"});
        }
        else if (viml_stridx("rightbelow", k) == 0 && viml_len(k) >= 6) {
            // rightb\%[elow]
            viml_add(modifiers, {"name":"rightbelow"});
        }
        else if (viml_stridx("sandbox", k) == 0 && viml_len(k) >= 3) {
            // san\%[dbox]
            viml_add(modifiers, {"name":"sandbox"});
        }
        else if (viml_stridx("silent", k) == 0 && viml_len(k) >= 3) {
            // sil\%[ent]
            if (c == "!") {
                this.reader.get();
                viml_add(modifiers, {"name":"silent", "bang":1});
            }
            else {
                viml_add(modifiers, {"name":"silent", "bang":0});
            }
        }
        else if (k == "tab") {
            // tab
            if (d != "") {
                viml_add(modifiers, {"name":"tab", "count":viml_str2nr(d, 10)});
            }
            else {
                viml_add(modifiers, {"name":"tab"});
            }
        }
        else if (viml_stridx("topleft", k) == 0 && viml_len(k) >= 2) {
            // to\%[pleft]
            viml_add(modifiers, {"name":"topleft"});
        }
        else if (viml_stridx("unsilent", k) == 0 && viml_len(k) >= 3) {
            // uns\%[ilent]
            viml_add(modifiers, {"name":"unsilent"});
        }
        else if (viml_stridx("vertical", k) == 0 && viml_len(k) >= 4) {
            // vert\%[ical]
            viml_add(modifiers, {"name":"vertical"});
        }
        else if (viml_stridx("verbose", k) == 0 && viml_len(k) >= 4) {
            // verb\%[ose]
            if (d != "") {
                viml_add(modifiers, {"name":"verbose", "count":viml_str2nr(d, 10)});
            }
            else {
                viml_add(modifiers, {"name":"verbose", "count":1});
            }
        }
        else {
            this.reader.seek_set(pos);
            break;
        }
    }
    this.ea.modifiers = modifiers;
}

// FIXME:
VimLParser.prototype.parse_range = function() {
    var tokens = [];
    while (TRUE) {
        while (TRUE) {
            this.reader.skip_white();
            var c = this.reader.peekn(1);
            if (c == "") {
                break;
            }
            if (c == ".") {
                viml_add(tokens, this.reader.getn(1));
            }
            else if (c == "$") {
                viml_add(tokens, this.reader.getn(1));
            }
            else if (c == "'") {
                this.reader.getn(1);
                var m = this.reader.getn(1);
                if (m == "") {
                    break;
                }
                viml_add(tokens, "'" + m);
            }
            else if (c == "/") {
                this.reader.getn(1);
                var __tmp = this.parse_pattern(c);
                var pattern = __tmp[0];
                var _ = __tmp[1];
                viml_add(tokens, pattern);
            }
            else if (c == "?") {
                this.reader.getn(1);
                var __tmp = this.parse_pattern(c);
                var pattern = __tmp[0];
                var _ = __tmp[1];
                viml_add(tokens, pattern);
            }
            else if (c == "\\") {
                var m = this.reader.p(1);
                if (m == "&" || m == "?" || m == "/") {
                    this.reader.seek_cur(2);
                    viml_add(tokens, "\\" + m);
                }
                else {
                    throw Err("E10: \\\\ should be followed by /, ? or &", this.reader.getpos());
                }
            }
            else if (isdigit(c)) {
                viml_add(tokens, this.reader.read_digit());
            }
            while (TRUE) {
                this.reader.skip_white();
                if (this.reader.peekn(1) == "") {
                    break;
                }
                var n = this.reader.read_integer();
                if (n == "") {
                    break;
                }
                viml_add(tokens, n);
            }
            if (this.reader.p(0) != "/" && this.reader.p(0) != "?") {
                break;
            }
        }
        if (this.reader.peekn(1) == "%") {
            viml_add(tokens, this.reader.getn(1));
        }
        else if (this.reader.peekn(1) == "*") {
            // && &cpoptions !~ '\*'
            viml_add(tokens, this.reader.getn(1));
        }
        if (this.reader.peekn(1) == ";") {
            viml_add(tokens, this.reader.getn(1));
            continue;
        }
        else if (this.reader.peekn(1) == ",") {
            viml_add(tokens, this.reader.getn(1));
            continue;
        }
        break;
    }
    this.ea.range = tokens;
}

// FIXME:
VimLParser.prototype.parse_pattern = function(delimiter) {
    var pattern = "";
    var endc = "";
    var inbracket = 0;
    while (TRUE) {
        var c = this.reader.getn(1);
        if (c == "") {
            break;
        }
        if (c == delimiter && inbracket == 0) {
            var endc = c;
            break;
        }
        pattern += c;
        if (c == "\\") {
            var c = this.reader.peekn(1);
            if (c == "") {
                throw Err("E682: Invalid search pattern or delimiter", this.reader.getpos());
            }
            this.reader.getn(1);
            pattern += c;
        }
        else if (c == "[") {
            inbracket += 1;
        }
        else if (c == "]") {
            inbracket -= 1;
        }
    }
    return [pattern, endc];
}

VimLParser.prototype.parse_command = function() {
    this.reader.skip_white_and_colon();
    this.ea.cmdpos = this.reader.getpos();
    if (this.reader.peekn(1) == "" || this.reader.peekn(1) == "\"") {
        if (!viml_empty(this.ea.modifiers) || !viml_empty(this.ea.range)) {
            this.parse_cmd_modifier_range();
        }
        return;
    }
    this.ea.cmd = this.find_command();
    if (this.ea.cmd === NIL) {
        this.reader.setpos(this.ea.cmdpos);
        throw Err(viml_printf("E492: Not an editor command: %s", this.reader.peekline()), this.ea.cmdpos);
    }
    if (this.reader.peekn(1) == "!" && this.ea.cmd.name != "substitute" && this.ea.cmd.name != "smagic" && this.ea.cmd.name != "snomagic") {
        this.reader.getn(1);
        this.ea.forceit = TRUE;
    }
    else {
        this.ea.forceit = FALSE;
    }
    if (!viml_eqregh(this.ea.cmd.flags, "\\<BANG\\>") && this.ea.forceit && !viml_eqregh(this.ea.cmd.flags, "\\<USERCMD\\>")) {
        throw Err("E477: No ! allowed", this.ea.cmdpos);
    }
    if (this.ea.cmd.name != "!") {
        this.reader.skip_white();
    }
    this.ea.argpos = this.reader.getpos();
    if (viml_eqregh(this.ea.cmd.flags, "\\<ARGOPT\\>")) {
        this.parse_argopt();
    }
    if (this.ea.cmd.name == "write" || this.ea.cmd.name == "update") {
        if (this.reader.p(0) == ">") {
            if (this.reader.p(1) != ">") {
                throw Err("E494: Use w or w>>", this.ea.cmdpos);
            }
            this.reader.seek_cur(2);
            this.reader.skip_white();
            this.ea.append = 1;
        }
        else if (this.reader.peekn(1) == "!" && this.ea.cmd.name == "write") {
            this.reader.getn(1);
            this.ea.usefilter = TRUE;
        }
    }
    if (this.ea.cmd.name == "read") {
        if (this.ea.forceit) {
            this.ea.usefilter = TRUE;
            this.ea.forceit = FALSE;
        }
        else if (this.reader.peekn(1) == "!") {
            this.reader.getn(1);
            this.ea.usefilter = TRUE;
        }
    }
    if (this.ea.cmd.name == "<" || this.ea.cmd.name == ">") {
        this.ea.amount = 1;
        while (this.reader.peekn(1) == this.ea.cmd.name) {
            this.reader.getn(1);
            this.ea.amount += 1;
        }
        this.reader.skip_white();
    }
    if (viml_eqregh(this.ea.cmd.flags, "\\<EDITCMD\\>") && !this.ea.usefilter) {
        this.parse_argcmd();
    }
    this._parse_command(this.ea.cmd.parser);
}

// TODO: self[a:parser]
VimLParser.prototype._parse_command = function(parser) {
    if (parser == "parse_cmd_append") {
        this.parse_cmd_append();
    }
    else if (parser == "parse_cmd_break") {
        this.parse_cmd_break();
    }
    else if (parser == "parse_cmd_call") {
        this.parse_cmd_call();
    }
    else if (parser == "parse_cmd_catch") {
        this.parse_cmd_catch();
    }
    else if (parser == "parse_cmd_common") {
        this.parse_cmd_common();
    }
    else if (parser == "parse_cmd_continue") {
        this.parse_cmd_continue();
    }
    else if (parser == "parse_cmd_delfunction") {
        this.parse_cmd_delfunction();
    }
    else if (parser == "parse_cmd_echo") {
        this.parse_cmd_echo();
    }
    else if (parser == "parse_cmd_echoconsole") {
        this.parse_cmd_echoconsole();
    }
    else if (parser == "parse_cmd_echoerr") {
        this.parse_cmd_echoerr();
    }
    else if (parser == "parse_cmd_echohl") {
        this.parse_cmd_echohl();
    }
    else if (parser == "parse_cmd_echomsg") {
        this.parse_cmd_echomsg();
    }
    else if (parser == "parse_cmd_echon") {
        this.parse_cmd_echon();
    }
    else if (parser == "parse_cmd_else") {
        this.parse_cmd_else();
    }
    else if (parser == "parse_cmd_elseif") {
        this.parse_cmd_elseif();
    }
    else if (parser == "parse_cmd_endfor") {
        this.parse_cmd_endfor();
    }
    else if (parser == "parse_cmd_endfunction") {
        this.parse_cmd_endfunction();
    }
    else if (parser == "parse_cmd_endif") {
        this.parse_cmd_endif();
    }
    else if (parser == "parse_cmd_endtry") {
        this.parse_cmd_endtry();
    }
    else if (parser == "parse_cmd_endwhile") {
        this.parse_cmd_endwhile();
    }
    else if (parser == "parse_cmd_execute") {
        this.parse_cmd_execute();
    }
    else if (parser == "parse_cmd_finally") {
        this.parse_cmd_finally();
    }
    else if (parser == "parse_cmd_finish") {
        this.parse_cmd_finish();
    }
    else if (parser == "parse_cmd_for") {
        this.parse_cmd_for();
    }
    else if (parser == "parse_cmd_function") {
        this.parse_cmd_function();
    }
    else if (parser == "parse_cmd_if") {
        this.parse_cmd_if();
    }
    else if (parser == "parse_cmd_insert") {
        this.parse_cmd_insert();
    }
    else if (parser == "parse_cmd_let") {
        this.parse_cmd_let();
    }
    else if (parser == "parse_cmd_const") {
        this.parse_cmd_const();
    }
    else if (parser == "parse_cmd_loadkeymap") {
        this.parse_cmd_loadkeymap();
    }
    else if (parser == "parse_cmd_lockvar") {
        this.parse_cmd_lockvar();
    }
    else if (parser == "parse_cmd_lua") {
        this.parse_cmd_lua();
    }
    else if (parser == "parse_cmd_modifier_range") {
        this.parse_cmd_modifier_range();
    }
    else if (parser == "parse_cmd_mzscheme") {
        this.parse_cmd_mzscheme();
    }
    else if (parser == "parse_cmd_perl") {
        this.parse_cmd_perl();
    }
    else if (parser == "parse_cmd_python") {
        this.parse_cmd_python();
    }
    else if (parser == "parse_cmd_python3") {
        this.parse_cmd_python3();
    }
    else if (parser == "parse_cmd_return") {
        this.parse_cmd_return();
    }
    else if (parser == "parse_cmd_ruby") {
        this.parse_cmd_ruby();
    }
    else if (parser == "parse_cmd_tcl") {
        this.parse_cmd_tcl();
    }
    else if (parser == "parse_cmd_throw") {
        this.parse_cmd_throw();
    }
    else if (parser == "parse_cmd_eval") {
        this.parse_cmd_eval();
    }
    else if (parser == "parse_cmd_try") {
        this.parse_cmd_try();
    }
    else if (parser == "parse_cmd_unlet") {
        this.parse_cmd_unlet();
    }
    else if (parser == "parse_cmd_unlockvar") {
        this.parse_cmd_unlockvar();
    }
    else if (parser == "parse_cmd_usercmd") {
        this.parse_cmd_usercmd();
    }
    else if (parser == "parse_cmd_while") {
        this.parse_cmd_while();
    }
    else if (parser == "parse_wincmd") {
        this.parse_wincmd();
    }
    else if (parser == "parse_cmd_syntax") {
        this.parse_cmd_syntax();
    }
    else {
        throw viml_printf("unknown parser: %s", viml_string(parser));
    }
}

VimLParser.prototype.find_command = function() {
    var c = this.reader.peekn(1);
    var name = "";
    if (c == "k") {
        this.reader.getn(1);
        var name = "k";
    }
    else if (c == "s" && viml_eqregh(this.reader.peekn(5), "\\v^s%(c[^sr][^i][^p]|g|i[^mlg]|I|r[^e])")) {
        this.reader.getn(1);
        var name = "substitute";
    }
    else if (viml_eqregh(c, "[@*!=><&~#]")) {
        this.reader.getn(1);
        var name = c;
    }
    else if (this.reader.peekn(2) == "py") {
        var name = this.reader.read_alnum();
    }
    else {
        var pos = this.reader.tell();
        var name = this.reader.read_alpha();
        if (name != "del" && viml_eqregh(name, "\\v^d%[elete][lp]$")) {
            this.reader.seek_set(pos);
            var name = this.reader.getn(viml_len(name) - 1);
        }
    }
    if (name == "") {
        return NIL;
    }
    if (viml_has_key(this.find_command_cache, name)) {
        return this.find_command_cache[name];
    }
    var cmd = NIL;
    var __c4 = this.builtin_commands;
    for (var __i4 = 0; __i4 < __c4.length; ++__i4) {
        var x = __c4[__i4];
        if (viml_stridx(x.name, name) == 0 && viml_len(name) >= x.minlen) {
            delete cmd;
            var cmd = x;
            break;
        }
    }
    if (this.neovim) {
        var __c5 = this.neovim_additional_commands;
        for (var __i5 = 0; __i5 < __c5.length; ++__i5) {
            var x = __c5[__i5];
            if (viml_stridx(x.name, name) == 0 && viml_len(name) >= x.minlen) {
                delete cmd;
                var cmd = x;
                break;
            }
        }
        var __c6 = this.neovim_removed_commands;
        for (var __i6 = 0; __i6 < __c6.length; ++__i6) {
            var x = __c6[__i6];
            if (viml_stridx(x.name, name) == 0 && viml_len(name) >= x.minlen) {
                delete cmd;
                var cmd = NIL;
                break;
            }
        }
    }
    // FIXME: user defined command
    if ((cmd === NIL || cmd.name == "Print") && viml_eqregh(name, "^[A-Z]")) {
        name += this.reader.read_alnum();
        delete cmd;
        var cmd = {"name":name, "flags":"USERCMD", "parser":"parse_cmd_usercmd"};
    }
    this.find_command_cache[name] = cmd;
    return cmd;
}

// TODO:
VimLParser.prototype.parse_hashbang = function() {
    this.reader.getn(-1);
}

// TODO:
// ++opt=val
VimLParser.prototype.parse_argopt = function() {
    while (this.reader.p(0) == "+" && this.reader.p(1) == "+") {
        var s = this.reader.peekn(20);
        if (viml_eqregh(s, "^++bin\\>")) {
            this.reader.getn(5);
            this.ea.force_bin = 1;
        }
        else if (viml_eqregh(s, "^++nobin\\>")) {
            this.reader.getn(7);
            this.ea.force_bin = 2;
        }
        else if (viml_eqregh(s, "^++edit\\>")) {
            this.reader.getn(6);
            this.ea.read_edit = 1;
        }
        else if (viml_eqregh(s, "^++ff=\\(dos\\|unix\\|mac\\)\\>")) {
            this.reader.getn(5);
            this.ea.force_ff = this.reader.read_alpha();
        }
        else if (viml_eqregh(s, "^++fileformat=\\(dos\\|unix\\|mac\\)\\>")) {
            this.reader.getn(13);
            this.ea.force_ff = this.reader.read_alpha();
        }
        else if (viml_eqregh(s, "^++enc=\\S")) {
            this.reader.getn(6);
            this.ea.force_enc = this.reader.read_nonwhite();
        }
        else if (viml_eqregh(s, "^++encoding=\\S")) {
            this.reader.getn(11);
            this.ea.force_enc = this.reader.read_nonwhite();
        }
        else if (viml_eqregh(s, "^++bad=\\(keep\\|drop\\|.\\)\\>")) {
            this.reader.getn(6);
            if (viml_eqregh(s, "^++bad=keep")) {
                this.ea.bad_char = this.reader.getn(4);
            }
            else if (viml_eqregh(s, "^++bad=drop")) {
                this.ea.bad_char = this.reader.getn(4);
            }
            else {
                this.ea.bad_char = this.reader.getn(1);
            }
        }
        else if (viml_eqregh(s, "^++")) {
            throw Err("E474: Invalid Argument", this.reader.getpos());
        }
        else {
            break;
        }
        this.reader.skip_white();
    }
}

// TODO:
// +command
VimLParser.prototype.parse_argcmd = function() {
    if (this.reader.peekn(1) == "+") {
        this.reader.getn(1);
        if (this.reader.peekn(1) == " ") {
            this.ea.do_ecmd_cmd = "$";
        }
        else {
            this.ea.do_ecmd_cmd = this.read_cmdarg();
        }
    }
}

VimLParser.prototype.read_cmdarg = function() {
    var r = "";
    while (TRUE) {
        var c = this.reader.peekn(1);
        if (c == "" || iswhite(c)) {
            break;
        }
        this.reader.getn(1);
        if (c == "\\") {
            var c = this.reader.getn(1);
        }
        r += c;
    }
    return r;
}

VimLParser.prototype.parse_comment = function() {
    var npos = this.reader.getpos();
    var c = this.reader.get();
    if (c != "\"") {
        throw Err(viml_printf("unexpected character: %s", c), npos);
    }
    var node = Node(NODE_COMMENT);
    node.pos = npos;
    node.str = this.reader.getn(-1);
    this.add_node(node);
}

VimLParser.prototype.parse_trail = function() {
    this.reader.skip_white();
    var c = this.reader.peek();
    if (c == "<EOF>") {
        // pass
    }
    else if (c == "<EOL>") {
        this.reader.get();
    }
    else if (c == "|") {
        this.reader.get();
    }
    else if (c == "\"") {
        this.parse_comment();
        this.reader.get();
    }
    else {
        throw Err(viml_printf("E488: Trailing characters: %s", c), this.reader.getpos());
    }
}

// modifier or range only command line
VimLParser.prototype.parse_cmd_modifier_range = function() {
    var node = Node(NODE_EXCMD);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.str = this.reader.getstr(this.ea.linepos, this.reader.getpos());
    this.add_node(node);
}

// TODO:
VimLParser.prototype.parse_cmd_common = function() {
    var end = this.reader.getpos();
    if (viml_eqregh(this.ea.cmd.flags, "\\<TRLBAR\\>") && !this.ea.usefilter) {
        var end = this.separate_nextcmd();
    }
    else if (this.ea.cmd.name == "!" || this.ea.cmd.name == "global" || this.ea.cmd.name == "vglobal" || this.ea.usefilter) {
        while (TRUE) {
            var end = this.reader.getpos();
            if (this.reader.getn(1) == "") {
                break;
            }
        }
    }
    else {
        while (TRUE) {
            var end = this.reader.getpos();
            if (this.reader.getn(1) == "") {
                break;
            }
        }
    }
    var node = Node(NODE_EXCMD);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.str = this.reader.getstr(this.ea.linepos, end);
    this.add_node(node);
}

VimLParser.prototype.separate_nextcmd = function() {
    if (this.ea.cmd.name == "vimgrep" || this.ea.cmd.name == "vimgrepadd" || this.ea.cmd.name == "lvimgrep" || this.ea.cmd.name == "lvimgrepadd") {
        this.skip_vimgrep_pat();
    }
    var pc = "";
    var end = this.reader.getpos();
    var nospend = end;
    while (TRUE) {
        var end = this.reader.getpos();
        if (!iswhite(pc)) {
            var nospend = end;
        }
        var c = this.reader.peek();
        if (c == "<EOF>" || c == "<EOL>") {
            break;
        }
        else if (c == "\x16") {
            // <C-V>
            this.reader.get();
            var end = this.reader.getpos();
            var nospend = this.reader.getpos();
            var c = this.reader.peek();
            if (c == "<EOF>" || c == "<EOL>") {
                break;
            }
            this.reader.get();
        }
        else if (this.reader.peekn(2) == "`=" && viml_eqregh(this.ea.cmd.flags, "\\<\\(XFILE\\|FILES\\|FILE1\\)\\>")) {
            this.reader.getn(2);
            this.parse_expr();
            var c = this.reader.peekn(1);
            if (c != "`") {
                throw Err(viml_printf("unexpected character: %s", c), this.reader.getpos());
            }
            this.reader.getn(1);
        }
        else if (c == "|" || c == "\n" || c == "\"" && !viml_eqregh(this.ea.cmd.flags, "\\<NOTRLCOM\\>") && (this.ea.cmd.name != "@" && this.ea.cmd.name != "*" || this.reader.getpos() != this.ea.argpos) && (this.ea.cmd.name != "redir" || this.reader.getpos().i != this.ea.argpos.i + 1 || pc != "@")) {
            var has_cpo_bar = FALSE;
            // &cpoptions =~ 'b'
            if ((!has_cpo_bar || !viml_eqregh(this.ea.cmd.flags, "\\<USECTRLV\\>")) && pc == "\\") {
                this.reader.get();
            }
            else {
                break;
            }
        }
        else {
            this.reader.get();
        }
        var pc = c;
    }
    if (!viml_eqregh(this.ea.cmd.flags, "\\<NOTRLCOM\\>")) {
        var end = nospend;
    }
    return end;
}

// FIXME
VimLParser.prototype.skip_vimgrep_pat = function() {
    if (this.reader.peekn(1) == "") {
        // pass
    }
    else if (isidc(this.reader.peekn(1))) {
        // :vimgrep pattern fname
        this.reader.read_nonwhite();
    }
    else {
        // :vimgrep /pattern/[g][j] fname
        var c = this.reader.getn(1);
        var __tmp = this.parse_pattern(c);
        var _ = __tmp[0];
        var endc = __tmp[1];
        if (c != endc) {
            return;
        }
        while (this.reader.p(0) == "g" || this.reader.p(0) == "j") {
            this.reader.getn(1);
        }
    }
}

VimLParser.prototype.parse_cmd_append = function() {
    this.reader.setpos(this.ea.linepos);
    var cmdline = this.reader.readline();
    var lines = [cmdline];
    var m = ".";
    while (TRUE) {
        if (this.reader.peek() == "<EOF>") {
            break;
        }
        var line = this.reader.getn(-1);
        viml_add(lines, line);
        if (line == m) {
            break;
        }
        this.reader.get();
    }
    var node = Node(NODE_EXCMD);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.str = viml_join(lines, "\n");
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_insert = function() {
    this.parse_cmd_append();
}

VimLParser.prototype.parse_cmd_loadkeymap = function() {
    this.reader.setpos(this.ea.linepos);
    var cmdline = this.reader.readline();
    var lines = [cmdline];
    while (TRUE) {
        if (this.reader.peek() == "<EOF>") {
            break;
        }
        var line = this.reader.readline();
        viml_add(lines, line);
    }
    var node = Node(NODE_EXCMD);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.str = viml_join(lines, "\n");
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_lua = function() {
    var lines = [];
    this.reader.skip_white();
    if (this.reader.peekn(2) == "<<") {
        this.reader.getn(2);
        this.reader.skip_white();
        var m = this.reader.readline();
        if (m == "") {
            var m = ".";
        }
        this.reader.setpos(this.ea.linepos);
        var cmdline = this.reader.getn(-1);
        var lines = [cmdline];
        this.reader.get();
        while (TRUE) {
            if (this.reader.peek() == "<EOF>") {
                break;
            }
            var line = this.reader.getn(-1);
            viml_add(lines, line);
            if (line == m) {
                break;
            }
            this.reader.get();
        }
    }
    else {
        this.reader.setpos(this.ea.linepos);
        var cmdline = this.reader.getn(-1);
        var lines = [cmdline];
    }
    var node = Node(NODE_EXCMD);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.str = viml_join(lines, "\n");
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_mzscheme = function() {
    this.parse_cmd_lua();
}

VimLParser.prototype.parse_cmd_perl = function() {
    this.parse_cmd_lua();
}

VimLParser.prototype.parse_cmd_python = function() {
    this.parse_cmd_lua();
}

VimLParser.prototype.parse_cmd_python3 = function() {
    this.parse_cmd_lua();
}

VimLParser.prototype.parse_cmd_ruby = function() {
    this.parse_cmd_lua();
}

VimLParser.prototype.parse_cmd_tcl = function() {
    this.parse_cmd_lua();
}

VimLParser.prototype.parse_cmd_finish = function() {
    this.parse_cmd_common();
    if (this.context[0].type == NODE_TOPLEVEL) {
        this.reader.seek_end(0);
    }
}

// FIXME
VimLParser.prototype.parse_cmd_usercmd = function() {
    this.parse_cmd_common();
}

VimLParser.prototype.parse_cmd_function = function() {
    var pos = this.reader.tell();
    this.reader.skip_white();
    // :function
    if (this.ends_excmds(this.reader.peek())) {
        this.reader.seek_set(pos);
        this.parse_cmd_common();
        return;
    }
    // :function /pattern
    if (this.reader.peekn(1) == "/") {
        this.reader.seek_set(pos);
        this.parse_cmd_common();
        return;
    }
    var left = this.parse_lvalue_func();
    this.reader.skip_white();
    if (left.type == NODE_IDENTIFIER) {
        var s = left.value;
        var ss = viml_split(s, "\\zs");
        if (ss[0] != "<" && ss[0] != "_" && !isupper(ss[0]) && viml_stridx(s, ":") == -1 && viml_stridx(s, "#") == -1) {
            throw Err(viml_printf("E128: Function name must start with a capital or contain a colon: %s", s), left.pos);
        }
    }
    // :function {name}
    if (this.reader.peekn(1) != "(") {
        this.reader.seek_set(pos);
        this.parse_cmd_common();
        return;
    }
    // :function[!] {name}([arguments]) [range] [abort] [dict] [closure]
    var node = Node(NODE_FUNCTION);
    node.pos = this.ea.cmdpos;
    node.body = [];
    node.ea = this.ea;
    node.left = left;
    node.rlist = [];
    node.default_args = [];
    node.attr = {"range":0, "abort":0, "dict":0, "closure":0};
    node.endfunction = NIL;
    this.reader.getn(1);
    var tokenizer = new ExprTokenizer(this.reader);
    if (tokenizer.peek().type == TOKEN_PCLOSE) {
        tokenizer.get();
    }
    else {
        var named = {};
        while (TRUE) {
            var varnode = Node(NODE_IDENTIFIER);
            var token = tokenizer.get();
            if (token.type == TOKEN_IDENTIFIER) {
                if (!isargname(token.value) || token.value == "firstline" || token.value == "lastline") {
                    throw Err(viml_printf("E125: Illegal argument: %s", token.value), token.pos);
                }
                else if (viml_has_key(named, token.value)) {
                    throw Err(viml_printf("E853: Duplicate argument name: %s", token.value), token.pos);
                }
                named[token.value] = 1;
                varnode.pos = token.pos;
                varnode.value = token.value;
                viml_add(node.rlist, varnode);
                if (tokenizer.peek().type == TOKEN_EQ) {
                    tokenizer.get();
                    viml_add(node.default_args, this.parse_expr());
                }
                else if (viml_len(node.default_args) > 0) {
                    throw Err("E989: Non-default argument follows default argument", varnode.pos);
                }
                // XXX: Vim doesn't skip white space before comma.  F(a ,b) => E475
                if (iswhite(this.reader.p(0)) && tokenizer.peek().type == TOKEN_COMMA) {
                    throw Err("E475: Invalid argument: White space is not allowed before comma", this.reader.getpos());
                }
                var token = tokenizer.get();
                if (token.type == TOKEN_COMMA) {
                    // XXX: Vim allows last comma.  F(a, b, ) => OK
                    if (tokenizer.peek().type == TOKEN_PCLOSE) {
                        tokenizer.get();
                        break;
                    }
                }
                else if (token.type == TOKEN_PCLOSE) {
                    break;
                }
                else {
                    throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
                }
            }
            else if (token.type == TOKEN_DOTDOTDOT) {
                varnode.pos = token.pos;
                varnode.value = token.value;
                viml_add(node.rlist, varnode);
                var token = tokenizer.get();
                if (token.type == TOKEN_PCLOSE) {
                    break;
                }
                else {
                    throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
                }
            }
            else {
                throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
            }
        }
    }
    while (TRUE) {
        this.reader.skip_white();
        var epos = this.reader.getpos();
        var key = this.reader.read_alpha();
        if (key == "") {
            break;
        }
        else if (key == "range") {
            node.attr.range = TRUE;
        }
        else if (key == "abort") {
            node.attr.abort = TRUE;
        }
        else if (key == "dict") {
            node.attr.dict = TRUE;
        }
        else if (key == "closure") {
            node.attr.closure = TRUE;
        }
        else {
            throw Err(viml_printf("unexpected token: %s", key), epos);
        }
    }
    this.add_node(node);
    this.push_context(node);
}

VimLParser.prototype.parse_cmd_endfunction = function() {
    this.check_missing_endif("ENDFUNCTION", this.ea.cmdpos);
    this.check_missing_endtry("ENDFUNCTION", this.ea.cmdpos);
    this.check_missing_endwhile("ENDFUNCTION", this.ea.cmdpos);
    this.check_missing_endfor("ENDFUNCTION", this.ea.cmdpos);
    if (this.context[0].type != NODE_FUNCTION) {
        throw Err("E193: :endfunction not inside a function", this.ea.cmdpos);
    }
    this.reader.getn(-1);
    var node = Node(NODE_ENDFUNCTION);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    this.context[0].endfunction = node;
    this.pop_context();
}

VimLParser.prototype.parse_cmd_delfunction = function() {
    var node = Node(NODE_DELFUNCTION);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.left = this.parse_lvalue_func();
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_return = function() {
    if (this.find_context(NODE_FUNCTION) == -1) {
        throw Err("E133: :return not inside a function", this.ea.cmdpos);
    }
    var node = Node(NODE_RETURN);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.left = NIL;
    this.reader.skip_white();
    var c = this.reader.peek();
    if (c == "\"" || !this.ends_excmds(c)) {
        node.left = this.parse_expr();
    }
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_call = function() {
    var node = Node(NODE_EXCALL);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    this.reader.skip_white();
    var c = this.reader.peek();
    if (this.ends_excmds(c)) {
        throw Err("E471: Argument required", this.reader.getpos());
    }
    node.left = this.parse_expr();
    if (node.left.type != NODE_CALL) {
        throw Err("Not an function call", node.left.pos);
    }
    this.add_node(node);
}

VimLParser.prototype.parse_heredoc = function(prefix) {
    var node = Node(NODE_HEREDOC);
    node.pos = this.ea.cmdpos;
    node.op = "";
    node.rlist = [];
    node.body = [];
    // allow prefix to precede heredoc end marker if true
    var is_trim = FALSE;
    while (TRUE) {
        this.reader.skip_white();
        var pos = this.reader.getpos();
        var key = this.reader.read_word();
        if (key == "") {
            break;
        }
        if (!islower(key[0])) {
            node.op = key;
            break;
        }
        else {
            var keynode = Node(NODE_STRING);
            keynode.pos = pos;
            keynode.value = key;
            viml_add(node.rlist, keynode);
            if (key == "trim") {
                var is_trim = TRUE;
            }
        }
    }
    if (node.op == "") {
        throw Err("E172: Missing marker", this.reader.getpos());
    }
    this.parse_trail();
    while (TRUE) {
        if (this.reader.peek() == "<EOF>") {
            break;
        }
        var pos = this.reader.getpos();
        var line = this.reader.getn(-1);
        if (line == node.op || is_trim && line == prefix + node.op) {
            return node;
        }
        var linenode = Node(NODE_STRING);
        linenode.pos = pos;
        linenode.value = line;
        viml_add(node.body, linenode);
        this.reader.get();
    }
    throw Err(viml_printf("E990: Missing end marker '%s'", node.op), this.reader.getpos());
}

VimLParser.prototype.parse_cmd_let = function() {
    var pos = this.reader.tell();
    this.reader.skip_white();
    // :let
    if (this.ends_excmds(this.reader.peek())) {
        this.reader.seek_set(pos);
        this.parse_cmd_common();
        return;
    }
    var lhs = this.parse_letlhs();
    this.reader.skip_white();
    var s1 = this.reader.peekn(1);
    var s2 = this.reader.peekn(2);
    // TODO check scriptversion?
    if (s2 == "..") {
        var s2 = this.reader.peekn(3);
    }
    else if (s2 == "=<") {
        var s2 = this.reader.peekn(3);
    }
    // :let {var-name} ..
    if (this.ends_excmds(s1) || s2 != "+=" && s2 != "-=" && s2 != ".=" && s2 != "..=" && s2 != "*=" && s2 != "/=" && s2 != "%=" && s2 != "=<<" && s1 != "=") {
        this.reader.seek_set(pos);
        this.parse_cmd_common();
        return;
    }
    // :let left op right
    var node = Node(NODE_LET);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.op = "";
    node.left = lhs.left;
    node.list = lhs.list;
    node.rest = lhs.rest;
    node.right = NIL;
    if (s2 == "+=" || s2 == "-=" || s2 == ".=" || s2 == "..=" || s2 == "*=" || s2 == "/=" || s2 == "%=") {
        this.reader.getn(viml_len(s2));
        node.op = s2;
    }
    else if (s2 == "=<<") {
        this.reader.getn(viml_len(s2));
        this.reader.skip_white();
        node.op = s2;
        // compute allowed prefix for heredoc end marker (e.g. EOF)
        var pos = this.reader.tell();
        while (this.reader.tell() > 0) {
            if (this.reader.peek() == "<EOL>") {
                this.reader.seek_cur(1);
                break;
            }
            this.reader.seek_cur(-1);
        }
        var prefix = "";
        while (TRUE) {
            var c = this.reader.getn(1);
            if (c == ":") {
                // any presence of leading ':' disables prefix for heredoc end marker
                var prefix = "";
                break;
            }
            else if (!iswhite(c)) {
                break;
            }
            prefix += c;
        }
        this.reader.seek_set(pos);
        node.right = this.parse_heredoc(prefix);
        this.add_node(node);
        return;
    }
    else if (s1 == "=") {
        this.reader.getn(1);
        node.op = s1;
    }
    else {
        throw "NOT REACHED";
    }
    node.right = this.parse_expr();
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_const = function() {
    var pos = this.reader.tell();
    this.reader.skip_white();
    // :const
    if (this.ends_excmds(this.reader.peek())) {
        this.reader.seek_set(pos);
        this.parse_cmd_common();
        return;
    }
    var lhs = this.parse_constlhs();
    this.reader.skip_white();
    var s1 = this.reader.peekn(1);
    // :const {var-name}
    if (this.ends_excmds(s1) || s1 != "=") {
        this.reader.seek_set(pos);
        this.parse_cmd_common();
        return;
    }
    // :const left op right
    var node = Node(NODE_CONST);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    this.reader.getn(1);
    node.op = s1;
    node.left = lhs.left;
    node.list = lhs.list;
    node.rest = lhs.rest;
    node.right = this.parse_expr();
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_unlet = function() {
    var node = Node(NODE_UNLET);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.list = this.parse_lvaluelist();
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_lockvar = function() {
    var node = Node(NODE_LOCKVAR);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.depth = NIL;
    node.list = [];
    this.reader.skip_white();
    if (isdigit(this.reader.peekn(1))) {
        node.depth = viml_str2nr(this.reader.read_digit(), 10);
    }
    node.list = this.parse_lvaluelist();
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_unlockvar = function() {
    var node = Node(NODE_UNLOCKVAR);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.depth = NIL;
    node.list = [];
    this.reader.skip_white();
    if (isdigit(this.reader.peekn(1))) {
        node.depth = viml_str2nr(this.reader.read_digit(), 10);
    }
    node.list = this.parse_lvaluelist();
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_if = function() {
    var node = Node(NODE_IF);
    node.pos = this.ea.cmdpos;
    node.body = [];
    node.ea = this.ea;
    node.cond = this.parse_expr();
    node.elseif = [];
    node._else = NIL;
    node.endif = NIL;
    this.add_node(node);
    this.push_context(node);
}

VimLParser.prototype.parse_cmd_elseif = function() {
    if (this.context[0].type != NODE_IF && this.context[0].type != NODE_ELSEIF) {
        throw Err("E582: :elseif without :if", this.ea.cmdpos);
    }
    if (this.context[0].type != NODE_IF) {
        this.pop_context();
    }
    var node = Node(NODE_ELSEIF);
    node.pos = this.ea.cmdpos;
    node.body = [];
    node.ea = this.ea;
    node.cond = this.parse_expr();
    viml_add(this.context[0].elseif, node);
    this.push_context(node);
}

VimLParser.prototype.parse_cmd_else = function() {
    if (this.context[0].type != NODE_IF && this.context[0].type != NODE_ELSEIF) {
        throw Err("E581: :else without :if", this.ea.cmdpos);
    }
    if (this.context[0].type != NODE_IF) {
        this.pop_context();
    }
    var node = Node(NODE_ELSE);
    node.pos = this.ea.cmdpos;
    node.body = [];
    node.ea = this.ea;
    this.context[0]._else = node;
    this.push_context(node);
}

VimLParser.prototype.parse_cmd_endif = function() {
    if (this.context[0].type != NODE_IF && this.context[0].type != NODE_ELSEIF && this.context[0].type != NODE_ELSE) {
        throw Err("E580: :endif without :if", this.ea.cmdpos);
    }
    if (this.context[0].type != NODE_IF) {
        this.pop_context();
    }
    var node = Node(NODE_ENDIF);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    this.context[0].endif = node;
    this.pop_context();
}

VimLParser.prototype.parse_cmd_while = function() {
    var node = Node(NODE_WHILE);
    node.pos = this.ea.cmdpos;
    node.body = [];
    node.ea = this.ea;
    node.cond = this.parse_expr();
    node.endwhile = NIL;
    this.add_node(node);
    this.push_context(node);
}

VimLParser.prototype.parse_cmd_endwhile = function() {
    if (this.context[0].type != NODE_WHILE) {
        throw Err("E588: :endwhile without :while", this.ea.cmdpos);
    }
    var node = Node(NODE_ENDWHILE);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    this.context[0].endwhile = node;
    this.pop_context();
}

VimLParser.prototype.parse_cmd_for = function() {
    var node = Node(NODE_FOR);
    node.pos = this.ea.cmdpos;
    node.body = [];
    node.ea = this.ea;
    node.left = NIL;
    node.right = NIL;
    node.endfor = NIL;
    var lhs = this.parse_letlhs();
    node.left = lhs.left;
    node.list = lhs.list;
    node.rest = lhs.rest;
    this.reader.skip_white();
    var epos = this.reader.getpos();
    if (this.reader.read_alpha() != "in") {
        throw Err("Missing \"in\" after :for", epos);
    }
    node.right = this.parse_expr();
    this.add_node(node);
    this.push_context(node);
}

VimLParser.prototype.parse_cmd_endfor = function() {
    if (this.context[0].type != NODE_FOR) {
        throw Err("E588: :endfor without :for", this.ea.cmdpos);
    }
    var node = Node(NODE_ENDFOR);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    this.context[0].endfor = node;
    this.pop_context();
}

VimLParser.prototype.parse_cmd_continue = function() {
    if (this.find_context(NODE_WHILE) == -1 && this.find_context(NODE_FOR) == -1) {
        throw Err("E586: :continue without :while or :for", this.ea.cmdpos);
    }
    var node = Node(NODE_CONTINUE);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_break = function() {
    if (this.find_context(NODE_WHILE) == -1 && this.find_context(NODE_FOR) == -1) {
        throw Err("E587: :break without :while or :for", this.ea.cmdpos);
    }
    var node = Node(NODE_BREAK);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_try = function() {
    var node = Node(NODE_TRY);
    node.pos = this.ea.cmdpos;
    node.body = [];
    node.ea = this.ea;
    node.catch = [];
    node._finally = NIL;
    node.endtry = NIL;
    this.add_node(node);
    this.push_context(node);
}

VimLParser.prototype.parse_cmd_catch = function() {
    if (this.context[0].type == NODE_FINALLY) {
        throw Err("E604: :catch after :finally", this.ea.cmdpos);
    }
    else if (this.context[0].type != NODE_TRY && this.context[0].type != NODE_CATCH) {
        throw Err("E603: :catch without :try", this.ea.cmdpos);
    }
    if (this.context[0].type != NODE_TRY) {
        this.pop_context();
    }
    var node = Node(NODE_CATCH);
    node.pos = this.ea.cmdpos;
    node.body = [];
    node.ea = this.ea;
    node.pattern = NIL;
    this.reader.skip_white();
    if (!this.ends_excmds(this.reader.peek())) {
        var __tmp = this.parse_pattern(this.reader.get());
        node.pattern = __tmp[0];
        var _ = __tmp[1];
    }
    viml_add(this.context[0].catch, node);
    this.push_context(node);
}

VimLParser.prototype.parse_cmd_finally = function() {
    if (this.context[0].type != NODE_TRY && this.context[0].type != NODE_CATCH) {
        throw Err("E606: :finally without :try", this.ea.cmdpos);
    }
    if (this.context[0].type != NODE_TRY) {
        this.pop_context();
    }
    var node = Node(NODE_FINALLY);
    node.pos = this.ea.cmdpos;
    node.body = [];
    node.ea = this.ea;
    this.context[0]._finally = node;
    this.push_context(node);
}

VimLParser.prototype.parse_cmd_endtry = function() {
    if (this.context[0].type != NODE_TRY && this.context[0].type != NODE_CATCH && this.context[0].type != NODE_FINALLY) {
        throw Err("E602: :endtry without :try", this.ea.cmdpos);
    }
    if (this.context[0].type != NODE_TRY) {
        this.pop_context();
    }
    var node = Node(NODE_ENDTRY);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    this.context[0].endtry = node;
    this.pop_context();
}

VimLParser.prototype.parse_cmd_throw = function() {
    var node = Node(NODE_THROW);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.left = this.parse_expr();
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_eval = function() {
    var node = Node(NODE_EVAL);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.left = this.parse_expr();
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_echo = function() {
    var node = Node(NODE_ECHO);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.list = this.parse_exprlist();
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_echon = function() {
    var node = Node(NODE_ECHON);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.list = this.parse_exprlist();
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_echohl = function() {
    var node = Node(NODE_ECHOHL);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.str = "";
    while (!this.ends_excmds(this.reader.peek())) {
        node.str += this.reader.get();
    }
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_echomsg = function() {
    var node = Node(NODE_ECHOMSG);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.list = this.parse_exprlist();
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_echoerr = function() {
    var node = Node(NODE_ECHOERR);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.list = this.parse_exprlist();
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_echoconsole = function() {
    var node = Node(NODE_ECHOCONSOLE);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.list = this.parse_exprlist();
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_execute = function() {
    var node = Node(NODE_EXECUTE);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.list = this.parse_exprlist();
    this.add_node(node);
}

VimLParser.prototype.parse_expr = function() {
    return new ExprParser(this.reader).parse();
}

VimLParser.prototype.parse_exprlist = function() {
    var list = [];
    while (TRUE) {
        this.reader.skip_white();
        var c = this.reader.peek();
        if (c != "\"" && this.ends_excmds(c)) {
            break;
        }
        var node = this.parse_expr();
        viml_add(list, node);
    }
    return list;
}

VimLParser.prototype.parse_lvalue_func = function() {
    var p = new LvalueParser(this.reader);
    var node = p.parse();
    if (node.type == NODE_IDENTIFIER || node.type == NODE_CURLYNAME || node.type == NODE_SUBSCRIPT || node.type == NODE_DOT || node.type == NODE_OPTION || node.type == NODE_ENV || node.type == NODE_REG) {
        return node;
    }
    throw Err("Invalid Expression", node.pos);
}

// FIXME:
VimLParser.prototype.parse_lvalue = function() {
    var p = new LvalueParser(this.reader);
    var node = p.parse();
    if (node.type == NODE_IDENTIFIER) {
        if (!isvarname(node.value)) {
            throw Err(viml_printf("E461: Illegal variable name: %s", node.value), node.pos);
        }
    }
    if (node.type == NODE_IDENTIFIER || node.type == NODE_CURLYNAME || node.type == NODE_SUBSCRIPT || node.type == NODE_SLICE || node.type == NODE_DOT || node.type == NODE_OPTION || node.type == NODE_ENV || node.type == NODE_REG) {
        return node;
    }
    throw Err("Invalid Expression", node.pos);
}

// TODO: merge with s:VimLParser.parse_lvalue()
VimLParser.prototype.parse_constlvalue = function() {
    var p = new LvalueParser(this.reader);
    var node = p.parse();
    if (node.type == NODE_IDENTIFIER) {
        if (!isvarname(node.value)) {
            throw Err(viml_printf("E461: Illegal variable name: %s", node.value), node.pos);
        }
    }
    if (node.type == NODE_IDENTIFIER || node.type == NODE_CURLYNAME) {
        return node;
    }
    else if (node.type == NODE_SUBSCRIPT || node.type == NODE_SLICE || node.type == NODE_DOT) {
        throw Err("E996: Cannot lock a list or dict", node.pos);
    }
    else if (node.type == NODE_OPTION) {
        throw Err("E996: Cannot lock an option", node.pos);
    }
    else if (node.type == NODE_ENV) {
        throw Err("E996: Cannot lock an environment variable", node.pos);
    }
    else if (node.type == NODE_REG) {
        throw Err("E996: Cannot lock a register", node.pos);
    }
    throw Err("Invalid Expression", node.pos);
}

VimLParser.prototype.parse_lvaluelist = function() {
    var list = [];
    var node = this.parse_expr();
    viml_add(list, node);
    while (TRUE) {
        this.reader.skip_white();
        if (this.ends_excmds(this.reader.peek())) {
            break;
        }
        var node = this.parse_lvalue();
        viml_add(list, node);
    }
    return list;
}

// FIXME:
VimLParser.prototype.parse_letlhs = function() {
    var lhs = {"left":NIL, "list":NIL, "rest":NIL};
    var tokenizer = new ExprTokenizer(this.reader);
    if (tokenizer.peek().type == TOKEN_SQOPEN) {
        tokenizer.get();
        lhs.list = [];
        while (TRUE) {
            var node = this.parse_lvalue();
            viml_add(lhs.list, node);
            var token = tokenizer.get();
            if (token.type == TOKEN_SQCLOSE) {
                break;
            }
            else if (token.type == TOKEN_COMMA) {
                continue;
            }
            else if (token.type == TOKEN_SEMICOLON) {
                var node = this.parse_lvalue();
                lhs.rest = node;
                var token = tokenizer.get();
                if (token.type == TOKEN_SQCLOSE) {
                    break;
                }
                else {
                    throw Err(viml_printf("E475 Invalid argument: %s", token.value), token.pos);
                }
            }
            else {
                throw Err(viml_printf("E475 Invalid argument: %s", token.value), token.pos);
            }
        }
    }
    else {
        lhs.left = this.parse_lvalue();
    }
    return lhs;
}

// TODO: merge with s:VimLParser.parse_letlhs() ?
VimLParser.prototype.parse_constlhs = function() {
    var lhs = {"left":NIL, "list":NIL, "rest":NIL};
    var tokenizer = new ExprTokenizer(this.reader);
    if (tokenizer.peek().type == TOKEN_SQOPEN) {
        tokenizer.get();
        lhs.list = [];
        while (TRUE) {
            var node = this.parse_lvalue();
            viml_add(lhs.list, node);
            var token = tokenizer.get();
            if (token.type == TOKEN_SQCLOSE) {
                break;
            }
            else if (token.type == TOKEN_COMMA) {
                continue;
            }
            else if (token.type == TOKEN_SEMICOLON) {
                var node = this.parse_lvalue();
                lhs.rest = node;
                var token = tokenizer.get();
                if (token.type == TOKEN_SQCLOSE) {
                    break;
                }
                else {
                    throw Err(viml_printf("E475 Invalid argument: %s", token.value), token.pos);
                }
            }
            else {
                throw Err(viml_printf("E475 Invalid argument: %s", token.value), token.pos);
            }
        }
    }
    else {
        lhs.left = this.parse_constlvalue();
    }
    return lhs;
}

VimLParser.prototype.ends_excmds = function(c) {
    return c == "" || c == "|" || c == "\"" || c == "<EOF>" || c == "<EOL>";
}

// FIXME: validate argument
VimLParser.prototype.parse_wincmd = function() {
    var c = this.reader.getn(1);
    if (c == "") {
        throw Err("E471: Argument required", this.reader.getpos());
    }
    else if (c == "g" || c == "\x07") {
        // <C-G>
        var c2 = this.reader.getn(1);
        if (c2 == "" || iswhite(c2)) {
            throw Err("E474: Invalid Argument", this.reader.getpos());
        }
    }
    var end = this.reader.getpos();
    this.reader.skip_white();
    if (!this.ends_excmds(this.reader.peek())) {
        throw Err("E474: Invalid Argument", this.reader.getpos());
    }
    var node = Node(NODE_EXCMD);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.str = this.reader.getstr(this.ea.linepos, end);
    this.add_node(node);
}

// FIXME: validate argument
VimLParser.prototype.parse_cmd_syntax = function() {
    var end = this.reader.getpos();
    while (TRUE) {
        var end = this.reader.getpos();
        var c = this.reader.peek();
        if (c == "/" || c == "'" || c == "\"") {
            this.reader.getn(1);
            this.parse_pattern(c);
        }
        else if (c == "=") {
            this.reader.getn(1);
            this.parse_pattern(" ");
        }
        else if (this.ends_excmds(c)) {
            break;
        }
        this.reader.getn(1);
    }
    var node = Node(NODE_EXCMD);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.str = this.reader.getstr(this.ea.linepos, end);
    this.add_node(node);
}

VimLParser.prototype.neovim_additional_commands = [{"name":"rshada", "minlen":3, "flags":"BANG|FILE1|TRLBAR|CMDWIN", "parser":"parse_cmd_common"}, {"name":"wshada", "minlen":3, "flags":"BANG|FILE1|TRLBAR|CMDWIN", "parser":"parse_cmd_common"}];
VimLParser.prototype.neovim_removed_commands = [{"name":"Print", "minlen":1, "flags":"RANGE|WHOLEFOLD|COUNT|EXFLAGS|TRLBAR|CMDWIN", "parser":"parse_cmd_common"}, {"name":"fixdel", "minlen":3, "flags":"TRLBAR|CMDWIN", "parser":"parse_cmd_common"}, {"name":"helpfind", "minlen":5, "flags":"EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"open", "minlen":1, "flags":"RANGE|BANG|EXTRA", "parser":"parse_cmd_common"}, {"name":"shell", "minlen":2, "flags":"TRLBAR|CMDWIN", "parser":"parse_cmd_common"}, {"name":"tearoff", "minlen":2, "flags":"NEEDARG|EXTRA|TRLBAR|NOTRLCOM|CMDWIN", "parser":"parse_cmd_common"}, {"name":"gvim", "minlen":2, "flags":"BANG|FILES|EDITCMD|ARGOPT|TRLBAR|CMDWIN", "parser":"parse_cmd_common"}];
// To find new builtin_commands, run the below script.
// $ scripts/update_builtin_commands.sh /path/to/vim/src/ex_cmds.h
VimLParser.prototype.builtin_commands = [{"name":"append", "minlen":1, "flags":"BANG|RANGE|ZEROR|TRLBAR|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_append"}, {"name":"abbreviate", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"abclear", "minlen":3, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"aboveleft", "minlen":3, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"abstract", "minlen":3, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"all", "minlen":2, "flags":"BANG|RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"amenu", "minlen":2, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"anoremenu", "minlen":2, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"args", "minlen":2, "flags":"BANG|FILES|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"argadd", "minlen":4, "flags":"BANG|RANGE|ZEROR|FILES|TRLBAR", "parser":"parse_cmd_common"}, {"name":"argdelete", "minlen":4, "flags":"BANG|RANGE|FILES|TRLBAR", "parser":"parse_cmd_common"}, {"name":"argdo", "minlen":5, "flags":"BANG|NEEDARG|EXTRA|NOTRLCOM|RANGE|DFLALL|EXPAND", "parser":"parse_cmd_common"}, {"name":"argdedupe", "minlen":6, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"argedit", "minlen":4, "flags":"BANG|NEEDARG|RANGE|ZEROR|FILES|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"argglobal", "minlen":4, "flags":"BANG|FILES|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"arglocal", "minlen":4, "flags":"BANG|FILES|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"argument", "minlen":4, "flags":"BANG|RANGE|COUNT|EXTRA|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"ascii", "minlen":2, "flags":"TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"autocmd", "minlen":2, "flags":"BANG|EXTRA|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"augroup", "minlen":3, "flags":"BANG|WORD1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"aunmenu", "minlen":3, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"buffer", "minlen":1, "flags":"BANG|RANGE|BUFNAME|BUFUNL|COUNT|EXTRA|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"bNext", "minlen":2, "flags":"BANG|RANGE|COUNT|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"ball", "minlen":2, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"badd", "minlen":3, "flags":"NEEDARG|FILE1|CMDARG|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"balt", "minlen":4, "flags":"NEEDARG|FILE1|CMDARG|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"bdelete", "minlen":2, "flags":"BANG|RANGE|BUFNAME|COUNT|EXTRA|TRLBAR", "parser":"parse_cmd_common"}, {"name":"behave", "minlen":2, "flags":"BANG|NEEDARG|WORD1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"belowright", "minlen":3, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"bfirst", "minlen":2, "flags":"BANG|RANGE|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"blast", "minlen":2, "flags":"BANG|RANGE|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"bmodified", "minlen":2, "flags":"BANG|RANGE|COUNT|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"bnext", "minlen":2, "flags":"BANG|RANGE|COUNT|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"botright", "minlen":2, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"bprevious", "minlen":2, "flags":"BANG|RANGE|COUNT|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"brewind", "minlen":2, "flags":"BANG|RANGE|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"break", "minlen":4, "flags":"TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_break"}, {"name":"breakadd", "minlen":6, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"breakdel", "minlen":6, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"breaklist", "minlen":6, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"browse", "minlen":3, "flags":"NEEDARG|EXTRA|NOTRLCOM|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"buffers", "minlen":7, "flags":"BANG|EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"bufdo", "minlen":4, "flags":"BANG|NEEDARG|EXTRA|NOTRLCOM|RANGE|DFLALL|EXPAND", "parser":"parse_cmd_common"}, {"name":"bunload", "minlen":3, "flags":"BANG|RANGE|BUFNAME|COUNT|EXTRA|TRLBAR", "parser":"parse_cmd_common"}, {"name":"bwipeout", "minlen":2, "flags":"BANG|RANGE|BUFNAME|BUFUNL|COUNT|EXTRA|TRLBAR", "parser":"parse_cmd_common"}, {"name":"change", "minlen":1, "flags":"BANG|WHOLEFOLD|RANGE|COUNT|TRLBAR|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"cNext", "minlen":2, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"cNfile", "minlen":3, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"cabbrev", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"cabclear", "minlen":4, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"cabove", "minlen":4, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"caddbuffer", "minlen":3, "flags":"RANGE|WORD1|TRLBAR", "parser":"parse_cmd_common"}, {"name":"caddexpr", "minlen":5, "flags":"NEEDARG|WORD1|NOTRLCOM|EXPR_ARG", "parser":"parse_cmd_common"}, {"name":"caddfile", "minlen":5, "flags":"TRLBAR|FILE1", "parser":"parse_cmd_common"}, {"name":"cafter", "minlen":3, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"call", "minlen":3, "flags":"RANGE|NEEDARG|EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_call"}, {"name":"catch", "minlen":3, "flags":"EXTRA|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_catch"}, {"name":"cbuffer", "minlen":2, "flags":"BANG|RANGE|WORD1|TRLBAR", "parser":"parse_cmd_common"}, {"name":"cbefore", "minlen":3, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"cbelow", "minlen":4, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"cbottom", "minlen":3, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"cc", "minlen":2, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"cclose", "minlen":3, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"cd", "minlen":2, "flags":"BANG|FILE1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"cdo", "minlen":3, "flags":"BANG|NEEDARG|EXTRA|NOTRLCOM|RANGE|DFLALL|EXPAND", "parser":"parse_cmd_common"}, {"name":"center", "minlen":2, "flags":"TRLBAR|RANGE|WHOLEFOLD|EXTRA|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"cexpr", "minlen":3, "flags":"NEEDARG|WORD1|NOTRLCOM|EXPR_ARG|BANG", "parser":"parse_cmd_common"}, {"name":"cfile", "minlen":2, "flags":"TRLBAR|FILE1|BANG", "parser":"parse_cmd_common"}, {"name":"cfdo", "minlen":3, "flags":"BANG|NEEDARG|EXTRA|NOTRLCOM|RANGE|DFLALL|EXPAND", "parser":"parse_cmd_common"}, {"name":"cfirst", "minlen":4, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"cgetfile", "minlen":2, "flags":"TRLBAR|FILE1", "parser":"parse_cmd_common"}, {"name":"cgetbuffer", "minlen":5, "flags":"RANGE|WORD1|TRLBAR", "parser":"parse_cmd_common"}, {"name":"cgetexpr", "minlen":5, "flags":"NEEDARG|WORD1|NOTRLCOM|EXPR_ARG", "parser":"parse_cmd_common"}, {"name":"chdir", "minlen":3, "flags":"BANG|FILE1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"changes", "minlen":7, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"checkpath", "minlen":3, "flags":"TRLBAR|BANG|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"checktime", "minlen":6, "flags":"RANGE|BUFNAME|COUNT|EXTRA|TRLBAR", "parser":"parse_cmd_common"}, {"name":"chistory", "minlen":3, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"clist", "minlen":2, "flags":"BANG|EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"clast", "minlen":3, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"class", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"close", "minlen":3, "flags":"BANG|RANGE|COUNT|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"clearjumps", "minlen":3, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"cmap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"cmapclear", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"cmenu", "minlen":3, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"cnext", "minlen":2, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"cnewer", "minlen":4, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"cnfile", "minlen":3, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"cnoremap", "minlen":3, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"cnoreabbrev", "minlen":6, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"cnoremenu", "minlen":7, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"copy", "minlen":2, "flags":"RANGE|WHOLEFOLD|EXTRA|TRLBAR|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"colder", "minlen":3, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"colorscheme", "minlen":4, "flags":"WORD1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"command", "minlen":3, "flags":"EXTRA|BANG|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"comclear", "minlen":4, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"compiler", "minlen":4, "flags":"BANG|TRLBAR|WORD1|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"continue", "minlen":3, "flags":"TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_continue"}, {"name":"confirm", "minlen":4, "flags":"NEEDARG|EXTRA|NOTRLCOM|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"const", "minlen":4, "flags":"EXTRA|BANG|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_const"}, {"name":"copen", "minlen":4, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"cprevious", "minlen":2, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"cpfile", "minlen":3, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"cquit", "minlen":2, "flags":"RANGE|COUNT|ZEROR|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"crewind", "minlen":2, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"cscope", "minlen":2, "flags":"EXTRA|NOTRLCOM|XFILE", "parser":"parse_cmd_common"}, {"name":"cstag", "minlen":3, "flags":"BANG|TRLBAR|WORD1", "parser":"parse_cmd_common"}, {"name":"cunmap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"cunabbrev", "minlen":4, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"cunmenu", "minlen":5, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"cwindow", "minlen":2, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"delete", "minlen":1, "flags":"RANGE|WHOLEFOLD|REGSTR|COUNT|TRLBAR|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"delmarks", "minlen":4, "flags":"BANG|EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"debug", "minlen":3, "flags":"NEEDARG|EXTRA|NOTRLCOM|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"debuggreedy", "minlen":6, "flags":"RANGE|ZEROR|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"def", "minlen":3, "flags":"EXTRA|BANG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"defer", "minlen":4, "flags":"NEEDARG|EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"defcompile", "minlen":4, "flags":"SBOXOK|CMDWIN|LOCK_OK|TRLBAR", "parser":"parse_cmd_common"}, {"name":"delcommand", "minlen":4, "flags":"NEEDARG|WORD1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"delfunction", "minlen":4, "flags":"BANG|NEEDARG|WORD1|CMDWIN|LOCK_OK", "parser":"parse_cmd_delfunction"}, {"name":"display", "minlen":2, "flags":"EXTRA|NOTRLCOM|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"diffupdate", "minlen":3, "flags":"BANG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"diffget", "minlen":5, "flags":"RANGE|EXTRA|TRLBAR|MODIFY", "parser":"parse_cmd_common"}, {"name":"diffoff", "minlen":5, "flags":"BANG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"diffpatch", "minlen":5, "flags":"EXTRA|FILE1|TRLBAR|MODIFY", "parser":"parse_cmd_common"}, {"name":"diffput", "minlen":6, "flags":"RANGE|EXTRA|TRLBAR", "parser":"parse_cmd_common"}, {"name":"diffsplit", "minlen":5, "flags":"EXTRA|FILE1|TRLBAR", "parser":"parse_cmd_common"}, {"name":"diffthis", "minlen":5, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"digraphs", "minlen":3, "flags":"BANG|EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"disassemble", "minlen":4, "flags":"BANG|EXTRA|NEEDARG|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"djump", "minlen":2, "flags":"BANG|RANGE|DFLALL|WHOLEFOLD|EXTRA", "parser":"parse_cmd_common"}, {"name":"dlist", "minlen":2, "flags":"BANG|RANGE|DFLALL|WHOLEFOLD|EXTRA|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"doautocmd", "minlen":2, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"doautoall", "minlen":7, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"drop", "minlen":2, "flags":"FILES|CMDARG|NEEDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"dsearch", "minlen":2, "flags":"BANG|RANGE|DFLALL|WHOLEFOLD|EXTRA|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"dsplit", "minlen":3, "flags":"BANG|RANGE|DFLALL|WHOLEFOLD|EXTRA", "parser":"parse_cmd_common"}, {"name":"edit", "minlen":1, "flags":"BANG|FILE1|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"earlier", "minlen":2, "flags":"TRLBAR|EXTRA|NOSPC|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"echo", "minlen":2, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_echo"}, {"name":"echoerr", "minlen":5, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_echoerr"}, {"name":"echohl", "minlen":5, "flags":"EXTRA|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_echohl"}, {"name":"echomsg", "minlen":5, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_echomsg"}, {"name":"echoconsole", "minlen":5, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_echoconsole"}, {"name":"echowindow", "minlen":5, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"echon", "minlen":5, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_echon"}, {"name":"else", "minlen":2, "flags":"TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_else"}, {"name":"elseif", "minlen":5, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_elseif"}, {"name":"emenu", "minlen":2, "flags":"NEEDARG|EXTRA|TRLBAR|NOTRLCOM|RANGE|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"endif", "minlen":2, "flags":"TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_endif"}, {"name":"endinterface", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"endclass", "minlen":4, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"enddef", "minlen":4, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"endenum", "minlen":4, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"endfunction", "minlen":4, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_endfunction"}, {"name":"endfor", "minlen":5, "flags":"TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_endfor"}, {"name":"endtry", "minlen":4, "flags":"TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_endtry"}, {"name":"endwhile", "minlen":4, "flags":"TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_endwhile"}, {"name":"enew", "minlen":3, "flags":"BANG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"enum", "minlen":3, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"eval", "minlen":2, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_eval"}, {"name":"ex", "minlen":2, "flags":"BANG|FILE1|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"execute", "minlen":3, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_execute"}, {"name":"exit", "minlen":3, "flags":"RANGE|WHOLEFOLD|BANG|FILE1|ARGOPT|DFLALL|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"export", "minlen":3, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"exusage", "minlen":3, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"file", "minlen":1, "flags":"RANGE|ZEROR|BANG|FILE1|TRLBAR", "parser":"parse_cmd_common"}, {"name":"files", "minlen":5, "flags":"BANG|EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"filetype", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"filter", "minlen":4, "flags":"BANG|NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"find", "minlen":3, "flags":"RANGE|BANG|FILE1|CMDARG|ARGOPT|TRLBAR|NEEDARG", "parser":"parse_cmd_common"}, {"name":"final", "minlen":4, "flags":"EXTRA|NOTRLCOM|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"finally", "minlen":6, "flags":"TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_finally"}, {"name":"finish", "minlen":4, "flags":"TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_finish"}, {"name":"first", "minlen":3, "flags":"EXTRA|BANG|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"fixdel", "minlen":3, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"fold", "minlen":2, "flags":"RANGE|WHOLEFOLD|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"foldclose", "minlen":5, "flags":"RANGE|BANG|WHOLEFOLD|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"folddoopen", "minlen":5, "flags":"RANGE|DFLALL|NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"folddoclosed", "minlen":7, "flags":"RANGE|DFLALL|NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"foldopen", "minlen":5, "flags":"RANGE|BANG|WHOLEFOLD|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"for", "minlen":3, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_for"}, {"name":"function", "minlen":2, "flags":"EXTRA|BANG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_function"}, {"name":"global", "minlen":1, "flags":"RANGE|WHOLEFOLD|BANG|EXTRA|DFLALL|SBOXOK|CMDWIN|LOCK_OK|NONWHITE_OK", "parser":"parse_cmd_common"}, {"name":"goto", "minlen":2, "flags":"RANGE|COUNT|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"grep", "minlen":2, "flags":"RANGE|BANG|NEEDARG|EXTRA|NOTRLCOM|TRLBAR|XFILE", "parser":"parse_cmd_common"}, {"name":"grepadd", "minlen":5, "flags":"RANGE|BANG|NEEDARG|EXTRA|NOTRLCOM|TRLBAR|XFILE", "parser":"parse_cmd_common"}, {"name":"gui", "minlen":2, "flags":"BANG|FILES|CMDARG|ARGOPT|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"gvim", "minlen":2, "flags":"BANG|FILES|CMDARG|ARGOPT|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"help", "minlen":1, "flags":"BANG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"helpclose", "minlen":5, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"helpfind", "minlen":5, "flags":"EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"helpgrep", "minlen":5, "flags":"EXTRA|NOTRLCOM|NEEDARG", "parser":"parse_cmd_common"}, {"name":"helptags", "minlen":5, "flags":"NEEDARG|FILES|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"hardcopy", "minlen":2, "flags":"RANGE|COUNT|EXTRA|EXPAND|TRLBAR|DFLALL|BANG", "parser":"parse_cmd_common"}, {"name":"highlight", "minlen":2, "flags":"BANG|EXTRA|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"hide", "minlen":3, "flags":"BANG|RANGE|COUNT|EXTRA|TRLBAR", "parser":"parse_cmd_common"}, {"name":"history", "minlen":3, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"horizontal", "minlen":2, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"insert", "minlen":1, "flags":"BANG|RANGE|TRLBAR|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_insert"}, {"name":"iabbrev", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"iabclear", "minlen":4, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"if", "minlen":2, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_if"}, {"name":"ijump", "minlen":2, "flags":"BANG|RANGE|DFLALL|WHOLEFOLD|EXTRA", "parser":"parse_cmd_common"}, {"name":"ilist", "minlen":2, "flags":"BANG|RANGE|DFLALL|WHOLEFOLD|EXTRA|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"imap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"imapclear", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"imenu", "minlen":3, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"import", "minlen":3, "flags":"EXTRA|NOTRLCOM|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"inoremap", "minlen":3, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"inoreabbrev", "minlen":6, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"inoremenu", "minlen":7, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"intro", "minlen":3, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"interface", "minlen":4, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"isearch", "minlen":2, "flags":"BANG|RANGE|DFLALL|WHOLEFOLD|EXTRA|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"isplit", "minlen":3, "flags":"BANG|RANGE|DFLALL|WHOLEFOLD|EXTRA", "parser":"parse_cmd_common"}, {"name":"iunmap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"iunabbrev", "minlen":4, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"iunmenu", "minlen":5, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"join", "minlen":1, "flags":"BANG|RANGE|WHOLEFOLD|COUNT|FLAGS|TRLBAR|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"jumps", "minlen":2, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"k", "minlen":1, "flags":"RANGE|WORD1|TRLBAR|SBOXOK|CMDWIN|LOCK_OK|NONWHITE_OK", "parser":"parse_cmd_common"}, {"name":"keepmarks", "minlen":2, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"keepjumps", "minlen":5, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"keeppatterns", "minlen":5, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"keepalt", "minlen":5, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"list", "minlen":1, "flags":"RANGE|WHOLEFOLD|COUNT|FLAGS|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"lNext", "minlen":2, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"lNfile", "minlen":3, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"last", "minlen":2, "flags":"EXTRA|BANG|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"labove", "minlen":3, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"language", "minlen":3, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"laddexpr", "minlen":3, "flags":"NEEDARG|WORD1|NOTRLCOM|EXPR_ARG", "parser":"parse_cmd_common"}, {"name":"laddbuffer", "minlen":5, "flags":"RANGE|WORD1|TRLBAR", "parser":"parse_cmd_common"}, {"name":"laddfile", "minlen":5, "flags":"TRLBAR|FILE1", "parser":"parse_cmd_common"}, {"name":"lafter", "minlen":3, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"later", "minlen":3, "flags":"TRLBAR|EXTRA|NOSPC|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"lbuffer", "minlen":2, "flags":"BANG|RANGE|WORD1|TRLBAR", "parser":"parse_cmd_common"}, {"name":"lbefore", "minlen":3, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"lbelow", "minlen":4, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"lbottom", "minlen":3, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"lcd", "minlen":2, "flags":"BANG|FILE1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"lchdir", "minlen":3, "flags":"BANG|FILE1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"lclose", "minlen":3, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"lcscope", "minlen":3, "flags":"EXTRA|NOTRLCOM|XFILE", "parser":"parse_cmd_common"}, {"name":"ldo", "minlen":2, "flags":"BANG|NEEDARG|EXTRA|NOTRLCOM|RANGE|DFLALL|EXPAND", "parser":"parse_cmd_common"}, {"name":"left", "minlen":2, "flags":"TRLBAR|RANGE|WHOLEFOLD|EXTRA|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"leftabove", "minlen":5, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"let", "minlen":3, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_let"}, {"name":"lexpr", "minlen":3, "flags":"NEEDARG|WORD1|NOTRLCOM|EXPR_ARG|BANG", "parser":"parse_cmd_common"}, {"name":"legacy", "minlen":3, "flags":"NEEDARG|EXTRA|NOTRLCOM|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"lfile", "minlen":2, "flags":"TRLBAR|FILE1|BANG", "parser":"parse_cmd_common"}, {"name":"lfdo", "minlen":3, "flags":"BANG|NEEDARG|EXTRA|NOTRLCOM|RANGE|DFLALL|EXPAND", "parser":"parse_cmd_common"}, {"name":"lfirst", "minlen":4, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"lgetfile", "minlen":2, "flags":"TRLBAR|FILE1", "parser":"parse_cmd_common"}, {"name":"lgetbuffer", "minlen":5, "flags":"RANGE|WORD1|TRLBAR", "parser":"parse_cmd_common"}, {"name":"lgetexpr", "minlen":5, "flags":"NEEDARG|WORD1|NOTRLCOM|EXPR_ARG", "parser":"parse_cmd_common"}, {"name":"lgrep", "minlen":3, "flags":"RANGE|BANG|NEEDARG|EXTRA|NOTRLCOM|TRLBAR|XFILE", "parser":"parse_cmd_common"}, {"name":"lgrepadd", "minlen":6, "flags":"RANGE|BANG|NEEDARG|EXTRA|NOTRLCOM|TRLBAR|XFILE", "parser":"parse_cmd_common"}, {"name":"lhelpgrep", "minlen":2, "flags":"EXTRA|NOTRLCOM|NEEDARG", "parser":"parse_cmd_common"}, {"name":"lhistory", "minlen":3, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"ll", "minlen":2, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"llast", "minlen":3, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"llist", "minlen":3, "flags":"BANG|EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"lmap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"lmapclear", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"lmake", "minlen":4, "flags":"BANG|EXTRA|NOTRLCOM|TRLBAR|XFILE", "parser":"parse_cmd_common"}, {"name":"lnoremap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"lnext", "minlen":3, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"lnewer", "minlen":4, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"lnfile", "minlen":3, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"loadview", "minlen":2, "flags":"FILE1|TRLBAR", "parser":"parse_cmd_common"}, {"name":"loadkeymap", "minlen":5, "flags":"CMDWIN|LOCK_OK", "parser":"parse_cmd_loadkeymap"}, {"name":"lockmarks", "minlen":3, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"lockvar", "minlen":5, "flags":"BANG|EXTRA|NEEDARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_lockvar"}, {"name":"lolder", "minlen":3, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"lopen", "minlen":3, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"lprevious", "minlen":2, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"lpfile", "minlen":3, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"lrewind", "minlen":2, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"ltag", "minlen":2, "flags":"TRLBAR|BANG|WORD1", "parser":"parse_cmd_common"}, {"name":"lunmap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"lua", "minlen":3, "flags":"RANGE|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_lua"}, {"name":"luado", "minlen":4, "flags":"RANGE|DFLALL|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"luafile", "minlen":4, "flags":"RANGE|FILE1|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"lvimgrep", "minlen":2, "flags":"RANGE|BANG|NEEDARG|EXTRA|NOTRLCOM|TRLBAR|XFILE|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"lvimgrepadd", "minlen":9, "flags":"RANGE|BANG|NEEDARG|EXTRA|NOTRLCOM|TRLBAR|XFILE|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"lwindow", "minlen":2, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"ls", "minlen":2, "flags":"BANG|EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"move", "minlen":1, "flags":"RANGE|WHOLEFOLD|EXTRA|TRLBAR|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"mark", "minlen":2, "flags":"RANGE|WORD1|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"make", "minlen":3, "flags":"BANG|EXTRA|NOTRLCOM|TRLBAR|XFILE", "parser":"parse_cmd_common"}, {"name":"map", "minlen":3, "flags":"BANG|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"mapclear", "minlen":4, "flags":"EXTRA|BANG|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"marks", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"match", "minlen":3, "flags":"RANGE|EXTRA|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"menu", "minlen":2, "flags":"RANGE|ZEROR|BANG|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"menutranslate", "minlen":5, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"messages", "minlen":3, "flags":"EXTRA|TRLBAR|RANGE|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"mkexrc", "minlen":2, "flags":"BANG|FILE1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"mksession", "minlen":3, "flags":"BANG|FILE1|TRLBAR", "parser":"parse_cmd_common"}, {"name":"mkspell", "minlen":4, "flags":"BANG|NEEDARG|EXTRA|NOTRLCOM|TRLBAR|XFILE", "parser":"parse_cmd_common"}, {"name":"mkvimrc", "minlen":3, "flags":"BANG|FILE1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"mkview", "minlen":5, "flags":"BANG|FILE1|TRLBAR", "parser":"parse_cmd_common"}, {"name":"mode", "minlen":3, "flags":"WORD1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"mzscheme", "minlen":2, "flags":"RANGE|EXTRA|DFLALL|NEEDARG|CMDWIN|LOCK_OK|SBOXOK|RESTRICT", "parser":"parse_cmd_mzscheme"}, {"name":"mzfile", "minlen":3, "flags":"RANGE|FILE1|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"next", "minlen":1, "flags":"RANGE|BANG|FILES|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"nbkey", "minlen":2, "flags":"EXTRA|NEEDARG", "parser":"parse_cmd_common"}, {"name":"nbclose", "minlen":3, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"nbstart", "minlen":3, "flags":"WORD1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"new", "minlen":3, "flags":"BANG|FILE1|RANGE|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"nmap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"nmapclear", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"nmenu", "minlen":3, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"nnoremap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"nnoremenu", "minlen":7, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"noremap", "minlen":2, "flags":"BANG|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"noautocmd", "minlen":3, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"nohlsearch", "minlen":3, "flags":"TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"noreabbrev", "minlen":5, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"noremenu", "minlen":6, "flags":"RANGE|ZEROR|BANG|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"noswapfile", "minlen":3, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"normal", "minlen":4, "flags":"RANGE|BANG|EXTRA|NEEDARG|NOTRLCOM|CTRLV|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"number", "minlen":2, "flags":"RANGE|WHOLEFOLD|COUNT|FLAGS|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"nunmap", "minlen":3, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"nunmenu", "minlen":5, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"open", "minlen":1, "flags":"RANGE|BANG|EXTRA", "parser":"parse_cmd_common"}, {"name":"oldfiles", "minlen":2, "flags":"BANG|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"omap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"omapclear", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"omenu", "minlen":3, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"only", "minlen":2, "flags":"BANG|RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"onoremap", "minlen":3, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"onoremenu", "minlen":7, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"options", "minlen":3, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"ounmap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"ounmenu", "minlen":5, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"ownsyntax", "minlen":2, "flags":"EXTRA|NOTRLCOM|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"print", "minlen":1, "flags":"RANGE|WHOLEFOLD|COUNT|FLAGS|TRLBAR|CMDWIN|LOCK_OK|SBOXOK", "parser":"parse_cmd_common"}, {"name":"packadd", "minlen":2, "flags":"BANG|FILE1|NEEDARG|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"packloadall", "minlen":5, "flags":"BANG|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"pclose", "minlen":2, "flags":"BANG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"perl", "minlen":2, "flags":"RANGE|EXTRA|DFLALL|NEEDARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_perl"}, {"name":"perldo", "minlen":5, "flags":"RANGE|EXTRA|DFLALL|NEEDARG|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"pedit", "minlen":3, "flags":"BANG|FILE1|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"pop", "minlen":2, "flags":"RANGE|BANG|COUNT|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"popup", "minlen":4, "flags":"NEEDARG|EXTRA|BANG|TRLBAR|NOTRLCOM|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"ppop", "minlen":2, "flags":"RANGE|BANG|COUNT|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"preserve", "minlen":3, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"previous", "minlen":4, "flags":"EXTRA|RANGE|COUNT|BANG|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"promptfind", "minlen":3, "flags":"EXTRA|NOTRLCOM|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"promptrepl", "minlen":7, "flags":"EXTRA|NOTRLCOM|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"profile", "minlen":4, "flags":"BANG|EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"profdel", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"psearch", "minlen":2, "flags":"BANG|RANGE|WHOLEFOLD|DFLALL|EXTRA", "parser":"parse_cmd_common"}, {"name":"ptag", "minlen":2, "flags":"RANGE|BANG|WORD1|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"ptNext", "minlen":3, "flags":"RANGE|BANG|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"ptfirst", "minlen":3, "flags":"RANGE|BANG|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"ptjump", "minlen":3, "flags":"BANG|TRLBAR|WORD1", "parser":"parse_cmd_common"}, {"name":"ptlast", "minlen":3, "flags":"BANG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"ptnext", "minlen":3, "flags":"RANGE|BANG|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"ptprevious", "minlen":3, "flags":"RANGE|BANG|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"ptrewind", "minlen":3, "flags":"RANGE|BANG|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"ptselect", "minlen":3, "flags":"BANG|TRLBAR|WORD1", "parser":"parse_cmd_common"}, {"name":"put", "minlen":2, "flags":"RANGE|WHOLEFOLD|BANG|REGSTR|TRLBAR|ZEROR|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"pwd", "minlen":2, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"python", "minlen":2, "flags":"RANGE|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_python"}, {"name":"pydo", "minlen":3, "flags":"RANGE|DFLALL|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"pyfile", "minlen":3, "flags":"RANGE|FILE1|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"py3", "minlen":3, "flags":"RANGE|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_python3"}, {"name":"py3do", "minlen":4, "flags":"RANGE|DFLALL|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"python3", "minlen":7, "flags":"RANGE|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_python3"}, {"name":"py3file", "minlen":4, "flags":"RANGE|FILE1|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"pyx", "minlen":3, "flags":"RANGE|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"pyxdo", "minlen":4, "flags":"RANGE|DFLALL|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"pythonx", "minlen":7, "flags":"RANGE|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"pyxfile", "minlen":4, "flags":"RANGE|FILE1|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"quit", "minlen":1, "flags":"BANG|RANGE|COUNT|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"quitall", "minlen":5, "flags":"BANG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"qall", "minlen":2, "flags":"BANG|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"read", "minlen":1, "flags":"BANG|RANGE|WHOLEFOLD|FILE1|ARGOPT|TRLBAR|ZEROR|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"recover", "minlen":3, "flags":"BANG|FILE1|TRLBAR", "parser":"parse_cmd_common"}, {"name":"redo", "minlen":3, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"redir", "minlen":4, "flags":"BANG|FILES|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"redraw", "minlen":4, "flags":"BANG|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"redrawstatus", "minlen":7, "flags":"BANG|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"redrawtabline", "minlen":7, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"registers", "minlen":3, "flags":"EXTRA|NOTRLCOM|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"resize", "minlen":3, "flags":"RANGE|TRLBAR|WORD1|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"retab", "minlen":3, "flags":"TRLBAR|RANGE|WHOLEFOLD|DFLALL|BANG|WORD1|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"return", "minlen":4, "flags":"EXTRA|NOTRLCOM|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_return"}, {"name":"rewind", "minlen":3, "flags":"EXTRA|BANG|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"right", "minlen":2, "flags":"TRLBAR|RANGE|WHOLEFOLD|EXTRA|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"rightbelow", "minlen":6, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"runtime", "minlen":2, "flags":"BANG|NEEDARG|FILES|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"ruby", "minlen":3, "flags":"RANGE|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_ruby"}, {"name":"rubydo", "minlen":5, "flags":"RANGE|DFLALL|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"rubyfile", "minlen":5, "flags":"RANGE|FILE1|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"rundo", "minlen":4, "flags":"NEEDARG|FILE1", "parser":"parse_cmd_common"}, {"name":"rviminfo", "minlen":2, "flags":"BANG|FILE1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"substitute", "minlen":1, "flags":"RANGE|WHOLEFOLD|EXTRA|CMDWIN|LOCK_OK|NONWHITE_OK", "parser":"parse_cmd_common"}, {"name":"sNext", "minlen":2, "flags":"EXTRA|RANGE|COUNT|BANG|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sargument", "minlen":2, "flags":"BANG|RANGE|COUNT|EXTRA|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sall", "minlen":3, "flags":"BANG|RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sandbox", "minlen":3, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"saveas", "minlen":3, "flags":"BANG|FILE1|ARGOPT|CMDWIN|LOCK_OK|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sbuffer", "minlen":2, "flags":"BANG|RANGE|BUFNAME|BUFUNL|COUNT|EXTRA|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sbNext", "minlen":3, "flags":"RANGE|COUNT|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sball", "minlen":3, "flags":"RANGE|COUNT|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sbfirst", "minlen":3, "flags":"CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sblast", "minlen":3, "flags":"CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sbmodified", "minlen":3, "flags":"RANGE|COUNT|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sbnext", "minlen":3, "flags":"RANGE|COUNT|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sbprevious", "minlen":3, "flags":"RANGE|COUNT|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sbrewind", "minlen":3, "flags":"CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"scriptnames", "minlen":2, "flags":"BANG|RANGE|COUNT|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"scriptencoding", "minlen":7, "flags":"WORD1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"scriptversion", "minlen":7, "flags":"WORD1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"scscope", "minlen":3, "flags":"EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"set", "minlen":2, "flags":"BANG|TRLBAR|EXTRA|CMDWIN|LOCK_OK|SBOXOK", "parser":"parse_cmd_common"}, {"name":"setfiletype", "minlen":4, "flags":"TRLBAR|EXTRA|NEEDARG|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"setglobal", "minlen":4, "flags":"BANG|TRLBAR|EXTRA|CMDWIN|LOCK_OK|SBOXOK", "parser":"parse_cmd_common"}, {"name":"setlocal", "minlen":4, "flags":"BANG|TRLBAR|EXTRA|CMDWIN|LOCK_OK|SBOXOK", "parser":"parse_cmd_common"}, {"name":"sfind", "minlen":2, "flags":"BANG|FILE1|RANGE|CMDARG|ARGOPT|TRLBAR|NEEDARG", "parser":"parse_cmd_common"}, {"name":"sfirst", "minlen":4, "flags":"EXTRA|BANG|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"shell", "minlen":2, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"simalt", "minlen":2, "flags":"NEEDARG|WORD1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"sign", "minlen":3, "flags":"NEEDARG|RANGE|EXTRA|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"silent", "minlen":3, "flags":"NEEDARG|EXTRA|BANG|NOTRLCOM|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"sleep", "minlen":2, "flags":"BANG|RANGE|COUNT|EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"slast", "minlen":3, "flags":"EXTRA|BANG|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"smagic", "minlen":2, "flags":"RANGE|WHOLEFOLD|EXTRA|CMDWIN|LOCK_OK|NONWHITE_OK", "parser":"parse_cmd_common"}, {"name":"smap", "minlen":4, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"smapclear", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"smenu", "minlen":3, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"snext", "minlen":2, "flags":"RANGE|BANG|FILES|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"snomagic", "minlen":3, "flags":"RANGE|WHOLEFOLD|EXTRA|CMDWIN|LOCK_OK|NONWHITE_OK", "parser":"parse_cmd_common"}, {"name":"snoremap", "minlen":4, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"snoremenu", "minlen":7, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"source", "minlen":2, "flags":"BANG|FILE1|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"sort", "minlen":3, "flags":"RANGE|DFLALL|WHOLEFOLD|BANG|EXTRA|NOTRLCOM|MODIFY", "parser":"parse_cmd_common"}, {"name":"split", "minlen":2, "flags":"BANG|FILE1|RANGE|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"spellgood", "minlen":3, "flags":"BANG|RANGE|NEEDARG|EXTRA|TRLBAR", "parser":"parse_cmd_common"}, {"name":"spelldump", "minlen":6, "flags":"BANG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"spellinfo", "minlen":6, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"spellrepall", "minlen":6, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"spellrare", "minlen":7, "flags":"BANG|RANGE|NEEDARG|EXTRA|TRLBAR", "parser":"parse_cmd_common"}, {"name":"spellundo", "minlen":6, "flags":"BANG|RANGE|NEEDARG|EXTRA|TRLBAR", "parser":"parse_cmd_common"}, {"name":"spellwrong", "minlen":6, "flags":"BANG|RANGE|NEEDARG|EXTRA|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sprevious", "minlen":3, "flags":"EXTRA|RANGE|COUNT|BANG|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"srewind", "minlen":2, "flags":"EXTRA|BANG|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"stop", "minlen":2, "flags":"TRLBAR|BANG|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"stag", "minlen":3, "flags":"RANGE|BANG|WORD1|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"startinsert", "minlen":4, "flags":"BANG|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"startgreplace", "minlen":6, "flags":"BANG|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"startreplace", "minlen":6, "flags":"BANG|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"static", "minlen":4, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"stopinsert", "minlen":5, "flags":"BANG|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"stjump", "minlen":3, "flags":"BANG|TRLBAR|WORD1", "parser":"parse_cmd_common"}, {"name":"stselect", "minlen":3, "flags":"BANG|TRLBAR|WORD1", "parser":"parse_cmd_common"}, {"name":"sunhide", "minlen":3, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sunmap", "minlen":4, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"sunmenu", "minlen":5, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"suspend", "minlen":3, "flags":"TRLBAR|BANG|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"sview", "minlen":2, "flags":"BANG|FILE1|RANGE|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"swapname", "minlen":2, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"syntax", "minlen":2, "flags":"EXTRA|NOTRLCOM|CMDWIN|LOCK_OK", "parser":"parse_cmd_syntax"}, {"name":"syntime", "minlen":5, "flags":"NEEDARG|WORD1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"syncbind", "minlen":4, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"smile", "minlen":3, "flags":"TRLBAR|CMDWIN|LOCK_OK|SBOXOK", "parser":"parse_cmd_common"}, {"name":"t", "minlen":1, "flags":"RANGE|WHOLEFOLD|EXTRA|TRLBAR|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"tNext", "minlen":2, "flags":"RANGE|BANG|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"tag", "minlen":2, "flags":"RANGE|BANG|WORD1|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"tags", "minlen":4, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tab", "minlen":3, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"tabclose", "minlen":4, "flags":"BANG|RANGE|ZEROR|EXTRA|NOSPC|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tabdo", "minlen":4, "flags":"NEEDARG|EXTRA|NOTRLCOM|RANGE|DFLALL|EXPAND", "parser":"parse_cmd_common"}, {"name":"tabedit", "minlen":4, "flags":"BANG|FILE1|RANGE|ZEROR|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"tabfind", "minlen":4, "flags":"BANG|FILE1|RANGE|ZEROR|CMDARG|ARGOPT|NEEDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"tabfirst", "minlen":6, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"tabmove", "minlen":4, "flags":"RANGE|ZEROR|EXTRA|NOSPC|TRLBAR", "parser":"parse_cmd_common"}, {"name":"tablast", "minlen":4, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"tabnext", "minlen":4, "flags":"RANGE|ZEROR|EXTRA|NOSPC|TRLBAR", "parser":"parse_cmd_common"}, {"name":"tabnew", "minlen":6, "flags":"BANG|FILE1|RANGE|ZEROR|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"tabonly", "minlen":4, "flags":"BANG|RANGE|ZEROR|EXTRA|NOSPC|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tabprevious", "minlen":4, "flags":"RANGE|ZEROR|EXTRA|NOSPC|TRLBAR", "parser":"parse_cmd_common"}, {"name":"tabNext", "minlen":4, "flags":"RANGE|ZEROR|EXTRA|NOSPC|TRLBAR", "parser":"parse_cmd_common"}, {"name":"tabrewind", "minlen":4, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"tabs", "minlen":4, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tcd", "minlen":2, "flags":"BANG|FILE1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tchdir", "minlen":3, "flags":"BANG|FILE1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tcl", "minlen":3, "flags":"RANGE|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_tcl"}, {"name":"tcldo", "minlen":4, "flags":"RANGE|DFLALL|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"tclfile", "minlen":4, "flags":"RANGE|FILE1|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"tearoff", "minlen":2, "flags":"NEEDARG|EXTRA|TRLBAR|NOTRLCOM|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"terminal", "minlen":3, "flags":"RANGE|BANG|FILES|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tfirst", "minlen":2, "flags":"RANGE|BANG|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"throw", "minlen":2, "flags":"EXTRA|NEEDARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_throw"}, {"name":"tjump", "minlen":2, "flags":"BANG|TRLBAR|WORD1", "parser":"parse_cmd_common"}, {"name":"tlast", "minlen":2, "flags":"BANG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"tlmenu", "minlen":3, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tlnoremenu", "minlen":3, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tlunmenu", "minlen":3, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tmenu", "minlen":2, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tmap", "minlen":3, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tmapclear", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tnext", "minlen":2, "flags":"RANGE|BANG|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"tnoremap", "minlen":3, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"topleft", "minlen":2, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"tprevious", "minlen":2, "flags":"RANGE|BANG|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"trewind", "minlen":2, "flags":"RANGE|BANG|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"try", "minlen":3, "flags":"TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_try"}, {"name":"tselect", "minlen":2, "flags":"BANG|TRLBAR|WORD1", "parser":"parse_cmd_common"}, {"name":"tunmenu", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tunmap", "minlen":5, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"type", "minlen":2, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"undo", "minlen":1, "flags":"RANGE|COUNT|ZEROR|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"undojoin", "minlen":5, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"undolist", "minlen":5, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"unabbreviate", "minlen":3, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"unhide", "minlen":3, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"unlet", "minlen":3, "flags":"BANG|EXTRA|NEEDARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_unlet"}, {"name":"unlockvar", "minlen":4, "flags":"BANG|EXTRA|NEEDARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_unlockvar"}, {"name":"unmap", "minlen":3, "flags":"BANG|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"unmenu", "minlen":4, "flags":"BANG|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"unsilent", "minlen":3, "flags":"NEEDARG|EXTRA|NOTRLCOM|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"update", "minlen":2, "flags":"RANGE|WHOLEFOLD|BANG|FILE1|ARGOPT|DFLALL|TRLBAR", "parser":"parse_cmd_common"}, {"name":"vglobal", "minlen":1, "flags":"RANGE|WHOLEFOLD|EXTRA|DFLALL|CMDWIN|LOCK_OK|NONWHITE_OK", "parser":"parse_cmd_common"}, {"name":"var", "minlen":2, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"version", "minlen":2, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"verbose", "minlen":4, "flags":"NEEDARG|RANGE|EXTRA|NOTRLCOM|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"vertical", "minlen":4, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"visual", "minlen":2, "flags":"BANG|FILE1|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"view", "minlen":3, "flags":"BANG|FILE1|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"vimgrep", "minlen":3, "flags":"RANGE|BANG|NEEDARG|EXTRA|NOTRLCOM|TRLBAR|XFILE|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"vimgrepadd", "minlen":8, "flags":"RANGE|BANG|NEEDARG|EXTRA|NOTRLCOM|TRLBAR|XFILE|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"vim9cmd", "minlen":4, "flags":"NEEDARG|EXTRA|NOTRLCOM|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"vim9script", "minlen":5, "flags":"WORD1|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"viusage", "minlen":3, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"vmap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"vmapclear", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"vmenu", "minlen":3, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"vnoremap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"vnew", "minlen":3, "flags":"BANG|FILE1|RANGE|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"vnoremenu", "minlen":7, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"vsplit", "minlen":2, "flags":"BANG|FILE1|RANGE|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"vunmap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"vunmenu", "minlen":5, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"write", "minlen":1, "flags":"RANGE|WHOLEFOLD|BANG|FILE1|ARGOPT|DFLALL|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"wNext", "minlen":2, "flags":"RANGE|WHOLEFOLD|BANG|FILE1|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"wall", "minlen":2, "flags":"BANG|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"while", "minlen":2, "flags":"EXTRA|NOTRLCOM|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_while"}, {"name":"winsize", "minlen":2, "flags":"EXTRA|NEEDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"wincmd", "minlen":4, "flags":"NEEDARG|WORD1|RANGE|CMDWIN|LOCK_OK", "parser":"parse_wincmd"}, {"name":"windo", "minlen":4, "flags":"NEEDARG|EXTRA|NOTRLCOM|RANGE|DFLALL|EXPAND", "parser":"parse_cmd_common"}, {"name":"winpos", "minlen":4, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"wnext", "minlen":2, "flags":"RANGE|BANG|FILE1|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"wprevious", "minlen":2, "flags":"RANGE|BANG|FILE1|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"wq", "minlen":2, "flags":"RANGE|WHOLEFOLD|BANG|FILE1|ARGOPT|DFLALL|TRLBAR", "parser":"parse_cmd_common"}, {"name":"wqall", "minlen":3, "flags":"BANG|FILE1|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"wundo", "minlen":2, "flags":"BANG|NEEDARG|FILE1", "parser":"parse_cmd_common"}, {"name":"wviminfo", "minlen":2, "flags":"BANG|FILE1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"xit", "minlen":1, "flags":"RANGE|WHOLEFOLD|BANG|FILE1|ARGOPT|DFLALL|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"xall", "minlen":2, "flags":"BANG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"xmap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"xmapclear", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"xmenu", "minlen":3, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"xnoremap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"xnoremenu", "minlen":7, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"xrestore", "minlen":2, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"xunmap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"xunmenu", "minlen":5, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"yank", "minlen":1, "flags":"RANGE|WHOLEFOLD|REGSTR|COUNT|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"z", "minlen":1, "flags":"RANGE|WHOLEFOLD|BANG|EXTRA|FLAGS|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"!", "minlen":1, "flags":"RANGE|WHOLEFOLD|BANG|FILES|CMDWIN|LOCK_OK|NONWHITE_OK", "parser":"parse_cmd_common"}, {"name":"#", "minlen":1, "flags":"RANGE|WHOLEFOLD|COUNT|FLAGS|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"&", "minlen":1, "flags":"RANGE|WHOLEFOLD|EXTRA|CMDWIN|LOCK_OK|MODIFY|NONWHITE_OK", "parser":"parse_cmd_common"}, {"name":"*", "minlen":1, "flags":"RANGE|WHOLEFOLD|EXTRA|TRLBAR|CMDWIN|LOCK_OK|NONWHITE_OK", "parser":"parse_cmd_common"}, {"name":"<", "minlen":1, "flags":"RANGE|WHOLEFOLD|COUNT|FLAGS|TRLBAR|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"=", "minlen":1, "flags":"RANGE|TRLBAR|DFLALL|FLAGS|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":">", "minlen":1, "flags":"RANGE|WHOLEFOLD|COUNT|FLAGS|TRLBAR|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"@", "minlen":1, "flags":"RANGE|WHOLEFOLD|EXTRA|TRLBAR|CMDWIN|LOCK_OK|NONWHITE_OK", "parser":"parse_cmd_common"}, {"name":"{", "minlen":1, "flags":"TRLBAR|LOCK_OK|CMDWIN", "parser":"parse_cmd_common"}, {"name":"}", "minlen":1, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"~", "minlen":1, "flags":"RANGE|WHOLEFOLD|EXTRA|CMDWIN|LOCK_OK|MODIFY|NONWHITE_OK", "parser":"parse_cmd_common"}, {"name":"Next", "minlen":1, "flags":"EXTRA|RANGE|COUNT|BANG|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"Print", "minlen":1, "flags":"RANGE|WHOLEFOLD|COUNT|FLAGS|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"X", "minlen":1, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"++", "minlen":1, "flags":"EXTRA|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"--", "minlen":1, "flags":"EXTRA|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}];
// To find new builtin_functions, run the below script.
// $ scripts/update_builtin_functions.sh /path/to/vim/src/evalfunc.c
VimLParser.prototype.builtin_functions = [{"name":"abs", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"acos", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"add", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"and", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"append", "min_argc":2, "max_argc":2, "argtype":"FEARG_2"}, {"name":"appendbufline", "min_argc":3, "max_argc":3, "argtype":"FEARG_3"}, {"name":"argc", "min_argc":0, "max_argc":1, "argtype":"0"}, {"name":"argidx", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"arglistid", "min_argc":0, "max_argc":2, "argtype":"0"}, {"name":"argv", "min_argc":0, "max_argc":2, "argtype":"0"}, {"name":"asin", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"assert_beeps", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"assert_equal", "min_argc":2, "max_argc":3, "argtype":"FEARG_2"}, {"name":"assert_equalfile", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"assert_exception", "min_argc":1, "max_argc":2, "argtype":"0"}, {"name":"assert_fails", "min_argc":1, "max_argc":5, "argtype":"FEARG_1"}, {"name":"assert_false", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"assert_inrange", "min_argc":3, "max_argc":4, "argtype":"FEARG_3"}, {"name":"assert_match", "min_argc":2, "max_argc":3, "argtype":"FEARG_2"}, {"name":"assert_nobeep", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"assert_notequal", "min_argc":2, "max_argc":3, "argtype":"FEARG_2"}, {"name":"assert_notmatch", "min_argc":2, "max_argc":3, "argtype":"FEARG_2"}, {"name":"assert_report", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"assert_true", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"atan", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"atan2", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"autocmd_add", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"autocmd_delete", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"autocmd_get", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"balloon_gettext", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"balloon_show", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"balloon_split", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"blob2list", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"browse", "min_argc":4, "max_argc":4, "argtype":"0"}, {"name":"browsedir", "min_argc":2, "max_argc":2, "argtype":"0"}, {"name":"bufadd", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"bufexists", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"buffer_exists", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"buffer_name", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"buffer_number", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"buflisted", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"bufload", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"bufloaded", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"bufname", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"bufnr", "min_argc":0, "max_argc":2, "argtype":"FEARG_1"}, {"name":"bufwinid", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"bufwinnr", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"byte2line", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"byteidx", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"byteidxcomp", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"call", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"ceil", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"ch_canread", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"ch_close", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"ch_close_in", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"ch_evalexpr", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"ch_evalraw", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"ch_getbufnr", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"ch_getjob", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"ch_info", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"ch_log", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"ch_logfile", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"ch_open", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"ch_read", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"ch_readblob", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"ch_readraw", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"ch_sendexpr", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"ch_sendraw", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"ch_setoptions", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"ch_status", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"changenr", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"char2nr", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"charclass", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"charcol", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"charidx", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"chdir", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"cindent", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"clearmatches", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"col", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"complete", "min_argc":2, "max_argc":2, "argtype":"FEARG_2"}, {"name":"complete_add", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"complete_check", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"complete_info", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"confirm", "min_argc":1, "max_argc":4, "argtype":"FEARG_1"}, {"name":"copy", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"cos", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"cosh", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"count", "min_argc":2, "max_argc":4, "argtype":"FEARG_1"}, {"name":"cscope_connection", "min_argc":0, "max_argc":3, "argtype":"0"}, {"name":"cursor", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"debugbreak", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"deepcopy", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"delete", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"deletebufline", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"did_filetype", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"diff_filler", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"diff_hlID", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"digraph_get", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"digraph_getlist", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"digraph_set", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"digraph_setlist", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"echoraw", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"empty", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"environ", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"escape", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"eval", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"eventhandler", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"executable", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"execute", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"exepath", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"exists", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"exists_compiled", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"exp", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"expand", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"expandcmd", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"extend", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"extendnew", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"feedkeys", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"file_readable", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"filereadable", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"filewritable", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"filter", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"finddir", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"findfile", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"flatten", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"flattennew", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"float2nr", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"floor", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"fmod", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"fnameescape", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"fnamemodify", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"foldclosed", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"foldclosedend", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"foldlevel", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"foldtext", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"foldtextresult", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"foreground", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"fullcommand", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"funcref", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"function", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"garbagecollect", "min_argc":0, "max_argc":1, "argtype":"0"}, {"name":"get", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"getbufinfo", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getbufline", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"getbufvar", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"getchangelist", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getchar", "min_argc":0, "max_argc":1, "argtype":"0"}, {"name":"getcharmod", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"getcharpos", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getcharsearch", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"getcharstr", "min_argc":0, "max_argc":1, "argtype":"0"}, {"name":"getcmdcompltype", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"getcmdline", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"getcmdpos", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"getcmdscreenpos", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"getcmdtype", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"getcmdwintype", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"getcompletion", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"getcurpos", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getcursorcharpos", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getcwd", "min_argc":0, "max_argc":2, "argtype":"FEARG_1"}, {"name":"getenv", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getfontname", "min_argc":0, "max_argc":1, "argtype":"0"}, {"name":"getfperm", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getfsize", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getftime", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getftype", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getimstatus", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"getjumplist", "min_argc":0, "max_argc":2, "argtype":"FEARG_1"}, {"name":"getline", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"getloclist", "min_argc":1, "max_argc":2, "argtype":"0"}, {"name":"getmarklist", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getmatches", "min_argc":0, "max_argc":1, "argtype":"0"}, {"name":"getmousepos", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"getpid", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"getpos", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getqflist", "min_argc":0, "max_argc":1, "argtype":"0"}, {"name":"getreg", "min_argc":0, "max_argc":3, "argtype":"FEARG_1"}, {"name":"getreginfo", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getregtype", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getscriptinfo", "min_argc":0, "max_argc":1, "argtype":"0"}, {"name":"gettabinfo", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"gettabvar", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"gettabwinvar", "min_argc":3, "max_argc":4, "argtype":"FEARG_1"}, {"name":"gettagstack", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"gettext", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getwininfo", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getwinpos", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getwinposx", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"getwinposy", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"getwinvar", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"glob", "min_argc":1, "max_argc":4, "argtype":"FEARG_1"}, {"name":"glob2regpat", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"globpath", "min_argc":2, "max_argc":5, "argtype":"FEARG_2"}, {"name":"has", "min_argc":1, "max_argc":2, "argtype":"0"}, {"name":"has_key", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"haslocaldir", "min_argc":0, "max_argc":2, "argtype":"FEARG_1"}, {"name":"hasmapto", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"highlightID", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"highlight_exists", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"histadd", "min_argc":2, "max_argc":2, "argtype":"FEARG_2"}, {"name":"histdel", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"histget", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"histnr", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"hlID", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"hlexists", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"hlget", "min_argc":0, "max_argc":2, "argtype":"FEARG_1"}, {"name":"hlset", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"hostname", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"iconv", "min_argc":3, "max_argc":3, "argtype":"FEARG_1"}, {"name":"indent", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"index", "min_argc":2, "max_argc":4, "argtype":"FEARG_1"}, {"name":"indexof", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"input", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"inputdialog", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"inputlist", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"inputrestore", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"inputsave", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"inputsecret", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"insert", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"interrupt", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"invert", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"isabsolutepath", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"isdirectory", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"isinf", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"islocked", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"isnan", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"items", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"job_getchannel", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"job_info", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"job_setoptions", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"job_start", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"job_status", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"job_stop", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"join", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"js_decode", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"js_encode", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"json_decode", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"json_encode", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"keys", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"last_buffer_nr", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"len", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"libcall", "min_argc":3, "max_argc":3, "argtype":"FEARG_3"}, {"name":"libcallnr", "min_argc":3, "max_argc":3, "argtype":"FEARG_3"}, {"name":"line", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"line2byte", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"lispindent", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"list2blob", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"list2str", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"listener_add", "min_argc":1, "max_argc":2, "argtype":"FEARG_2"}, {"name":"listener_flush", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"listener_remove", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"localtime", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"log", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"log10", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"luaeval", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"map", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"maparg", "min_argc":1, "max_argc":4, "argtype":"FEARG_1"}, {"name":"mapcheck", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"maplist", "min_argc":0, "max_argc":1, "argtype":"0"}, {"name":"mapnew", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"mapset", "min_argc":3, "max_argc":3, "argtype":"FEARG_1"}, {"name":"match", "min_argc":2, "max_argc":4, "argtype":"FEARG_1"}, {"name":"matchadd", "min_argc":2, "max_argc":5, "argtype":"FEARG_1"}, {"name":"matchaddpos", "min_argc":2, "max_argc":5, "argtype":"FEARG_1"}, {"name":"matcharg", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"matchdelete", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"matchend", "min_argc":2, "max_argc":4, "argtype":"FEARG_1"}, {"name":"matchfuzzy", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"matchfuzzypos", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"matchlist", "min_argc":2, "max_argc":4, "argtype":"FEARG_1"}, {"name":"matchstr", "min_argc":2, "max_argc":4, "argtype":"FEARG_1"}, {"name":"matchstrpos", "min_argc":2, "max_argc":4, "argtype":"FEARG_1"}, {"name":"max", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"menu_info", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"min", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"mkdir", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"mode", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"mzeval", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"nextnonblank", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"nr2char", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"or", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"pathshorten", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"perleval", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"popup_atcursor", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"popup_beval", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"popup_clear", "min_argc":0, "max_argc":1, "argtype":"0"}, {"name":"popup_close", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"popup_create", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"popup_dialog", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"popup_filter_menu", "min_argc":2, "max_argc":2, "argtype":"0"}, {"name":"popup_filter_yesno", "min_argc":2, "max_argc":2, "argtype":"0"}, {"name":"popup_findinfo", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"popup_findpreview", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"popup_getoptions", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"popup_getpos", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"popup_hide", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"popup_list", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"popup_locate", "min_argc":2, "max_argc":2, "argtype":"0"}, {"name":"popup_menu", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"popup_move", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"popup_notification", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"popup_setoptions", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"popup_settext", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"popup_show", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"pow", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"prevnonblank", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"printf", "min_argc":1, "max_argc":19, "argtype":"FEARG_2"}, {"name":"prompt_getprompt", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"prompt_setcallback", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"prompt_setinterrupt", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"prompt_setprompt", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"prop_add", "min_argc":3, "max_argc":3, "argtype":"FEARG_1"}, {"name":"prop_add_list", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"prop_clear", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"prop_find", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"prop_list", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"prop_remove", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"prop_type_add", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"prop_type_change", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"prop_type_delete", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"prop_type_get", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"prop_type_list", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"pum_getpos", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"pumvisible", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"py3eval", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"pyeval", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"pyxeval", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"rand", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"range", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"readblob", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"readdir", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"readdirex", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"readfile", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"reduce", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"reg_executing", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"reg_recording", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"reltime", "min_argc":0, "max_argc":2, "argtype":"FEARG_1"}, {"name":"reltimefloat", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"reltimestr", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"remote_expr", "min_argc":2, "max_argc":4, "argtype":"FEARG_1"}, {"name":"remote_foreground", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"remote_peek", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"remote_read", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"remote_send", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"remote_startserver", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"remove", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"rename", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"repeat", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"resolve", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"reverse", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"round", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"rubyeval", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"screenattr", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"screenchar", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"screenchars", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"screencol", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"screenpos", "min_argc":3, "max_argc":3, "argtype":"FEARG_1"}, {"name":"screenrow", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"screenstring", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"search", "min_argc":1, "max_argc":5, "argtype":"FEARG_1"}, {"name":"searchcount", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"searchdecl", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"searchpair", "min_argc":3, "max_argc":7, "argtype":"0"}, {"name":"searchpairpos", "min_argc":3, "max_argc":7, "argtype":"0"}, {"name":"searchpos", "min_argc":1, "max_argc":5, "argtype":"FEARG_1"}, {"name":"server2client", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"serverlist", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"setbufline", "min_argc":3, "max_argc":3, "argtype":"FEARG_3"}, {"name":"setbufvar", "min_argc":3, "max_argc":3, "argtype":"FEARG_3"}, {"name":"setcellwidths", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"setcharpos", "min_argc":2, "max_argc":2, "argtype":"FEARG_2"}, {"name":"setcharsearch", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"setcmdline", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"setcmdpos", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"setcursorcharpos", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"setenv", "min_argc":2, "max_argc":2, "argtype":"FEARG_2"}, {"name":"setfperm", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"setline", "min_argc":2, "max_argc":2, "argtype":"FEARG_2"}, {"name":"setloclist", "min_argc":2, "max_argc":4, "argtype":"FEARG_2"}, {"name":"setmatches", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"setpos", "min_argc":2, "max_argc":2, "argtype":"FEARG_2"}, {"name":"setqflist", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"setreg", "min_argc":2, "max_argc":3, "argtype":"FEARG_2"}, {"name":"settabvar", "min_argc":3, "max_argc":3, "argtype":"FEARG_3"}, {"name":"settabwinvar", "min_argc":4, "max_argc":4, "argtype":"FEARG_4"}, {"name":"settagstack", "min_argc":2, "max_argc":3, "argtype":"FEARG_2"}, {"name":"setwinvar", "min_argc":3, "max_argc":3, "argtype":"FEARG_3"}, {"name":"sha256", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"shellescape", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"shiftwidth", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"sign_define", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"sign_getdefined", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"sign_getplaced", "min_argc":0, "max_argc":2, "argtype":"FEARG_1"}, {"name":"sign_jump", "min_argc":3, "max_argc":3, "argtype":"FEARG_1"}, {"name":"sign_place", "min_argc":4, "max_argc":5, "argtype":"FEARG_1"}, {"name":"sign_placelist", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"sign_undefine", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"sign_unplace", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"sign_unplacelist", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"simplify", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"sin", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"sinh", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"slice", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"sort", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"sound_clear", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"sound_playevent", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"sound_playfile", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"sound_stop", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"soundfold", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"spellbadword", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"spellsuggest", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"split", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"sqrt", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"srand", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"state", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"str2float", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"str2list", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"str2nr", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"strcharlen", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"strcharpart", "min_argc":2, "max_argc":4, "argtype":"FEARG_1"}, {"name":"strchars", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"strdisplaywidth", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"strftime", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"strgetchar", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"stridx", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"string", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"strlen", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"strpart", "min_argc":2, "max_argc":4, "argtype":"FEARG_1"}, {"name":"strptime", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"strridx", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"strtrans", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"strwidth", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"submatch", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"substitute", "min_argc":4, "max_argc":4, "argtype":"FEARG_1"}, {"name":"swapinfo", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"swapname", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"synID", "min_argc":3, "max_argc":3, "argtype":"0"}, {"name":"synIDattr", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"synIDtrans", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"synconcealed", "min_argc":2, "max_argc":2, "argtype":"0"}, {"name":"synstack", "min_argc":2, "max_argc":2, "argtype":"0"}, {"name":"system", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"systemlist", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"tabpagebuflist", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"tabpagenr", "min_argc":0, "max_argc":1, "argtype":"0"}, {"name":"tabpagewinnr", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"tagfiles", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"taglist", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"tan", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"tanh", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"tempname", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"term_dumpdiff", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"term_dumpload", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"term_dumpwrite", "min_argc":2, "max_argc":3, "argtype":"FEARG_2"}, {"name":"term_getaltscreen", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"term_getansicolors", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"term_getattr", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"term_getcursor", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"term_getjob", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"term_getline", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"term_getscrolled", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"term_getsize", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"term_getstatus", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"term_gettitle", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"term_gettty", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"term_list", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"term_scrape", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"term_sendkeys", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"term_setansicolors", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"term_setapi", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"term_setkill", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"term_setrestore", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"term_setsize", "min_argc":3, "max_argc":3, "argtype":"FEARG_1"}, {"name":"term_start", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"term_wait", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"terminalprops", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"test_alloc_fail", "min_argc":3, "max_argc":3, "argtype":"FEARG_1"}, {"name":"test_autochdir", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"test_feedinput", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"test_garbagecollect_now", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"test_garbagecollect_soon", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"test_getvalue", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"test_gui_drop_files", "min_argc":4, "max_argc":4, "argtype":"0"}, {"name":"test_gui_event", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"test_gui_mouse_event", "min_argc":5, "max_argc":5, "argtype":"0"}, {"name":"test_ignore_error", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"test_null_blob", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"test_null_channel", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"test_null_dict", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"test_null_function", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"test_null_job", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"test_null_list", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"test_null_partial", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"test_null_string", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"test_option_not_set", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"test_override", "min_argc":2, "max_argc":2, "argtype":"FEARG_2"}, {"name":"test_refcount", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"test_scrollbar", "min_argc":3, "max_argc":3, "argtype":"FEARG_2"}, {"name":"test_setmouse", "min_argc":2, "max_argc":2, "argtype":"0"}, {"name":"test_settime", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"test_srand_seed", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"test_unknown", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"test_void", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"timer_info", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"timer_pause", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"timer_start", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"timer_stop", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"timer_stopall", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"tolower", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"toupper", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"tr", "min_argc":3, "max_argc":3, "argtype":"FEARG_1"}, {"name":"trim", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"trunc", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"type", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"typename", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"undofile", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"undotree", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"uniq", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"values", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"virtcol", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"virtcol2col", "min_argc":3, "max_argc":3, "argtype":"FEARG_1"}, {"name":"visualmode", "min_argc":0, "max_argc":1, "argtype":"0"}, {"name":"wildmenumode", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"win_execute", "min_argc":2, "max_argc":3, "argtype":"FEARG_2"}, {"name":"win_findbuf", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"win_getid", "min_argc":0, "max_argc":2, "argtype":"FEARG_1"}, {"name":"win_gettype", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"win_gotoid", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"win_id2tabwin", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"win_id2win", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"win_move_separator", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"win_move_statusline", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"win_screenpos", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"win_splitmove", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"winbufnr", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"wincol", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"windowsversion", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"winheight", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"winlayout", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"winline", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"winnr", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"winrestcmd", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"winrestview", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"winsaveview", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"winwidth", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"wordcount", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"writefile", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"xor", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}];
function ExprTokenizer() { this.__init__.apply(this, arguments); }
ExprTokenizer.prototype.__init__ = function(reader) {
    this.reader = reader;
    this.cache = {};
}

ExprTokenizer.prototype.token = function(type, value, pos) {
    return {"type":type, "value":value, "pos":pos};
}

ExprTokenizer.prototype.peek = function() {
    var pos = this.reader.tell();
    var r = this.get();
    this.reader.seek_set(pos);
    return r;
}

ExprTokenizer.prototype.get = function() {
    // FIXME: remove dirty hack
    if (viml_has_key(this.cache, this.reader.tell())) {
        var x = this.cache[this.reader.tell()];
        this.reader.seek_set(x[0]);
        return x[1];
    }
    var pos = this.reader.tell();
    this.reader.skip_white();
    var r = this.get2();
    this.cache[pos] = [this.reader.tell(), r];
    return r;
}

ExprTokenizer.prototype.get2 = function() {
    var r = this.reader;
    var pos = r.getpos();
    var c = r.peek();
    if (c == "<EOF>") {
        return this.token(TOKEN_EOF, c, pos);
    }
    else if (c == "<EOL>") {
        r.seek_cur(1);
        return this.token(TOKEN_EOL, c, pos);
    }
    else if (iswhite(c)) {
        var s = r.read_white();
        return this.token(TOKEN_SPACE, s, pos);
    }
    else if (c == "0" && (r.p(1) == "X" || r.p(1) == "x") && isxdigit(r.p(2))) {
        var s = r.getn(3);
        s += r.read_xdigit();
        return this.token(TOKEN_NUMBER, s, pos);
    }
    else if (c == "0" && (r.p(1) == "B" || r.p(1) == "b") && (r.p(2) == "0" || r.p(2) == "1")) {
        var s = r.getn(3);
        s += r.read_bdigit();
        return this.token(TOKEN_NUMBER, s, pos);
    }
    else if (c == "0" && (r.p(1) == "Z" || r.p(1) == "z") && r.p(2) != ".") {
        var s = r.getn(2);
        s += r.read_blob();
        return this.token(TOKEN_BLOB, s, pos);
    }
    else if (isdigit(c)) {
        var s = r.read_digit();
        if (r.p(0) == "." && isdigit(r.p(1))) {
            s += r.getn(1);
            s += r.read_digit();
            if ((r.p(0) == "E" || r.p(0) == "e") && (isdigit(r.p(1)) || (r.p(1) == "-" || r.p(1) == "+") && isdigit(r.p(2)))) {
                s += r.getn(2);
                s += r.read_digit();
            }
        }
        return this.token(TOKEN_NUMBER, s, pos);
    }
    else if (c == "i" && r.p(1) == "s" && !isidc(r.p(2))) {
        if (r.p(2) == "?") {
            r.seek_cur(3);
            return this.token(TOKEN_ISCI, "is?", pos);
        }
        else if (r.p(2) == "#") {
            r.seek_cur(3);
            return this.token(TOKEN_ISCS, "is#", pos);
        }
        else {
            r.seek_cur(2);
            return this.token(TOKEN_IS, "is", pos);
        }
    }
    else if (c == "i" && r.p(1) == "s" && r.p(2) == "n" && r.p(3) == "o" && r.p(4) == "t" && !isidc(r.p(5))) {
        if (r.p(5) == "?") {
            r.seek_cur(6);
            return this.token(TOKEN_ISNOTCI, "isnot?", pos);
        }
        else if (r.p(5) == "#") {
            r.seek_cur(6);
            return this.token(TOKEN_ISNOTCS, "isnot#", pos);
        }
        else {
            r.seek_cur(5);
            return this.token(TOKEN_ISNOT, "isnot", pos);
        }
    }
    else if (isnamec1(c)) {
        var s = r.read_name();
        return this.token(TOKEN_IDENTIFIER, s, pos);
    }
    else if (c == "|" && r.p(1) == "|") {
        r.seek_cur(2);
        return this.token(TOKEN_OROR, "||", pos);
    }
    else if (c == "&" && r.p(1) == "&") {
        r.seek_cur(2);
        return this.token(TOKEN_ANDAND, "&&", pos);
    }
    else if (c == "=" && r.p(1) == "=") {
        if (r.p(2) == "?") {
            r.seek_cur(3);
            return this.token(TOKEN_EQEQCI, "==?", pos);
        }
        else if (r.p(2) == "#") {
            r.seek_cur(3);
            return this.token(TOKEN_EQEQCS, "==#", pos);
        }
        else {
            r.seek_cur(2);
            return this.token(TOKEN_EQEQ, "==", pos);
        }
    }
    else if (c == "!" && r.p(1) == "=") {
        if (r.p(2) == "?") {
            r.seek_cur(3);
            return this.token(TOKEN_NEQCI, "!=?", pos);
        }
        else if (r.p(2) == "#") {
            r.seek_cur(3);
            return this.token(TOKEN_NEQCS, "!=#", pos);
        }
        else {
            r.seek_cur(2);
            return this.token(TOKEN_NEQ, "!=", pos);
        }
    }
    else if (c == ">" && r.p(1) == "=") {
        if (r.p(2) == "?") {
            r.seek_cur(3);
            return this.token(TOKEN_GTEQCI, ">=?", pos);
        }
        else if (r.p(2) == "#") {
            r.seek_cur(3);
            return this.token(TOKEN_GTEQCS, ">=#", pos);
        }
        else {
            r.seek_cur(2);
            return this.token(TOKEN_GTEQ, ">=", pos);
        }
    }
    else if (c == "<" && r.p(1) == "=") {
        if (r.p(2) == "?") {
            r.seek_cur(3);
            return this.token(TOKEN_LTEQCI, "<=?", pos);
        }
        else if (r.p(2) == "#") {
            r.seek_cur(3);
            return this.token(TOKEN_LTEQCS, "<=#", pos);
        }
        else {
            r.seek_cur(2);
            return this.token(TOKEN_LTEQ, "<=", pos);
        }
    }
    else if (c == "=" && r.p(1) == "~") {
        if (r.p(2) == "?") {
            r.seek_cur(3);
            return this.token(TOKEN_MATCHCI, "=~?", pos);
        }
        else if (r.p(2) == "#") {
            r.seek_cur(3);
            return this.token(TOKEN_MATCHCS, "=~#", pos);
        }
        else {
            r.seek_cur(2);
            return this.token(TOKEN_MATCH, "=~", pos);
        }
    }
    else if (c == "!" && r.p(1) == "~") {
        if (r.p(2) == "?") {
            r.seek_cur(3);
            return this.token(TOKEN_NOMATCHCI, "!~?", pos);
        }
        else if (r.p(2) == "#") {
            r.seek_cur(3);
            return this.token(TOKEN_NOMATCHCS, "!~#", pos);
        }
        else {
            r.seek_cur(2);
            return this.token(TOKEN_NOMATCH, "!~", pos);
        }
    }
    else if (c == ">") {
        if (r.p(1) == "?") {
            r.seek_cur(2);
            return this.token(TOKEN_GTCI, ">?", pos);
        }
        else if (r.p(1) == "#") {
            r.seek_cur(2);
            return this.token(TOKEN_GTCS, ">#", pos);
        }
        else {
            r.seek_cur(1);
            return this.token(TOKEN_GT, ">", pos);
        }
    }
    else if (c == "<") {
        if (r.p(1) == "?") {
            r.seek_cur(2);
            return this.token(TOKEN_LTCI, "<?", pos);
        }
        else if (r.p(1) == "#") {
            r.seek_cur(2);
            return this.token(TOKEN_LTCS, "<#", pos);
        }
        else {
            r.seek_cur(1);
            return this.token(TOKEN_LT, "<", pos);
        }
    }
    else if (c == "+") {
        r.seek_cur(1);
        return this.token(TOKEN_PLUS, "+", pos);
    }
    else if (c == "-") {
        if (r.p(1) == ">") {
            r.seek_cur(2);
            return this.token(TOKEN_ARROW, "->", pos);
        }
        else {
            r.seek_cur(1);
            return this.token(TOKEN_MINUS, "-", pos);
        }
    }
    else if (c == ".") {
        if (r.p(1) == "." && r.p(2) == ".") {
            r.seek_cur(3);
            return this.token(TOKEN_DOTDOTDOT, "...", pos);
        }
        else if (r.p(1) == ".") {
            r.seek_cur(2);
            return this.token(TOKEN_DOTDOT, "..", pos);
            // TODO check scriptversion?
        }
        else {
            r.seek_cur(1);
            return this.token(TOKEN_DOT, ".", pos);
            // TODO check scriptversion?
        }
    }
    else if (c == "*") {
        r.seek_cur(1);
        return this.token(TOKEN_STAR, "*", pos);
    }
    else if (c == "/") {
        r.seek_cur(1);
        return this.token(TOKEN_SLASH, "/", pos);
    }
    else if (c == "%") {
        r.seek_cur(1);
        return this.token(TOKEN_PERCENT, "%", pos);
    }
    else if (c == "!") {
        r.seek_cur(1);
        return this.token(TOKEN_NOT, "!", pos);
    }
    else if (c == "?") {
        r.seek_cur(1);
        return this.token(TOKEN_QUESTION, "?", pos);
    }
    else if (c == ":") {
        r.seek_cur(1);
        return this.token(TOKEN_COLON, ":", pos);
    }
    else if (c == "#") {
        if (r.p(1) == "{") {
            r.seek_cur(2);
            return this.token(TOKEN_LITCOPEN, "#{", pos);
        }
        else {
            r.seek_cur(1);
            return this.token(TOKEN_SHARP, "#", pos);
        }
    }
    else if (c == "(") {
        r.seek_cur(1);
        return this.token(TOKEN_POPEN, "(", pos);
    }
    else if (c == ")") {
        r.seek_cur(1);
        return this.token(TOKEN_PCLOSE, ")", pos);
    }
    else if (c == "[") {
        r.seek_cur(1);
        return this.token(TOKEN_SQOPEN, "[", pos);
    }
    else if (c == "]") {
        r.seek_cur(1);
        return this.token(TOKEN_SQCLOSE, "]", pos);
    }
    else if (c == "{") {
        r.seek_cur(1);
        return this.token(TOKEN_COPEN, "{", pos);
    }
    else if (c == "}") {
        r.seek_cur(1);
        return this.token(TOKEN_CCLOSE, "}", pos);
    }
    else if (c == ",") {
        r.seek_cur(1);
        return this.token(TOKEN_COMMA, ",", pos);
    }
    else if (c == "'") {
        r.seek_cur(1);
        return this.token(TOKEN_SQUOTE, "'", pos);
    }
    else if (c == "\"") {
        r.seek_cur(1);
        return this.token(TOKEN_DQUOTE, "\"", pos);
    }
    else if (c == "$") {
        var s = r.getn(1);
        s += r.read_word();
        return this.token(TOKEN_ENV, s, pos);
    }
    else if (c == "@") {
        // @<EOL> is treated as @"
        return this.token(TOKEN_REG, r.getn(2), pos);
    }
    else if (c == "&") {
        var s = "";
        if ((r.p(1) == "g" || r.p(1) == "l") && r.p(2) == ":") {
            var s = r.getn(3) + r.read_word();
        }
        else {
            var s = r.getn(1) + r.read_word();
        }
        return this.token(TOKEN_OPTION, s, pos);
    }
    else if (c == "=") {
        r.seek_cur(1);
        return this.token(TOKEN_EQ, "=", pos);
    }
    else if (c == "|") {
        r.seek_cur(1);
        return this.token(TOKEN_OR, "|", pos);
    }
    else if (c == ";") {
        r.seek_cur(1);
        return this.token(TOKEN_SEMICOLON, ";", pos);
    }
    else if (c == "`") {
        r.seek_cur(1);
        return this.token(TOKEN_BACKTICK, "`", pos);
    }
    else {
        throw Err(viml_printf("unexpected character: %s", c), this.reader.getpos());
    }
}

ExprTokenizer.prototype.get_sstring = function() {
    this.reader.skip_white();
    var c = this.reader.p(0);
    if (c != "'") {
        throw Err(viml_printf("unexpected character: %s", c), this.reader.getpos());
    }
    this.reader.seek_cur(1);
    var s = "";
    while (TRUE) {
        var c = this.reader.p(0);
        if (c == "<EOF>" || c == "<EOL>") {
            throw Err("unexpected EOL", this.reader.getpos());
        }
        else if (c == "'") {
            this.reader.seek_cur(1);
            if (this.reader.p(0) == "'") {
                this.reader.seek_cur(1);
                s += "''";
            }
            else {
                break;
            }
        }
        else {
            this.reader.seek_cur(1);
            s += c;
        }
    }
    return s;
}

ExprTokenizer.prototype.get_dstring = function() {
    this.reader.skip_white();
    var c = this.reader.p(0);
    if (c != "\"") {
        throw Err(viml_printf("unexpected character: %s", c), this.reader.getpos());
    }
    this.reader.seek_cur(1);
    var s = "";
    while (TRUE) {
        var c = this.reader.p(0);
        if (c == "<EOF>" || c == "<EOL>") {
            throw Err("unexpectd EOL", this.reader.getpos());
        }
        else if (c == "\"") {
            this.reader.seek_cur(1);
            break;
        }
        else if (c == "\\") {
            this.reader.seek_cur(1);
            s += c;
            var c = this.reader.p(0);
            if (c == "<EOF>" || c == "<EOL>") {
                throw Err("ExprTokenizer: unexpected EOL", this.reader.getpos());
            }
            this.reader.seek_cur(1);
            s += c;
        }
        else {
            this.reader.seek_cur(1);
            s += c;
        }
    }
    return s;
}

ExprTokenizer.prototype.parse_dict_literal_key = function() {
    this.reader.skip_white();
    var c = this.reader.peek();
    if (!isalnum(c) && c != "_" && c != "-") {
        throw Err(viml_printf("unexpected character: %s", c), this.reader.getpos());
    }
    var node = Node(NODE_STRING);
    var s = c;
    this.reader.seek_cur(1);
    node.pos = this.reader.getpos();
    while (TRUE) {
        var c = this.reader.p(0);
        if (c == "<EOF>" || c == "<EOL>") {
            throw Err("unexpectd EOL", this.reader.getpos());
        }
        if (!isalnum(c) && c != "_" && c != "-") {
            break;
        }
        this.reader.seek_cur(1);
        s += c;
    }
    node.value = "'" + s + "'";
    return node;
}

function ExprParser() { this.__init__.apply(this, arguments); }
ExprParser.prototype.__init__ = function(reader) {
    this.reader = reader;
    this.tokenizer = new ExprTokenizer(reader);
}

ExprParser.prototype.parse = function() {
    return this.parse_expr1();
}

// expr1: expr2 ? expr1 : expr1
ExprParser.prototype.parse_expr1 = function() {
    var left = this.parse_expr2();
    var pos = this.reader.tell();
    var token = this.tokenizer.get();
    if (token.type == TOKEN_QUESTION) {
        var node = Node(NODE_TERNARY);
        node.pos = token.pos;
        node.cond = left;
        node.left = this.parse_expr1();
        var token = this.tokenizer.get();
        if (token.type != TOKEN_COLON) {
            throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
        }
        node.right = this.parse_expr1();
        var left = node;
    }
    else {
        this.reader.seek_set(pos);
    }
    return left;
}

// expr2: expr3 || expr3 ..
ExprParser.prototype.parse_expr2 = function() {
    var left = this.parse_expr3();
    while (TRUE) {
        var pos = this.reader.tell();
        var token = this.tokenizer.get();
        if (token.type == TOKEN_OROR) {
            var node = Node(NODE_OR);
            node.pos = token.pos;
            node.left = left;
            node.right = this.parse_expr3();
            var left = node;
        }
        else {
            this.reader.seek_set(pos);
            break;
        }
    }
    return left;
}

// expr3: expr4 && expr4
ExprParser.prototype.parse_expr3 = function() {
    var left = this.parse_expr4();
    while (TRUE) {
        var pos = this.reader.tell();
        var token = this.tokenizer.get();
        if (token.type == TOKEN_ANDAND) {
            var node = Node(NODE_AND);
            node.pos = token.pos;
            node.left = left;
            node.right = this.parse_expr4();
            var left = node;
        }
        else {
            this.reader.seek_set(pos);
            break;
        }
    }
    return left;
}

// expr4: expr5 == expr5
//        expr5 != expr5
//        expr5 >  expr5
//        expr5 >= expr5
//        expr5 <  expr5
//        expr5 <= expr5
//        expr5 =~ expr5
//        expr5 !~ expr5
//
//        expr5 ==? expr5
//        expr5 ==# expr5
//        etc.
//
//        expr5 is expr5
//        expr5 isnot expr5
ExprParser.prototype.parse_expr4 = function() {
    var left = this.parse_expr5();
    var pos = this.reader.tell();
    var token = this.tokenizer.get();
    if (token.type == TOKEN_EQEQ) {
        var node = Node(NODE_EQUAL);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_EQEQCI) {
        var node = Node(NODE_EQUALCI);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_EQEQCS) {
        var node = Node(NODE_EQUALCS);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_NEQ) {
        var node = Node(NODE_NEQUAL);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_NEQCI) {
        var node = Node(NODE_NEQUALCI);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_NEQCS) {
        var node = Node(NODE_NEQUALCS);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_GT) {
        var node = Node(NODE_GREATER);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_GTCI) {
        var node = Node(NODE_GREATERCI);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_GTCS) {
        var node = Node(NODE_GREATERCS);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_GTEQ) {
        var node = Node(NODE_GEQUAL);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_GTEQCI) {
        var node = Node(NODE_GEQUALCI);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_GTEQCS) {
        var node = Node(NODE_GEQUALCS);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_LT) {
        var node = Node(NODE_SMALLER);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_LTCI) {
        var node = Node(NODE_SMALLERCI);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_LTCS) {
        var node = Node(NODE_SMALLERCS);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_LTEQ) {
        var node = Node(NODE_SEQUAL);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_LTEQCI) {
        var node = Node(NODE_SEQUALCI);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_LTEQCS) {
        var node = Node(NODE_SEQUALCS);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_MATCH) {
        var node = Node(NODE_MATCH);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_MATCHCI) {
        var node = Node(NODE_MATCHCI);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_MATCHCS) {
        var node = Node(NODE_MATCHCS);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_NOMATCH) {
        var node = Node(NODE_NOMATCH);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_NOMATCHCI) {
        var node = Node(NODE_NOMATCHCI);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_NOMATCHCS) {
        var node = Node(NODE_NOMATCHCS);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_IS) {
        var node = Node(NODE_IS);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_ISCI) {
        var node = Node(NODE_ISCI);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_ISCS) {
        var node = Node(NODE_ISCS);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_ISNOT) {
        var node = Node(NODE_ISNOT);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_ISNOTCI) {
        var node = Node(NODE_ISNOTCI);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_ISNOTCS) {
        var node = Node(NODE_ISNOTCS);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else {
        this.reader.seek_set(pos);
    }
    return left;
}

// expr5: expr6 + expr6 ..
//        expr6 - expr6 ..
//        expr6 . expr6 ..
//        expr6 .. expr6 ..
ExprParser.prototype.parse_expr5 = function() {
    var left = this.parse_expr6();
    while (TRUE) {
        var pos = this.reader.tell();
        var token = this.tokenizer.get();
        if (token.type == TOKEN_PLUS) {
            var node = Node(NODE_ADD);
            node.pos = token.pos;
            node.left = left;
            node.right = this.parse_expr6();
            var left = node;
        }
        else if (token.type == TOKEN_MINUS) {
            var node = Node(NODE_SUBTRACT);
            node.pos = token.pos;
            node.left = left;
            node.right = this.parse_expr6();
            var left = node;
        }
        else if (token.type == TOKEN_DOTDOT) {
            // TODO check scriptversion?
            var node = Node(NODE_CONCAT);
            node.pos = token.pos;
            node.left = left;
            node.right = this.parse_expr6();
            var left = node;
        }
        else if (token.type == TOKEN_DOT) {
            // TODO check scriptversion?
            var node = Node(NODE_CONCAT);
            node.pos = token.pos;
            node.left = left;
            node.right = this.parse_expr6();
            var left = node;
        }
        else {
            this.reader.seek_set(pos);
            break;
        }
    }
    return left;
}

// expr6: expr7 * expr7 ..
//        expr7 / expr7 ..
//        expr7 % expr7 ..
ExprParser.prototype.parse_expr6 = function() {
    var left = this.parse_expr7();
    while (TRUE) {
        var pos = this.reader.tell();
        var token = this.tokenizer.get();
        if (token.type == TOKEN_STAR) {
            var node = Node(NODE_MULTIPLY);
            node.pos = token.pos;
            node.left = left;
            node.right = this.parse_expr7();
            var left = node;
        }
        else if (token.type == TOKEN_SLASH) {
            var node = Node(NODE_DIVIDE);
            node.pos = token.pos;
            node.left = left;
            node.right = this.parse_expr7();
            var left = node;
        }
        else if (token.type == TOKEN_PERCENT) {
            var node = Node(NODE_REMAINDER);
            node.pos = token.pos;
            node.left = left;
            node.right = this.parse_expr7();
            var left = node;
        }
        else {
            this.reader.seek_set(pos);
            break;
        }
    }
    return left;
}

// expr7: ! expr7
//        - expr7
//        + expr7
ExprParser.prototype.parse_expr7 = function() {
    var pos = this.reader.tell();
    var token = this.tokenizer.get();
    if (token.type == TOKEN_NOT) {
        var node = Node(NODE_NOT);
        node.pos = token.pos;
        node.left = this.parse_expr7();
        return node;
    }
    else if (token.type == TOKEN_MINUS) {
        var node = Node(NODE_MINUS);
        node.pos = token.pos;
        node.left = this.parse_expr7();
        return node;
    }
    else if (token.type == TOKEN_PLUS) {
        var node = Node(NODE_PLUS);
        node.pos = token.pos;
        node.left = this.parse_expr7();
        return node;
    }
    else {
        this.reader.seek_set(pos);
        var node = this.parse_expr8();
        return node;
    }
}

// expr8: expr8[expr1]
//        expr8[expr1 : expr1]
//        expr8.name
//        expr8->name(expr1, ...)
//        expr8->s:user_func(expr1, ...)
//        expr8->{lambda}(expr1, ...)
//        expr8(expr1, ...)
ExprParser.prototype.parse_expr8 = function() {
    var left = this.parse_expr9();
    while (TRUE) {
        var pos = this.reader.tell();
        var c = this.reader.peek();
        var token = this.tokenizer.get();
        if (!iswhite(c) && token.type == TOKEN_SQOPEN) {
            var npos = token.pos;
            if (this.tokenizer.peek().type == TOKEN_COLON) {
                this.tokenizer.get();
                var node = Node(NODE_SLICE);
                node.pos = npos;
                node.left = left;
                node.rlist = [NIL, NIL];
                var token = this.tokenizer.peek();
                if (token.type != TOKEN_SQCLOSE) {
                    node.rlist[1] = this.parse_expr1();
                }
                var token = this.tokenizer.get();
                if (token.type != TOKEN_SQCLOSE) {
                    throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
                }
                var left = node;
            }
            else {
                var right = this.parse_expr1();
                if (this.tokenizer.peek().type == TOKEN_COLON) {
                    this.tokenizer.get();
                    var node = Node(NODE_SLICE);
                    node.pos = npos;
                    node.left = left;
                    node.rlist = [right, NIL];
                    var token = this.tokenizer.peek();
                    if (token.type != TOKEN_SQCLOSE) {
                        node.rlist[1] = this.parse_expr1();
                    }
                    var token = this.tokenizer.get();
                    if (token.type != TOKEN_SQCLOSE) {
                        throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
                    }
                    var left = node;
                }
                else {
                    var node = Node(NODE_SUBSCRIPT);
                    node.pos = npos;
                    node.left = left;
                    node.right = right;
                    var token = this.tokenizer.get();
                    if (token.type != TOKEN_SQCLOSE) {
                        throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
                    }
                    var left = node;
                }
            }
            delete node;
        }
        else if (token.type == TOKEN_ARROW) {
            var funcname_or_lambda = this.parse_expr9();
            var token = this.tokenizer.get();
            if (token.type != TOKEN_POPEN) {
                throw Err("E107: Missing parentheses: lambda", token.pos);
            }
            var right = Node(NODE_CALL);
            right.pos = token.pos;
            right.left = funcname_or_lambda;
            right.rlist = this.parse_rlist();
            var node = Node(NODE_METHOD);
            node.pos = token.pos;
            node.left = left;
            node.right = right;
            var left = node;
            delete node;
        }
        else if (token.type == TOKEN_POPEN) {
            var node = Node(NODE_CALL);
            node.pos = token.pos;
            node.left = left;
            node.rlist = this.parse_rlist();
            var left = node;
            delete node;
        }
        else if (!iswhite(c) && token.type == TOKEN_DOT) {
            // TODO check scriptversion?
            var node = this.parse_dot(token, left);
            if (node === NIL) {
                this.reader.seek_set(pos);
                break;
            }
            var left = node;
            delete node;
        }
        else {
            this.reader.seek_set(pos);
            break;
        }
    }
    return left;
}

ExprParser.prototype.parse_rlist = function() {
    var rlist = [];
    var token = this.tokenizer.peek();
    if (this.tokenizer.peek().type == TOKEN_PCLOSE) {
        this.tokenizer.get();
    }
    else {
        while (TRUE) {
            viml_add(rlist, this.parse_expr1());
            var token = this.tokenizer.get();
            if (token.type == TOKEN_COMMA) {
                // XXX: Vim allows foo(a, b, ).  Lint should warn it.
                if (this.tokenizer.peek().type == TOKEN_PCLOSE) {
                    this.tokenizer.get();
                    break;
                }
            }
            else if (token.type == TOKEN_PCLOSE) {
                break;
            }
            else {
                throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
            }
        }
    }
    if (viml_len(rlist) > MAX_FUNC_ARGS) {
        // TODO: funcname E740: Too many arguments for function: %s
        throw Err("E740: Too many arguments for function", token.pos);
    }
    return rlist;
}

// expr9: number
//        "string"
//        'string'
//        [expr1, ...]
//        {expr1: expr1, ...}
//        #{literal_key1: expr1, ...}
//        {args -> expr1}
//        &option
//        (expr1)
//        variable
//        var{ria}ble
//        $VAR
//        @r
//        function(expr1, ...)
//        func{ti}on(expr1, ...)
ExprParser.prototype.parse_expr9 = function() {
    var pos = this.reader.tell();
    var token = this.tokenizer.get();
    var node = Node(-1);
    if (token.type == TOKEN_NUMBER) {
        var node = Node(NODE_NUMBER);
        node.pos = token.pos;
        node.value = token.value;
    }
    else if (token.type == TOKEN_BLOB) {
        var node = Node(NODE_BLOB);
        node.pos = token.pos;
        node.value = token.value;
    }
    else if (token.type == TOKEN_DQUOTE) {
        this.reader.seek_set(pos);
        var node = Node(NODE_STRING);
        node.pos = token.pos;
        node.value = "\"" + this.tokenizer.get_dstring() + "\"";
    }
    else if (token.type == TOKEN_SQUOTE) {
        this.reader.seek_set(pos);
        var node = Node(NODE_STRING);
        node.pos = token.pos;
        node.value = "'" + this.tokenizer.get_sstring() + "'";
    }
    else if (token.type == TOKEN_SQOPEN) {
        var node = Node(NODE_LIST);
        node.pos = token.pos;
        node.value = [];
        var token = this.tokenizer.peek();
        if (token.type == TOKEN_SQCLOSE) {
            this.tokenizer.get();
        }
        else {
            while (TRUE) {
                viml_add(node.value, this.parse_expr1());
                var token = this.tokenizer.peek();
                if (token.type == TOKEN_COMMA) {
                    this.tokenizer.get();
                    if (this.tokenizer.peek().type == TOKEN_SQCLOSE) {
                        this.tokenizer.get();
                        break;
                    }
                }
                else if (token.type == TOKEN_SQCLOSE) {
                    this.tokenizer.get();
                    break;
                }
                else {
                    throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
                }
            }
        }
    }
    else if (token.type == TOKEN_COPEN || token.type == TOKEN_LITCOPEN) {
        var is_litdict = token.type == TOKEN_LITCOPEN;
        var savepos = this.reader.tell();
        var nodepos = token.pos;
        var token = this.tokenizer.get();
        var lambda = token.type == TOKEN_ARROW;
        if (!lambda && !(token.type == TOKEN_SQUOTE || token.type == TOKEN_DQUOTE)) {
            // if the token type is stirng, we cannot peek next token and we can
            // assume it's not lambda.
            var token2 = this.tokenizer.peek();
            var lambda = token2.type == TOKEN_ARROW || token2.type == TOKEN_COMMA;
        }
        // fallback to dict or {expr} if true
        var fallback = FALSE;
        if (lambda) {
            // lambda {token,...} {->...} {token->...}
            var node = Node(NODE_LAMBDA);
            node.pos = nodepos;
            node.rlist = [];
            var named = {};
            while (TRUE) {
                if (token.type == TOKEN_ARROW) {
                    break;
                }
                else if (token.type == TOKEN_IDENTIFIER) {
                    if (!isargname(token.value)) {
                        throw Err(viml_printf("E125: Illegal argument: %s", token.value), token.pos);
                    }
                    else if (viml_has_key(named, token.value)) {
                        throw Err(viml_printf("E853: Duplicate argument name: %s", token.value), token.pos);
                    }
                    named[token.value] = 1;
                    var varnode = Node(NODE_IDENTIFIER);
                    varnode.pos = token.pos;
                    varnode.value = token.value;
                    // XXX: Vim doesn't skip white space before comma.  {a ,b -> ...} => E475
                    if (iswhite(this.reader.p(0)) && this.tokenizer.peek().type == TOKEN_COMMA) {
                        throw Err("E475: Invalid argument: White space is not allowed before comma", this.reader.getpos());
                    }
                    var token = this.tokenizer.get();
                    viml_add(node.rlist, varnode);
                    if (token.type == TOKEN_COMMA) {
                        // XXX: Vim allows last comma.  {a, b, -> ...} => OK
                        var token = this.tokenizer.peek();
                        if (token.type == TOKEN_ARROW) {
                            this.tokenizer.get();
                            break;
                        }
                    }
                    else if (token.type == TOKEN_ARROW) {
                        break;
                    }
                    else {
                        throw Err(viml_printf("unexpected token: %s, type: %d", token.value, token.type), token.pos);
                    }
                }
                else if (token.type == TOKEN_DOTDOTDOT) {
                    var varnode = Node(NODE_IDENTIFIER);
                    varnode.pos = token.pos;
                    varnode.value = token.value;
                    viml_add(node.rlist, varnode);
                    var token = this.tokenizer.peek();
                    if (token.type == TOKEN_ARROW) {
                        this.tokenizer.get();
                        break;
                    }
                    else {
                        throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
                    }
                }
                else {
                    var fallback = TRUE;
                    break;
                }
                var token = this.tokenizer.get();
            }
            if (!fallback) {
                node.left = this.parse_expr1();
                var token = this.tokenizer.get();
                if (token.type != TOKEN_CCLOSE) {
                    throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
                }
                return node;
            }
        }
        // dict
        var node = Node(NODE_DICT);
        node.pos = nodepos;
        node.value = [];
        this.reader.seek_set(savepos);
        var token = this.tokenizer.peek();
        if (token.type == TOKEN_CCLOSE) {
            this.tokenizer.get();
            return node;
        }
        while (1) {
            var key = is_litdict ? this.tokenizer.parse_dict_literal_key() : this.parse_expr1();
            var token = this.tokenizer.get();
            if (token.type == TOKEN_CCLOSE) {
                if (!viml_empty(node.value)) {
                    throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
                }
                this.reader.seek_set(pos);
                var node = this.parse_identifier();
                break;
            }
            if (token.type != TOKEN_COLON) {
                throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
            }
            var val = this.parse_expr1();
            viml_add(node.value, [key, val]);
            var token = this.tokenizer.get();
            if (token.type == TOKEN_COMMA) {
                if (this.tokenizer.peek().type == TOKEN_CCLOSE) {
                    this.tokenizer.get();
                    break;
                }
            }
            else if (token.type == TOKEN_CCLOSE) {
                break;
            }
            else {
                throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
            }
        }
        return node;
    }
    else if (token.type == TOKEN_POPEN) {
        var node = this.parse_expr1();
        var token = this.tokenizer.get();
        if (token.type != TOKEN_PCLOSE) {
            throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
        }
    }
    else if (token.type == TOKEN_OPTION) {
        var node = Node(NODE_OPTION);
        node.pos = token.pos;
        node.value = token.value;
    }
    else if (token.type == TOKEN_IDENTIFIER) {
        this.reader.seek_set(pos);
        var node = this.parse_identifier();
    }
    else if (FALSE && (token.type == TOKEN_COLON || token.type == TOKEN_SHARP)) {
        // XXX: no parse error but invalid expression
        this.reader.seek_set(pos);
        var node = this.parse_identifier();
    }
    else if (token.type == TOKEN_LT && viml_equalci(this.reader.peekn(4), "SID>")) {
        this.reader.seek_set(pos);
        var node = this.parse_identifier();
    }
    else if (token.type == TOKEN_IS || token.type == TOKEN_ISCS || token.type == TOKEN_ISNOT || token.type == TOKEN_ISNOTCS) {
        this.reader.seek_set(pos);
        var node = this.parse_identifier();
    }
    else if (token.type == TOKEN_ENV) {
        var node = Node(NODE_ENV);
        node.pos = token.pos;
        node.value = token.value;
    }
    else if (token.type == TOKEN_REG) {
        var node = Node(NODE_REG);
        node.pos = token.pos;
        node.value = token.value;
    }
    else {
        throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
    }
    return node;
}

// SUBSCRIPT or CONCAT
//   dict "." [0-9A-Za-z_]+ => (subscript dict key)
//   str  "." expr6         => (concat str expr6)
ExprParser.prototype.parse_dot = function(token, left) {
    if (left.type != NODE_IDENTIFIER && left.type != NODE_CURLYNAME && left.type != NODE_DICT && left.type != NODE_SUBSCRIPT && left.type != NODE_CALL && left.type != NODE_DOT) {
        return NIL;
    }
    if (!iswordc(this.reader.p(0))) {
        return NIL;
    }
    var pos = this.reader.getpos();
    var name = this.reader.read_word();
    if (isnamec(this.reader.p(0))) {
        // XXX: foo is str => ok, foo is obj => invalid expression
        // foo.s:bar or foo.bar#baz
        return NIL;
    }
    var node = Node(NODE_DOT);
    node.pos = token.pos;
    node.left = left;
    node.right = Node(NODE_IDENTIFIER);
    node.right.pos = pos;
    node.right.value = name;
    return node;
}

// CONCAT
//   str  ".." expr6         => (concat str expr6)
ExprParser.prototype.parse_concat = function(token, left) {
    if (left.type != NODE_IDENTIFIER && left.type != NODE_CURLYNAME && left.type != NODE_DICT && left.type != NODE_SUBSCRIPT && left.type != NODE_CALL && left.type != NODE_DOT) {
        return NIL;
    }
    if (!iswordc(this.reader.p(0))) {
        return NIL;
    }
    var pos = this.reader.getpos();
    var name = this.reader.read_word();
    if (isnamec(this.reader.p(0))) {
        // XXX: foo is str => ok, foo is obj => invalid expression
        // foo.s:bar or foo.bar#baz
        return NIL;
    }
    var node = Node(NODE_CONCAT);
    node.pos = token.pos;
    node.left = left;
    node.right = Node(NODE_IDENTIFIER);
    node.right.pos = pos;
    node.right.value = name;
    return node;
}

ExprParser.prototype.parse_identifier = function() {
    this.reader.skip_white();
    var npos = this.reader.getpos();
    var curly_parts = this.parse_curly_parts();
    if (viml_len(curly_parts) == 1 && curly_parts[0].type == NODE_CURLYNAMEPART) {
        var node = Node(NODE_IDENTIFIER);
        node.pos = npos;
        node.value = curly_parts[0].value;
        return node;
    }
    else {
        var node = Node(NODE_CURLYNAME);
        node.pos = npos;
        node.value = curly_parts;
        return node;
    }
}

ExprParser.prototype.parse_curly_parts = function() {
    var curly_parts = [];
    var c = this.reader.peek();
    var pos = this.reader.getpos();
    if (c == "<" && viml_equalci(this.reader.peekn(5), "<SID>")) {
        var name = this.reader.getn(5);
        var node = Node(NODE_CURLYNAMEPART);
        node.curly = FALSE;
        // Keep backword compatibility for the curly attribute
        node.pos = pos;
        node.value = name;
        viml_add(curly_parts, node);
    }
    while (TRUE) {
        var c = this.reader.peek();
        if (isnamec(c)) {
            var pos = this.reader.getpos();
            var name = this.reader.read_name();
            var node = Node(NODE_CURLYNAMEPART);
            node.curly = FALSE;
            // Keep backword compatibility for the curly attribute
            node.pos = pos;
            node.value = name;
            viml_add(curly_parts, node);
        }
        else if (c == "{") {
            this.reader.get();
            var pos = this.reader.getpos();
            var node = Node(NODE_CURLYNAMEEXPR);
            node.curly = TRUE;
            // Keep backword compatibility for the curly attribute
            node.pos = pos;
            node.value = this.parse_expr1();
            viml_add(curly_parts, node);
            this.reader.skip_white();
            var c = this.reader.p(0);
            if (c != "}") {
                throw Err(viml_printf("unexpected token: %s", c), this.reader.getpos());
            }
            this.reader.seek_cur(1);
        }
        else {
            break;
        }
    }
    return curly_parts;
}

function LvalueParser() { ExprParser.apply(this, arguments); this.__init__.apply(this, arguments); }
LvalueParser.prototype = Object.create(ExprParser.prototype);
LvalueParser.prototype.parse = function() {
    return this.parse_lv8();
}

// expr8: expr8[expr1]
//        expr8[expr1 : expr1]
//        expr8.name
LvalueParser.prototype.parse_lv8 = function() {
    var left = this.parse_lv9();
    while (TRUE) {
        var pos = this.reader.tell();
        var c = this.reader.peek();
        var token = this.tokenizer.get();
        if (!iswhite(c) && token.type == TOKEN_SQOPEN) {
            var npos = token.pos;
            var node = Node(-1);
            if (this.tokenizer.peek().type == TOKEN_COLON) {
                this.tokenizer.get();
                var node = Node(NODE_SLICE);
                node.pos = npos;
                node.left = left;
                node.rlist = [NIL, NIL];
                var token = this.tokenizer.peek();
                if (token.type != TOKEN_SQCLOSE) {
                    node.rlist[1] = this.parse_expr1();
                }
                var token = this.tokenizer.get();
                if (token.type != TOKEN_SQCLOSE) {
                    throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
                }
            }
            else {
                var right = this.parse_expr1();
                if (this.tokenizer.peek().type == TOKEN_COLON) {
                    this.tokenizer.get();
                    var node = Node(NODE_SLICE);
                    node.pos = npos;
                    node.left = left;
                    node.rlist = [right, NIL];
                    var token = this.tokenizer.peek();
                    if (token.type != TOKEN_SQCLOSE) {
                        node.rlist[1] = this.parse_expr1();
                    }
                    var token = this.tokenizer.get();
                    if (token.type != TOKEN_SQCLOSE) {
                        throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
                    }
                }
                else {
                    var node = Node(NODE_SUBSCRIPT);
                    node.pos = npos;
                    node.left = left;
                    node.right = right;
                    var token = this.tokenizer.get();
                    if (token.type != TOKEN_SQCLOSE) {
                        throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
                    }
                }
            }
            var left = node;
            delete node;
        }
        else if (!iswhite(c) && token.type == TOKEN_DOT) {
            var node = this.parse_dot(token, left);
            if (node === NIL) {
                this.reader.seek_set(pos);
                break;
            }
            var left = node;
            delete node;
        }
        else {
            this.reader.seek_set(pos);
            break;
        }
    }
    return left;
}

// expr9: &option
//        variable
//        var{ria}ble
//        $VAR
//        @r
LvalueParser.prototype.parse_lv9 = function() {
    var pos = this.reader.tell();
    var token = this.tokenizer.get();
    var node = Node(-1);
    if (token.type == TOKEN_COPEN) {
        this.reader.seek_set(pos);
        var node = this.parse_identifier();
    }
    else if (token.type == TOKEN_OPTION) {
        var node = Node(NODE_OPTION);
        node.pos = token.pos;
        node.value = token.value;
    }
    else if (token.type == TOKEN_IDENTIFIER) {
        this.reader.seek_set(pos);
        var node = this.parse_identifier();
    }
    else if (token.type == TOKEN_LT && viml_equalci(this.reader.peekn(4), "SID>")) {
        this.reader.seek_set(pos);
        var node = this.parse_identifier();
    }
    else if (token.type == TOKEN_ENV) {
        var node = Node(NODE_ENV);
        node.pos = token.pos;
        node.value = token.value;
    }
    else if (token.type == TOKEN_REG) {
        var node = Node(NODE_REG);
        node.pos = token.pos;
        node.pos = token.pos;
        node.value = token.value;
    }
    else {
        throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
    }
    return node;
}

function StringReader() { this.__init__.apply(this, arguments); }
StringReader.prototype.__init__ = function(lines) {
    this.buf = [];
    this.pos = [];
    var lnum = 0;
    var offset = 0;
    while (lnum < viml_len(lines)) {
        var col = 0;
        var __c7 = viml_split(lines[lnum], "\\zs");
        for (var __i7 = 0; __i7 < __c7.length; ++__i7) {
            var c = __c7[__i7];
            viml_add(this.buf, c);
            viml_add(this.pos, [lnum + 1, col + 1, offset]);
            col += viml_len(c);
            offset += viml_len(c);
        }
        while (lnum + 1 < viml_len(lines) && viml_eqregh(lines[lnum + 1], "^\\s*\\\\")) {
            var skip = TRUE;
            var col = 0;
            var __c8 = viml_split(lines[lnum + 1], "\\zs");
            for (var __i8 = 0; __i8 < __c8.length; ++__i8) {
                var c = __c8[__i8];
                if (skip) {
                    if (c == "\\") {
                        var skip = FALSE;
                    }
                }
                else {
                    viml_add(this.buf, c);
                    viml_add(this.pos, [lnum + 2, col + 1, offset]);
                }
                col += viml_len(c);
                offset += viml_len(c);
            }
            lnum += 1;
            offset += 1;
        }
        viml_add(this.buf, "<EOL>");
        viml_add(this.pos, [lnum + 1, col + 1, offset]);
        lnum += 1;
        offset += 1;
    }
    // for <EOF>
    viml_add(this.pos, [lnum + 1, 0, offset]);
    this.i = 0;
}

StringReader.prototype.eof = function() {
    return this.i >= viml_len(this.buf);
}

StringReader.prototype.tell = function() {
    return this.i;
}

StringReader.prototype.seek_set = function(i) {
    this.i = i;
}

StringReader.prototype.seek_cur = function(i) {
    this.i = this.i + i;
}

StringReader.prototype.seek_end = function(i) {
    this.i = viml_len(this.buf) + i;
}

StringReader.prototype.p = function(i) {
    if (this.i >= viml_len(this.buf)) {
        return "<EOF>";
    }
    return this.buf[this.i + i];
}

StringReader.prototype.peek = function() {
    if (this.i >= viml_len(this.buf)) {
        return "<EOF>";
    }
    return this.buf[this.i];
}

StringReader.prototype.get = function() {
    if (this.i >= viml_len(this.buf)) {
        return "<EOF>";
    }
    this.i += 1;
    return this.buf[this.i - 1];
}

StringReader.prototype.peekn = function(n) {
    var pos = this.tell();
    var r = this.getn(n);
    this.seek_set(pos);
    return r;
}

StringReader.prototype.getn = function(n) {
    var r = "";
    var j = 0;
    while (this.i < viml_len(this.buf) && (n < 0 || j < n)) {
        var c = this.buf[this.i];
        if (c == "<EOL>") {
            break;
        }
        r += c;
        this.i += 1;
        j += 1;
    }
    return r;
}

StringReader.prototype.peekline = function() {
    return this.peekn(-1);
}

StringReader.prototype.readline = function() {
    var r = this.getn(-1);
    this.get();
    return r;
}

StringReader.prototype.getstr = function(begin, end) {
    var r = "";
    var __c9 = viml_range(begin.i, end.i - 1);
    for (var __i9 = 0; __i9 < __c9.length; ++__i9) {
        var i = __c9[__i9];
        if (i >= viml_len(this.buf)) {
            break;
        }
        var c = this.buf[i];
        if (c == "<EOL>") {
            var c = "\n";
        }
        r += c;
    }
    return r;
}

StringReader.prototype.getpos = function() {
    var __tmp = this.pos[this.i];
    var lnum = __tmp[0];
    var col = __tmp[1];
    var offset = __tmp[2];
    return {"i":this.i, "lnum":lnum, "col":col, "offset":offset};
}

StringReader.prototype.setpos = function(pos) {
    this.i = pos.i;
}

StringReader.prototype.read_alpha = function() {
    var r = "";
    while (isalpha(this.peekn(1))) {
        r += this.getn(1);
    }
    return r;
}

StringReader.prototype.read_alnum = function() {
    var r = "";
    while (isalnum(this.peekn(1))) {
        r += this.getn(1);
    }
    return r;
}

StringReader.prototype.read_digit = function() {
    var r = "";
    while (isdigit(this.peekn(1))) {
        r += this.getn(1);
    }
    return r;
}

StringReader.prototype.read_odigit = function() {
    var r = "";
    while (isodigit(this.peekn(1))) {
        r += this.getn(1);
    }
    return r;
}

StringReader.prototype.read_blob = function() {
    var r = "";
    while (1) {
        var s = this.peekn(2);
        if (viml_eqregh(s, "^[0-9A-Fa-f][0-9A-Fa-f]$")) {
            r += this.getn(2);
        }
        else if (viml_eqregh(s, "^\\.[0-9A-Fa-f]$")) {
            r += this.getn(1);
        }
        else if (viml_eqregh(s, "^[0-9A-Fa-f][^0-9A-Fa-f]$")) {
            throw Err("E973: Blob literal should have an even number of hex characters:" + s, this.getpos());
        }
        else {
            break;
        }
    }
    return r;
}

StringReader.prototype.read_xdigit = function() {
    var r = "";
    while (isxdigit(this.peekn(1))) {
        r += this.getn(1);
    }
    return r;
}

StringReader.prototype.read_bdigit = function() {
    var r = "";
    while (this.peekn(1) == "0" || this.peekn(1) == "1") {
        r += this.getn(1);
    }
    return r;
}

StringReader.prototype.read_integer = function() {
    var r = "";
    var c = this.peekn(1);
    if (c == "-" || c == "+") {
        var r = this.getn(1);
    }
    return r + this.read_digit();
}

StringReader.prototype.read_word = function() {
    var r = "";
    while (iswordc(this.peekn(1))) {
        r += this.getn(1);
    }
    return r;
}

StringReader.prototype.read_white = function() {
    var r = "";
    while (iswhite(this.peekn(1))) {
        r += this.getn(1);
    }
    return r;
}

StringReader.prototype.read_nonwhite = function() {
    var r = "";
    var ch = this.peekn(1);
    while (!iswhite(ch) && ch != "") {
        r += this.getn(1);
        var ch = this.peekn(1);
    }
    return r;
}

StringReader.prototype.read_name = function() {
    var r = "";
    while (isnamec(this.peekn(1))) {
        r += this.getn(1);
    }
    return r;
}

StringReader.prototype.skip_white = function() {
    while (iswhite(this.peekn(1))) {
        this.seek_cur(1);
    }
}

StringReader.prototype.skip_white_and_colon = function() {
    while (TRUE) {
        var c = this.peekn(1);
        if (!iswhite(c) && c != ":") {
            break;
        }
        this.seek_cur(1);
    }
}

function Compiler() { this.__init__.apply(this, arguments); }
Compiler.prototype.__init__ = function() {
    this.indent = [""];
    this.lines = [];
}

Compiler.prototype.out = function() {
    var a000 = Array.prototype.slice.call(arguments, 0);
    if (viml_len(a000) == 1) {
        if (a000[0][0] == ")") {
            this.lines[this.lines.length - 1] += a000[0];
        }
        else {
            viml_add(this.lines, this.indent[0] + a000[0]);
        }
    }
    else {
        viml_add(this.lines, this.indent[0] + viml_printf.apply(null, a000));
    }
}

Compiler.prototype.incindent = function(s) {
    viml_insert(this.indent, this.indent[0] + s);
}

Compiler.prototype.decindent = function() {
    viml_remove(this.indent, 0);
}

Compiler.prototype.compile = function(node) {
    if (node.type == NODE_TOPLEVEL) {
        return this.compile_toplevel(node);
    }
    else if (node.type == NODE_COMMENT) {
        this.compile_comment(node);
        return NIL;
    }
    else if (node.type == NODE_EXCMD) {
        this.compile_excmd(node);
        return NIL;
    }
    else if (node.type == NODE_FUNCTION) {
        this.compile_function(node);
        return NIL;
    }
    else if (node.type == NODE_DELFUNCTION) {
        this.compile_delfunction(node);
        return NIL;
    }
    else if (node.type == NODE_RETURN) {
        this.compile_return(node);
        return NIL;
    }
    else if (node.type == NODE_EXCALL) {
        this.compile_excall(node);
        return NIL;
    }
    else if (node.type == NODE_EVAL) {
        this.compile_eval(node);
        return NIL;
    }
    else if (node.type == NODE_LET) {
        this.compile_let(node);
        return NIL;
    }
    else if (node.type == NODE_CONST) {
        this.compile_const(node);
        return NIL;
    }
    else if (node.type == NODE_UNLET) {
        this.compile_unlet(node);
        return NIL;
    }
    else if (node.type == NODE_LOCKVAR) {
        this.compile_lockvar(node);
        return NIL;
    }
    else if (node.type == NODE_UNLOCKVAR) {
        this.compile_unlockvar(node);
        return NIL;
    }
    else if (node.type == NODE_IF) {
        this.compile_if(node);
        return NIL;
    }
    else if (node.type == NODE_WHILE) {
        this.compile_while(node);
        return NIL;
    }
    else if (node.type == NODE_FOR) {
        this.compile_for(node);
        return NIL;
    }
    else if (node.type == NODE_CONTINUE) {
        this.compile_continue(node);
        return NIL;
    }
    else if (node.type == NODE_BREAK) {
        this.compile_break(node);
        return NIL;
    }
    else if (node.type == NODE_TRY) {
        this.compile_try(node);
        return NIL;
    }
    else if (node.type == NODE_THROW) {
        this.compile_throw(node);
        return NIL;
    }
    else if (node.type == NODE_ECHO) {
        this.compile_echo(node);
        return NIL;
    }
    else if (node.type == NODE_ECHON) {
        this.compile_echon(node);
        return NIL;
    }
    else if (node.type == NODE_ECHOHL) {
        this.compile_echohl(node);
        return NIL;
    }
    else if (node.type == NODE_ECHOMSG) {
        this.compile_echomsg(node);
        return NIL;
    }
    else if (node.type == NODE_ECHOERR) {
        this.compile_echoerr(node);
        return NIL;
    }
    else if (node.type == NODE_ECHOCONSOLE) {
        this.compile_echoconsole(node);
        return NIL;
    }
    else if (node.type == NODE_EXECUTE) {
        this.compile_execute(node);
        return NIL;
    }
    else if (node.type == NODE_TERNARY) {
        return this.compile_ternary(node);
    }
    else if (node.type == NODE_OR) {
        return this.compile_or(node);
    }
    else if (node.type == NODE_AND) {
        return this.compile_and(node);
    }
    else if (node.type == NODE_EQUAL) {
        return this.compile_equal(node);
    }
    else if (node.type == NODE_EQUALCI) {
        return this.compile_equalci(node);
    }
    else if (node.type == NODE_EQUALCS) {
        return this.compile_equalcs(node);
    }
    else if (node.type == NODE_NEQUAL) {
        return this.compile_nequal(node);
    }
    else if (node.type == NODE_NEQUALCI) {
        return this.compile_nequalci(node);
    }
    else if (node.type == NODE_NEQUALCS) {
        return this.compile_nequalcs(node);
    }
    else if (node.type == NODE_GREATER) {
        return this.compile_greater(node);
    }
    else if (node.type == NODE_GREATERCI) {
        return this.compile_greaterci(node);
    }
    else if (node.type == NODE_GREATERCS) {
        return this.compile_greatercs(node);
    }
    else if (node.type == NODE_GEQUAL) {
        return this.compile_gequal(node);
    }
    else if (node.type == NODE_GEQUALCI) {
        return this.compile_gequalci(node);
    }
    else if (node.type == NODE_GEQUALCS) {
        return this.compile_gequalcs(node);
    }
    else if (node.type == NODE_SMALLER) {
        return this.compile_smaller(node);
    }
    else if (node.type == NODE_SMALLERCI) {
        return this.compile_smallerci(node);
    }
    else if (node.type == NODE_SMALLERCS) {
        return this.compile_smallercs(node);
    }
    else if (node.type == NODE_SEQUAL) {
        return this.compile_sequal(node);
    }
    else if (node.type == NODE_SEQUALCI) {
        return this.compile_sequalci(node);
    }
    else if (node.type == NODE_SEQUALCS) {
        return this.compile_sequalcs(node);
    }
    else if (node.type == NODE_MATCH) {
        return this.compile_match(node);
    }
    else if (node.type == NODE_MATCHCI) {
        return this.compile_matchci(node);
    }
    else if (node.type == NODE_MATCHCS) {
        return this.compile_matchcs(node);
    }
    else if (node.type == NODE_NOMATCH) {
        return this.compile_nomatch(node);
    }
    else if (node.type == NODE_NOMATCHCI) {
        return this.compile_nomatchci(node);
    }
    else if (node.type == NODE_NOMATCHCS) {
        return this.compile_nomatchcs(node);
    }
    else if (node.type == NODE_IS) {
        return this.compile_is(node);
    }
    else if (node.type == NODE_ISCI) {
        return this.compile_isci(node);
    }
    else if (node.type == NODE_ISCS) {
        return this.compile_iscs(node);
    }
    else if (node.type == NODE_ISNOT) {
        return this.compile_isnot(node);
    }
    else if (node.type == NODE_ISNOTCI) {
        return this.compile_isnotci(node);
    }
    else if (node.type == NODE_ISNOTCS) {
        return this.compile_isnotcs(node);
    }
    else if (node.type == NODE_ADD) {
        return this.compile_add(node);
    }
    else if (node.type == NODE_SUBTRACT) {
        return this.compile_subtract(node);
    }
    else if (node.type == NODE_CONCAT) {
        return this.compile_concat(node);
    }
    else if (node.type == NODE_MULTIPLY) {
        return this.compile_multiply(node);
    }
    else if (node.type == NODE_DIVIDE) {
        return this.compile_divide(node);
    }
    else if (node.type == NODE_REMAINDER) {
        return this.compile_remainder(node);
    }
    else if (node.type == NODE_NOT) {
        return this.compile_not(node);
    }
    else if (node.type == NODE_PLUS) {
        return this.compile_plus(node);
    }
    else if (node.type == NODE_MINUS) {
        return this.compile_minus(node);
    }
    else if (node.type == NODE_SUBSCRIPT) {
        return this.compile_subscript(node);
    }
    else if (node.type == NODE_SLICE) {
        return this.compile_slice(node);
    }
    else if (node.type == NODE_DOT) {
        return this.compile_dot(node);
    }
    else if (node.type == NODE_METHOD) {
        return this.compile_method(node);
    }
    else if (node.type == NODE_CALL) {
        return this.compile_call(node);
    }
    else if (node.type == NODE_NUMBER) {
        return this.compile_number(node);
    }
    else if (node.type == NODE_BLOB) {
        return this.compile_blob(node);
    }
    else if (node.type == NODE_STRING) {
        return this.compile_string(node);
    }
    else if (node.type == NODE_LIST) {
        return this.compile_list(node);
    }
    else if (node.type == NODE_DICT) {
        return this.compile_dict(node);
    }
    else if (node.type == NODE_OPTION) {
        return this.compile_option(node);
    }
    else if (node.type == NODE_IDENTIFIER) {
        return this.compile_identifier(node);
    }
    else if (node.type == NODE_CURLYNAME) {
        return this.compile_curlyname(node);
    }
    else if (node.type == NODE_ENV) {
        return this.compile_env(node);
    }
    else if (node.type == NODE_REG) {
        return this.compile_reg(node);
    }
    else if (node.type == NODE_CURLYNAMEPART) {
        return this.compile_curlynamepart(node);
    }
    else if (node.type == NODE_CURLYNAMEEXPR) {
        return this.compile_curlynameexpr(node);
    }
    else if (node.type == NODE_LAMBDA) {
        return this.compile_lambda(node);
    }
    else if (node.type == NODE_HEREDOC) {
        return this.compile_heredoc(node);
    }
    else {
        throw viml_printf("Compiler: unknown node: %s", viml_string(node));
    }
    return NIL;
}

Compiler.prototype.compile_body = function(body) {
    var __c10 = body;
    for (var __i10 = 0; __i10 < __c10.length; ++__i10) {
        var node = __c10[__i10];
        this.compile(node);
    }
}

Compiler.prototype.compile_toplevel = function(node) {
    this.compile_body(node.body);
    return this.lines;
}

Compiler.prototype.compile_comment = function(node) {
    this.out(";%s", node.str);
}

Compiler.prototype.compile_excmd = function(node) {
    this.out("(excmd \"%s\")", viml_escape(node.str, "\\\""));
}

Compiler.prototype.compile_function = function(node) {
    var left = this.compile(node.left);
    var rlist = node.rlist.map((function(vval) { return this.compile(vval); }).bind(this));
    var default_args = node.default_args.map((function(vval) { return this.compile(vval); }).bind(this));
    if (!viml_empty(rlist)) {
        var remaining = FALSE;
        if (rlist[rlist.length - 1] == "...") {
            viml_remove(rlist, -1);
            var remaining = TRUE;
        }
        var __c11 = viml_range(viml_len(rlist));
        for (var __i11 = 0; __i11 < __c11.length; ++__i11) {
            var i = __c11[__i11];
            if (i < viml_len(rlist) - viml_len(default_args)) {
                left += viml_printf(" %s", rlist[i]);
            }
            else {
                left += viml_printf(" (%s %s)", rlist[i], default_args[i + viml_len(default_args) - viml_len(rlist)]);
            }
        }
        if (remaining) {
            left += " . ...";
        }
    }
    this.out("(function (%s)", left);
    this.incindent("  ");
    this.compile_body(node.body);
    this.out(")");
    this.decindent();
}

Compiler.prototype.compile_delfunction = function(node) {
    this.out("(delfunction %s)", this.compile(node.left));
}

Compiler.prototype.compile_return = function(node) {
    if (node.left === NIL) {
        this.out("(return)");
    }
    else {
        this.out("(return %s)", this.compile(node.left));
    }
}

Compiler.prototype.compile_excall = function(node) {
    this.out("(call %s)", this.compile(node.left));
}

Compiler.prototype.compile_eval = function(node) {
    this.out("(eval %s)", this.compile(node.left));
}

Compiler.prototype.compile_let = function(node) {
    var left = "";
    if (node.left !== NIL) {
        var left = this.compile(node.left);
    }
    else {
        var left = viml_join(node.list.map((function(vval) { return this.compile(vval); }).bind(this)), " ");
        if (node.rest !== NIL) {
            left += " . " + this.compile(node.rest);
        }
        var left = "(" + left + ")";
    }
    var right = this.compile(node.right);
    this.out("(let %s %s %s)", node.op, left, right);
}

// TODO: merge with s:Compiler.compile_let() ?
Compiler.prototype.compile_const = function(node) {
    var left = "";
    if (node.left !== NIL) {
        var left = this.compile(node.left);
    }
    else {
        var left = viml_join(node.list.map((function(vval) { return this.compile(vval); }).bind(this)), " ");
        if (node.rest !== NIL) {
            left += " . " + this.compile(node.rest);
        }
        var left = "(" + left + ")";
    }
    var right = this.compile(node.right);
    this.out("(const %s %s %s)", node.op, left, right);
}

Compiler.prototype.compile_unlet = function(node) {
    var list = node.list.map((function(vval) { return this.compile(vval); }).bind(this));
    this.out("(unlet %s)", viml_join(list, " "));
}

Compiler.prototype.compile_lockvar = function(node) {
    var list = node.list.map((function(vval) { return this.compile(vval); }).bind(this));
    if (node.depth === NIL) {
        this.out("(lockvar %s)", viml_join(list, " "));
    }
    else {
        this.out("(lockvar %d %s)", node.depth, viml_join(list, " "));
    }
}

Compiler.prototype.compile_unlockvar = function(node) {
    var list = node.list.map((function(vval) { return this.compile(vval); }).bind(this));
    if (node.depth === NIL) {
        this.out("(unlockvar %s)", viml_join(list, " "));
    }
    else {
        this.out("(unlockvar %d %s)", node.depth, viml_join(list, " "));
    }
}

Compiler.prototype.compile_if = function(node) {
    this.out("(if %s", this.compile(node.cond));
    this.incindent("  ");
    this.compile_body(node.body);
    this.decindent();
    var __c12 = node.elseif;
    for (var __i12 = 0; __i12 < __c12.length; ++__i12) {
        var enode = __c12[__i12];
        this.out(" elseif %s", this.compile(enode.cond));
        this.incindent("  ");
        this.compile_body(enode.body);
        this.decindent();
    }
    if (node._else !== NIL) {
        this.out(" else");
        this.incindent("  ");
        this.compile_body(node._else.body);
        this.decindent();
    }
    this.incindent("  ");
    this.out(")");
    this.decindent();
}

Compiler.prototype.compile_while = function(node) {
    this.out("(while %s", this.compile(node.cond));
    this.incindent("  ");
    this.compile_body(node.body);
    this.out(")");
    this.decindent();
}

Compiler.prototype.compile_for = function(node) {
    var left = "";
    if (node.left !== NIL) {
        var left = this.compile(node.left);
    }
    else {
        var left = viml_join(node.list.map((function(vval) { return this.compile(vval); }).bind(this)), " ");
        if (node.rest !== NIL) {
            left += " . " + this.compile(node.rest);
        }
        var left = "(" + left + ")";
    }
    var right = this.compile(node.right);
    this.out("(for %s %s", left, right);
    this.incindent("  ");
    this.compile_body(node.body);
    this.out(")");
    this.decindent();
}

Compiler.prototype.compile_continue = function(node) {
    this.out("(continue)");
}

Compiler.prototype.compile_break = function(node) {
    this.out("(break)");
}

Compiler.prototype.compile_try = function(node) {
    this.out("(try");
    this.incindent("  ");
    this.compile_body(node.body);
    var __c13 = node.catch;
    for (var __i13 = 0; __i13 < __c13.length; ++__i13) {
        var cnode = __c13[__i13];
        if (cnode.pattern !== NIL) {
            this.decindent();
            this.out(" catch /%s/", cnode.pattern);
            this.incindent("  ");
            this.compile_body(cnode.body);
        }
        else {
            this.decindent();
            this.out(" catch");
            this.incindent("  ");
            this.compile_body(cnode.body);
        }
    }
    if (node._finally !== NIL) {
        this.decindent();
        this.out(" finally");
        this.incindent("  ");
        this.compile_body(node._finally.body);
    }
    this.out(")");
    this.decindent();
}

Compiler.prototype.compile_throw = function(node) {
    this.out("(throw %s)", this.compile(node.left));
}

Compiler.prototype.compile_echo = function(node) {
    var list = node.list.map((function(vval) { return this.compile(vval); }).bind(this));
    this.out("(echo %s)", viml_join(list, " "));
}

Compiler.prototype.compile_echon = function(node) {
    var list = node.list.map((function(vval) { return this.compile(vval); }).bind(this));
    this.out("(echon %s)", viml_join(list, " "));
}

Compiler.prototype.compile_echohl = function(node) {
    this.out("(echohl \"%s\")", viml_escape(node.str, "\\\""));
}

Compiler.prototype.compile_echomsg = function(node) {
    var list = node.list.map((function(vval) { return this.compile(vval); }).bind(this));
    this.out("(echomsg %s)", viml_join(list, " "));
}

Compiler.prototype.compile_echoerr = function(node) {
    var list = node.list.map((function(vval) { return this.compile(vval); }).bind(this));
    this.out("(echoerr %s)", viml_join(list, " "));
}

Compiler.prototype.compile_echoconsole = function(node) {
    var list = node.list.map((function(vval) { return this.compile(vval); }).bind(this));
    this.out("(echoconsole %s)", viml_join(list, " "));
}

Compiler.prototype.compile_execute = function(node) {
    var list = node.list.map((function(vval) { return this.compile(vval); }).bind(this));
    this.out("(execute %s)", viml_join(list, " "));
}

Compiler.prototype.compile_ternary = function(node) {
    return viml_printf("(?: %s %s %s)", this.compile(node.cond), this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_or = function(node) {
    return viml_printf("(|| %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_and = function(node) {
    return viml_printf("(&& %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_equal = function(node) {
    return viml_printf("(== %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_equalci = function(node) {
    return viml_printf("(==? %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_equalcs = function(node) {
    return viml_printf("(==# %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_nequal = function(node) {
    return viml_printf("(!= %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_nequalci = function(node) {
    return viml_printf("(!=? %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_nequalcs = function(node) {
    return viml_printf("(!=# %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_greater = function(node) {
    return viml_printf("(> %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_greaterci = function(node) {
    return viml_printf("(>? %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_greatercs = function(node) {
    return viml_printf("(># %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_gequal = function(node) {
    return viml_printf("(>= %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_gequalci = function(node) {
    return viml_printf("(>=? %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_gequalcs = function(node) {
    return viml_printf("(>=# %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_smaller = function(node) {
    return viml_printf("(< %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_smallerci = function(node) {
    return viml_printf("(<? %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_smallercs = function(node) {
    return viml_printf("(<# %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_sequal = function(node) {
    return viml_printf("(<= %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_sequalci = function(node) {
    return viml_printf("(<=? %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_sequalcs = function(node) {
    return viml_printf("(<=# %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_match = function(node) {
    return viml_printf("(=~ %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_matchci = function(node) {
    return viml_printf("(=~? %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_matchcs = function(node) {
    return viml_printf("(=~# %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_nomatch = function(node) {
    return viml_printf("(!~ %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_nomatchci = function(node) {
    return viml_printf("(!~? %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_nomatchcs = function(node) {
    return viml_printf("(!~# %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_is = function(node) {
    return viml_printf("(is %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_isci = function(node) {
    return viml_printf("(is? %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_iscs = function(node) {
    return viml_printf("(is# %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_isnot = function(node) {
    return viml_printf("(isnot %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_isnotci = function(node) {
    return viml_printf("(isnot? %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_isnotcs = function(node) {
    return viml_printf("(isnot# %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_add = function(node) {
    return viml_printf("(+ %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_subtract = function(node) {
    return viml_printf("(- %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_concat = function(node) {
    return viml_printf("(concat %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_multiply = function(node) {
    return viml_printf("(* %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_divide = function(node) {
    return viml_printf("(/ %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_remainder = function(node) {
    return viml_printf("(%% %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_not = function(node) {
    return viml_printf("(! %s)", this.compile(node.left));
}

Compiler.prototype.compile_plus = function(node) {
    return viml_printf("(+ %s)", this.compile(node.left));
}

Compiler.prototype.compile_minus = function(node) {
    return viml_printf("(- %s)", this.compile(node.left));
}

Compiler.prototype.compile_subscript = function(node) {
    return viml_printf("(subscript %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_slice = function(node) {
    var r0 = node.rlist[0] === NIL ? "nil" : this.compile(node.rlist[0]);
    var r1 = node.rlist[1] === NIL ? "nil" : this.compile(node.rlist[1]);
    return viml_printf("(slice %s %s %s)", this.compile(node.left), r0, r1);
}

Compiler.prototype.compile_dot = function(node) {
    return viml_printf("(dot %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_method = function(node) {
    return viml_printf("(method %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_call = function(node) {
    var rlist = node.rlist.map((function(vval) { return this.compile(vval); }).bind(this));
    if (viml_empty(rlist)) {
        return viml_printf("(%s)", this.compile(node.left));
    }
    else {
        return viml_printf("(%s %s)", this.compile(node.left), viml_join(rlist, " "));
    }
}

Compiler.prototype.compile_number = function(node) {
    return node.value;
}

Compiler.prototype.compile_blob = function(node) {
    return node.value;
}

Compiler.prototype.compile_string = function(node) {
    return node.value;
}

Compiler.prototype.compile_list = function(node) {
    var value = node.value.map((function(vval) { return this.compile(vval); }).bind(this));
    if (viml_empty(value)) {
        return "(list)";
    }
    else {
        return viml_printf("(list %s)", viml_join(value, " "));
    }
}

Compiler.prototype.compile_dict = function(node) {
    var value = node.value.map((function(vval) { return "(" + this.compile(vval[0]) + " " + this.compile(vval[1]) + ")"; }).bind(this));
    if (viml_empty(value)) {
        return "(dict)";
    }
    else {
        return viml_printf("(dict %s)", viml_join(value, " "));
    }
}

Compiler.prototype.compile_option = function(node) {
    return node.value;
}

Compiler.prototype.compile_identifier = function(node) {
    return node.value;
}

Compiler.prototype.compile_curlyname = function(node) {
    return viml_join(node.value.map((function(vval) { return this.compile(vval); }).bind(this)), "");
}

Compiler.prototype.compile_env = function(node) {
    return node.value;
}

Compiler.prototype.compile_reg = function(node) {
    return node.value;
}

Compiler.prototype.compile_curlynamepart = function(node) {
    return node.value;
}

Compiler.prototype.compile_curlynameexpr = function(node) {
    return "{" + this.compile(node.value) + "}";
}

Compiler.prototype.escape_string = function(str) {
    var m = {"\n":"\\n", "\t":"\\t", "\r":"\\r"};
    var out = "\"";
    var __c14 = viml_range(viml_len(str));
    for (var __i14 = 0; __i14 < __c14.length; ++__i14) {
        var i = __c14[__i14];
        var c = str[i];
        if (viml_has_key(m, c)) {
            out += m[c];
        }
        else {
            out += c;
        }
    }
    out += "\"";
    return out;
}

Compiler.prototype.compile_lambda = function(node) {
    var rlist = node.rlist.map((function(vval) { return this.compile(vval); }).bind(this));
    return viml_printf("(lambda (%s) %s)", viml_join(rlist, " "), this.compile(node.left));
}

Compiler.prototype.compile_heredoc = function(node) {
    if (viml_empty(node.rlist)) {
        var rlist = "(list)";
    }
    else {
        var rlist = "(list " + viml_join(node.rlist.map((function(vval) { return this.escape_string(vval.value); }).bind(this)), " ") + ")";
    }
    if (viml_empty(node.body)) {
        var body = "(list)";
    }
    else {
        var body = "(list " + viml_join(node.body.map((function(vval) { return this.escape_string(vval.value); }).bind(this)), " ") + ")";
    }
    var op = this.escape_string(node.op);
    return viml_printf("(heredoc %s %s %s)", rlist, op, body);
}

// TODO: under construction
function RegexpParser() { this.__init__.apply(this, arguments); }
RegexpParser.prototype.RE_VERY_NOMAGIC = 1;
RegexpParser.prototype.RE_NOMAGIC = 2;
RegexpParser.prototype.RE_MAGIC = 3;
RegexpParser.prototype.RE_VERY_MAGIC = 4;
RegexpParser.prototype.__init__ = function(reader, cmd, delim) {
    this.reader = reader;
    this.cmd = cmd;
    this.delim = delim;
    this.reg_magic = this.RE_MAGIC;
}

RegexpParser.prototype.isend = function(c) {
    return c == "<EOF>" || c == "<EOL>" || c == this.delim;
}

RegexpParser.prototype.parse_regexp = function() {
    var prevtoken = "";
    var ntoken = "";
    var ret = [];
    if (this.reader.peekn(4) == "\\%#=") {
        var epos = this.reader.getpos();
        var token = this.reader.getn(5);
        if (token != "\\%#=0" && token != "\\%#=1" && token != "\\%#=2") {
            throw Err("E864: \\%#= can only be followed by 0, 1, or 2", epos);
        }
        viml_add(ret, token);
    }
    while (!this.isend(this.reader.peek())) {
        var prevtoken = ntoken;
        var __tmp = this.get_token();
        var token = __tmp[0];
        var ntoken = __tmp[1];
        if (ntoken == "\\m") {
            this.reg_magic = this.RE_MAGIC;
        }
        else if (ntoken == "\\M") {
            this.reg_magic = this.RE_NOMAGIC;
        }
        else if (ntoken == "\\v") {
            this.reg_magic = this.RE_VERY_MAGIC;
        }
        else if (ntoken == "\\V") {
            this.reg_magic = this.RE_VERY_NOMAGIC;
        }
        else if (ntoken == "\\*") {
            // '*' is not magic as the very first character.
            if (prevtoken == "" || prevtoken == "\\^" || prevtoken == "\\&" || prevtoken == "\\|" || prevtoken == "\\(") {
                var ntoken = "*";
            }
        }
        else if (ntoken == "\\^") {
            // '^' is only magic as the very first character.
            if (this.reg_magic != this.RE_VERY_MAGIC && prevtoken != "" && prevtoken != "\\&" && prevtoken != "\\|" && prevtoken != "\\n" && prevtoken != "\\(" && prevtoken != "\\%(") {
                var ntoken = "^";
            }
        }
        else if (ntoken == "\\$") {
            // '$' is only magic as the very last character
            var pos = this.reader.tell();
            if (this.reg_magic != this.RE_VERY_MAGIC) {
                while (!this.isend(this.reader.peek())) {
                    var __tmp = this.get_token();
                    var t = __tmp[0];
                    var n = __tmp[1];
                    // XXX: Vim doesn't check \v and \V?
                    if (n == "\\c" || n == "\\C" || n == "\\m" || n == "\\M" || n == "\\Z") {
                        continue;
                    }
                    if (n != "\\|" && n != "\\&" && n != "\\n" && n != "\\)") {
                        var ntoken = "$";
                    }
                    break;
                }
            }
            this.reader.seek_set(pos);
        }
        else if (ntoken == "\\?") {
            // '?' is literal in '?' command.
            if (this.cmd == "?") {
                var ntoken = "?";
            }
        }
        viml_add(ret, ntoken);
    }
    return ret;
}

// @return [actual_token, normalized_token]
RegexpParser.prototype.get_token = function() {
    if (this.reg_magic == this.RE_VERY_MAGIC) {
        return this.get_token_very_magic();
    }
    else if (this.reg_magic == this.RE_MAGIC) {
        return this.get_token_magic();
    }
    else if (this.reg_magic == this.RE_NOMAGIC) {
        return this.get_token_nomagic();
    }
    else if (this.reg_magic == this.RE_VERY_NOMAGIC) {
        return this.get_token_very_nomagic();
    }
}

RegexpParser.prototype.get_token_very_magic = function() {
    if (this.isend(this.reader.peek())) {
        return ["<END>", "<END>"];
    }
    var c = this.reader.get();
    if (c == "\\") {
        return this.get_token_backslash_common();
    }
    else if (c == "*") {
        return ["*", "\\*"];
    }
    else if (c == "+") {
        return ["+", "\\+"];
    }
    else if (c == "=") {
        return ["=", "\\="];
    }
    else if (c == "?") {
        return ["?", "\\?"];
    }
    else if (c == "{") {
        return this.get_token_brace("{");
    }
    else if (c == "@") {
        return this.get_token_at("@");
    }
    else if (c == "^") {
        return ["^", "\\^"];
    }
    else if (c == "$") {
        return ["$", "\\$"];
    }
    else if (c == ".") {
        return [".", "\\."];
    }
    else if (c == "<") {
        return ["<", "\\<"];
    }
    else if (c == ">") {
        return [">", "\\>"];
    }
    else if (c == "%") {
        return this.get_token_percent("%");
    }
    else if (c == "[") {
        return this.get_token_sq("[");
    }
    else if (c == "~") {
        return ["~", "\\~"];
    }
    else if (c == "|") {
        return ["|", "\\|"];
    }
    else if (c == "&") {
        return ["&", "\\&"];
    }
    else if (c == "(") {
        return ["(", "\\("];
    }
    else if (c == ")") {
        return [")", "\\)"];
    }
    return [c, c];
}

RegexpParser.prototype.get_token_magic = function() {
    if (this.isend(this.reader.peek())) {
        return ["<END>", "<END>"];
    }
    var c = this.reader.get();
    if (c == "\\") {
        var pos = this.reader.tell();
        var c = this.reader.get();
        if (c == "+") {
            return ["\\+", "\\+"];
        }
        else if (c == "=") {
            return ["\\=", "\\="];
        }
        else if (c == "?") {
            return ["\\?", "\\?"];
        }
        else if (c == "{") {
            return this.get_token_brace("\\{");
        }
        else if (c == "@") {
            return this.get_token_at("\\@");
        }
        else if (c == "<") {
            return ["\\<", "\\<"];
        }
        else if (c == ">") {
            return ["\\>", "\\>"];
        }
        else if (c == "%") {
            return this.get_token_percent("\\%");
        }
        else if (c == "|") {
            return ["\\|", "\\|"];
        }
        else if (c == "&") {
            return ["\\&", "\\&"];
        }
        else if (c == "(") {
            return ["\\(", "\\("];
        }
        else if (c == ")") {
            return ["\\)", "\\)"];
        }
        this.reader.seek_set(pos);
        return this.get_token_backslash_common();
    }
    else if (c == "*") {
        return ["*", "\\*"];
    }
    else if (c == "^") {
        return ["^", "\\^"];
    }
    else if (c == "$") {
        return ["$", "\\$"];
    }
    else if (c == ".") {
        return [".", "\\."];
    }
    else if (c == "[") {
        return this.get_token_sq("[");
    }
    else if (c == "~") {
        return ["~", "\\~"];
    }
    return [c, c];
}

RegexpParser.prototype.get_token_nomagic = function() {
    if (this.isend(this.reader.peek())) {
        return ["<END>", "<END>"];
    }
    var c = this.reader.get();
    if (c == "\\") {
        var pos = this.reader.tell();
        var c = this.reader.get();
        if (c == "*") {
            return ["\\*", "\\*"];
        }
        else if (c == "+") {
            return ["\\+", "\\+"];
        }
        else if (c == "=") {
            return ["\\=", "\\="];
        }
        else if (c == "?") {
            return ["\\?", "\\?"];
        }
        else if (c == "{") {
            return this.get_token_brace("\\{");
        }
        else if (c == "@") {
            return this.get_token_at("\\@");
        }
        else if (c == ".") {
            return ["\\.", "\\."];
        }
        else if (c == "<") {
            return ["\\<", "\\<"];
        }
        else if (c == ">") {
            return ["\\>", "\\>"];
        }
        else if (c == "%") {
            return this.get_token_percent("\\%");
        }
        else if (c == "~") {
            return ["\\~", "\\^"];
        }
        else if (c == "[") {
            return this.get_token_sq("\\[");
        }
        else if (c == "|") {
            return ["\\|", "\\|"];
        }
        else if (c == "&") {
            return ["\\&", "\\&"];
        }
        else if (c == "(") {
            return ["\\(", "\\("];
        }
        else if (c == ")") {
            return ["\\)", "\\)"];
        }
        this.reader.seek_set(pos);
        return this.get_token_backslash_common();
    }
    else if (c == "^") {
        return ["^", "\\^"];
    }
    else if (c == "$") {
        return ["$", "\\$"];
    }
    return [c, c];
}

RegexpParser.prototype.get_token_very_nomagic = function() {
    if (this.isend(this.reader.peek())) {
        return ["<END>", "<END>"];
    }
    var c = this.reader.get();
    if (c == "\\") {
        var pos = this.reader.tell();
        var c = this.reader.get();
        if (c == "*") {
            return ["\\*", "\\*"];
        }
        else if (c == "+") {
            return ["\\+", "\\+"];
        }
        else if (c == "=") {
            return ["\\=", "\\="];
        }
        else if (c == "?") {
            return ["\\?", "\\?"];
        }
        else if (c == "{") {
            return this.get_token_brace("\\{");
        }
        else if (c == "@") {
            return this.get_token_at("\\@");
        }
        else if (c == "^") {
            return ["\\^", "\\^"];
        }
        else if (c == "$") {
            return ["\\$", "\\$"];
        }
        else if (c == "<") {
            return ["\\<", "\\<"];
        }
        else if (c == ">") {
            return ["\\>", "\\>"];
        }
        else if (c == "%") {
            return this.get_token_percent("\\%");
        }
        else if (c == "~") {
            return ["\\~", "\\~"];
        }
        else if (c == "[") {
            return this.get_token_sq("\\[");
        }
        else if (c == "|") {
            return ["\\|", "\\|"];
        }
        else if (c == "&") {
            return ["\\&", "\\&"];
        }
        else if (c == "(") {
            return ["\\(", "\\("];
        }
        else if (c == ")") {
            return ["\\)", "\\)"];
        }
        this.reader.seek_set(pos);
        return this.get_token_backslash_common();
    }
    return [c, c];
}

RegexpParser.prototype.get_token_backslash_common = function() {
    var cclass = "iIkKfFpPsSdDxXoOwWhHaAlLuU";
    var c = this.reader.get();
    if (c == "\\") {
        return ["\\\\", "\\\\"];
    }
    else if (viml_stridx(cclass, c) != -1) {
        return ["\\" + c, "\\" + c];
    }
    else if (c == "_") {
        var epos = this.reader.getpos();
        var c = this.reader.get();
        if (viml_stridx(cclass, c) != -1) {
            return ["\\_" + c, "\\_ . c"];
        }
        else if (c == "^") {
            return ["\\_^", "\\_^"];
        }
        else if (c == "$") {
            return ["\\_$", "\\_$"];
        }
        else if (c == ".") {
            return ["\\_.", "\\_."];
        }
        else if (c == "[") {
            return this.get_token_sq("\\_[");
        }
        throw Err("E63: invalid use of \\_", epos);
    }
    else if (viml_stridx("etrb", c) != -1) {
        return ["\\" + c, "\\" + c];
    }
    else if (viml_stridx("123456789", c) != -1) {
        return ["\\" + c, "\\" + c];
    }
    else if (c == "z") {
        var epos = this.reader.getpos();
        var c = this.reader.get();
        if (viml_stridx("123456789", c) != -1) {
            return ["\\z" + c, "\\z" + c];
        }
        else if (c == "s") {
            return ["\\zs", "\\zs"];
        }
        else if (c == "e") {
            return ["\\ze", "\\ze"];
        }
        else if (c == "(") {
            return ["\\z(", "\\z("];
        }
        throw Err("E68: Invalid character after \\z", epos);
    }
    else if (viml_stridx("cCmMvVZ", c) != -1) {
        return ["\\" + c, "\\" + c];
    }
    else if (c == "%") {
        var epos = this.reader.getpos();
        var c = this.reader.get();
        if (c == "d") {
            var r = this.getdecchrs();
            if (r != "") {
                return ["\\%d" + r, "\\%d" + r];
            }
        }
        else if (c == "o") {
            var r = this.getoctchrs();
            if (r != "") {
                return ["\\%o" + r, "\\%o" + r];
            }
        }
        else if (c == "x") {
            var r = this.gethexchrs(2);
            if (r != "") {
                return ["\\%x" + r, "\\%x" + r];
            }
        }
        else if (c == "u") {
            var r = this.gethexchrs(4);
            if (r != "") {
                return ["\\%u" + r, "\\%u" + r];
            }
        }
        else if (c == "U") {
            var r = this.gethexchrs(8);
            if (r != "") {
                return ["\\%U" + r, "\\%U" + r];
            }
        }
        throw Err("E678: Invalid character after \\%[dxouU]", epos);
    }
    return ["\\" + c, c];
}

// \{}
RegexpParser.prototype.get_token_brace = function(pre) {
    var r = "";
    var minus = "";
    var comma = "";
    var n = "";
    var m = "";
    if (this.reader.p(0) == "-") {
        var minus = this.reader.get();
        r += minus;
    }
    if (isdigit(this.reader.p(0))) {
        var n = this.reader.read_digit();
        r += n;
    }
    if (this.reader.p(0) == ",") {
        var comma = this.rader.get();
        r += comma;
    }
    if (isdigit(this.reader.p(0))) {
        var m = this.reader.read_digit();
        r += m;
    }
    if (this.reader.p(0) == "\\") {
        r += this.reader.get();
    }
    if (this.reader.p(0) != "}") {
        throw Err("E554: Syntax error in \\{...}", this.reader.getpos());
    }
    this.reader.get();
    return [pre + r, "\\{" + minus + n + comma + m + "}"];
}

// \[]
RegexpParser.prototype.get_token_sq = function(pre) {
    var start = this.reader.tell();
    var r = "";
    // Complement of range
    if (this.reader.p(0) == "^") {
        r += this.reader.get();
    }
    // At the start ']' and '-' mean the literal character.
    if (this.reader.p(0) == "]" || this.reader.p(0) == "-") {
        r += this.reader.get();
    }
    while (TRUE) {
        var startc = 0;
        var c = this.reader.p(0);
        if (this.isend(c)) {
            // If there is no matching ']', we assume the '[' is a normal character.
            this.reader.seek_set(start);
            return [pre, "["];
        }
        else if (c == "]") {
            this.reader.seek_cur(1);
            return [pre + r + "]", "\\[" + r + "]"];
        }
        else if (c == "[") {
            var e = this.get_token_sq_char_class();
            if (e == "") {
                var e = this.get_token_sq_equi_class();
                if (e == "") {
                    var e = this.get_token_sq_coll_element();
                    if (e == "") {
                        var __tmp = this.get_token_sq_c();
                        var e = __tmp[0];
                        var startc = __tmp[1];
                    }
                }
            }
            r += e;
        }
        else {
            var __tmp = this.get_token_sq_c();
            var e = __tmp[0];
            var startc = __tmp[1];
            r += e;
        }
        if (startc != 0 && this.reader.p(0) == "-" && !this.isend(this.reader.p(1)) && !(this.reader.p(1) == "\\" && this.reader.p(2) == "n")) {
            this.reader.seek_cur(1);
            r += "-";
            var c = this.reader.p(0);
            if (c == "[") {
                var e = this.get_token_sq_coll_element();
                if (e != "") {
                    var endc = viml_char2nr(e[2]);
                }
                else {
                    var __tmp = this.get_token_sq_c();
                    var e = __tmp[0];
                    var endc = __tmp[1];
                }
                r += e;
            }
            else {
                var __tmp = this.get_token_sq_c();
                var e = __tmp[0];
                var endc = __tmp[1];
                r += e;
            }
            if (startc > endc || endc > startc + 256) {
                throw Err("E16: Invalid range", this.reader.getpos());
            }
        }
    }
}

// [c]
RegexpParser.prototype.get_token_sq_c = function() {
    var c = this.reader.p(0);
    if (c == "\\") {
        this.reader.seek_cur(1);
        var c = this.reader.p(0);
        if (c == "n") {
            this.reader.seek_cur(1);
            return ["\\n", 0];
        }
        else if (c == "r") {
            this.reader.seek_cur(1);
            return ["\\r", 13];
        }
        else if (c == "t") {
            this.reader.seek_cur(1);
            return ["\\t", 9];
        }
        else if (c == "e") {
            this.reader.seek_cur(1);
            return ["\\e", 27];
        }
        else if (c == "b") {
            this.reader.seek_cur(1);
            return ["\\b", 8];
        }
        else if (viml_stridx("]^-\\", c) != -1) {
            this.reader.seek_cur(1);
            return ["\\" + c, viml_char2nr(c)];
        }
        else if (viml_stridx("doxuU", c) != -1) {
            var __tmp = this.get_token_sq_coll_char();
            var c = __tmp[0];
            var n = __tmp[1];
            return [c, n];
        }
        else {
            return ["\\", viml_char2nr("\\")];
        }
    }
    else if (c == "-") {
        this.reader.seek_cur(1);
        return ["-", viml_char2nr("-")];
    }
    else {
        this.reader.seek_cur(1);
        return [c, viml_char2nr(c)];
    }
}

// [\d123]
RegexpParser.prototype.get_token_sq_coll_char = function() {
    var pos = this.reader.tell();
    var c = this.reader.get();
    if (c == "d") {
        var r = this.getdecchrs();
        var n = viml_str2nr(r, 10);
    }
    else if (c == "o") {
        var r = this.getoctchrs();
        var n = viml_str2nr(r, 8);
    }
    else if (c == "x") {
        var r = this.gethexchrs(2);
        var n = viml_str2nr(r, 16);
    }
    else if (c == "u") {
        var r = this.gethexchrs(4);
        var n = viml_str2nr(r, 16);
    }
    else if (c == "U") {
        var r = this.gethexchrs(8);
        var n = viml_str2nr(r, 16);
    }
    else {
        var r = "";
    }
    if (r == "") {
        this.reader.seek_set(pos);
        return "\\";
    }
    return ["\\" + c + r, n];
}

// [[.a.]]
RegexpParser.prototype.get_token_sq_coll_element = function() {
    if (this.reader.p(0) == "[" && this.reader.p(1) == "." && !this.isend(this.reader.p(2)) && this.reader.p(3) == "." && this.reader.p(4) == "]") {
        return this.reader.getn(5);
    }
    return "";
}

// [[=a=]]
RegexpParser.prototype.get_token_sq_equi_class = function() {
    if (this.reader.p(0) == "[" && this.reader.p(1) == "=" && !this.isend(this.reader.p(2)) && this.reader.p(3) == "=" && this.reader.p(4) == "]") {
        return this.reader.getn(5);
    }
    return "";
}

// [[:alpha:]]
RegexpParser.prototype.get_token_sq_char_class = function() {
    var class_names = ["alnum", "alpha", "blank", "cntrl", "digit", "graph", "lower", "print", "punct", "space", "upper", "xdigit", "tab", "return", "backspace", "escape"];
    var pos = this.reader.tell();
    if (this.reader.p(0) == "[" && this.reader.p(1) == ":") {
        this.reader.seek_cur(2);
        var r = this.reader.read_alpha();
        if (this.reader.p(0) == ":" && this.reader.p(1) == "]") {
            this.reader.seek_cur(2);
            var __c15 = class_names;
            for (var __i15 = 0; __i15 < __c15.length; ++__i15) {
                var name = __c15[__i15];
                if (r == name) {
                    return "[:" + name + ":]";
                }
            }
        }
    }
    this.reader.seek_set(pos);
    return "";
}

// \@...
RegexpParser.prototype.get_token_at = function(pre) {
    var epos = this.reader.getpos();
    var c = this.reader.get();
    if (c == ">") {
        return [pre + ">", "\\@>"];
    }
    else if (c == "=") {
        return [pre + "=", "\\@="];
    }
    else if (c == "!") {
        return [pre + "!", "\\@!"];
    }
    else if (c == "<") {
        var c = this.reader.get();
        if (c == "=") {
            return [pre + "<=", "\\@<="];
        }
        else if (c == "!") {
            return [pre + "<!", "\\@<!"];
        }
    }
    throw Err("E64: @ follows nothing", epos);
}

// \%...
RegexpParser.prototype.get_token_percent = function(pre) {
    var c = this.reader.get();
    if (c == "^") {
        return [pre + "^", "\\%^"];
    }
    else if (c == "$") {
        return [pre + "$", "\\%$"];
    }
    else if (c == "V") {
        return [pre + "V", "\\%V"];
    }
    else if (c == "#") {
        return [pre + "#", "\\%#"];
    }
    else if (c == "[") {
        return this.get_token_percent_sq(pre + "[");
    }
    else if (c == "(") {
        return [pre + "(", "\\%("];
    }
    else {
        return this.get_token_mlcv(pre);
    }
}

// \%[]
RegexpParser.prototype.get_token_percent_sq = function(pre) {
    var r = "";
    while (TRUE) {
        var c = this.reader.peek();
        if (this.isend(c)) {
            throw Err("E69: Missing ] after \\%[", this.reader.getpos());
        }
        else if (c == "]") {
            if (r == "") {
                throw Err("E70: Empty \\%[", this.reader.getpos());
            }
            this.reader.seek_cur(1);
            break;
        }
        this.reader.seek_cur(1);
        r += c;
    }
    return [pre + r + "]", "\\%[" + r + "]"];
}

// \%'m \%l \%c \%v
RegexpParser.prototype.get_token_mlvc = function(pre) {
    var r = "";
    var cmp = "";
    if (this.reader.p(0) == "<" || this.reader.p(0) == ">") {
        var cmp = this.reader.get();
        r += cmp;
    }
    if (this.reader.p(0) == "'") {
        r += this.reader.get();
        var c = this.reader.p(0);
        if (this.isend(c)) {
            // FIXME: Should be error?  Vim allow this.
            var c = "";
        }
        else {
            var c = this.reader.get();
        }
        return [pre + r + c, "\\%" + cmp + "'" + c];
    }
    else if (isdigit(this.reader.p(0))) {
        var d = this.reader.read_digit();
        r += d;
        var c = this.reader.p(0);
        if (c == "l") {
            this.reader.get();
            return [pre + r + "l", "\\%" + cmp + d + "l"];
        }
        else if (c == "c") {
            this.reader.get();
            return [pre + r + "c", "\\%" + cmp + d + "c"];
        }
        else if (c == "v") {
            this.reader.get();
            return [pre + r + "v", "\\%" + cmp + d + "v"];
        }
    }
    throw Err("E71: Invalid character after %", this.reader.getpos());
}

RegexpParser.prototype.getdecchrs = function() {
    return this.reader.read_digit();
}

RegexpParser.prototype.getoctchrs = function() {
    return this.reader.read_odigit();
}

RegexpParser.prototype.gethexchrs = function(n) {
    var r = "";
    var __c16 = viml_range(n);
    for (var __i16 = 0; __i16 < __c16.length; ++__i16) {
        var i = __c16[__i16];
        var c = this.reader.peek();
        if (!isxdigit(c)) {
            break;
        }
        r += this.reader.get();
    }
    return r;
}

if (__webpack_require__.c[__webpack_require__.s] === module) {
  main();
}
else {
  module.exports = {
    VimLParser: VimLParser,
    StringReader: StringReader,
    Compiler: Compiler
  };
}


/***/ }),

/***/ 61:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");;

/***/ }),

/***/ 25:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");;

/***/ }),

/***/ 70:
/***/ ((module) => {

"use strict";
module.exports = require("events");;

/***/ }),

/***/ 60:
/***/ ((module) => {

"use strict";
module.exports = require("fs");;

/***/ }),

/***/ 26:
/***/ ((module) => {

"use strict";
module.exports = require("net");;

/***/ }),

/***/ 24:
/***/ ((module) => {

"use strict";
module.exports = require("os");;

/***/ }),

/***/ 23:
/***/ ((module) => {

"use strict";
module.exports = require("path");;

/***/ }),

/***/ 59:
/***/ ((module) => {

"use strict";
module.exports = require("url");;

/***/ }),

/***/ 10:
/***/ ((module) => {

"use strict";
module.exports = require("util");;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__(__webpack_require__.s = 391);
/******/ 	var __webpack_export_target__ = exports;
/******/ 	for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;