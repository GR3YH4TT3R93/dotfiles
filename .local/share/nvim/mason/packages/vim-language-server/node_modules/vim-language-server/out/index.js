/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var shvl = __importStar(__webpack_require__(1));
var vscode_languageserver_1 = __webpack_require__(2);
var constant_1 = __webpack_require__(64);
var completion_1 = __webpack_require__(65);
var completionResolve_1 = __webpack_require__(176);
var definition_1 = __webpack_require__(177);
var documentHighlight_1 = __webpack_require__(178);
var foldingRange_1 = __webpack_require__(179);
var hover_1 = __webpack_require__(180);
var references_1 = __webpack_require__(181);
var rename_1 = __webpack_require__(182);
var signatureHelp_1 = __webpack_require__(183);
var builtin_1 = __webpack_require__(77);
var config_1 = __importDefault(__webpack_require__(73));
var connection_1 = __webpack_require__(156);
var documents_1 = __webpack_require__(74);
var parser_1 = __webpack_require__(184);
var selectionRange_1 = __webpack_require__(388);
var documentSymbol_1 = __webpack_require__(389);
// lsp initialize
connection_1.connection.onInitialize(function (param) {
    var renamePrepareSupport = param.capabilities.textDocument && param.capabilities.textDocument.rename && param.capabilities.textDocument.rename.prepareSupport === true;
    var _a = param.initializationOptions, initializationOptions = _a === void 0 ? {} : _a;
    var isNeovim = initializationOptions.isNeovim, iskeyword = initializationOptions.iskeyword, runtimepath = initializationOptions.runtimepath, vimruntime = initializationOptions.vimruntime, diagnostic = initializationOptions.diagnostic, suggest = initializationOptions.suggest, indexes = initializationOptions.indexes;
    var runtimepaths = runtimepath ? runtimepath.split(",") : [];
    // config by user's initializationOptions
    var conf = {
        isNeovim: isNeovim || false,
        iskeyword: iskeyword || "",
        runtimepath: runtimepaths,
        vimruntime: (vimruntime || "").trim(),
        diagnostic: __assign({ enable: true }, (diagnostic || {})),
        snippetSupport: shvl.get(param, "capabilities.textDocument.completion.completionItem.snippetSupport"),
        suggest: __assign({ fromRuntimepath: false, fromVimruntime: true }, (suggest || {})),
        indexes: __assign({ runtimepath: true, gap: 100, count: 1, projectRootPatterns: constant_1.projectRootPatterns }, (indexes || {})),
        capabilities: param.capabilities
    };
    // init config
    config_1.default.init(conf);
    // init builtin docs
    builtin_1.builtinDocs.init();
    return {
        capabilities: {
            textDocumentSync: vscode_languageserver_1.TextDocumentSyncKind.Incremental,
            documentHighlightProvider: true,
            foldingRangeProvider: true,
            selectionRangeProvider: true,
            documentSymbolProvider: true,
            hoverProvider: true,
            completionProvider: {
                triggerCharacters: [".", ":", "#", "[", "&", "$", "<", '"', "'"],
                resolveProvider: true,
            },
            signatureHelpProvider: {
                triggerCharacters: ["(", ","],
            },
            definitionProvider: true,
            referencesProvider: true,
            renameProvider: renamePrepareSupport ? {
                prepareProvider: true,
            } : true,
        },
    };
});
// document change or open
documents_1.documents.onDidChangeContent(function (change) {
    parser_1.next(change.document);
});
documents_1.documents.onDidClose(function (evt) {
    parser_1.unsubscribe(evt.document);
});
// listen for document's open/close/change
documents_1.documents.listen(connection_1.connection);
// handle completion
connection_1.connection.onCompletion(completion_1.completionProvider);
// handle completion resolve
connection_1.connection.onCompletionResolve(completionResolve_1.completionResolveProvider);
// handle signature help
connection_1.connection.onSignatureHelp(signatureHelp_1.signatureHelpProvider);
// handle hover
connection_1.connection.onHover(hover_1.hoverProvider);
// handle definition request
connection_1.connection.onDefinition(definition_1.definitionProvider);
// handle references
connection_1.connection.onReferences(references_1.referencesProvider);
// handle rename
connection_1.connection.onPrepareRename(rename_1.prepareProvider);
connection_1.connection.onRenameRequest(rename_1.renameProvider);
// document highlight
connection_1.connection.onDocumentHighlight(documentHighlight_1.documentHighlightProvider);
// folding range
connection_1.connection.onFoldingRanges(foldingRange_1.foldingRangeProvider);
// select range
connection_1.connection.onSelectionRanges(selectionRange_1.selectionRangeProvider);
// document symbols
connection_1.connection.onDocumentSymbol(documentSymbol_1.documentSymbolProvider);
connection_1.connection.onNotification('$/change/iskeyword', function (iskeyword) {
    config_1.default.changeByKey('iskeyword', iskeyword);
});
// lsp start
connection_1.connection.listen();


/***/ }),
/* 1 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "get": () => (/* binding */ t),
/* harmony export */   "set": () => (/* binding */ n)
/* harmony export */ });
function t(t,n,r){return void 0===(t=(n.split?n.split("."):n).reduce(function(t,n){return t&&t[n]},t))?r:t}function n(t,n,r,e){return(n=n.split?n.split("."):n).slice(0,-1).reduce(function(t,n){return t[n]=t[n]||{}},t)[n.pop()]=r,t}
//# sourceMappingURL=shvl.mjs.map


/***/ }),
/* 2 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../../typings/thenable.d.ts" />
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createConnection = exports.Files = void 0;
const Is = __webpack_require__(3);
const server_1 = __webpack_require__(4);
const fm = __webpack_require__(58);
const node_1 = __webpack_require__(62);
__exportStar(__webpack_require__(62), exports);
__exportStar(__webpack_require__(63), exports);
var Files;
(function (Files) {
    Files.uriToFilePath = fm.uriToFilePath;
    Files.resolveGlobalNodePath = fm.resolveGlobalNodePath;
    Files.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;
    Files.resolve = fm.resolve;
    Files.resolveModulePath = fm.resolveModulePath;
})(Files = exports.Files || (exports.Files = {}));
let _protocolConnection;
function endProtocolConnection() {
    if (_protocolConnection === undefined) {
        return;
    }
    try {
        _protocolConnection.end();
    }
    catch (_err) {
        // Ignore. The client process could have already
        // did and we can't send an end into the connection.
    }
}
let _shutdownReceived = false;
let exitTimer = undefined;
function setupExitTimer() {
    const argName = '--clientProcessId';
    function runTimer(value) {
        try {
            let processId = parseInt(value);
            if (!isNaN(processId)) {
                exitTimer = setInterval(() => {
                    try {
                        process.kill(processId, 0);
                    }
                    catch (ex) {
                        // Parent process doesn't exist anymore. Exit the server.
                        endProtocolConnection();
                        process.exit(_shutdownReceived ? 0 : 1);
                    }
                }, 3000);
            }
        }
        catch (e) {
            // Ignore errors;
        }
    }
    for (let i = 2; i < process.argv.length; i++) {
        let arg = process.argv[i];
        if (arg === argName && i + 1 < process.argv.length) {
            runTimer(process.argv[i + 1]);
            return;
        }
        else {
            let args = arg.split('=');
            if (args[0] === argName) {
                runTimer(args[1]);
            }
        }
    }
}
setupExitTimer();
const watchDog = {
    initialize: (params) => {
        const processId = params.processId;
        if (Is.number(processId) && exitTimer === undefined) {
            // We received a parent process id. Set up a timer to periodically check
            // if the parent is still alive.
            setInterval(() => {
                try {
                    process.kill(processId, 0);
                }
                catch (ex) {
                    // Parent process doesn't exist anymore. Exit the server.
                    process.exit(_shutdownReceived ? 0 : 1);
                }
            }, 3000);
        }
    },
    get shutdownReceived() {
        return _shutdownReceived;
    },
    set shutdownReceived(value) {
        _shutdownReceived = value;
    },
    exit: (code) => {
        endProtocolConnection();
        process.exit(code);
    }
};
function createConnection(arg1, arg2, arg3, arg4) {
    let factories;
    let input;
    let output;
    let options;
    if (arg1 !== void 0 && arg1.__brand === 'features') {
        factories = arg1;
        arg1 = arg2;
        arg2 = arg3;
        arg3 = arg4;
    }
    if (node_1.ConnectionStrategy.is(arg1) || node_1.ConnectionOptions.is(arg1)) {
        options = arg1;
    }
    else {
        input = arg1;
        output = arg2;
        options = arg3;
    }
    return _createConnection(input, output, options, factories);
}
exports.createConnection = createConnection;
function _createConnection(input, output, options, factories) {
    if (!input && !output && process.argv.length > 2) {
        let port = void 0;
        let pipeName = void 0;
        let argv = process.argv.slice(2);
        for (let i = 0; i < argv.length; i++) {
            let arg = argv[i];
            if (arg === '--node-ipc') {
                input = new node_1.IPCMessageReader(process);
                output = new node_1.IPCMessageWriter(process);
                break;
            }
            else if (arg === '--stdio') {
                input = process.stdin;
                output = process.stdout;
                break;
            }
            else if (arg === '--socket') {
                port = parseInt(argv[i + 1]);
                break;
            }
            else if (arg === '--pipe') {
                pipeName = argv[i + 1];
                break;
            }
            else {
                var args = arg.split('=');
                if (args[0] === '--socket') {
                    port = parseInt(args[1]);
                    break;
                }
                else if (args[0] === '--pipe') {
                    pipeName = args[1];
                    break;
                }
            }
        }
        if (port) {
            let transport = node_1.createServerSocketTransport(port);
            input = transport[0];
            output = transport[1];
        }
        else if (pipeName) {
            let transport = node_1.createServerPipeTransport(pipeName);
            input = transport[0];
            output = transport[1];
        }
    }
    var commandLineMessage = 'Use arguments of createConnection or set command line parameters: \'--node-ipc\', \'--stdio\' or \'--socket={number}\'';
    if (!input) {
        throw new Error('Connection input stream is not set. ' + commandLineMessage);
    }
    if (!output) {
        throw new Error('Connection output stream is not set. ' + commandLineMessage);
    }
    // Backwards compatibility
    if (Is.func(input.read) && Is.func(input.on)) {
        let inputStream = input;
        inputStream.on('end', () => {
            endProtocolConnection();
            process.exit(_shutdownReceived ? 0 : 1);
        });
        inputStream.on('close', () => {
            endProtocolConnection();
            process.exit(_shutdownReceived ? 0 : 1);
        });
    }
    const connectionFactory = (logger) => {
        const result = node_1.createProtocolConnection(input, output, logger, options);
        return result;
    };
    return server_1.createConnection(connectionFactory, watchDog, factories);
}
//# sourceMappingURL=main.js.map

/***/ }),
/* 3 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.thenable = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function thenable(value) {
    return value && func(value.then);
}
exports.thenable = thenable;
//# sourceMappingURL=is.js.map

/***/ }),
/* 4 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createConnection = exports.combineFeatures = exports.combineLanguagesFeatures = exports.combineWorkspaceFeatures = exports.combineWindowFeatures = exports.combineClientFeatures = exports.combineTracerFeatures = exports.combineTelemetryFeatures = exports.combineConsoleFeatures = exports._LanguagesImpl = exports.BulkUnregistration = exports.BulkRegistration = exports.ErrorMessageTracker = exports.TextDocuments = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(5);
const Is = __webpack_require__(3);
const UUID = __webpack_require__(48);
const progress_1 = __webpack_require__(49);
const configuration_1 = __webpack_require__(50);
const workspaceFolders_1 = __webpack_require__(51);
const callHierarchy_1 = __webpack_require__(52);
const semanticTokens_1 = __webpack_require__(53);
const showDocument_1 = __webpack_require__(54);
const fileOperations_1 = __webpack_require__(55);
const linkedEditingRange_1 = __webpack_require__(56);
const moniker_1 = __webpack_require__(57);
function null2Undefined(value) {
    if (value === null) {
        return undefined;
    }
    return value;
}
/**
 * A manager for simple text documents
 */
class TextDocuments {
    /**
     * Create a new text document manager.
     */
    constructor(configuration) {
        this._documents = Object.create(null);
        this._configuration = configuration;
        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been opened or the content changes.
     */
    get onDidChangeContent() {
        return this._onDidChangeContent.event;
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been opened.
     */
    get onDidOpen() {
        return this._onDidOpen.event;
    }
    /**
     * An event that fires when a text document managed by this manager
     * will be saved.
     */
    get onWillSave() {
        return this._onWillSave.event;
    }
    /**
     * Sets a handler that will be called if a participant wants to provide
     * edits during a text document save.
     */
    onWillSaveWaitUntil(handler) {
        this._willSaveWaitUntil = handler;
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been saved.
     */
    get onDidSave() {
        return this._onDidSave.event;
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been closed.
     */
    get onDidClose() {
        return this._onDidClose.event;
    }
    /**
     * Returns the document for the given URI. Returns undefined if
     * the document is not managed by this instance.
     *
     * @param uri The text document's URI to retrieve.
     * @return the text document or `undefined`.
     */
    get(uri) {
        return this._documents[uri];
    }
    /**
     * Returns all text documents managed by this instance.
     *
     * @return all text documents.
     */
    all() {
        return Object.keys(this._documents).map(key => this._documents[key]);
    }
    /**
     * Returns the URIs of all text documents managed by this instance.
     *
     * @return the URI's of all text documents.
     */
    keys() {
        return Object.keys(this._documents);
    }
    /**
     * Listens for `low level` notification on the given connection to
     * update the text documents managed by this instance.
     *
     * Please note that the connection only provides handlers not an event model. Therefore
     * listening on a connection will overwrite the following handlers on a connection:
     * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,
     * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.
     *
     * Use the corresponding events on the TextDocuments instance instead.
     *
     * @param connection The connection to listen on.
     */
    listen(connection) {
        connection.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Full;
        connection.onDidOpenTextDocument((event) => {
            let td = event.textDocument;
            let document = this._configuration.create(td.uri, td.languageId, td.version, td.text);
            this._documents[td.uri] = document;
            let toFire = Object.freeze({ document });
            this._onDidOpen.fire(toFire);
            this._onDidChangeContent.fire(toFire);
        });
        connection.onDidChangeTextDocument((event) => {
            let td = event.textDocument;
            let changes = event.contentChanges;
            if (changes.length === 0) {
                return;
            }
            let document = this._documents[td.uri];
            const { version } = td;
            if (version === null || version === undefined) {
                throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
            }
            document = this._configuration.update(document, changes, version);
            this._documents[td.uri] = document;
            this._onDidChangeContent.fire(Object.freeze({ document }));
        });
        connection.onDidCloseTextDocument((event) => {
            let document = this._documents[event.textDocument.uri];
            if (document) {
                delete this._documents[event.textDocument.uri];
                this._onDidClose.fire(Object.freeze({ document }));
            }
        });
        connection.onWillSaveTextDocument((event) => {
            let document = this._documents[event.textDocument.uri];
            if (document) {
                this._onWillSave.fire(Object.freeze({ document, reason: event.reason }));
            }
        });
        connection.onWillSaveTextDocumentWaitUntil((event, token) => {
            let document = this._documents[event.textDocument.uri];
            if (document && this._willSaveWaitUntil) {
                return this._willSaveWaitUntil(Object.freeze({ document, reason: event.reason }), token);
            }
            else {
                return [];
            }
        });
        connection.onDidSaveTextDocument((event) => {
            let document = this._documents[event.textDocument.uri];
            if (document) {
                this._onDidSave.fire(Object.freeze({ document }));
            }
        });
    }
}
exports.TextDocuments = TextDocuments;
/**
 * Helps tracking error message. Equal occurrences of the same
 * message are only stored once. This class is for example
 * useful if text documents are validated in a loop and equal
 * error message should be folded into one.
 */
class ErrorMessageTracker {
    constructor() {
        this._messages = Object.create(null);
    }
    /**
     * Add a message to the tracker.
     *
     * @param message The message to add.
     */
    add(message) {
        let count = this._messages[message];
        if (!count) {
            count = 0;
        }
        count++;
        this._messages[message] = count;
    }
    /**
     * Send all tracked messages to the connection's window.
     *
     * @param connection The connection established between client and server.
     */
    sendErrors(connection) {
        Object.keys(this._messages).forEach(message => {
            connection.window.showErrorMessage(message);
        });
    }
}
exports.ErrorMessageTracker = ErrorMessageTracker;
class RemoteConsoleImpl {
    constructor() {
    }
    rawAttach(connection) {
        this._rawConnection = connection;
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    fillServerCapabilities(_capabilities) {
    }
    initialize(_capabilities) {
    }
    error(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
    }
    warn(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
    }
    info(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
    }
    log(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
    }
    send(type, message) {
        if (this._rawConnection) {
            this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message });
        }
    }
}
class _RemoteWindowImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    showErrorMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
    showWarningMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
    showInformationMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
}
const RemoteWindowImpl = showDocument_1.ShowDocumentFeature(progress_1.ProgressFeature(_RemoteWindowImpl));
var BulkRegistration;
(function (BulkRegistration) {
    /**
     * Creates a new bulk registration.
     * @return an empty bulk registration.
     */
    function create() {
        return new BulkRegistrationImpl();
    }
    BulkRegistration.create = create;
})(BulkRegistration = exports.BulkRegistration || (exports.BulkRegistration = {}));
class BulkRegistrationImpl {
    constructor() {
        this._registrations = [];
        this._registered = new Set();
    }
    add(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        if (this._registered.has(method)) {
            throw new Error(`${method} is already added to this registration`);
        }
        const id = UUID.generateUuid();
        this._registrations.push({
            id: id,
            method: method,
            registerOptions: registerOptions || {}
        });
        this._registered.add(method);
    }
    asRegistrationParams() {
        return {
            registrations: this._registrations
        };
    }
}
var BulkUnregistration;
(function (BulkUnregistration) {
    function create() {
        return new BulkUnregistrationImpl(undefined, []);
    }
    BulkUnregistration.create = create;
})(BulkUnregistration = exports.BulkUnregistration || (exports.BulkUnregistration = {}));
class BulkUnregistrationImpl {
    constructor(_connection, unregistrations) {
        this._connection = _connection;
        this._unregistrations = new Map();
        unregistrations.forEach(unregistration => {
            this._unregistrations.set(unregistration.method, unregistration);
        });
    }
    get isAttached() {
        return !!this._connection;
    }
    attach(connection) {
        this._connection = connection;
    }
    add(unregistration) {
        this._unregistrations.set(unregistration.method, unregistration);
    }
    dispose() {
        let unregistrations = [];
        for (let unregistration of this._unregistrations.values()) {
            unregistrations.push(unregistration);
        }
        let params = {
            unregisterations: unregistrations
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(undefined, (_error) => {
            this._connection.console.info(`Bulk unregistration failed.`);
        });
    }
    disposeSingle(arg) {
        const method = Is.string(arg) ? arg : arg.method;
        const unregistration = this._unregistrations.get(method);
        if (!unregistration) {
            return false;
        }
        let params = {
            unregisterations: [unregistration]
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
            this._unregistrations.delete(method);
        }, (_error) => {
            this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
        });
        return true;
    }
}
class RemoteClientImpl {
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
            return this.registerMany(typeOrRegistrations);
        }
        else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
            return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
        }
        else {
            return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
        }
    }
    registerSingle1(unregistration, type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
            registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        if (!unregistration.isAttached) {
            unregistration.attach(this.connection);
        }
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
            unregistration.add({ id: id, method: method });
            return unregistration;
        }, (_error) => {
            this.connection.console.info(`Registering request handler for ${method} failed.`);
            return Promise.reject(_error);
        });
    }
    registerSingle2(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
            registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
            return vscode_languageserver_protocol_1.Disposable.create(() => {
                this.unregisterSingle(id, method);
            });
        }, (_error) => {
            this.connection.console.info(`Registering request handler for ${method} failed.`);
            return Promise.reject(_error);
        });
    }
    unregisterSingle(id, method) {
        let params = {
            unregisterations: [{ id, method }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(undefined, (_error) => {
            this.connection.console.info(`Un-registering request handler for ${id} failed.`);
        });
    }
    registerMany(registrations) {
        let params = registrations.asRegistrationParams();
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
            return new BulkUnregistrationImpl(this._connection, params.registrations.map(registration => { return { id: registration.id, method: registration.method }; }));
        }, (_error) => {
            this.connection.console.info(`Bulk registration failed.`);
            return Promise.reject(_error);
        });
    }
}
class _RemoteWorkspaceImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    applyEdit(paramOrEdit) {
        function isApplyWorkspaceEditParams(value) {
            return value && !!value.edit;
        }
        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
    }
}
const RemoteWorkspaceImpl = fileOperations_1.FileOperationsFeature(workspaceFolders_1.WorkspaceFoldersFeature(configuration_1.ConfigurationFeature(_RemoteWorkspaceImpl)));
class TracerImpl {
    constructor() {
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    set trace(value) {
        this._trace = value;
    }
    log(message, verbose) {
        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
            return;
        }
        this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
            message: message,
            verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : undefined
        });
    }
}
class TelemetryImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    logEvent(data) {
        this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data);
    }
}
class _LanguagesImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    attachWorkDoneProgress(params) {
        return progress_1.attachWorkDone(this.connection, params);
    }
    attachPartialResultProgress(_type, params) {
        return progress_1.attachPartialResult(this.connection, params);
    }
}
exports._LanguagesImpl = _LanguagesImpl;
const LanguagesImpl = moniker_1.MonikerFeature(linkedEditingRange_1.LinkedEditingRangeFeature(semanticTokens_1.SemanticTokensFeature(callHierarchy_1.CallHierarchyFeature(_LanguagesImpl))));
function combineConsoleFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineConsoleFeatures = combineConsoleFeatures;
function combineTelemetryFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineTelemetryFeatures = combineTelemetryFeatures;
function combineTracerFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineTracerFeatures = combineTracerFeatures;
function combineClientFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineClientFeatures = combineClientFeatures;
function combineWindowFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineWindowFeatures = combineWindowFeatures;
function combineWorkspaceFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineWorkspaceFeatures = combineWorkspaceFeatures;
function combineLanguagesFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineLanguagesFeatures = combineLanguagesFeatures;
function combineFeatures(one, two) {
    function combine(one, two, func) {
        if (one && two) {
            return func(one, two);
        }
        else if (one) {
            return one;
        }
        else {
            return two;
        }
    }
    let result = {
        __brand: 'features',
        console: combine(one.console, two.console, combineConsoleFeatures),
        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
        client: combine(one.client, two.client, combineClientFeatures),
        window: combine(one.window, two.window, combineWindowFeatures),
        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures)
    };
    return result;
}
exports.combineFeatures = combineFeatures;
function createConnection(connectionFactory, watchDog, factories) {
    const logger = (factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl());
    const connection = connectionFactory(logger);
    logger.rawAttach(connection);
    const tracer = (factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl());
    const telemetry = (factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl());
    const client = (factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl());
    const remoteWindow = (factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl());
    const workspace = (factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl());
    const languages = (factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl());
    const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages];
    function asPromise(value) {
        if (value instanceof Promise) {
            return value;
        }
        else if (Is.thenable(value)) {
            return new Promise((resolve, reject) => {
                value.then((resolved) => resolve(resolved), (error) => reject(error));
            });
        }
        else {
            return Promise.resolve(value);
        }
    }
    let shutdownHandler = undefined;
    let initializeHandler = undefined;
    let exitHandler = undefined;
    let protocolConnection = {
        listen: () => connection.listen(),
        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection.onRequest(type, handler),
        sendNotification: (type, param) => {
            const method = Is.string(type) ? type : type.method;
            if (arguments.length === 1) {
                connection.sendNotification(method);
            }
            else {
                connection.sendNotification(method, param);
            }
        },
        onNotification: (type, handler) => connection.onNotification(type, handler),
        onProgress: connection.onProgress,
        sendProgress: connection.sendProgress,
        onInitialize: (handler) => initializeHandler = handler,
        onInitialized: (handler) => connection.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
        onShutdown: (handler) => shutdownHandler = handler,
        onExit: (handler) => exitHandler = handler,
        get console() { return logger; },
        get telemetry() { return telemetry; },
        get tracer() { return tracer; },
        get client() { return client; },
        get window() { return remoteWindow; },
        get workspace() { return workspace; },
        get languages() { return languages; },
        onDidChangeConfiguration: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
        onDidChangeWatchedFiles: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
        __textDocumentSync: undefined,
        onDidOpenTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
        onDidChangeTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
        onDidCloseTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
        onWillSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
        onWillSaveTextDocumentWaitUntil: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
        onDidSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
        sendDiagnostics: (params) => connection.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
        onHover: (handler) => connection.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
        }),
        onCompletion: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCompletionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
        onSignatureHelp: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
        }),
        onDeclaration: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onTypeDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onImplementation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onReferences: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDocumentHighlight: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDocumentSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onWorkspaceSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCodeAction: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCodeActionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onCodeLens: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCodeLensResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onDocumentFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
        }),
        onDocumentRangeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
        }),
        onDocumentOnTypeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onRenameRequest: (handler) => connection.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
        }),
        onPrepareRename: (handler) => connection.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onDocumentLinks: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDocumentLinkResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onDocumentColor: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onColorPresentation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onFoldingRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onSelectionRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onExecuteCommand: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
        }),
        dispose: () => connection.dispose()
    };
    for (let remote of allRemotes) {
        remote.attach(protocolConnection);
    }
    connection.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
        watchDog.initialize(params);
        if (Is.string(params.trace)) {
            tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
        }
        for (let remote of allRemotes) {
            remote.initialize(params.capabilities);
        }
        if (initializeHandler) {
            let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, progress_1.attachWorkDone(connection, params), undefined);
            return asPromise(result).then((value) => {
                if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
                    return value;
                }
                let result = value;
                if (!result) {
                    result = { capabilities: {} };
                }
                let capabilities = result.capabilities;
                if (!capabilities) {
                    capabilities = {};
                    result.capabilities = capabilities;
                }
                if (capabilities.textDocumentSync === undefined || capabilities.textDocumentSync === null) {
                    capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
                }
                else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {
                    capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
                }
                for (let remote of allRemotes) {
                    remote.fillServerCapabilities(capabilities);
                }
                return result;
            });
        }
        else {
            let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
            for (let remote of allRemotes) {
                remote.fillServerCapabilities(result.capabilities);
            }
            return result;
        }
    });
    connection.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
        watchDog.shutdownReceived = true;
        if (shutdownHandler) {
            return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
        }
        else {
            return undefined;
        }
    });
    connection.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
        try {
            if (exitHandler) {
                exitHandler();
            }
        }
        finally {
            if (watchDog.shutdownReceived) {
                watchDog.exit(0);
            }
            else {
                watchDog.exit(1);
            }
        }
    });
    connection.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
    });
    return protocolConnection;
}
exports.createConnection = createConnection;
//# sourceMappingURL=server.js.map

/***/ }),
/* 5 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createProtocolConnection = void 0;
const node_1 = __webpack_require__(6);
__exportStar(__webpack_require__(6), exports);
__exportStar(__webpack_require__(27), exports);
function createProtocolConnection(input, output, logger, options) {
    return node_1.createMessageConnection(input, output, logger, options);
}
exports.createProtocolConnection = createProtocolConnection;
//# sourceMappingURL=main.js.map

/***/ }),
/* 6 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(7);

/***/ }),
/* 7 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessageConnection = exports.createServerSocketTransport = exports.createClientSocketTransport = exports.createServerPipeTransport = exports.createClientPipeTransport = exports.generateRandomPipeName = exports.StreamMessageWriter = exports.StreamMessageReader = exports.SocketMessageWriter = exports.SocketMessageReader = exports.IPCMessageWriter = exports.IPCMessageReader = void 0;
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */
const ril_1 = __webpack_require__(8);
// Install the node runtime abstract.
ril_1.default.install();
const api_1 = __webpack_require__(13);
const path = __webpack_require__(23);
const os = __webpack_require__(24);
const crypto_1 = __webpack_require__(25);
const net_1 = __webpack_require__(26);
__exportStar(__webpack_require__(13), exports);
class IPCMessageReader extends api_1.AbstractMessageReader {
    constructor(process) {
        super();
        this.process = process;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose());
    }
    listen(callback) {
        this.process.on('message', callback);
        return api_1.Disposable.create(() => this.process.off('message', callback));
    }
}
exports.IPCMessageReader = IPCMessageReader;
class IPCMessageWriter extends api_1.AbstractMessageWriter {
    constructor(process) {
        super();
        this.process = process;
        this.errorCount = 0;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose);
    }
    write(msg) {
        try {
            if (typeof this.process.send === 'function') {
                this.process.send(msg, undefined, undefined, (error) => {
                    if (error) {
                        this.errorCount++;
                        this.handleError(error, msg);
                    }
                    else {
                        this.errorCount = 0;
                    }
                });
            }
            return Promise.resolve();
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
    }
}
exports.IPCMessageWriter = IPCMessageWriter;
class SocketMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(socket, encoding = 'utf-8') {
        super(ril_1.default().stream.asReadableStream(socket), encoding);
    }
}
exports.SocketMessageReader = SocketMessageReader;
class SocketMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(socket, options) {
        super(ril_1.default().stream.asWritableStream(socket), options);
        this.socket = socket;
    }
    dispose() {
        super.dispose();
        this.socket.destroy();
    }
}
exports.SocketMessageWriter = SocketMessageWriter;
class StreamMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(readble, encoding) {
        super(ril_1.default().stream.asReadableStream(readble), encoding);
    }
}
exports.StreamMessageReader = StreamMessageReader;
class StreamMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(writable, options) {
        super(ril_1.default().stream.asWritableStream(writable), options);
    }
}
exports.StreamMessageWriter = StreamMessageWriter;
const XDG_RUNTIME_DIR = process.env['XDG_RUNTIME_DIR'];
const safeIpcPathLengths = new Map([
    ['linux', 107],
    ['darwin', 103]
]);
function generateRandomPipeName() {
    const randomSuffix = crypto_1.randomBytes(21).toString('hex');
    if (process.platform === 'win32') {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
    }
    let result;
    if (XDG_RUNTIME_DIR) {
        result = path.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
    }
    else {
        result = path.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
    }
    const limit = safeIpcPathLengths.get(process.platform);
    if (limit !== undefined && result.length >= limit) {
        ril_1.default().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
    }
    return result;
}
exports.generateRandomPipeName = generateRandomPipeName;
function createClientPipeTransport(pipeName, encoding = 'utf-8') {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        let server = net_1.createServer((socket) => {
            server.close();
            connectResolve([
                new SocketMessageReader(socket, encoding),
                new SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(pipeName, () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientPipeTransport = createClientPipeTransport;
function createServerPipeTransport(pipeName, encoding = 'utf-8') {
    const socket = net_1.createConnection(pipeName);
    return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerPipeTransport = createServerPipeTransport;
function createClientSocketTransport(port, encoding = 'utf-8') {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        const server = net_1.createServer((socket) => {
            server.close();
            connectResolve([
                new SocketMessageReader(socket, encoding),
                new SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(port, '127.0.0.1', () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientSocketTransport = createClientSocketTransport;
function createServerSocketTransport(port, encoding = 'utf-8') {
    const socket = net_1.createConnection(port, '127.0.0.1');
    return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerSocketTransport = createServerSocketTransport;
function isReadableStream(value) {
    const candidate = value;
    return candidate.read !== undefined && candidate.addListener !== undefined;
}
function isWritableStream(value) {
    const candidate = value;
    return candidate.write !== undefined && candidate.addListener !== undefined;
}
function createMessageConnection(input, output, logger, options) {
    if (!logger) {
        logger = api_1.NullLogger;
    }
    const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
    const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
    if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return api_1.createMessageConnection(reader, writer, logger, options);
}
exports.createMessageConnection = createMessageConnection;
//# sourceMappingURL=main.js.map

/***/ }),
/* 8 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ral_1 = __webpack_require__(9);
const util_1 = __webpack_require__(10);
const disposable_1 = __webpack_require__(11);
const messageBuffer_1 = __webpack_require__(12);
class MessageBuffer extends messageBuffer_1.AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        super(encoding);
    }
    emptyBuffer() {
        return MessageBuffer.emptyBuffer;
    }
    fromString(value, encoding) {
        return Buffer.from(value, encoding);
    }
    toString(value, encoding) {
        if (value instanceof Buffer) {
            return value.toString(encoding);
        }
        else {
            return new util_1.TextDecoder(encoding).decode(value);
        }
    }
    asNative(buffer, length) {
        if (length === undefined) {
            return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        }
        else {
            return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
    }
    allocNative(length) {
        return Buffer.allocUnsafe(length);
    }
}
MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
class ReadableStreamWrapper {
    constructor(stream) {
        this.stream = stream;
    }
    onClose(listener) {
        this.stream.on('close', listener);
        return disposable_1.Disposable.create(() => this.stream.off('close', listener));
    }
    onError(listener) {
        this.stream.on('error', listener);
        return disposable_1.Disposable.create(() => this.stream.off('error', listener));
    }
    onEnd(listener) {
        this.stream.on('end', listener);
        return disposable_1.Disposable.create(() => this.stream.off('end', listener));
    }
    onData(listener) {
        this.stream.on('data', listener);
        return disposable_1.Disposable.create(() => this.stream.off('data', listener));
    }
}
class WritableStreamWrapper {
    constructor(stream) {
        this.stream = stream;
    }
    onClose(listener) {
        this.stream.on('close', listener);
        return disposable_1.Disposable.create(() => this.stream.off('close', listener));
    }
    onError(listener) {
        this.stream.on('error', listener);
        return disposable_1.Disposable.create(() => this.stream.off('error', listener));
    }
    onEnd(listener) {
        this.stream.on('end', listener);
        return disposable_1.Disposable.create(() => this.stream.off('end', listener));
    }
    write(data, encoding) {
        return new Promise((resolve, reject) => {
            const callback = (error) => {
                if (error === undefined || error === null) {
                    resolve();
                }
                else {
                    reject(error);
                }
            };
            if (typeof data === 'string') {
                this.stream.write(data, encoding, callback);
            }
            else {
                this.stream.write(data, callback);
            }
        });
    }
    end() {
        this.stream.end();
    }
}
const _ril = Object.freeze({
    messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
    }),
    applicationJson: Object.freeze({
        encoder: Object.freeze({
            name: 'application/json',
            encode: (msg, options) => {
                try {
                    return Promise.resolve(Buffer.from(JSON.stringify(msg, undefined, 0), options.charset));
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
        }),
        decoder: Object.freeze({
            name: 'application/json',
            decode: (buffer, options) => {
                try {
                    if (buffer instanceof Buffer) {
                        return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
                    }
                    else {
                        return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
        })
    }),
    stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
    }),
    console: console,
    timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
            return setTimeout(callback, ms, ...args);
        },
        clearTimeout(handle) {
            clearTimeout(handle);
        },
        setImmediate(callback, ...args) {
            return setImmediate(callback, ...args);
        },
        clearImmediate(handle) {
            clearImmediate(handle);
        }
    })
});
function RIL() {
    return _ril;
}
(function (RIL) {
    function install() {
        ral_1.default.install(_ril);
    }
    RIL.install = install;
})(RIL || (RIL = {}));
exports.default = RIL;
//# sourceMappingURL=ril.js.map

/***/ }),
/* 9 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
let _ral;
function RAL() {
    if (_ral === undefined) {
        throw new Error(`No runtime abstraction layer installed`);
    }
    return _ral;
}
(function (RAL) {
    function install(ral) {
        if (ral === undefined) {
            throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
    }
    RAL.install = install;
})(RAL || (RAL = {}));
exports.default = RAL;
//# sourceMappingURL=ral.js.map

/***/ }),
/* 10 */
/***/ ((module) => {

"use strict";
module.exports = require("util");;

/***/ }),
/* 11 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Disposable = void 0;
var Disposable;
(function (Disposable) {
    function create(func) {
        return {
            dispose: func
        };
    }
    Disposable.create = create;
})(Disposable = exports.Disposable || (exports.Disposable = {}));
//# sourceMappingURL=disposable.js.map

/***/ }),
/* 12 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractMessageBuffer = void 0;
const CR = 13;
const LF = 10;
const CRLF = '\r\n';
class AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
    }
    get encoding() {
        return this._encoding;
    }
    append(chunk) {
        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
    }
    tryReadHeaders() {
        if (this._chunks.length === 0) {
            return undefined;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row: while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column: while (offset < chunk.length) {
                const value = chunk[offset];
                switch (value) {
                    case CR:
                        switch (state) {
                            case 0:
                                state = 1;
                                break;
                            case 2:
                                state = 3;
                                break;
                            default:
                                state = 0;
                        }
                        break;
                    case LF:
                        switch (state) {
                            case 1:
                                state = 2;
                                break;
                            case 3:
                                state = 4;
                                offset++;
                                break row;
                            default:
                                state = 0;
                        }
                        break;
                    default:
                        state = 0;
                }
                offset++;
            }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
        }
        if (state !== 4) {
            return undefined;
        }
        // The buffer contains the two CRLF at the end. So we will
        // have two empty lines after the split at the end as well.
        const buffer = this._read(chunkBytesRead + offset);
        const result = new Map();
        const headers = this.toString(buffer, 'ascii').split(CRLF);
        if (headers.length < 2) {
            return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
            const header = headers[i];
            const index = header.indexOf(':');
            if (index === -1) {
                throw new Error('Message header must separate key and value using :');
            }
            const key = header.substr(0, index);
            const value = header.substr(index + 1).trim();
            result.set(key, value);
        }
        return result;
    }
    tryReadBody(length) {
        if (this._totalLength < length) {
            return undefined;
        }
        return this._read(length);
    }
    get numberOfBytes() {
        return this._totalLength;
    }
    _read(byteCount) {
        if (byteCount === 0) {
            return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
            throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
            // super fast path, precisely first chunk must be returned
            const chunk = this._chunks[0];
            this._chunks.shift();
            this._totalLength -= byteCount;
            return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
            // fast path, the reading is entirely within the first chunk
            const chunk = this._chunks[0];
            const result = this.asNative(chunk, byteCount);
            this._chunks[0] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            return result;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
            const chunk = this._chunks[chunkIndex];
            if (chunk.byteLength > byteCount) {
                // this chunk will survive
                const chunkPart = chunk.slice(0, byteCount);
                result.set(chunkPart, resultOffset);
                resultOffset += byteCount;
                this._chunks[chunkIndex] = chunk.slice(byteCount);
                this._totalLength -= byteCount;
                byteCount -= byteCount;
            }
            else {
                // this chunk will be entirely read
                result.set(chunk, resultOffset);
                resultOffset += chunk.byteLength;
                this._chunks.shift();
                this._totalLength -= chunk.byteLength;
                byteCount -= chunk.byteLength;
            }
        }
        return result;
    }
}
exports.AbstractMessageBuffer = AbstractMessageBuffer;
//# sourceMappingURL=messageBuffer.js.map

/***/ }),
/* 13 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../../typings/thenable.d.ts" />
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.Trace = exports.ProgressType = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.RAL = void 0;
exports.CancellationStrategy = void 0;
const messages_1 = __webpack_require__(14);
Object.defineProperty(exports, "RequestType", ({ enumerable: true, get: function () { return messages_1.RequestType; } }));
Object.defineProperty(exports, "RequestType0", ({ enumerable: true, get: function () { return messages_1.RequestType0; } }));
Object.defineProperty(exports, "RequestType1", ({ enumerable: true, get: function () { return messages_1.RequestType1; } }));
Object.defineProperty(exports, "RequestType2", ({ enumerable: true, get: function () { return messages_1.RequestType2; } }));
Object.defineProperty(exports, "RequestType3", ({ enumerable: true, get: function () { return messages_1.RequestType3; } }));
Object.defineProperty(exports, "RequestType4", ({ enumerable: true, get: function () { return messages_1.RequestType4; } }));
Object.defineProperty(exports, "RequestType5", ({ enumerable: true, get: function () { return messages_1.RequestType5; } }));
Object.defineProperty(exports, "RequestType6", ({ enumerable: true, get: function () { return messages_1.RequestType6; } }));
Object.defineProperty(exports, "RequestType7", ({ enumerable: true, get: function () { return messages_1.RequestType7; } }));
Object.defineProperty(exports, "RequestType8", ({ enumerable: true, get: function () { return messages_1.RequestType8; } }));
Object.defineProperty(exports, "RequestType9", ({ enumerable: true, get: function () { return messages_1.RequestType9; } }));
Object.defineProperty(exports, "ResponseError", ({ enumerable: true, get: function () { return messages_1.ResponseError; } }));
Object.defineProperty(exports, "ErrorCodes", ({ enumerable: true, get: function () { return messages_1.ErrorCodes; } }));
Object.defineProperty(exports, "NotificationType", ({ enumerable: true, get: function () { return messages_1.NotificationType; } }));
Object.defineProperty(exports, "NotificationType0", ({ enumerable: true, get: function () { return messages_1.NotificationType0; } }));
Object.defineProperty(exports, "NotificationType1", ({ enumerable: true, get: function () { return messages_1.NotificationType1; } }));
Object.defineProperty(exports, "NotificationType2", ({ enumerable: true, get: function () { return messages_1.NotificationType2; } }));
Object.defineProperty(exports, "NotificationType3", ({ enumerable: true, get: function () { return messages_1.NotificationType3; } }));
Object.defineProperty(exports, "NotificationType4", ({ enumerable: true, get: function () { return messages_1.NotificationType4; } }));
Object.defineProperty(exports, "NotificationType5", ({ enumerable: true, get: function () { return messages_1.NotificationType5; } }));
Object.defineProperty(exports, "NotificationType6", ({ enumerable: true, get: function () { return messages_1.NotificationType6; } }));
Object.defineProperty(exports, "NotificationType7", ({ enumerable: true, get: function () { return messages_1.NotificationType7; } }));
Object.defineProperty(exports, "NotificationType8", ({ enumerable: true, get: function () { return messages_1.NotificationType8; } }));
Object.defineProperty(exports, "NotificationType9", ({ enumerable: true, get: function () { return messages_1.NotificationType9; } }));
Object.defineProperty(exports, "ParameterStructures", ({ enumerable: true, get: function () { return messages_1.ParameterStructures; } }));
const disposable_1 = __webpack_require__(11);
Object.defineProperty(exports, "Disposable", ({ enumerable: true, get: function () { return disposable_1.Disposable; } }));
const events_1 = __webpack_require__(16);
Object.defineProperty(exports, "Event", ({ enumerable: true, get: function () { return events_1.Event; } }));
Object.defineProperty(exports, "Emitter", ({ enumerable: true, get: function () { return events_1.Emitter; } }));
const cancellation_1 = __webpack_require__(17);
Object.defineProperty(exports, "CancellationTokenSource", ({ enumerable: true, get: function () { return cancellation_1.CancellationTokenSource; } }));
Object.defineProperty(exports, "CancellationToken", ({ enumerable: true, get: function () { return cancellation_1.CancellationToken; } }));
const messageReader_1 = __webpack_require__(18);
Object.defineProperty(exports, "MessageReader", ({ enumerable: true, get: function () { return messageReader_1.MessageReader; } }));
Object.defineProperty(exports, "AbstractMessageReader", ({ enumerable: true, get: function () { return messageReader_1.AbstractMessageReader; } }));
Object.defineProperty(exports, "ReadableStreamMessageReader", ({ enumerable: true, get: function () { return messageReader_1.ReadableStreamMessageReader; } }));
const messageWriter_1 = __webpack_require__(19);
Object.defineProperty(exports, "MessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.MessageWriter; } }));
Object.defineProperty(exports, "AbstractMessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.AbstractMessageWriter; } }));
Object.defineProperty(exports, "WriteableStreamMessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.WriteableStreamMessageWriter; } }));
const connection_1 = __webpack_require__(21);
Object.defineProperty(exports, "ConnectionStrategy", ({ enumerable: true, get: function () { return connection_1.ConnectionStrategy; } }));
Object.defineProperty(exports, "ConnectionOptions", ({ enumerable: true, get: function () { return connection_1.ConnectionOptions; } }));
Object.defineProperty(exports, "NullLogger", ({ enumerable: true, get: function () { return connection_1.NullLogger; } }));
Object.defineProperty(exports, "createMessageConnection", ({ enumerable: true, get: function () { return connection_1.createMessageConnection; } }));
Object.defineProperty(exports, "ProgressType", ({ enumerable: true, get: function () { return connection_1.ProgressType; } }));
Object.defineProperty(exports, "Trace", ({ enumerable: true, get: function () { return connection_1.Trace; } }));
Object.defineProperty(exports, "TraceFormat", ({ enumerable: true, get: function () { return connection_1.TraceFormat; } }));
Object.defineProperty(exports, "SetTraceNotification", ({ enumerable: true, get: function () { return connection_1.SetTraceNotification; } }));
Object.defineProperty(exports, "LogTraceNotification", ({ enumerable: true, get: function () { return connection_1.LogTraceNotification; } }));
Object.defineProperty(exports, "ConnectionErrors", ({ enumerable: true, get: function () { return connection_1.ConnectionErrors; } }));
Object.defineProperty(exports, "ConnectionError", ({ enumerable: true, get: function () { return connection_1.ConnectionError; } }));
Object.defineProperty(exports, "CancellationReceiverStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationReceiverStrategy; } }));
Object.defineProperty(exports, "CancellationSenderStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationSenderStrategy; } }));
Object.defineProperty(exports, "CancellationStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationStrategy; } }));
const ral_1 = __webpack_require__(9);
exports.RAL = ral_1.default;
//# sourceMappingURL=api.js.map

/***/ }),
/* 14 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isResponseMessage = exports.isNotificationMessage = exports.isRequestMessage = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
const is = __webpack_require__(15);
/**
 * Predefined error codes.
 */
var ErrorCodes;
(function (ErrorCodes) {
    // Defined by JSON RPC
    ErrorCodes.ParseError = -32700;
    ErrorCodes.InvalidRequest = -32600;
    ErrorCodes.MethodNotFound = -32601;
    ErrorCodes.InvalidParams = -32602;
    ErrorCodes.InternalError = -32603;
    /**
     * This is the start range of JSON RPC reserved error codes.
     * It doesn't denote a real error code. No application error codes should
     * be defined between the start and end range. For backwards
     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
     * are left in the range.
     *
     * @since 3.16.0
    */
    ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
    /** @deprecated use  jsonrpcReservedErrorRangeStart */
    ErrorCodes.serverErrorStart = ErrorCodes.jsonrpcReservedErrorRangeStart;
    ErrorCodes.MessageWriteError = -32099;
    ErrorCodes.MessageReadError = -32098;
    ErrorCodes.ServerNotInitialized = -32002;
    ErrorCodes.UnknownErrorCode = -32001;
    /**
     * This is the end range of JSON RPC reserved error codes.
     * It doesn't denote a real error code.
     *
     * @since 3.16.0
    */
    ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
    /** @deprecated use  jsonrpcReservedErrorRangeEnd */
    ErrorCodes.serverErrorEnd = ErrorCodes.jsonrpcReservedErrorRangeEnd;
})(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
/**
 * An error object return in a response in case a request
 * has failed.
 */
class ResponseError extends Error {
    constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
    }
    toJson() {
        return {
            code: this.code,
            message: this.message,
            data: this.data,
        };
    }
}
exports.ResponseError = ResponseError;
class ParameterStructures {
    constructor(kind) {
        this.kind = kind;
    }
    static is(value) {
        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
    }
    toString() {
        return this.kind;
    }
}
exports.ParameterStructures = ParameterStructures;
/**
 * The parameter structure is automatically inferred on the number of parameters
 * and the parameter type in case of a single param.
 */
ParameterStructures.auto = new ParameterStructures('auto');
/**
 * Forces `byPosition` parameter structure. This is useful if you have a single
 * parameter which has a literal type.
 */
ParameterStructures.byPosition = new ParameterStructures('byPosition');
/**
 * Forces `byName` parameter structure. This is only useful when having a single
 * parameter. The library will report errors if used with a different number of
 * parameters.
 */
ParameterStructures.byName = new ParameterStructures('byName');
/**
 * An abstract implementation of a MessageType.
 */
class AbstractMessageSignature {
    constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
    }
    get parameterStructures() {
        return ParameterStructures.auto;
    }
}
exports.AbstractMessageSignature = AbstractMessageSignature;
/**
 * Classes to type request response pairs
 */
class RequestType0 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 0);
    }
}
exports.RequestType0 = RequestType0;
class RequestType extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.RequestType = RequestType;
class RequestType1 extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.RequestType1 = RequestType1;
class RequestType2 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 2);
    }
}
exports.RequestType2 = RequestType2;
class RequestType3 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 3);
    }
}
exports.RequestType3 = RequestType3;
class RequestType4 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 4);
    }
}
exports.RequestType4 = RequestType4;
class RequestType5 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 5);
    }
}
exports.RequestType5 = RequestType5;
class RequestType6 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 6);
    }
}
exports.RequestType6 = RequestType6;
class RequestType7 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 7);
    }
}
exports.RequestType7 = RequestType7;
class RequestType8 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 8);
    }
}
exports.RequestType8 = RequestType8;
class RequestType9 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 9);
    }
}
exports.RequestType9 = RequestType9;
class NotificationType extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.NotificationType = NotificationType;
class NotificationType0 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 0);
    }
}
exports.NotificationType0 = NotificationType0;
class NotificationType1 extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.NotificationType1 = NotificationType1;
class NotificationType2 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 2);
    }
}
exports.NotificationType2 = NotificationType2;
class NotificationType3 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 3);
    }
}
exports.NotificationType3 = NotificationType3;
class NotificationType4 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 4);
    }
}
exports.NotificationType4 = NotificationType4;
class NotificationType5 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 5);
    }
}
exports.NotificationType5 = NotificationType5;
class NotificationType6 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 6);
    }
}
exports.NotificationType6 = NotificationType6;
class NotificationType7 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 7);
    }
}
exports.NotificationType7 = NotificationType7;
class NotificationType8 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 8);
    }
}
exports.NotificationType8 = NotificationType8;
class NotificationType9 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 9);
    }
}
exports.NotificationType9 = NotificationType9;
/**
 * Tests if the given message is a request message
 */
function isRequestMessage(message) {
    const candidate = message;
    return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
}
exports.isRequestMessage = isRequestMessage;
/**
 * Tests if the given message is a notification message
 */
function isNotificationMessage(message) {
    const candidate = message;
    return candidate && is.string(candidate.method) && message.id === void 0;
}
exports.isNotificationMessage = isNotificationMessage;
/**
 * Tests if the given message is a response message
 */
function isResponseMessage(message) {
    const candidate = message;
    return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
}
exports.isResponseMessage = isResponseMessage;
//# sourceMappingURL=messages.js.map

/***/ }),
/* 15 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
//# sourceMappingURL=is.js.map

/***/ }),
/* 16 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Emitter = exports.Event = void 0;
const ral_1 = __webpack_require__(9);
var Event;
(function (Event) {
    const _disposable = { dispose() { } };
    Event.None = function () { return _disposable; };
})(Event = exports.Event || (exports.Event = {}));
class CallbackList {
    add(callback, context = null, bucket) {
        if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
        }
    }
    remove(callback, context = null) {
        if (!this._callbacks) {
            return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
                if (this._contexts[i] === context) {
                    // callback & context match => remove it
                    this._callbacks.splice(i, 1);
                    this._contexts.splice(i, 1);
                    return;
                }
                else {
                    foundCallbackWithDifferentContext = true;
                }
            }
        }
        if (foundCallbackWithDifferentContext) {
            throw new Error('When adding a listener with a context, you should remove it with the same context');
        }
    }
    invoke(...args) {
        if (!this._callbacks) {
            return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
            try {
                ret.push(callbacks[i].apply(contexts[i], args));
            }
            catch (e) {
                // eslint-disable-next-line no-console
                ral_1.default().console.error(e);
            }
        }
        return ret;
    }
    isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
        this._callbacks = undefined;
        this._contexts = undefined;
    }
}
class Emitter {
    constructor(_options) {
        this._options = _options;
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
        if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
                if (!this._callbacks) {
                    this._callbacks = new CallbackList();
                }
                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                    this._options.onFirstListenerAdd(this);
                }
                this._callbacks.add(listener, thisArgs);
                const result = {
                    dispose: () => {
                        if (!this._callbacks) {
                            // disposable is disposed after emitter is disposed.
                            return;
                        }
                        this._callbacks.remove(listener, thisArgs);
                        result.dispose = Emitter._noop;
                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                            this._options.onLastListenerRemove(this);
                        }
                    }
                };
                if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        }
        return this._event;
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
        if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
        }
    }
    dispose() {
        if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = undefined;
        }
    }
}
exports.Emitter = Emitter;
Emitter._noop = function () { };
//# sourceMappingURL=events.js.map

/***/ }),
/* 17 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CancellationTokenSource = exports.CancellationToken = void 0;
const ral_1 = __webpack_require__(9);
const Is = __webpack_require__(15);
const events_1 = __webpack_require__(16);
var CancellationToken;
(function (CancellationToken) {
    CancellationToken.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
    });
    CancellationToken.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
    });
    function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken.None
            || candidate === CancellationToken.Cancelled
            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));
    }
    CancellationToken.is = is;
})(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
const shortcutEvent = Object.freeze(function (callback, context) {
    const handle = ral_1.default().timer.setTimeout(callback.bind(context), 0);
    return { dispose() { ral_1.default().timer.clearTimeout(handle); } };
});
class MutableToken {
    constructor() {
        this._isCancelled = false;
    }
    cancel() {
        if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
                this._emitter.fire(undefined);
                this.dispose();
            }
        }
    }
    get isCancellationRequested() {
        return this._isCancelled;
    }
    get onCancellationRequested() {
        if (this._isCancelled) {
            return shortcutEvent;
        }
        if (!this._emitter) {
            this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
    }
    dispose() {
        if (this._emitter) {
            this._emitter.dispose();
            this._emitter = undefined;
        }
    }
}
class CancellationTokenSource {
    get token() {
        if (!this._token) {
            // be lazy and create the token only when
            // actually needed
            this._token = new MutableToken();
        }
        return this._token;
    }
    cancel() {
        if (!this._token) {
            // save an object by returning the default
            // cancelled token when cancellation happens
            // before someone asks for the token
            this._token = CancellationToken.Cancelled;
        }
        else {
            this._token.cancel();
        }
    }
    dispose() {
        if (!this._token) {
            // ensure to initialize with an empty token if we had none
            this._token = CancellationToken.None;
        }
        else if (this._token instanceof MutableToken) {
            // actually dispose
            this._token.dispose();
        }
    }
}
exports.CancellationTokenSource = CancellationTokenSource;
//# sourceMappingURL=cancellation.js.map

/***/ }),
/* 18 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
const ral_1 = __webpack_require__(9);
const Is = __webpack_require__(15);
const events_1 = __webpack_require__(16);
var MessageReader;
(function (MessageReader) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&
            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
    }
    MessageReader.is = is;
})(MessageReader = exports.MessageReader || (exports.MessageReader = {}));
class AbstractMessageReader {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error) {
        this.errorEmitter.fire(this.asError(error));
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    get onPartialMessage() {
        return this.partialMessageEmitter.event;
    }
    firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageReader = AbstractMessageReader;
var ResolvedMessageReaderOptions;
(function (ResolvedMessageReaderOptions) {
    function fromOptions(options) {
        var _a;
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = new Map();
        if (options === undefined || typeof options === 'string') {
            charset = options !== null && options !== void 0 ? options : 'utf-8';
        }
        else {
            charset = (_a = options.charset) !== null && _a !== void 0 ? _a : 'utf-8';
            if (options.contentDecoder !== undefined) {
                contentDecoder = options.contentDecoder;
                contentDecoders.set(contentDecoder.name, contentDecoder);
            }
            if (options.contentDecoders !== undefined) {
                for (const decoder of options.contentDecoders) {
                    contentDecoders.set(decoder.name, decoder);
                }
            }
            if (options.contentTypeDecoder !== undefined) {
                contentTypeDecoder = options.contentTypeDecoder;
                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
            }
            if (options.contentTypeDecoders !== undefined) {
                for (const decoder of options.contentTypeDecoders) {
                    contentTypeDecoders.set(decoder.name, decoder);
                }
            }
        }
        if (contentTypeDecoder === undefined) {
            contentTypeDecoder = ral_1.default().applicationJson.decoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
    }
    ResolvedMessageReaderOptions.fromOptions = fromOptions;
})(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
class ReadableStreamMessageReader extends AbstractMessageReader {
    constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = ral_1.default().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 10000;
        this.nextMessageLength = -1;
        this.messageToken = 0;
    }
    set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
    }
    get partialMessageTimeout() {
        return this._partialMessageTimeout;
    }
    listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = undefined;
        this.callback = callback;
        const result = this.readable.onData((data) => {
            this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
    }
    onData(data) {
        this.buffer.append(data);
        while (true) {
            if (this.nextMessageLength === -1) {
                const headers = this.buffer.tryReadHeaders();
                if (!headers) {
                    return;
                }
                const contentLength = headers.get('Content-Length');
                if (!contentLength) {
                    throw new Error('Header must provide a Content-Length property.');
                }
                const length = parseInt(contentLength);
                if (isNaN(length)) {
                    throw new Error('Content-Length value must be a number.');
                }
                this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === undefined) {
                /** We haven't received the full message yet. */
                this.setPartialMessageTimer();
                return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            let p;
            if (this.options.contentDecoder !== undefined) {
                p = this.options.contentDecoder.decode(body);
            }
            else {
                p = Promise.resolve(body);
            }
            p.then((value) => {
                this.options.contentTypeDecoder.decode(value, this.options).then((msg) => {
                    this.callback(msg);
                }, (error) => {
                    this.fireError(error);
                });
            }, (error) => {
                this.fireError(error);
            });
        }
    }
    clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
            ral_1.default().timer.clearTimeout(this.partialMessageTimer);
            this.partialMessageTimer = undefined;
        }
    }
    setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
            return;
        }
        this.partialMessageTimer = ral_1.default().timer.setTimeout((token, timeout) => {
            this.partialMessageTimer = undefined;
            if (token === this.messageToken) {
                this.firePartialMessage({ messageToken: token, waitingTime: timeout });
                this.setPartialMessageTimer();
            }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
    }
}
exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
//# sourceMappingURL=messageReader.js.map

/***/ }),
/* 19 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
const ral_1 = __webpack_require__(9);
const Is = __webpack_require__(15);
const semaphore_1 = __webpack_require__(20);
const events_1 = __webpack_require__(16);
const ContentLength = 'Content-Length: ';
const CRLF = '\r\n';
var MessageWriter;
(function (MessageWriter) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&
            Is.func(candidate.onError) && Is.func(candidate.write);
    }
    MessageWriter.is = is;
})(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));
class AbstractMessageWriter {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageWriter = AbstractMessageWriter;
var ResolvedMessageWriterOptions;
(function (ResolvedMessageWriterOptions) {
    function fromOptions(options) {
        var _a, _b;
        if (options === undefined || typeof options === 'string') {
            return { charset: options !== null && options !== void 0 ? options : 'utf-8', contentTypeEncoder: ral_1.default().applicationJson.encoder };
        }
        else {
            return { charset: (_a = options.charset) !== null && _a !== void 0 ? _a : 'utf-8', contentEncoder: options.contentEncoder, contentTypeEncoder: (_b = options.contentTypeEncoder) !== null && _b !== void 0 ? _b : ral_1.default().applicationJson.encoder };
        }
    }
    ResolvedMessageWriterOptions.fromOptions = fromOptions;
})(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
class WriteableStreamMessageWriter extends AbstractMessageWriter {
    constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
    }
    async write(msg) {
        return this.writeSemaphore.lock(async () => {
            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
                if (this.options.contentEncoder !== undefined) {
                    return this.options.contentEncoder.encode(buffer);
                }
                else {
                    return buffer;
                }
            });
            return payload.then((buffer) => {
                const headers = [];
                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
                headers.push(CRLF);
                return this.doWrite(msg, headers, buffer);
            }, (error) => {
                this.fireError(error);
                throw error;
            });
        });
    }
    async doWrite(msg, headers, data) {
        try {
            await this.writable.write(headers.join(''), 'ascii');
            return this.writable.write(data);
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
        this.writable.end();
    }
}
exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
//# sourceMappingURL=messageWriter.js.map

/***/ }),
/* 20 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Semaphore = void 0;
const ral_1 = __webpack_require__(9);
class Semaphore {
    constructor(capacity = 1) {
        if (capacity <= 0) {
            throw new Error('Capacity must be greater than 0');
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
    }
    lock(thunk) {
        return new Promise((resolve, reject) => {
            this._waiting.push({ thunk, resolve, reject });
            this.runNext();
        });
    }
    get active() {
        return this._active;
    }
    runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        ral_1.default().timer.setImmediate(() => this.doRunNext());
    }
    doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
        }
        try {
            const result = next.thunk();
            if (result instanceof Promise) {
                result.then((value) => {
                    this._active--;
                    next.resolve(value);
                    this.runNext();
                }, (err) => {
                    this._active--;
                    next.reject(err);
                    this.runNext();
                });
            }
            else {
                this._active--;
                next.resolve(result);
                this.runNext();
            }
        }
        catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
        }
    }
}
exports.Semaphore = Semaphore;
//# sourceMappingURL=semaphore.js.map

/***/ }),
/* 21 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessageConnection = exports.ConnectionOptions = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.Trace = exports.NullLogger = exports.ProgressType = void 0;
const ral_1 = __webpack_require__(9);
const Is = __webpack_require__(15);
const messages_1 = __webpack_require__(14);
const linkedMap_1 = __webpack_require__(22);
const events_1 = __webpack_require__(16);
const cancellation_1 = __webpack_require__(17);
var CancelNotification;
(function (CancelNotification) {
    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
})(CancelNotification || (CancelNotification = {}));
var ProgressNotification;
(function (ProgressNotification) {
    ProgressNotification.type = new messages_1.NotificationType('$/progress');
})(ProgressNotification || (ProgressNotification = {}));
class ProgressType {
    constructor() {
    }
}
exports.ProgressType = ProgressType;
var StarRequestHandler;
(function (StarRequestHandler) {
    function is(value) {
        return Is.func(value);
    }
    StarRequestHandler.is = is;
})(StarRequestHandler || (StarRequestHandler = {}));
exports.NullLogger = Object.freeze({
    error: () => { },
    warn: () => { },
    info: () => { },
    log: () => { }
});
var Trace;
(function (Trace) {
    Trace[Trace["Off"] = 0] = "Off";
    Trace[Trace["Messages"] = 1] = "Messages";
    Trace[Trace["Verbose"] = 2] = "Verbose";
})(Trace = exports.Trace || (exports.Trace = {}));
(function (Trace) {
    function fromString(value) {
        if (!Is.string(value)) {
            return Trace.Off;
        }
        value = value.toLowerCase();
        switch (value) {
            case 'off':
                return Trace.Off;
            case 'messages':
                return Trace.Messages;
            case 'verbose':
                return Trace.Verbose;
            default:
                return Trace.Off;
        }
    }
    Trace.fromString = fromString;
    function toString(value) {
        switch (value) {
            case Trace.Off:
                return 'off';
            case Trace.Messages:
                return 'messages';
            case Trace.Verbose:
                return 'verbose';
            default:
                return 'off';
        }
    }
    Trace.toString = toString;
})(Trace = exports.Trace || (exports.Trace = {}));
var TraceFormat;
(function (TraceFormat) {
    TraceFormat["Text"] = "text";
    TraceFormat["JSON"] = "json";
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
(function (TraceFormat) {
    function fromString(value) {
        value = value.toLowerCase();
        if (value === 'json') {
            return TraceFormat.JSON;
        }
        else {
            return TraceFormat.Text;
        }
    }
    TraceFormat.fromString = fromString;
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
var SetTraceNotification;
(function (SetTraceNotification) {
    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
})(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));
var LogTraceNotification;
(function (LogTraceNotification) {
    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
})(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));
var ConnectionErrors;
(function (ConnectionErrors) {
    /**
     * The connection is closed.
     */
    ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
    /**
     * The connection got disposed.
     */
    ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
    /**
     * The connection is already in listening mode.
     */
    ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
})(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));
class ConnectionError extends Error {
    constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
    }
}
exports.ConnectionError = ConnectionError;
var ConnectionStrategy;
(function (ConnectionStrategy) {
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
    }
    ConnectionStrategy.is = is;
})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));
var CancellationReceiverStrategy;
(function (CancellationReceiverStrategy) {
    CancellationReceiverStrategy.Message = Object.freeze({
        createCancellationTokenSource(_) {
            return new cancellation_1.CancellationTokenSource();
        }
    });
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.createCancellationTokenSource);
    }
    CancellationReceiverStrategy.is = is;
})(CancellationReceiverStrategy = exports.CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = {}));
var CancellationSenderStrategy;
(function (CancellationSenderStrategy) {
    CancellationSenderStrategy.Message = Object.freeze({
        sendCancellation(conn, id) {
            conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) { }
    });
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
    }
    CancellationSenderStrategy.is = is;
})(CancellationSenderStrategy = exports.CancellationSenderStrategy || (exports.CancellationSenderStrategy = {}));
var CancellationStrategy;
(function (CancellationStrategy) {
    CancellationStrategy.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
    });
    function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
    }
    CancellationStrategy.is = is;
})(CancellationStrategy = exports.CancellationStrategy || (exports.CancellationStrategy = {}));
var ConnectionOptions;
(function (ConnectionOptions) {
    function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
    }
    ConnectionOptions.is = is;
})(ConnectionOptions = exports.ConnectionOptions || (exports.ConnectionOptions = {}));
var ConnectionState;
(function (ConnectionState) {
    ConnectionState[ConnectionState["New"] = 1] = "New";
    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
})(ConnectionState || (ConnectionState = {}));
function createMessageConnection(messageReader, messageWriter, _logger, options) {
    const logger = _logger !== undefined ? _logger : exports.NullLogger;
    let sequenceNumber = 0;
    let notificationSquenceNumber = 0;
    let unknownResponseSquenceNumber = 0;
    const version = '2.0';
    let starRequestHandler = undefined;
    const requestHandlers = Object.create(null);
    let starNotificationHandler = undefined;
    const notificationHandlers = Object.create(null);
    const progressHandlers = new Map();
    let timer;
    let messageQueue = new linkedMap_1.LinkedMap();
    let responsePromises = Object.create(null);
    let requestTokens = Object.create(null);
    let trace = Trace.Off;
    let traceFormat = TraceFormat.Text;
    let tracer;
    let state = ConnectionState.New;
    const errorEmitter = new events_1.Emitter();
    const closeEmitter = new events_1.Emitter();
    const unhandledNotificationEmitter = new events_1.Emitter();
    const unhandledProgressEmitter = new events_1.Emitter();
    const disposeEmitter = new events_1.Emitter();
    const cancellationStrategy = (options && options.cancellationStrategy) ? options.cancellationStrategy : CancellationStrategy.Message;
    function createRequestQueueKey(id) {
        if (id === null) {
            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return 'req-' + id.toString();
    }
    function createResponseQueueKey(id) {
        if (id === null) {
            return 'res-unknown-' + (++unknownResponseSquenceNumber).toString();
        }
        else {
            return 'res-' + id.toString();
        }
    }
    function createNotificationQueueKey() {
        return 'not-' + (++notificationSquenceNumber).toString();
    }
    function addMessageToQueue(queue, message) {
        if (messages_1.isRequestMessage(message)) {
            queue.set(createRequestQueueKey(message.id), message);
        }
        else if (messages_1.isResponseMessage(message)) {
            queue.set(createResponseQueueKey(message.id), message);
        }
        else {
            queue.set(createNotificationQueueKey(), message);
        }
    }
    function cancelUndispatched(_message) {
        return undefined;
    }
    function isListening() {
        return state === ConnectionState.Listening;
    }
    function isClosed() {
        return state === ConnectionState.Closed;
    }
    function isDisposed() {
        return state === ConnectionState.Disposed;
    }
    function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(undefined);
        }
        // If the connection is disposed don't sent close events.
    }
    function readErrorHandler(error) {
        errorEmitter.fire([error, undefined, undefined]);
    }
    function writeErrorHandler(data) {
        errorEmitter.fire(data);
    }
    messageReader.onClose(closeHandler);
    messageReader.onError(readErrorHandler);
    messageWriter.onClose(closeHandler);
    messageWriter.onError(writeErrorHandler);
    function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
            return;
        }
        timer = ral_1.default().timer.setImmediate(() => {
            timer = undefined;
            processMessageQueue();
        });
    }
    function processMessageQueue() {
        if (messageQueue.size === 0) {
            return;
        }
        const message = messageQueue.shift();
        try {
            if (messages_1.isRequestMessage(message)) {
                handleRequest(message);
            }
            else if (messages_1.isNotificationMessage(message)) {
                handleNotification(message);
            }
            else if (messages_1.isResponseMessage(message)) {
                handleResponse(message);
            }
            else {
                handleInvalidMessage(message);
            }
        }
        finally {
            triggerMessageQueue();
        }
    }
    const callback = (message) => {
        try {
            // We have received a cancellation message. Check if the message is still in the queue
            // and cancel it if allowed to do so.
            if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
                const key = createRequestQueueKey(message.params.id);
                const toCancel = messageQueue.get(key);
                if (messages_1.isRequestMessage(toCancel)) {
                    const strategy = options === null || options === void 0 ? void 0 : options.connectionStrategy;
                    const response = (strategy && strategy.cancelUndispatched) ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                    if (response && (response.error !== undefined || response.result !== undefined)) {
                        messageQueue.delete(key);
                        response.id = toCancel.id;
                        traceSendingResponse(response, message.method, Date.now());
                        messageWriter.write(response);
                        return;
                    }
                }
            }
            addMessageToQueue(messageQueue, message);
        }
        finally {
            triggerMessageQueue();
        }
    };
    function handleRequest(requestMessage) {
        if (isDisposed()) {
            // we return here silently since we fired an event when the
            // connection got disposed.
            return;
        }
        function reply(resultOrError, method, startTime) {
            const message = {
                jsonrpc: version,
                id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
                message.error = resultOrError.toJson();
            }
            else {
                message.result = resultOrError === undefined ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        function replyError(error, method, startTime) {
            const message = {
                jsonrpc: version,
                id: requestMessage.id,
                error: error.toJson()
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        function replySuccess(result, method, startTime) {
            // The JSON RPC defines that a response must either have a result or an error
            // So we can't treat undefined as a valid response result.
            if (result === undefined) {
                result = null;
            }
            const message = {
                jsonrpc: version,
                id: requestMessage.id,
                result: result
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers[requestMessage.method];
        let type;
        let requestHandler;
        if (element) {
            type = element.type;
            requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
            const tokenKey = String(requestMessage.id);
            const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
            requestTokens[tokenKey] = cancellationSource;
            try {
                let handlerResult;
                if (requestHandler) {
                    if (requestMessage.params === undefined) {
                        if (type !== undefined && type.numberOfParams !== 0) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but recevied none.`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(cancellationSource.token);
                    }
                    else if (Array.isArray(requestMessage.params)) {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                    }
                    else {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                    }
                }
                else if (starRequestHandler) {
                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                }
                const promise = handlerResult;
                if (!handlerResult) {
                    delete requestTokens[tokenKey];
                    replySuccess(handlerResult, requestMessage.method, startTime);
                }
                else if (promise.then) {
                    promise.then((resultOrError) => {
                        delete requestTokens[tokenKey];
                        reply(resultOrError, requestMessage.method, startTime);
                    }, error => {
                        delete requestTokens[tokenKey];
                        if (error instanceof messages_1.ResponseError) {
                            replyError(error, requestMessage.method, startTime);
                        }
                        else if (error && Is.string(error.message)) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                        }
                        else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                        }
                    });
                }
                else {
                    delete requestTokens[tokenKey];
                    reply(handlerResult, requestMessage.method, startTime);
                }
            }
            catch (error) {
                delete requestTokens[tokenKey];
                if (error instanceof messages_1.ResponseError) {
                    reply(error, requestMessage.method, startTime);
                }
                else if (error && Is.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                }
                else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
            }
        }
        else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
    }
    function handleResponse(responseMessage) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        if (responseMessage.id === null) {
            if (responseMessage.error) {
                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
            }
            else {
                logger.error(`Received response message without id. No further error information provided.`);
            }
        }
        else {
            const key = String(responseMessage.id);
            const responsePromise = responsePromises[key];
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise) {
                delete responsePromises[key];
                try {
                    if (responseMessage.error) {
                        const error = responseMessage.error;
                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                    }
                    else if (responseMessage.result !== undefined) {
                        responsePromise.resolve(responseMessage.result);
                    }
                    else {
                        throw new Error('Should never happen.');
                    }
                }
                catch (error) {
                    if (error.message) {
                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                    }
                    else {
                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                    }
                }
            }
        }
    }
    function handleNotification(message) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        let type = undefined;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
            notificationHandler = (params) => {
                const id = params.id;
                const source = requestTokens[String(id)];
                if (source) {
                    source.cancel();
                }
            };
        }
        else {
            const element = notificationHandlers[message.method];
            if (element) {
                notificationHandler = element.handler;
                type = element.type;
            }
        }
        if (notificationHandler || starNotificationHandler) {
            try {
                traceReceivedNotification(message);
                if (notificationHandler) {
                    if (message.params === undefined) {
                        if (type !== undefined) {
                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but recevied none.`);
                            }
                        }
                        notificationHandler();
                    }
                    else if (Array.isArray(message.params)) {
                        if (type !== undefined) {
                            if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                                logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                            }
                            if (type.numberOfParams !== message.params.length) {
                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${message.params.length} argumennts`);
                            }
                        }
                        notificationHandler(...message.params);
                    }
                    else {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                        }
                        notificationHandler(message.params);
                    }
                }
                else if (starNotificationHandler) {
                    starNotificationHandler(message.method, message.params);
                }
            }
            catch (error) {
                if (error.message) {
                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                }
                else {
                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                }
            }
        }
        else {
            unhandledNotificationEmitter.fire(message);
        }
    }
    function handleInvalidMessage(message) {
        if (!message) {
            logger.error('Received empty message.');
            return;
        }
        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
        // Test whether we find an id to reject the promise
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
            const key = String(responseMessage.id);
            const responseHandler = responsePromises[key];
            if (responseHandler) {
                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
            }
        }
    }
    function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose && message.params) {
                data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('send-request', message);
        }
    }
    function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.params) {
                    data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('send-notification', message);
        }
    }
    function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.error && message.error.data) {
                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${JSON.stringify(message.result, null, 4)}\n\n`;
                    }
                    else if (message.error === undefined) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        }
        else {
            logLSPMessage('send-response', message);
        }
    }
    function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose && message.params) {
                data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('receive-request', message);
        }
    }
    function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.params) {
                    data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('receive-notification', message);
        }
    }
    function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.error && message.error.data) {
                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${JSON.stringify(message.result, null, 4)}\n\n`;
                    }
                    else if (message.error === undefined) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            if (responsePromise) {
                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            }
            else {
                tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
        }
        else {
            logLSPMessage('receive-response', message);
        }
    }
    function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
            return;
        }
        const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
        };
        tracer.log(lspMessage);
    }
    function throwIfClosedOrDisposed() {
        if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
        }
        if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
        }
    }
    function throwIfListening() {
        if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
        }
    }
    function throwIfNotListening() {
        if (!isListening()) {
            throw new Error('Call listen() first.');
        }
    }
    function undefinedToNull(param) {
        if (param === undefined) {
            return null;
        }
        else {
            return param;
        }
    }
    function nullToUndefined(param) {
        if (param === null) {
            return undefined;
        }
        else {
            return param;
        }
    }
    function isNamedParam(param) {
        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
    }
    function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
            case messages_1.ParameterStructures.auto:
                if (isNamedParam(param)) {
                    return nullToUndefined(param);
                }
                else {
                    return [undefinedToNull(param)];
                }
                break;
            case messages_1.ParameterStructures.byName:
                if (!isNamedParam(param)) {
                    throw new Error(`Recevied parameters by name but param is not an object literal.`);
                }
                return nullToUndefined(param);
            case messages_1.ParameterStructures.byPosition:
                return [undefinedToNull(param)];
            default:
                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
    }
    function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
            case 0:
                result = undefined;
                break;
            case 1:
                result = computeSingleParam(type.parameterStructures, params[0]);
                break;
            default:
                result = [];
                for (let i = 0; i < params.length && i < numberOfParams; i++) {
                    result.push(undefinedToNull(params[i]));
                }
                if (params.length < numberOfParams) {
                    for (let i = params.length; i < numberOfParams; i++) {
                        result.push(null);
                    }
                }
                break;
        }
        return result;
    }
    const connection = {
        sendNotification: (type, ...args) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is.string(type)) {
                method = type;
                const first = args[0];
                let paramStart = 0;
                let parameterStructures = messages_1.ParameterStructures.auto;
                if (messages_1.ParameterStructures.is(first)) {
                    paramStart = 1;
                    parameterStructures = first;
                }
                let paramEnd = args.length;
                const numberOfParams = paramEnd - paramStart;
                switch (numberOfParams) {
                    case 0:
                        messageParams = undefined;
                        break;
                    case 1:
                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                        break;
                    default:
                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                            throw new Error(`Recevied ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                        }
                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
                        break;
                }
            }
            else {
                const params = args;
                method = type.method;
                messageParams = computeMessageParams(type, params);
            }
            const notificationMessage = {
                jsonrpc: version,
                method: method,
                params: messageParams
            };
            traceSendingNotification(notificationMessage);
            messageWriter.write(notificationMessage);
        },
        onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            let method;
            if (Is.func(type)) {
                starNotificationHandler = type;
            }
            else if (handler) {
                if (Is.string(type)) {
                    method = type;
                    notificationHandlers[type] = { type: undefined, handler };
                }
                else {
                    method = type.method;
                    notificationHandlers[type.method] = { type, handler };
                }
            }
            return {
                dispose: () => {
                    if (method !== undefined) {
                        delete notificationHandlers[method];
                    }
                    else {
                        starNotificationHandler = undefined;
                    }
                }
            };
        },
        onProgress: (_type, token, handler) => {
            if (progressHandlers.has(token)) {
                throw new Error(`Progress handler for token ${token} already registered`);
            }
            progressHandlers.set(token, handler);
            return {
                dispose: () => {
                    progressHandlers.delete(token);
                }
            };
        },
        sendProgress: (_type, token, value) => {
            connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = undefined;
            if (Is.string(type)) {
                method = type;
                const first = args[0];
                const last = args[args.length - 1];
                let paramStart = 0;
                let parameterStructures = messages_1.ParameterStructures.auto;
                if (messages_1.ParameterStructures.is(first)) {
                    paramStart = 1;
                    parameterStructures = first;
                }
                let paramEnd = args.length;
                if (cancellation_1.CancellationToken.is(last)) {
                    paramEnd = paramEnd - 1;
                    token = last;
                }
                const numberOfParams = paramEnd - paramStart;
                switch (numberOfParams) {
                    case 0:
                        messageParams = undefined;
                        break;
                    case 1:
                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                        break;
                    default:
                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                            throw new Error(`Recevied ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                        }
                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
                        break;
                }
            }
            else {
                const params = args;
                method = type.method;
                messageParams = computeMessageParams(type, params);
                const numberOfParams = type.numberOfParams;
                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
            }
            const id = sequenceNumber++;
            let disposable;
            if (token) {
                disposable = token.onCancellationRequested(() => {
                    cancellationStrategy.sender.sendCancellation(connection, id);
                });
            }
            const result = new Promise((resolve, reject) => {
                const requestMessage = {
                    jsonrpc: version,
                    id: id,
                    method: method,
                    params: messageParams
                };
                const resolveWithCleanup = (r) => {
                    resolve(r);
                    cancellationStrategy.sender.cleanup(id);
                    disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
                };
                const rejectWithCleanup = (r) => {
                    reject(r);
                    cancellationStrategy.sender.cleanup(id);
                    disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
                };
                let responsePromise = { method: method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
                traceSendingRequest(requestMessage);
                try {
                    messageWriter.write(requestMessage);
                }
                catch (e) {
                    // Writing the message failed. So we need to reject the promise.
                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : 'Unknown reason'));
                    responsePromise = null;
                }
                if (responsePromise) {
                    responsePromises[String(id)] = responsePromise;
                }
            });
            return result;
        },
        onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            let method = null;
            if (StarRequestHandler.is(type)) {
                method = undefined;
                starRequestHandler = type;
            }
            else if (Is.string(type)) {
                method = null;
                if (handler !== undefined) {
                    method = type;
                    requestHandlers[type] = { handler: handler, type: undefined };
                }
            }
            else {
                if (handler !== undefined) {
                    method = type.method;
                    requestHandlers[type.method] = { type, handler };
                }
            }
            return {
                dispose: () => {
                    if (method === null) {
                        return;
                    }
                    if (method !== undefined) {
                        delete requestHandlers[method];
                    }
                    else {
                        starRequestHandler = undefined;
                    }
                }
            };
        },
        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== undefined) {
                if (Is.boolean(sendNotificationOrTraceOptions)) {
                    _sendNotification = sendNotificationOrTraceOptions;
                }
                else {
                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
                tracer = undefined;
            }
            else {
                tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
                connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
            messageWriter.end();
        },
        dispose: () => {
            if (isDisposed()) {
                return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(undefined);
            const error = new Error('Connection got disposed.');
            Object.keys(responsePromises).forEach((key) => {
                responsePromises[key].reject(error);
            });
            responsePromises = Object.create(null);
            requestTokens = Object.create(null);
            messageQueue = new linkedMap_1.LinkedMap();
            // Test for backwards compatibility
            if (Is.func(messageWriter.dispose)) {
                messageWriter.dispose();
            }
            if (Is.func(messageReader.dispose)) {
                messageReader.dispose();
            }
        },
        listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader.listen(callback);
        },
        inspect: () => {
            // eslint-disable-next-line no-console
            ral_1.default().console.log('inspect');
        }
    };
    connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        tracer.log(params.message, trace === Trace.Verbose ? params.verbose : undefined);
    });
    connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
            handler(params.value);
        }
        else {
            unhandledProgressEmitter.fire(params);
        }
    });
    return connection;
}
exports.createMessageConnection = createMessageConnection;
//# sourceMappingURL=connection.js.map

/***/ }),
/* 22 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
var Touch;
(function (Touch) {
    Touch.None = 0;
    Touch.First = 1;
    Touch.AsOld = Touch.First;
    Touch.Last = 2;
    Touch.AsNew = Touch.Last;
})(Touch = exports.Touch || (exports.Touch = {}));
class LinkedMap {
    constructor() {
        this[Symbol.toStringTag] = 'LinkedMap';
        this._map = new Map();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        this._state = 0;
    }
    clear() {
        this._map.clear();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        this._state++;
    }
    isEmpty() {
        return !this._head && !this._tail;
    }
    get size() {
        return this._size;
    }
    get first() {
        var _a;
        return (_a = this._head) === null || _a === void 0 ? void 0 : _a.value;
    }
    get last() {
        var _a;
        return (_a = this._tail) === null || _a === void 0 ? void 0 : _a.value;
    }
    has(key) {
        return this._map.has(key);
    }
    get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        if (touch !== Touch.None) {
            this.touch(item, touch);
        }
        return item.value;
    }
    set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
            item.value = value;
            if (touch !== Touch.None) {
                this.touch(item, touch);
            }
        }
        else {
            item = { key, value, next: undefined, previous: undefined };
            switch (touch) {
                case Touch.None:
                    this.addItemLast(item);
                    break;
                case Touch.First:
                    this.addItemFirst(item);
                    break;
                case Touch.Last:
                    this.addItemLast(item);
                    break;
                default:
                    this.addItemLast(item);
                    break;
            }
            this._map.set(key, item);
            this._size++;
        }
        return this;
    }
    delete(key) {
        return !!this.remove(key);
    }
    remove(key) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    shift() {
        if (!this._head && !this._tail) {
            return undefined;
        }
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
            if (thisArg) {
                callbackfn.bind(thisArg)(current.value, current.key, this);
            }
            else {
                callbackfn(current.value, current.key, this);
            }
            if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
            }
            current = current.next;
        }
    }
    keys() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]() {
                return iterator;
            },
            next() {
                if (map._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: current.key, done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    values() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]() {
                return iterator;
            },
            next() {
                if (map._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: current.value, done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    entries() {
        const map = this;
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]() {
                return iterator;
            },
            next() {
                if (map._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: [current.key, current.value], done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    trimOld(newSize) {
        if (newSize >= this.size) {
            return;
        }
        if (newSize === 0) {
            this.clear();
            return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
            this._map.delete(current.key);
            current = current.next;
            currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
            current.previous = undefined;
        }
        this._state++;
    }
    addItemFirst(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._tail = item;
        }
        else if (!this._head) {
            throw new Error('Invalid list');
        }
        else {
            item.next = this._head;
            this._head.previous = item;
        }
        this._head = item;
        this._state++;
    }
    addItemLast(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._head = item;
        }
        else if (!this._tail) {
            throw new Error('Invalid list');
        }
        else {
            item.previous = this._tail;
            this._tail.next = item;
        }
        this._tail = item;
        this._state++;
    }
    removeItem(item) {
        if (item === this._head && item === this._tail) {
            this._head = undefined;
            this._tail = undefined;
        }
        else if (item === this._head) {
            // This can only happend if size === 1 which is handle
            // by the case above.
            if (!item.next) {
                throw new Error('Invalid list');
            }
            item.next.previous = undefined;
            this._head = item.next;
        }
        else if (item === this._tail) {
            // This can only happend if size === 1 which is handle
            // by the case above.
            if (!item.previous) {
                throw new Error('Invalid list');
            }
            item.previous.next = undefined;
            this._tail = item.previous;
        }
        else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
                throw new Error('Invalid list');
            }
            next.previous = previous;
            previous.next = next;
        }
        item.next = undefined;
        item.previous = undefined;
        this._state++;
    }
    touch(item, touch) {
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        if ((touch !== Touch.First && touch !== Touch.Last)) {
            return;
        }
        if (touch === Touch.First) {
            if (item === this._head) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item
            if (item === this._tail) {
                // previous must be defined since item was not head but is tail
                // So there are more than on item in the map
                previous.next = undefined;
                this._tail = previous;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            // Insert the node at head
            item.previous = undefined;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
            this._state++;
        }
        else if (touch === Touch.Last) {
            if (item === this._tail) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item.
            if (item === this._head) {
                // next must be defined since item was not tail but is head
                // So there are more than on item in the map
                next.previous = undefined;
                this._head = next;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            item.next = undefined;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
            this._state++;
        }
    }
    toJSON() {
        const data = [];
        this.forEach((value, key) => {
            data.push([key, value]);
        });
        return data;
    }
    fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
            this.set(key, value);
        }
    }
}
exports.LinkedMap = LinkedMap;
class LRUCache extends LinkedMap {
    constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
    }
    get limit() {
        return this._limit;
    }
    set limit(limit) {
        this._limit = limit;
        this.checkTrim();
    }
    get ratio() {
        return this._ratio;
    }
    set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
    }
    get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
    }
    peek(key) {
        return super.get(key, Touch.None);
    }
    set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
    }
    checkTrim() {
        if (this.size > this._limit) {
            this.trimOld(Math.round(this._limit * this._ratio));
        }
    }
}
exports.LRUCache = LRUCache;
//# sourceMappingURL=linkedMap.js.map

/***/ }),
/* 23 */
/***/ ((module) => {

"use strict";
module.exports = require("path");;

/***/ }),
/* 24 */
/***/ ((module) => {

"use strict";
module.exports = require("os");;

/***/ }),
/* 25 */
/***/ ((module) => {

"use strict";
module.exports = require("crypto");;

/***/ }),
/* 26 */
/***/ ((module) => {

"use strict";
module.exports = require("net");;

/***/ }),
/* 27 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LSPErrorCodes = exports.createProtocolConnection = void 0;
__exportStar(__webpack_require__(7), exports);
__exportStar(__webpack_require__(28), exports);
__exportStar(__webpack_require__(29), exports);
__exportStar(__webpack_require__(30), exports);
var connection_1 = __webpack_require__(47);
Object.defineProperty(exports, "createProtocolConnection", ({ enumerable: true, get: function () { return connection_1.createProtocolConnection; } }));
var LSPErrorCodes;
(function (LSPErrorCodes) {
    /**
    * This is the start range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */
    LSPErrorCodes.lspReservedErrorRangeStart = -32899;
    LSPErrorCodes.ContentModified = -32801;
    LSPErrorCodes.RequestCancelled = -32800;
    /**
    * This is the end range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */
    LSPErrorCodes.lspReservedErrorRangeEnd = -32800;
})(LSPErrorCodes = exports.LSPErrorCodes || (exports.LSPErrorCodes = {}));
//# sourceMappingURL=api.js.map

/***/ }),
/* 28 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "integer": () => (/* binding */ integer),
/* harmony export */   "uinteger": () => (/* binding */ uinteger),
/* harmony export */   "Position": () => (/* binding */ Position),
/* harmony export */   "Range": () => (/* binding */ Range),
/* harmony export */   "Location": () => (/* binding */ Location),
/* harmony export */   "LocationLink": () => (/* binding */ LocationLink),
/* harmony export */   "Color": () => (/* binding */ Color),
/* harmony export */   "ColorInformation": () => (/* binding */ ColorInformation),
/* harmony export */   "ColorPresentation": () => (/* binding */ ColorPresentation),
/* harmony export */   "FoldingRangeKind": () => (/* binding */ FoldingRangeKind),
/* harmony export */   "FoldingRange": () => (/* binding */ FoldingRange),
/* harmony export */   "DiagnosticRelatedInformation": () => (/* binding */ DiagnosticRelatedInformation),
/* harmony export */   "DiagnosticSeverity": () => (/* binding */ DiagnosticSeverity),
/* harmony export */   "DiagnosticTag": () => (/* binding */ DiagnosticTag),
/* harmony export */   "CodeDescription": () => (/* binding */ CodeDescription),
/* harmony export */   "Diagnostic": () => (/* binding */ Diagnostic),
/* harmony export */   "Command": () => (/* binding */ Command),
/* harmony export */   "TextEdit": () => (/* binding */ TextEdit),
/* harmony export */   "ChangeAnnotation": () => (/* binding */ ChangeAnnotation),
/* harmony export */   "ChangeAnnotationIdentifier": () => (/* binding */ ChangeAnnotationIdentifier),
/* harmony export */   "AnnotatedTextEdit": () => (/* binding */ AnnotatedTextEdit),
/* harmony export */   "TextDocumentEdit": () => (/* binding */ TextDocumentEdit),
/* harmony export */   "CreateFile": () => (/* binding */ CreateFile),
/* harmony export */   "RenameFile": () => (/* binding */ RenameFile),
/* harmony export */   "DeleteFile": () => (/* binding */ DeleteFile),
/* harmony export */   "WorkspaceEdit": () => (/* binding */ WorkspaceEdit),
/* harmony export */   "WorkspaceChange": () => (/* binding */ WorkspaceChange),
/* harmony export */   "TextDocumentIdentifier": () => (/* binding */ TextDocumentIdentifier),
/* harmony export */   "VersionedTextDocumentIdentifier": () => (/* binding */ VersionedTextDocumentIdentifier),
/* harmony export */   "OptionalVersionedTextDocumentIdentifier": () => (/* binding */ OptionalVersionedTextDocumentIdentifier),
/* harmony export */   "TextDocumentItem": () => (/* binding */ TextDocumentItem),
/* harmony export */   "MarkupKind": () => (/* binding */ MarkupKind),
/* harmony export */   "MarkupContent": () => (/* binding */ MarkupContent),
/* harmony export */   "CompletionItemKind": () => (/* binding */ CompletionItemKind),
/* harmony export */   "InsertTextFormat": () => (/* binding */ InsertTextFormat),
/* harmony export */   "CompletionItemTag": () => (/* binding */ CompletionItemTag),
/* harmony export */   "InsertReplaceEdit": () => (/* binding */ InsertReplaceEdit),
/* harmony export */   "InsertTextMode": () => (/* binding */ InsertTextMode),
/* harmony export */   "CompletionItem": () => (/* binding */ CompletionItem),
/* harmony export */   "CompletionList": () => (/* binding */ CompletionList),
/* harmony export */   "MarkedString": () => (/* binding */ MarkedString),
/* harmony export */   "Hover": () => (/* binding */ Hover),
/* harmony export */   "ParameterInformation": () => (/* binding */ ParameterInformation),
/* harmony export */   "SignatureInformation": () => (/* binding */ SignatureInformation),
/* harmony export */   "DocumentHighlightKind": () => (/* binding */ DocumentHighlightKind),
/* harmony export */   "DocumentHighlight": () => (/* binding */ DocumentHighlight),
/* harmony export */   "SymbolKind": () => (/* binding */ SymbolKind),
/* harmony export */   "SymbolTag": () => (/* binding */ SymbolTag),
/* harmony export */   "SymbolInformation": () => (/* binding */ SymbolInformation),
/* harmony export */   "DocumentSymbol": () => (/* binding */ DocumentSymbol),
/* harmony export */   "CodeActionKind": () => (/* binding */ CodeActionKind),
/* harmony export */   "CodeActionContext": () => (/* binding */ CodeActionContext),
/* harmony export */   "CodeAction": () => (/* binding */ CodeAction),
/* harmony export */   "CodeLens": () => (/* binding */ CodeLens),
/* harmony export */   "FormattingOptions": () => (/* binding */ FormattingOptions),
/* harmony export */   "DocumentLink": () => (/* binding */ DocumentLink),
/* harmony export */   "SelectionRange": () => (/* binding */ SelectionRange),
/* harmony export */   "EOL": () => (/* binding */ EOL),
/* harmony export */   "TextDocument": () => (/* binding */ TextDocument)
/* harmony export */ });
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var integer;
(function (integer) {
    integer.MIN_VALUE = -2147483648;
    integer.MAX_VALUE = 2147483647;
})(integer || (integer = {}));
var uinteger;
(function (uinteger) {
    uinteger.MIN_VALUE = 0;
    uinteger.MAX_VALUE = 2147483647;
})(uinteger || (uinteger = {}));
/**
 * The Position namespace provides helper functions to work with
 * [Position](#Position) literals.
 */
var Position;
(function (Position) {
    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */
    function create(line, character) {
        if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
        }
        if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
        }
        return { line: line, character: character };
    }
    Position.create = create;
    /**
     * Checks whether the given literal conforms to the [Position](#Position) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
    }
    Position.is = is;
})(Position || (Position = {}));
/**
 * The Range namespace provides helper functions to work with
 * [Range](#Range) literals.
 */
var Range;
(function (Range) {
    function create(one, two, three, four) {
        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
        }
        else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
        }
        else {
            throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
        }
    }
    Range.create = create;
    /**
     * Checks whether the given literal conforms to the [Range](#Range) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
    }
    Range.is = is;
})(Range || (Range = {}));
/**
 * The Location namespace provides helper functions to work with
 * [Location](#Location) literals.
 */
var Location;
(function (Location) {
    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */
    function create(uri, range) {
        return { uri: uri, range: range };
    }
    Location.create = create;
    /**
     * Checks whether the given literal conforms to the [Location](#Location) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
    }
    Location.is = is;
})(Location || (Location = {}));
/**
 * The LocationLink namespace provides helper functions to work with
 * [LocationLink](#LocationLink) literals.
 */
var LocationLink;
(function (LocationLink) {
    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };
    }
    LocationLink.create = create;
    /**
     * Checks whether the given literal conforms to the [LocationLink](#LocationLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)
            && (Range.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange))
            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
    }
    LocationLink.is = is;
})(LocationLink || (LocationLink = {}));
/**
 * The Color namespace provides helper functions to work with
 * [Color](#Color) literals.
 */
var Color;
(function (Color) {
    /**
     * Creates a new Color literal.
     */
    function create(red, green, blue, alpha) {
        return {
            red: red,
            green: green,
            blue: blue,
            alpha: alpha,
        };
    }
    Color.create = create;
    /**
     * Checks whether the given literal conforms to the [Color](#Color) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.numberRange(candidate.red, 0, 1)
            && Is.numberRange(candidate.green, 0, 1)
            && Is.numberRange(candidate.blue, 0, 1)
            && Is.numberRange(candidate.alpha, 0, 1);
    }
    Color.is = is;
})(Color || (Color = {}));
/**
 * The ColorInformation namespace provides helper functions to work with
 * [ColorInformation](#ColorInformation) literals.
 */
var ColorInformation;
(function (ColorInformation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(range, color) {
        return {
            range: range,
            color: color,
        };
    }
    ColorInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Range.is(candidate.range) && Color.is(candidate.color);
    }
    ColorInformation.is = is;
})(ColorInformation || (ColorInformation = {}));
/**
 * The Color namespace provides helper functions to work with
 * [ColorPresentation](#ColorPresentation) literals.
 */
var ColorPresentation;
(function (ColorPresentation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(label, textEdit, additionalTextEdits) {
        return {
            label: label,
            textEdit: textEdit,
            additionalTextEdits: additionalTextEdits,
        };
    }
    ColorPresentation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate.label)
            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))
            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
    }
    ColorPresentation.is = is;
})(ColorPresentation || (ColorPresentation = {}));
/**
 * Enum of known range kinds
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind["Comment"] = "comment";
    /**
     * Folding range for a imports or includes
     */
    FoldingRangeKind["Imports"] = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind["Region"] = "region";
})(FoldingRangeKind || (FoldingRangeKind = {}));
/**
 * The folding range namespace provides helper functions to work with
 * [FoldingRange](#FoldingRange) literals.
 */
var FoldingRange;
(function (FoldingRange) {
    /**
     * Creates a new FoldingRange literal.
     */
    function create(startLine, endLine, startCharacter, endCharacter, kind) {
        var result = {
            startLine: startLine,
            endLine: endLine
        };
        if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
            result.kind = kind;
        }
        return result;
    }
    FoldingRange.create = create;
    /**
     * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)
            && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))
            && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))
            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
    }
    FoldingRange.is = is;
})(FoldingRange || (FoldingRange = {}));
/**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.
 */
var DiagnosticRelatedInformation;
(function (DiagnosticRelatedInformation) {
    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */
    function create(location, message) {
        return {
            location: location,
            message: message
        };
    }
    DiagnosticRelatedInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
    }
    DiagnosticRelatedInformation.is = is;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
/**
 * The diagnostic's severity.
 */
var DiagnosticSeverity;
(function (DiagnosticSeverity) {
    /**
     * Reports an error.
     */
    DiagnosticSeverity.Error = 1;
    /**
     * Reports a warning.
     */
    DiagnosticSeverity.Warning = 2;
    /**
     * Reports an information.
     */
    DiagnosticSeverity.Information = 3;
    /**
     * Reports a hint.
     */
    DiagnosticSeverity.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
/**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */
var DiagnosticTag;
(function (DiagnosticTag) {
    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */
    DiagnosticTag.Unnecessary = 1;
    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */
    DiagnosticTag.Deprecated = 2;
})(DiagnosticTag || (DiagnosticTag = {}));
/**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */
var CodeDescription;
(function (CodeDescription) {
    function is(value) {
        var candidate = value;
        return candidate !== undefined && candidate !== null && Is.string(candidate.href);
    }
    CodeDescription.is = is;
})(CodeDescription || (CodeDescription = {}));
/**
 * The Diagnostic namespace provides helper functions to work with
 * [Diagnostic](#Diagnostic) literals.
 */
var Diagnostic;
(function (Diagnostic) {
    /**
     * Creates a new Diagnostic literal.
     */
    function create(range, message, severity, code, source, relatedInformation) {
        var result = { range: range, message: message };
        if (Is.defined(severity)) {
            result.severity = severity;
        }
        if (Is.defined(code)) {
            result.code = code;
        }
        if (Is.defined(source)) {
            result.source = source;
        }
        if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
        }
        return result;
    }
    Diagnostic.create = create;
    /**
     * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.
     */
    function is(value) {
        var _a;
        var candidate = value;
        return Is.defined(candidate)
            && Range.is(candidate.range)
            && Is.string(candidate.message)
            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))
            && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))
            && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))
            && (Is.string(candidate.source) || Is.undefined(candidate.source))
            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic.is = is;
})(Diagnostic || (Diagnostic = {}));
/**
 * The Command namespace provides helper functions to work with
 * [Command](#Command) literals.
 */
var Command;
(function (Command) {
    /**
     * Creates a new Command literal.
     */
    function create(title, command) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var result = { title: title, command: command };
        if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
        }
        return result;
    }
    Command.create = create;
    /**
     * Checks whether the given literal conforms to the [Command](#Command) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
    }
    Command.is = is;
})(Command || (Command = {}));
/**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */
var TextEdit;
(function (TextEdit) {
    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */
    function replace(range, newText) {
        return { range: range, newText: newText };
    }
    TextEdit.replace = replace;
    /**
     * Creates a insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */
    function insert(position, newText) {
        return { range: { start: position, end: position }, newText: newText };
    }
    TextEdit.insert = insert;
    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */
    function del(range) {
        return { range: range, newText: '' };
    }
    TextEdit.del = del;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate)
            && Is.string(candidate.newText)
            && Range.is(candidate.range);
    }
    TextEdit.is = is;
})(TextEdit || (TextEdit = {}));
var ChangeAnnotation;
(function (ChangeAnnotation) {
    function create(label, needsConfirmation, description) {
        var result = { label: label };
        if (needsConfirmation !== undefined) {
            result.needsConfirmation = needsConfirmation;
        }
        if (description !== undefined) {
            result.description = description;
        }
        return result;
    }
    ChangeAnnotation.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && Is.objectLiteral(candidate) && Is.string(candidate.label) &&
            (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&
            (Is.string(candidate.description) || candidate.description === undefined);
    }
    ChangeAnnotation.is = is;
})(ChangeAnnotation || (ChangeAnnotation = {}));
var ChangeAnnotationIdentifier;
(function (ChangeAnnotationIdentifier) {
    function is(value) {
        var candidate = value;
        return typeof candidate === 'string';
    }
    ChangeAnnotationIdentifier.is = is;
})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
var AnnotatedTextEdit;
(function (AnnotatedTextEdit) {
    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */
    function replace(range, newText, annotation) {
        return { range: range, newText: newText, annotationId: annotation };
    }
    AnnotatedTextEdit.replace = replace;
    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */
    function insert(position, newText, annotation) {
        return { range: { start: position, end: position }, newText: newText, annotationId: annotation };
    }
    AnnotatedTextEdit.insert = insert;
    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */
    function del(range, annotation) {
        return { range: range, newText: '', annotationId: annotation };
    }
    AnnotatedTextEdit.del = del;
    function is(value) {
        var candidate = value;
        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    AnnotatedTextEdit.is = is;
})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
/**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */
var TextDocumentEdit;
(function (TextDocumentEdit) {
    /**
     * Creates a new `TextDocumentEdit`
     */
    function create(textDocument, edits) {
        return { textDocument: textDocument, edits: edits };
    }
    TextDocumentEdit.create = create;
    function is(value) {
        var candidate = value;
        return Is.defined(candidate)
            && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)
            && Array.isArray(candidate.edits);
    }
    TextDocumentEdit.is = is;
})(TextDocumentEdit || (TextDocumentEdit = {}));
var CreateFile;
(function (CreateFile) {
    function create(uri, options, annotation) {
        var result = {
            kind: 'create',
            uri: uri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    CreateFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    CreateFile.is = is;
})(CreateFile || (CreateFile = {}));
var RenameFile;
(function (RenameFile) {
    function create(oldUri, newUri, options, annotation) {
        var result = {
            kind: 'rename',
            oldUri: oldUri,
            newUri: newUri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    RenameFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    RenameFile.is = is;
})(RenameFile || (RenameFile = {}));
var DeleteFile;
(function (DeleteFile) {
    function create(uri, options, annotation) {
        var result = {
            kind: 'delete',
            uri: uri
        };
        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    DeleteFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    DeleteFile.is = is;
})(DeleteFile || (DeleteFile = {}));
var WorkspaceEdit;
(function (WorkspaceEdit) {
    function is(value) {
        var candidate = value;
        return candidate &&
            (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&
            (candidate.documentChanges === undefined || candidate.documentChanges.every(function (change) {
                if (Is.string(change.kind)) {
                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                }
                else {
                    return TextDocumentEdit.is(change);
                }
            }));
    }
    WorkspaceEdit.is = is;
})(WorkspaceEdit || (WorkspaceEdit = {}));
var TextEditChangeImpl = /** @class */ (function () {
    function TextEditChangeImpl(edits, changeAnnotations) {
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
    }
    TextEditChangeImpl.prototype.insert = function (position, newText, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.insert(position, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.insert(position, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.insert(position, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.replace = function (range, newText, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.replace(range, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.replace(range, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.replace(range, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.delete = function (range, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.del(range);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.del(range, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.del(range, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.add = function (edit) {
        this.edits.push(edit);
    };
    TextEditChangeImpl.prototype.all = function () {
        return this.edits;
    };
    TextEditChangeImpl.prototype.clear = function () {
        this.edits.splice(0, this.edits.length);
    };
    TextEditChangeImpl.prototype.assertChangeAnnotations = function (value) {
        if (value === undefined) {
            throw new Error("Text edit change is not configured to manage change annotations.");
        }
    };
    return TextEditChangeImpl;
}());
/**
 * A helper class
 */
var ChangeAnnotations = /** @class */ (function () {
    function ChangeAnnotations(annotations) {
        this._annotations = annotations === undefined ? Object.create(null) : annotations;
        this._counter = 0;
        this._size = 0;
    }
    ChangeAnnotations.prototype.all = function () {
        return this._annotations;
    };
    Object.defineProperty(ChangeAnnotations.prototype, "size", {
        get: function () {
            return this._size;
        },
        enumerable: false,
        configurable: true
    });
    ChangeAnnotations.prototype.manage = function (idOrAnnotation, annotation) {
        var id;
        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
            id = idOrAnnotation;
        }
        else {
            id = this.nextId();
            annotation = idOrAnnotation;
        }
        if (this._annotations[id] !== undefined) {
            throw new Error("Id " + id + " is already in use.");
        }
        if (annotation === undefined) {
            throw new Error("No annotation provided for id " + id);
        }
        this._annotations[id] = annotation;
        this._size++;
        return id;
    };
    ChangeAnnotations.prototype.nextId = function () {
        this._counter++;
        return this._counter.toString();
    };
    return ChangeAnnotations;
}());
/**
 * A workspace change helps constructing changes to a workspace.
 */
var WorkspaceChange = /** @class */ (function () {
    function WorkspaceChange(workspaceEdit) {
        var _this = this;
        this._textEditChanges = Object.create(null);
        if (workspaceEdit !== undefined) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function (change) {
                    if (TextDocumentEdit.is(change)) {
                        var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                        _this._textEditChanges[change.textDocument.uri] = textEditChange;
                    }
                });
            }
            else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function (key) {
                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                    _this._textEditChanges[key] = textEditChange;
                });
            }
        }
        else {
            this._workspaceEdit = {};
        }
    }
    Object.defineProperty(WorkspaceChange.prototype, "edit", {
        /**
         * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal
         * use to be returned from a workspace edit operation like rename.
         */
        get: function () {
            this.initDocumentChanges();
            if (this._changeAnnotations !== undefined) {
                if (this._changeAnnotations.size === 0) {
                    this._workspaceEdit.changeAnnotations = undefined;
                }
                else {
                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
            }
            return this._workspaceEdit;
        },
        enumerable: false,
        configurable: true
    });
    WorkspaceChange.prototype.getTextEditChange = function (key) {
        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === undefined) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
            var textDocument = { uri: key.uri, version: key.version };
            var result = this._textEditChanges[textDocument.uri];
            if (!result) {
                var edits = [];
                var textDocumentEdit = {
                    textDocument: textDocument,
                    edits: edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
            }
            return result;
        }
        else {
            this.initChanges();
            if (this._workspaceEdit.changes === undefined) {
                throw new Error('Workspace edit is not configured for normal text edit changes.');
            }
            var result = this._textEditChanges[key];
            if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
            }
            return result;
        }
    };
    WorkspaceChange.prototype.initDocumentChanges = function () {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._changeAnnotations = new ChangeAnnotations();
            this._workspaceEdit.documentChanges = [];
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
    };
    WorkspaceChange.prototype.initChanges = function () {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._workspaceEdit.changes = Object.create(null);
        }
    };
    WorkspaceChange.prototype.createFile = function (uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = CreateFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = CreateFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = RenameFile.create(oldUri, newUri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = RenameFile.create(oldUri, newUri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    WorkspaceChange.prototype.deleteFile = function (uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = DeleteFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = DeleteFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    return WorkspaceChange;
}());

/**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.
 */
var TextDocumentIdentifier;
(function (TextDocumentIdentifier) {
    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */
    function create(uri) {
        return { uri: uri };
    }
    TextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
    }
    TextDocumentIdentifier.is = is;
})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
/**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.
 */
var VersionedTextDocumentIdentifier;
(function (VersionedTextDocumentIdentifier) {
    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param uri The document's text.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    VersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
    }
    VersionedTextDocumentIdentifier.is = is;
})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
/**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) literals.
 */
var OptionalVersionedTextDocumentIdentifier;
(function (OptionalVersionedTextDocumentIdentifier) {
    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param uri The document's text.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    OptionalVersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
    }
    OptionalVersionedTextDocumentIdentifier.is = is;
})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
/**
 * The TextDocumentItem namespace provides helper functions to work with
 * [TextDocumentItem](#TextDocumentItem) literals.
 */
var TextDocumentItem;
(function (TextDocumentItem) {
    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */
    function create(uri, languageId, version, text) {
        return { uri: uri, languageId: languageId, version: version, text: text };
    }
    TextDocumentItem.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
    }
    TextDocumentItem.is = is;
})(TextDocumentItem || (TextDocumentItem = {}));
/**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */
var MarkupKind;
(function (MarkupKind) {
    /**
     * Plain text is supported as a content format
     */
    MarkupKind.PlainText = 'plaintext';
    /**
     * Markdown is supported as a content format
     */
    MarkupKind.Markdown = 'markdown';
})(MarkupKind || (MarkupKind = {}));
(function (MarkupKind) {
    /**
     * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.
     */
    function is(value) {
        var candidate = value;
        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
    }
    MarkupKind.is = is;
})(MarkupKind || (MarkupKind = {}));
var MarkupContent;
(function (MarkupContent) {
    /**
     * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
    }
    MarkupContent.is = is;
})(MarkupContent || (MarkupContent = {}));
/**
 * The kind of a completion entry.
 */
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind.Text = 1;
    CompletionItemKind.Method = 2;
    CompletionItemKind.Function = 3;
    CompletionItemKind.Constructor = 4;
    CompletionItemKind.Field = 5;
    CompletionItemKind.Variable = 6;
    CompletionItemKind.Class = 7;
    CompletionItemKind.Interface = 8;
    CompletionItemKind.Module = 9;
    CompletionItemKind.Property = 10;
    CompletionItemKind.Unit = 11;
    CompletionItemKind.Value = 12;
    CompletionItemKind.Enum = 13;
    CompletionItemKind.Keyword = 14;
    CompletionItemKind.Snippet = 15;
    CompletionItemKind.Color = 16;
    CompletionItemKind.File = 17;
    CompletionItemKind.Reference = 18;
    CompletionItemKind.Folder = 19;
    CompletionItemKind.EnumMember = 20;
    CompletionItemKind.Constant = 21;
    CompletionItemKind.Struct = 22;
    CompletionItemKind.Event = 23;
    CompletionItemKind.Operator = 24;
    CompletionItemKind.TypeParameter = 25;
})(CompletionItemKind || (CompletionItemKind = {}));
/**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */
var InsertTextFormat;
(function (InsertTextFormat) {
    /**
     * The primary text to be inserted is treated as a plain string.
     */
    InsertTextFormat.PlainText = 1;
    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */
    InsertTextFormat.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
/**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */
var CompletionItemTag;
(function (CompletionItemTag) {
    /**
     * Render a completion as obsolete, usually using a strike-out.
     */
    CompletionItemTag.Deprecated = 1;
})(CompletionItemTag || (CompletionItemTag = {}));
/**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */
var InsertReplaceEdit;
(function (InsertReplaceEdit) {
    /**
     * Creates a new insert / replace edit
     */
    function create(newText, insert, replace) {
        return { newText: newText, insert: insert, replace: replace };
    }
    InsertReplaceEdit.create = create;
    /**
     * Checks whether the given literal conforms to the [InsertReplaceEdit](#InsertReplaceEdit) interface.
     */
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
    }
    InsertReplaceEdit.is = is;
})(InsertReplaceEdit || (InsertReplaceEdit = {}));
/**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */
var InsertTextMode;
(function (InsertTextMode) {
    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */
    InsertTextMode.asIs = 1;
    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */
    InsertTextMode.adjustIndentation = 2;
})(InsertTextMode || (InsertTextMode = {}));
/**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */
var CompletionItem;
(function (CompletionItem) {
    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */
    function create(label) {
        return { label: label };
    }
    CompletionItem.create = create;
})(CompletionItem || (CompletionItem = {}));
/**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */
var CompletionList;
(function (CompletionList) {
    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */
    function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
    }
    CompletionList.create = create;
})(CompletionList || (CompletionList = {}));
var MarkedString;
(function (MarkedString) {
    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */
    function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
    }
    MarkedString.fromPlainText = fromPlainText;
    /**
     * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));
    }
    MarkedString.is = is;
})(MarkedString || (MarkedString = {}));
var Hover;
(function (Hover) {
    /**
     * Checks whether the given value conforms to the [Hover](#Hover) interface.
     */
    function is(value) {
        var candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||
            MarkedString.is(candidate.contents) ||
            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));
    }
    Hover.is = is;
})(Hover || (Hover = {}));
/**
 * The ParameterInformation namespace provides helper functions to work with
 * [ParameterInformation](#ParameterInformation) literals.
 */
var ParameterInformation;
(function (ParameterInformation) {
    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */
    function create(label, documentation) {
        return documentation ? { label: label, documentation: documentation } : { label: label };
    }
    ParameterInformation.create = create;
})(ParameterInformation || (ParameterInformation = {}));
/**
 * The SignatureInformation namespace provides helper functions to work with
 * [SignatureInformation](#SignatureInformation) literals.
 */
var SignatureInformation;
(function (SignatureInformation) {
    function create(label, documentation) {
        var parameters = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
        }
        var result = { label: label };
        if (Is.defined(documentation)) {
            result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
            result.parameters = parameters;
        }
        else {
            result.parameters = [];
        }
        return result;
    }
    SignatureInformation.create = create;
})(SignatureInformation || (SignatureInformation = {}));
/**
 * A document highlight kind.
 */
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind.Text = 1;
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind.Read = 2;
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind.Write = 3;
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
/**
 * DocumentHighlight namespace to provide helper functions to work with
 * [DocumentHighlight](#DocumentHighlight) literals.
 */
var DocumentHighlight;
(function (DocumentHighlight) {
    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     */
    function create(range, kind) {
        var result = { range: range };
        if (Is.number(kind)) {
            result.kind = kind;
        }
        return result;
    }
    DocumentHighlight.create = create;
})(DocumentHighlight || (DocumentHighlight = {}));
/**
 * A symbol kind.
 */
var SymbolKind;
(function (SymbolKind) {
    SymbolKind.File = 1;
    SymbolKind.Module = 2;
    SymbolKind.Namespace = 3;
    SymbolKind.Package = 4;
    SymbolKind.Class = 5;
    SymbolKind.Method = 6;
    SymbolKind.Property = 7;
    SymbolKind.Field = 8;
    SymbolKind.Constructor = 9;
    SymbolKind.Enum = 10;
    SymbolKind.Interface = 11;
    SymbolKind.Function = 12;
    SymbolKind.Variable = 13;
    SymbolKind.Constant = 14;
    SymbolKind.String = 15;
    SymbolKind.Number = 16;
    SymbolKind.Boolean = 17;
    SymbolKind.Array = 18;
    SymbolKind.Object = 19;
    SymbolKind.Key = 20;
    SymbolKind.Null = 21;
    SymbolKind.EnumMember = 22;
    SymbolKind.Struct = 23;
    SymbolKind.Event = 24;
    SymbolKind.Operator = 25;
    SymbolKind.TypeParameter = 26;
})(SymbolKind || (SymbolKind = {}));
/**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 * @since 3.16
 */
var SymbolTag;
(function (SymbolTag) {
    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */
    SymbolTag.Deprecated = 1;
})(SymbolTag || (SymbolTag = {}));
var SymbolInformation;
(function (SymbolInformation) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol, defaults to the current document.
     * @param containerName The name of the symbol containing the symbol.
     */
    function create(name, kind, range, uri, containerName) {
        var result = {
            name: name,
            kind: kind,
            location: { uri: uri, range: range }
        };
        if (containerName) {
            result.containerName = containerName;
        }
        return result;
    }
    SymbolInformation.create = create;
})(SymbolInformation || (SymbolInformation = {}));
var DocumentSymbol;
(function (DocumentSymbol) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */
    function create(name, detail, kind, range, selectionRange, children) {
        var result = {
            name: name,
            detail: detail,
            kind: kind,
            range: range,
            selectionRange: selectionRange
        };
        if (children !== undefined) {
            result.children = children;
        }
        return result;
    }
    DocumentSymbol.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.
     */
    function is(value) {
        var candidate = value;
        return candidate &&
            Is.string(candidate.name) && Is.number(candidate.kind) &&
            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&
            (candidate.detail === undefined || Is.string(candidate.detail)) &&
            (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&
            (candidate.children === undefined || Array.isArray(candidate.children)) &&
            (candidate.tags === undefined || Array.isArray(candidate.tags));
    }
    DocumentSymbol.is = is;
})(DocumentSymbol || (DocumentSymbol = {}));
/**
 * A set of predefined code action kinds
 */
var CodeActionKind;
(function (CodeActionKind) {
    /**
     * Empty kind.
     */
    CodeActionKind.Empty = '';
    /**
     * Base kind for quickfix actions: 'quickfix'
     */
    CodeActionKind.QuickFix = 'quickfix';
    /**
     * Base kind for refactoring actions: 'refactor'
     */
    CodeActionKind.Refactor = 'refactor';
    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */
    CodeActionKind.RefactorExtract = 'refactor.extract';
    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */
    CodeActionKind.RefactorInline = 'refactor.inline';
    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */
    CodeActionKind.RefactorRewrite = 'refactor.rewrite';
    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */
    CodeActionKind.Source = 'source';
    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */
    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */
    CodeActionKind.SourceFixAll = 'source.fixAll';
})(CodeActionKind || (CodeActionKind = {}));
/**
 * The CodeActionContext namespace provides helper functions to work with
 * [CodeActionContext](#CodeActionContext) literals.
 */
var CodeActionContext;
(function (CodeActionContext) {
    /**
     * Creates a new CodeActionContext literal.
     */
    function create(diagnostics, only) {
        var result = { diagnostics: diagnostics };
        if (only !== undefined && only !== null) {
            result.only = only;
        }
        return result;
    }
    CodeActionContext.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string));
    }
    CodeActionContext.is = is;
})(CodeActionContext || (CodeActionContext = {}));
var CodeAction;
(function (CodeAction) {
    function create(title, kindOrCommandOrEdit, kind) {
        var result = { title: title };
        var checkKind = true;
        if (typeof kindOrCommandOrEdit === 'string') {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
        }
        else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
        }
        else {
            result.edit = kindOrCommandOrEdit;
        }
        if (checkKind && kind !== undefined) {
            result.kind = kind;
        }
        return result;
    }
    CodeAction.create = create;
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.title) &&
            (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&
            (candidate.kind === undefined || Is.string(candidate.kind)) &&
            (candidate.edit !== undefined || candidate.command !== undefined) &&
            (candidate.command === undefined || Command.is(candidate.command)) &&
            (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&
            (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
    }
    CodeAction.is = is;
})(CodeAction || (CodeAction = {}));
/**
 * The CodeLens namespace provides helper functions to work with
 * [CodeLens](#CodeLens) literals.
 */
var CodeLens;
(function (CodeLens) {
    /**
     * Creates a new CodeLens literal.
     */
    function create(range, data) {
        var result = { range: range };
        if (Is.defined(data)) {
            result.data = data;
        }
        return result;
    }
    CodeLens.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
    }
    CodeLens.is = is;
})(CodeLens || (CodeLens = {}));
/**
 * The FormattingOptions namespace provides helper functions to work with
 * [FormattingOptions](#FormattingOptions) literals.
 */
var FormattingOptions;
(function (FormattingOptions) {
    /**
     * Creates a new FormattingOptions literal.
     */
    function create(tabSize, insertSpaces) {
        return { tabSize: tabSize, insertSpaces: insertSpaces };
    }
    FormattingOptions.create = create;
    /**
     * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
    }
    FormattingOptions.is = is;
})(FormattingOptions || (FormattingOptions = {}));
/**
 * The DocumentLink namespace provides helper functions to work with
 * [DocumentLink](#DocumentLink) literals.
 */
var DocumentLink;
(function (DocumentLink) {
    /**
     * Creates a new DocumentLink literal.
     */
    function create(range, target, data) {
        return { range: range, target: target, data: data };
    }
    DocumentLink.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
    }
    DocumentLink.is = is;
})(DocumentLink || (DocumentLink = {}));
/**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */
var SelectionRange;
(function (SelectionRange) {
    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */
    function create(range, parent) {
        return { range: range, parent: parent };
    }
    SelectionRange.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
    }
    SelectionRange.is = is;
})(SelectionRange || (SelectionRange = {}));
var EOL = ['\n', '\r\n', '\r'];
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)
            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
    }
    TextDocument.is = is;
    function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort(edits, function (a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            }
            else {
                throw new Error('Overlapping edit');
            }
            lastModifiedOffset = startOffset;
        }
        return text;
    }
    TextDocument.applyEdits = applyEdits;
    function mergeSort(data, compare) {
        if (data.length <= 1) {
            // sorted
            return data;
        }
        var p = (data.length / 2) | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort(left, compare);
        mergeSort(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
                // smaller_equal -> take left to preserve order
                data[i++] = left[leftIdx++];
            }
            else {
                // greater -> take right
                data[i++] = right[rightIdx++];
            }
        }
        while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
        }
        return data;
    }
})(TextDocument || (TextDocument = {}));
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var FullTextDocument = /** @class */ (function () {
    function FullTextDocument(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    Object.defineProperty(FullTextDocument.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "languageId", {
        get: function () {
            return this._languageId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: false,
        configurable: true
    });
    FullTextDocument.prototype.getText = function (range) {
        if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    };
    FullTextDocument.prototype.update = function (event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = undefined;
    };
    FullTextDocument.prototype.getLineOffsets = function () {
        if (this._lineOffsets === undefined) {
            var lineOffsets = [];
            var text = this._content;
            var isLineStart = true;
            for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                    lineOffsets.push(i);
                    isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = (ch === '\r' || ch === '\n');
                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                    i++;
                }
            }
            if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
    };
    FullTextDocument.prototype.positionAt = function (offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
            return Position.create(0, offset);
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        var line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
    };
    FullTextDocument.prototype.offsetAt = function (position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
        get: function () {
            return this.getLineOffsets().length;
        },
        enumerable: false,
        configurable: true
    });
    return FullTextDocument;
}());
var Is;
(function (Is) {
    var toString = Object.prototype.toString;
    function defined(value) {
        return typeof value !== 'undefined';
    }
    Is.defined = defined;
    function undefined(value) {
        return typeof value === 'undefined';
    }
    Is.undefined = undefined;
    function boolean(value) {
        return value === true || value === false;
    }
    Is.boolean = boolean;
    function string(value) {
        return toString.call(value) === '[object String]';
    }
    Is.string = string;
    function number(value) {
        return toString.call(value) === '[object Number]';
    }
    Is.number = number;
    function numberRange(value, min, max) {
        return toString.call(value) === '[object Number]' && min <= value && value <= max;
    }
    Is.numberRange = numberRange;
    function integer(value) {
        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
    }
    Is.integer = integer;
    function uinteger(value) {
        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
    }
    Is.uinteger = uinteger;
    function func(value) {
        return toString.call(value) === '[object Function]';
    }
    Is.func = func;
    function objectLiteral(value) {
        // Strictly speaking class instances pass this check as well. Since the LSP
        // doesn't use classes we ignore this for now. If we do we need to add something
        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
        return value !== null && typeof value === 'object';
    }
    Is.objectLiteral = objectLiteral;
    function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
    }
    Is.typedArray = typedArray;
})(Is || (Is = {}));


/***/ }),
/* 29 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtocolNotificationType = exports.ProtocolNotificationType0 = exports.ProtocolRequestType = exports.ProtocolRequestType0 = exports.RegistrationType = void 0;
const vscode_jsonrpc_1 = __webpack_require__(7);
class RegistrationType {
    constructor(method) {
        this.method = method;
    }
}
exports.RegistrationType = RegistrationType;
class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolRequestType0 = ProtocolRequestType0;
class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
    constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
    }
}
exports.ProtocolRequestType = ProtocolRequestType;
class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolNotificationType0 = ProtocolNotificationType0;
class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
    constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
    }
}
exports.ProtocolNotificationType = ProtocolNotificationType;
// let x: ProtocolNotificationType<number, { value: number}>;
// let y: ProtocolNotificationType<string, { value: number}>;
// x = y;
//# sourceMappingURL=messages.js.map

/***/ }),
/* 30 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeError = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.DocumentFilter = void 0;
exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.SemanticTokens = exports.SemanticTokenModifiers = exports.SemanticTokenTypes = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = void 0;
const Is = __webpack_require__(31);
const messages_1 = __webpack_require__(29);
const protocol_implementation_1 = __webpack_require__(32);
Object.defineProperty(exports, "ImplementationRequest", ({ enumerable: true, get: function () { return protocol_implementation_1.ImplementationRequest; } }));
const protocol_typeDefinition_1 = __webpack_require__(33);
Object.defineProperty(exports, "TypeDefinitionRequest", ({ enumerable: true, get: function () { return protocol_typeDefinition_1.TypeDefinitionRequest; } }));
const protocol_workspaceFolders_1 = __webpack_require__(34);
Object.defineProperty(exports, "WorkspaceFoldersRequest", ({ enumerable: true, get: function () { return protocol_workspaceFolders_1.WorkspaceFoldersRequest; } }));
Object.defineProperty(exports, "DidChangeWorkspaceFoldersNotification", ({ enumerable: true, get: function () { return protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification; } }));
const protocol_configuration_1 = __webpack_require__(35);
Object.defineProperty(exports, "ConfigurationRequest", ({ enumerable: true, get: function () { return protocol_configuration_1.ConfigurationRequest; } }));
const protocol_colorProvider_1 = __webpack_require__(36);
Object.defineProperty(exports, "DocumentColorRequest", ({ enumerable: true, get: function () { return protocol_colorProvider_1.DocumentColorRequest; } }));
Object.defineProperty(exports, "ColorPresentationRequest", ({ enumerable: true, get: function () { return protocol_colorProvider_1.ColorPresentationRequest; } }));
const protocol_foldingRange_1 = __webpack_require__(37);
Object.defineProperty(exports, "FoldingRangeRequest", ({ enumerable: true, get: function () { return protocol_foldingRange_1.FoldingRangeRequest; } }));
const protocol_declaration_1 = __webpack_require__(38);
Object.defineProperty(exports, "DeclarationRequest", ({ enumerable: true, get: function () { return protocol_declaration_1.DeclarationRequest; } }));
const protocol_selectionRange_1 = __webpack_require__(39);
Object.defineProperty(exports, "SelectionRangeRequest", ({ enumerable: true, get: function () { return protocol_selectionRange_1.SelectionRangeRequest; } }));
const protocol_progress_1 = __webpack_require__(40);
Object.defineProperty(exports, "WorkDoneProgress", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgress; } }));
Object.defineProperty(exports, "WorkDoneProgressCreateRequest", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCreateRequest; } }));
Object.defineProperty(exports, "WorkDoneProgressCancelNotification", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCancelNotification; } }));
const protocol_callHierarchy_1 = __webpack_require__(41);
Object.defineProperty(exports, "CallHierarchyIncomingCallsRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest; } }));
Object.defineProperty(exports, "CallHierarchyOutgoingCallsRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest; } }));
Object.defineProperty(exports, "CallHierarchyPrepareRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyPrepareRequest; } }));
const protocol_semanticTokens_1 = __webpack_require__(42);
Object.defineProperty(exports, "SemanticTokenTypes", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokenTypes; } }));
Object.defineProperty(exports, "SemanticTokenModifiers", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokenModifiers; } }));
Object.defineProperty(exports, "SemanticTokens", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokens; } }));
Object.defineProperty(exports, "TokenFormat", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.TokenFormat; } }));
Object.defineProperty(exports, "SemanticTokensRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRequest; } }));
Object.defineProperty(exports, "SemanticTokensDeltaRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensDeltaRequest; } }));
Object.defineProperty(exports, "SemanticTokensRangeRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRangeRequest; } }));
Object.defineProperty(exports, "SemanticTokensRefreshRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRefreshRequest; } }));
Object.defineProperty(exports, "SemanticTokensRegistrationType", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRegistrationType; } }));
const protocol_showDocument_1 = __webpack_require__(43);
Object.defineProperty(exports, "ShowDocumentRequest", ({ enumerable: true, get: function () { return protocol_showDocument_1.ShowDocumentRequest; } }));
const protocol_linkedEditingRange_1 = __webpack_require__(44);
Object.defineProperty(exports, "LinkedEditingRangeRequest", ({ enumerable: true, get: function () { return protocol_linkedEditingRange_1.LinkedEditingRangeRequest; } }));
const protocol_fileOperations_1 = __webpack_require__(45);
Object.defineProperty(exports, "FileOperationPatternKind", ({ enumerable: true, get: function () { return protocol_fileOperations_1.FileOperationPatternKind; } }));
Object.defineProperty(exports, "DidCreateFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidCreateFilesNotification; } }));
Object.defineProperty(exports, "WillCreateFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillCreateFilesRequest; } }));
Object.defineProperty(exports, "DidRenameFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidRenameFilesNotification; } }));
Object.defineProperty(exports, "WillRenameFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillRenameFilesRequest; } }));
Object.defineProperty(exports, "DidDeleteFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidDeleteFilesNotification; } }));
Object.defineProperty(exports, "WillDeleteFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillDeleteFilesRequest; } }));
const protocol_moniker_1 = __webpack_require__(46);
Object.defineProperty(exports, "UniquenessLevel", ({ enumerable: true, get: function () { return protocol_moniker_1.UniquenessLevel; } }));
Object.defineProperty(exports, "MonikerKind", ({ enumerable: true, get: function () { return protocol_moniker_1.MonikerKind; } }));
Object.defineProperty(exports, "MonikerRequest", ({ enumerable: true, get: function () { return protocol_moniker_1.MonikerRequest; } }));
// @ts-ignore: to avoid inlining LocationLink as dynamic import
let __noDynamicImport;
/**
 * The DocumentFilter namespace provides helper functions to work with
 * [DocumentFilter](#DocumentFilter) literals.
 */
var DocumentFilter;
(function (DocumentFilter) {
    function is(value) {
        const candidate = value;
        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
    }
    DocumentFilter.is = is;
})(DocumentFilter = exports.DocumentFilter || (exports.DocumentFilter = {}));
/**
 * The DocumentSelector namespace provides helper functions to work with
 * [DocumentSelector](#DocumentSelector)s.
 */
var DocumentSelector;
(function (DocumentSelector) {
    function is(value) {
        if (!Array.isArray(value)) {
            return false;
        }
        for (let elem of value) {
            if (!Is.string(elem) && !DocumentFilter.is(elem)) {
                return false;
            }
        }
        return true;
    }
    DocumentSelector.is = is;
})(DocumentSelector = exports.DocumentSelector || (exports.DocumentSelector = {}));
/**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */
var RegistrationRequest;
(function (RegistrationRequest) {
    RegistrationRequest.type = new messages_1.ProtocolRequestType('client/registerCapability');
})(RegistrationRequest = exports.RegistrationRequest || (exports.RegistrationRequest = {}));
/**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */
var UnregistrationRequest;
(function (UnregistrationRequest) {
    UnregistrationRequest.type = new messages_1.ProtocolRequestType('client/unregisterCapability');
})(UnregistrationRequest = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));
var ResourceOperationKind;
(function (ResourceOperationKind) {
    /**
     * Supports creating new files and folders.
     */
    ResourceOperationKind.Create = 'create';
    /**
     * Supports renaming existing files and folders.
     */
    ResourceOperationKind.Rename = 'rename';
    /**
     * Supports deleting existing files and folders.
     */
    ResourceOperationKind.Delete = 'delete';
})(ResourceOperationKind = exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));
var FailureHandlingKind;
(function (FailureHandlingKind) {
    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */
    FailureHandlingKind.Abort = 'abort';
    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */
    FailureHandlingKind.Transactional = 'transactional';
    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling strategy is abort.
     */
    FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */
    FailureHandlingKind.Undo = 'undo';
})(FailureHandlingKind = exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));
/**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * [StaticRegistrationOptions](#StaticRegistrationOptions) literals.
 */
var StaticRegistrationOptions;
(function (StaticRegistrationOptions) {
    function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
    }
    StaticRegistrationOptions.hasId = hasId;
})(StaticRegistrationOptions = exports.StaticRegistrationOptions || (exports.StaticRegistrationOptions = {}));
/**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * [TextDocumentRegistrationOptions](#TextDocumentRegistrationOptions) literals.
 */
var TextDocumentRegistrationOptions;
(function (TextDocumentRegistrationOptions) {
    function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
    }
    TextDocumentRegistrationOptions.is = is;
})(TextDocumentRegistrationOptions = exports.TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = {}));
/**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * [WorkDoneProgressOptions](#WorkDoneProgressOptions) literals.
 */
var WorkDoneProgressOptions;
(function (WorkDoneProgressOptions) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
    }
    WorkDoneProgressOptions.is = is;
    function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
    }
    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
})(WorkDoneProgressOptions = exports.WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = {}));
/**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type [InitializeParams](#InitializeParams)
 * the response if of type [InitializeResult](#InitializeResult) of a Thenable that
 * resolves to such.
 */
var InitializeRequest;
(function (InitializeRequest) {
    InitializeRequest.type = new messages_1.ProtocolRequestType('initialize');
})(InitializeRequest = exports.InitializeRequest || (exports.InitializeRequest = {}));
/**
 * Known error codes for an `InitializeError`;
 */
var InitializeError;
(function (InitializeError) {
    /**
     * If the protocol version provided by the client can't be handled by the server.
     * @deprecated This initialize error got replaced by client capabilities. There is
     * no version handshake in version 3.0x
     */
    InitializeError.unknownProtocolVersion = 1;
})(InitializeError = exports.InitializeError || (exports.InitializeError = {}));
/**
 * The initialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */
var InitializedNotification;
(function (InitializedNotification) {
    InitializedNotification.type = new messages_1.ProtocolNotificationType('initialized');
})(InitializedNotification = exports.InitializedNotification || (exports.InitializedNotification = {}));
//---- Shutdown Method ----
/**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */
var ShutdownRequest;
(function (ShutdownRequest) {
    ShutdownRequest.type = new messages_1.ProtocolRequestType0('shutdown');
})(ShutdownRequest = exports.ShutdownRequest || (exports.ShutdownRequest = {}));
//---- Exit Notification ----
/**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */
var ExitNotification;
(function (ExitNotification) {
    ExitNotification.type = new messages_1.ProtocolNotificationType0('exit');
})(ExitNotification = exports.ExitNotification || (exports.ExitNotification = {}));
/**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */
var DidChangeConfigurationNotification;
(function (DidChangeConfigurationNotification) {
    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeConfiguration');
})(DidChangeConfigurationNotification = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));
//---- Message show and log notifications ----
/**
 * The message type
 */
var MessageType;
(function (MessageType) {
    /**
     * An error message.
     */
    MessageType.Error = 1;
    /**
     * A warning message.
     */
    MessageType.Warning = 2;
    /**
     * An information message.
     */
    MessageType.Info = 3;
    /**
     * A log message.
     */
    MessageType.Log = 4;
})(MessageType = exports.MessageType || (exports.MessageType = {}));
/**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */
var ShowMessageNotification;
(function (ShowMessageNotification) {
    ShowMessageNotification.type = new messages_1.ProtocolNotificationType('window/showMessage');
})(ShowMessageNotification = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));
/**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */
var ShowMessageRequest;
(function (ShowMessageRequest) {
    ShowMessageRequest.type = new messages_1.ProtocolRequestType('window/showMessageRequest');
})(ShowMessageRequest = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));
/**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */
var LogMessageNotification;
(function (LogMessageNotification) {
    LogMessageNotification.type = new messages_1.ProtocolNotificationType('window/logMessage');
})(LogMessageNotification = exports.LogMessageNotification || (exports.LogMessageNotification = {}));
//---- Telemetry notification
/**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */
var TelemetryEventNotification;
(function (TelemetryEventNotification) {
    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType('telemetry/event');
})(TelemetryEventNotification = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));
/**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */
var TextDocumentSyncKind;
(function (TextDocumentSyncKind) {
    /**
     * Documents should not be synced at all.
     */
    TextDocumentSyncKind.None = 0;
    /**
     * Documents are synced by always sending the full content
     * of the document.
     */
    TextDocumentSyncKind.Full = 1;
    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */
    TextDocumentSyncKind.Incremental = 2;
})(TextDocumentSyncKind = exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));
/**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */
var DidOpenTextDocumentNotification;
(function (DidOpenTextDocumentNotification) {
    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
})(DidOpenTextDocumentNotification = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));
var TextDocumentContentChangeEvent;
(function (TextDocumentContentChangeEvent) {
    /**
     * Checks whether the information describes a delta event.
     */
    function isIncremental(event) {
        let candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range !== undefined &&
            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
    }
    TextDocumentContentChangeEvent.isIncremental = isIncremental;
    /**
     * Checks whether the information describes a full replacement event.
     */
    function isFull(event) {
        let candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
    }
    TextDocumentContentChangeEvent.isFull = isFull;
})(TextDocumentContentChangeEvent = exports.TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = {}));
/**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */
var DidChangeTextDocumentNotification;
(function (DidChangeTextDocumentNotification) {
    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
})(DidChangeTextDocumentNotification = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));
/**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */
var DidCloseTextDocumentNotification;
(function (DidCloseTextDocumentNotification) {
    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
})(DidCloseTextDocumentNotification = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));
/**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */
var DidSaveTextDocumentNotification;
(function (DidSaveTextDocumentNotification) {
    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
})(DidSaveTextDocumentNotification = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));
/**
 * Represents reasons why a text document is saved.
 */
var TextDocumentSaveReason;
(function (TextDocumentSaveReason) {
    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */
    TextDocumentSaveReason.Manual = 1;
    /**
     * Automatic after a delay.
     */
    TextDocumentSaveReason.AfterDelay = 2;
    /**
     * When the editor lost focus.
     */
    TextDocumentSaveReason.FocusOut = 3;
})(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
/**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */
var WillSaveTextDocumentNotification;
(function (WillSaveTextDocumentNotification) {
    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
})(WillSaveTextDocumentNotification = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));
/**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */
var WillSaveTextDocumentWaitUntilRequest;
(function (WillSaveTextDocumentWaitUntilRequest) {
    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
})(WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));
/**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */
var DidChangeWatchedFilesNotification;
(function (DidChangeWatchedFilesNotification) {
    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeWatchedFiles');
})(DidChangeWatchedFilesNotification = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));
/**
 * The file event type
 */
var FileChangeType;
(function (FileChangeType) {
    /**
     * The file got created.
     */
    FileChangeType.Created = 1;
    /**
     * The file got changed.
     */
    FileChangeType.Changed = 2;
    /**
     * The file got deleted.
     */
    FileChangeType.Deleted = 3;
})(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
var WatchKind;
(function (WatchKind) {
    /**
     * Interested in create events.
     */
    WatchKind.Create = 1;
    /**
     * Interested in change events
     */
    WatchKind.Change = 2;
    /**
     * Interested in delete events
     */
    WatchKind.Delete = 4;
})(WatchKind = exports.WatchKind || (exports.WatchKind = {}));
/**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */
var PublishDiagnosticsNotification;
(function (PublishDiagnosticsNotification) {
    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType('textDocument/publishDiagnostics');
})(PublishDiagnosticsNotification = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));
/**
 * How a completion was triggered
 */
var CompletionTriggerKind;
(function (CompletionTriggerKind) {
    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */
    CompletionTriggerKind.Invoked = 1;
    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */
    CompletionTriggerKind.TriggerCharacter = 2;
    /**
     * Completion was re-triggered as current completion list is incomplete
     */
    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
})(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
/**
 * Request to request completion at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response
 * is of type [CompletionItem[]](#CompletionItem) or [CompletionList](#CompletionList)
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the [`detail`](#CompletionItem.detail)
 * and [`documentation`](#CompletionItem.documentation) properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */
var CompletionRequest;
(function (CompletionRequest) {
    CompletionRequest.method = 'textDocument/completion';
    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
})(CompletionRequest = exports.CompletionRequest || (exports.CompletionRequest = {}));
/**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type [CompletionItem](#CompletionItem) the response
 * is of type [CompletionItem](#CompletionItem) or a Thenable that resolves to such.
 */
var CompletionResolveRequest;
(function (CompletionResolveRequest) {
    CompletionResolveRequest.method = 'completionItem/resolve';
    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
})(CompletionResolveRequest = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));
/**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response is of
 * type [Hover](#Hover) or a Thenable that resolves to such.
 */
var HoverRequest;
(function (HoverRequest) {
    HoverRequest.method = 'textDocument/hover';
    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
})(HoverRequest = exports.HoverRequest || (exports.HoverRequest = {}));
/**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */
var SignatureHelpTriggerKind;
(function (SignatureHelpTriggerKind) {
    /**
     * Signature help was invoked manually by the user or by a command.
     */
    SignatureHelpTriggerKind.Invoked = 1;
    /**
     * Signature help was triggered by a trigger character.
     */
    SignatureHelpTriggerKind.TriggerCharacter = 2;
    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */
    SignatureHelpTriggerKind.ContentChange = 3;
})(SignatureHelpTriggerKind = exports.SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = {}));
var SignatureHelpRequest;
(function (SignatureHelpRequest) {
    SignatureHelpRequest.method = 'textDocument/signatureHelp';
    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
})(SignatureHelpRequest = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));
/**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the response is of either type [Definition](#Definition)
 * or a typed array of [DefinitionLink](#DefinitionLink) or a Thenable that resolves
 * to such.
 */
var DefinitionRequest;
(function (DefinitionRequest) {
    DefinitionRequest.method = 'textDocument/definition';
    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
})(DefinitionRequest = exports.DefinitionRequest || (exports.DefinitionRequest = {}));
/**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type [ReferenceParams](#ReferenceParams) the response is of type
 * [Location[]](#Location) or a Thenable that resolves to such.
 */
var ReferencesRequest;
(function (ReferencesRequest) {
    ReferencesRequest.method = 'textDocument/references';
    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
})(ReferencesRequest = exports.ReferencesRequest || (exports.ReferencesRequest = {}));
/**
 * Request to resolve a [DocumentHighlight](#DocumentHighlight) for a given
 * text document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]
 * (#DocumentHighlight) or a Thenable that resolves to such.
 */
var DocumentHighlightRequest;
(function (DocumentHighlightRequest) {
    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
})(DocumentHighlightRequest = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));
/**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type [TextDocumentIdentifier](#TextDocumentIdentifier) the
 * response is of type [SymbolInformation[]](#SymbolInformation) or a Thenable
 * that resolves to such.
 */
var DocumentSymbolRequest;
(function (DocumentSymbolRequest) {
    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
})(DocumentSymbolRequest = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));
/**
 * A request to provide commands for the given text document and range.
 */
var CodeActionRequest;
(function (CodeActionRequest) {
    CodeActionRequest.method = 'textDocument/codeAction';
    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
})(CodeActionRequest = exports.CodeActionRequest || (exports.CodeActionRequest = {}));
/**
 * Request to resolve additional information for a given code action.The request's
 * parameter is of type [CodeAction](#CodeAction) the response
 * is of type [CodeAction](#CodeAction) or a Thenable that resolves to such.
 */
var CodeActionResolveRequest;
(function (CodeActionResolveRequest) {
    CodeActionResolveRequest.method = 'codeAction/resolve';
    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);
})(CodeActionResolveRequest = exports.CodeActionResolveRequest || (exports.CodeActionResolveRequest = {}));
/**
 * A request to list project-wide symbols matching the query string given
 * by the [WorkspaceSymbolParams](#WorkspaceSymbolParams). The response is
 * of type [SymbolInformation[]](#SymbolInformation) or a Thenable that
 * resolves to such.
 */
var WorkspaceSymbolRequest;
(function (WorkspaceSymbolRequest) {
    WorkspaceSymbolRequest.method = 'workspace/symbol';
    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
})(WorkspaceSymbolRequest = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));
/**
 * A request to provide code lens for the given text document.
 */
var CodeLensRequest;
(function (CodeLensRequest) {
    CodeLensRequest.method = 'textDocument/codeLens';
    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);
})(CodeLensRequest = exports.CodeLensRequest || (exports.CodeLensRequest = {}));
/**
 * A request to resolve a command for a given code lens.
 */
var CodeLensResolveRequest;
(function (CodeLensResolveRequest) {
    CodeLensResolveRequest.method = 'codeLens/resolve';
    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);
})(CodeLensResolveRequest = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));
/**
 * A request to refresh all code actions
 *
 * @since 3.16.0
 */
var CodeLensRefreshRequest;
(function (CodeLensRefreshRequest) {
    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;
    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);
})(CodeLensRefreshRequest = exports.CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = {}));
/**
 * A request to provide document links
 */
var DocumentLinkRequest;
(function (DocumentLinkRequest) {
    DocumentLinkRequest.method = 'textDocument/documentLink';
    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
})(DocumentLinkRequest = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));
/**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type [DocumentLink](#DocumentLink) the response
 * is of type [DocumentLink](#DocumentLink) or a Thenable that resolves to such.
 */
var DocumentLinkResolveRequest;
(function (DocumentLinkResolveRequest) {
    DocumentLinkResolveRequest.method = 'documentLink/resolve';
    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);
})(DocumentLinkResolveRequest = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));
/**
 * A request to to format a whole document.
 */
var DocumentFormattingRequest;
(function (DocumentFormattingRequest) {
    DocumentFormattingRequest.method = 'textDocument/formatting';
    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
})(DocumentFormattingRequest = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));
/**
 * A request to to format a range in a document.
 */
var DocumentRangeFormattingRequest;
(function (DocumentRangeFormattingRequest) {
    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
})(DocumentRangeFormattingRequest = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));
/**
 * A request to format a document on type.
 */
var DocumentOnTypeFormattingRequest;
(function (DocumentOnTypeFormattingRequest) {
    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
})(DocumentOnTypeFormattingRequest = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));
//---- Rename ----------------------------------------------
var PrepareSupportDefaultBehavior;
(function (PrepareSupportDefaultBehavior) {
    /**
     * The client's default behavior is to select the identifier
     * according the to language's syntax rule.
     */
    PrepareSupportDefaultBehavior.Identifier = 1;
})(PrepareSupportDefaultBehavior = exports.PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = {}));
/**
 * A request to rename a symbol.
 */
var RenameRequest;
(function (RenameRequest) {
    RenameRequest.method = 'textDocument/rename';
    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
})(RenameRequest = exports.RenameRequest || (exports.RenameRequest = {}));
/**
 * A request to test and perform the setup necessary for a rename.
 *
 * @since 3.16 - support for default behavior
 */
var PrepareRenameRequest;
(function (PrepareRenameRequest) {
    PrepareRenameRequest.method = 'textDocument/prepareRename';
    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
})(PrepareRenameRequest = exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));
/**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */
var ExecuteCommandRequest;
(function (ExecuteCommandRequest) {
    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType('workspace/executeCommand');
})(ExecuteCommandRequest = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));
/**
 * A request sent from the server to the client to modified certain resources.
 */
var ApplyWorkspaceEditRequest;
(function (ApplyWorkspaceEditRequest) {
    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
})(ApplyWorkspaceEditRequest = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));
//# sourceMappingURL=protocol.js.map

/***/ }),
/* 31 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.objectLiteral = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function objectLiteral(value) {
    // Strictly speaking class instances pass this check as well. Since the LSP
    // doesn't use classes we ignore this for now. If we do we need to add something
    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
    return value !== null && typeof value === 'object';
}
exports.objectLiteral = objectLiteral;
//# sourceMappingURL=is.js.map

/***/ }),
/* 32 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImplementationRequest = void 0;
const messages_1 = __webpack_require__(29);
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
var ImplementationRequest;
(function (ImplementationRequest) {
    ImplementationRequest.method = 'textDocument/implementation';
    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
})(ImplementationRequest = exports.ImplementationRequest || (exports.ImplementationRequest = {}));
//# sourceMappingURL=protocol.implementation.js.map

/***/ }),
/* 33 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeDefinitionRequest = void 0;
const messages_1 = __webpack_require__(29);
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
var TypeDefinitionRequest;
(function (TypeDefinitionRequest) {
    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
})(TypeDefinitionRequest = exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));
//# sourceMappingURL=protocol.typeDefinition.js.map

/***/ }),
/* 34 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = void 0;
const messages_1 = __webpack_require__(29);
/**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */
var WorkspaceFoldersRequest;
(function (WorkspaceFoldersRequest) {
    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0('workspace/workspaceFolders');
})(WorkspaceFoldersRequest = exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));
/**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */
var DidChangeWorkspaceFoldersNotification;
(function (DidChangeWorkspaceFoldersNotification) {
    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeWorkspaceFolders');
})(DidChangeWorkspaceFoldersNotification = exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));
//# sourceMappingURL=protocol.workspaceFolders.js.map

/***/ }),
/* 35 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigurationRequest = void 0;
const messages_1 = __webpack_require__(29);
/**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */
var ConfigurationRequest;
(function (ConfigurationRequest) {
    ConfigurationRequest.type = new messages_1.ProtocolRequestType('workspace/configuration');
})(ConfigurationRequest = exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));
//# sourceMappingURL=protocol.configuration.js.map

/***/ }),
/* 36 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorPresentationRequest = exports.DocumentColorRequest = void 0;
const messages_1 = __webpack_require__(29);
/**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type [DocumentColorParams](#DocumentColorParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */
var DocumentColorRequest;
(function (DocumentColorRequest) {
    DocumentColorRequest.method = 'textDocument/documentColor';
    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
})(DocumentColorRequest = exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));
/**
 * A request to list all presentation for a color. The request's
 * parameter is of type [ColorPresentationParams](#ColorPresentationParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */
var ColorPresentationRequest;
(function (ColorPresentationRequest) {
    ColorPresentationRequest.type = new messages_1.ProtocolRequestType('textDocument/colorPresentation');
})(ColorPresentationRequest = exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));
//# sourceMappingURL=protocol.colorProvider.js.map

/***/ }),
/* 37 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FoldingRangeRequest = exports.FoldingRangeKind = void 0;
const messages_1 = __webpack_require__(29);
/**
 * Enum of known range kinds
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind["Comment"] = "comment";
    /**
     * Folding range for a imports or includes
     */
    FoldingRangeKind["Imports"] = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind["Region"] = "region";
})(FoldingRangeKind = exports.FoldingRangeKind || (exports.FoldingRangeKind = {}));
/**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type [FoldingRangeParams](#FoldingRangeParams), the
 * response is of type [FoldingRangeList](#FoldingRangeList) or a Thenable
 * that resolves to such.
 */
var FoldingRangeRequest;
(function (FoldingRangeRequest) {
    FoldingRangeRequest.method = 'textDocument/foldingRange';
    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
})(FoldingRangeRequest = exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));
//# sourceMappingURL=protocol.foldingRange.js.map

/***/ }),
/* 38 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeclarationRequest = void 0;
const messages_1 = __webpack_require__(29);
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Declaration](#Declaration)
 * or a typed array of [DeclarationLink](#DeclarationLink) or a Thenable that resolves
 * to such.
 */
var DeclarationRequest;
(function (DeclarationRequest) {
    DeclarationRequest.method = 'textDocument/declaration';
    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
})(DeclarationRequest = exports.DeclarationRequest || (exports.DeclarationRequest = {}));
//# sourceMappingURL=protocol.declaration.js.map

/***/ }),
/* 39 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionRangeRequest = void 0;
const messages_1 = __webpack_require__(29);
/**
 * A request to provide selection ranges in a document. The request's
 * parameter is of type [SelectionRangeParams](#SelectionRangeParams), the
 * response is of type [SelectionRange[]](#SelectionRange[]) or a Thenable
 * that resolves to such.
 */
var SelectionRangeRequest;
(function (SelectionRangeRequest) {
    SelectionRangeRequest.method = 'textDocument/selectionRange';
    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
})(SelectionRangeRequest = exports.SelectionRangeRequest || (exports.SelectionRangeRequest = {}));
//# sourceMappingURL=protocol.selectionRange.js.map

/***/ }),
/* 40 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = void 0;
const vscode_jsonrpc_1 = __webpack_require__(7);
const messages_1 = __webpack_require__(29);
var WorkDoneProgress;
(function (WorkDoneProgress) {
    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
    function is(value) {
        return value === WorkDoneProgress.type;
    }
    WorkDoneProgress.is = is;
})(WorkDoneProgress = exports.WorkDoneProgress || (exports.WorkDoneProgress = {}));
/**
 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
 * reporting from the server.
 */
var WorkDoneProgressCreateRequest;
(function (WorkDoneProgressCreateRequest) {
    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType('window/workDoneProgress/create');
})(WorkDoneProgressCreateRequest = exports.WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = {}));
/**
 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
 * initiated on the server side.
 */
var WorkDoneProgressCancelNotification;
(function (WorkDoneProgressCancelNotification) {
    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType('window/workDoneProgress/cancel');
})(WorkDoneProgressCancelNotification = exports.WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = {}));
//# sourceMappingURL=protocol.progress.js.map

/***/ }),
/* 41 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = void 0;
const messages_1 = __webpack_require__(29);
/**
 * A request to result a `CallHierarchyItem` in a document at a given position.
 * Can be used as an input to a incoming or outgoing call hierarchy.
 *
 * @since 3.16.0
 */
var CallHierarchyPrepareRequest;
(function (CallHierarchyPrepareRequest) {
    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
})(CallHierarchyPrepareRequest = exports.CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = {}));
/**
 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */
var CallHierarchyIncomingCallsRequest;
(function (CallHierarchyIncomingCallsRequest) {
    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
})(CallHierarchyIncomingCallsRequest = exports.CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = {}));
/**
 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */
var CallHierarchyOutgoingCallsRequest;
(function (CallHierarchyOutgoingCallsRequest) {
    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
})(CallHierarchyOutgoingCallsRequest = exports.CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = {}));
//# sourceMappingURL=protocol.callHierarchy.js.map

/***/ }),
/* 42 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = exports.SemanticTokens = exports.SemanticTokenModifiers = exports.SemanticTokenTypes = void 0;
const messages_1 = __webpack_require__(29);
/**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */
var SemanticTokenTypes;
(function (SemanticTokenTypes) {
    SemanticTokenTypes["namespace"] = "namespace";
    /**
     * Represents a generic type. Acts as a fallback for types which can't be mapped to
     * a specific type like class or enum.
     */
    SemanticTokenTypes["type"] = "type";
    SemanticTokenTypes["class"] = "class";
    SemanticTokenTypes["enum"] = "enum";
    SemanticTokenTypes["interface"] = "interface";
    SemanticTokenTypes["struct"] = "struct";
    SemanticTokenTypes["typeParameter"] = "typeParameter";
    SemanticTokenTypes["parameter"] = "parameter";
    SemanticTokenTypes["variable"] = "variable";
    SemanticTokenTypes["property"] = "property";
    SemanticTokenTypes["enumMember"] = "enumMember";
    SemanticTokenTypes["event"] = "event";
    SemanticTokenTypes["function"] = "function";
    SemanticTokenTypes["method"] = "method";
    SemanticTokenTypes["macro"] = "macro";
    SemanticTokenTypes["keyword"] = "keyword";
    SemanticTokenTypes["modifier"] = "modifier";
    SemanticTokenTypes["comment"] = "comment";
    SemanticTokenTypes["string"] = "string";
    SemanticTokenTypes["number"] = "number";
    SemanticTokenTypes["regexp"] = "regexp";
    SemanticTokenTypes["operator"] = "operator";
})(SemanticTokenTypes = exports.SemanticTokenTypes || (exports.SemanticTokenTypes = {}));
/**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */
var SemanticTokenModifiers;
(function (SemanticTokenModifiers) {
    SemanticTokenModifiers["declaration"] = "declaration";
    SemanticTokenModifiers["definition"] = "definition";
    SemanticTokenModifiers["readonly"] = "readonly";
    SemanticTokenModifiers["static"] = "static";
    SemanticTokenModifiers["deprecated"] = "deprecated";
    SemanticTokenModifiers["abstract"] = "abstract";
    SemanticTokenModifiers["async"] = "async";
    SemanticTokenModifiers["modification"] = "modification";
    SemanticTokenModifiers["documentation"] = "documentation";
    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
})(SemanticTokenModifiers = exports.SemanticTokenModifiers || (exports.SemanticTokenModifiers = {}));
/**
 * @since 3.16.0
 */
var SemanticTokens;
(function (SemanticTokens) {
    function is(value) {
        const candidate = value;
        return candidate !== undefined && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&
            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
    }
    SemanticTokens.is = is;
})(SemanticTokens = exports.SemanticTokens || (exports.SemanticTokens = {}));
//------- 'textDocument/semanticTokens' -----
var TokenFormat;
(function (TokenFormat) {
    TokenFormat.Relative = 'relative';
})(TokenFormat = exports.TokenFormat || (exports.TokenFormat = {}));
var SemanticTokensRegistrationType;
(function (SemanticTokensRegistrationType) {
    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';
    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);
})(SemanticTokensRegistrationType = exports.SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRequest;
(function (SemanticTokensRequest) {
    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';
    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
})(SemanticTokensRequest = exports.SemanticTokensRequest || (exports.SemanticTokensRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensDeltaRequest;
(function (SemanticTokensDeltaRequest) {
    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';
    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);
})(SemanticTokensDeltaRequest = exports.SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRangeRequest;
(function (SemanticTokensRangeRequest) {
    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
})(SemanticTokensRangeRequest = exports.SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRefreshRequest;
(function (SemanticTokensRefreshRequest) {
    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;
    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);
})(SemanticTokensRefreshRequest = exports.SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = {}));
//# sourceMappingURL=protocol.semanticTokens.js.map

/***/ }),
/* 43 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShowDocumentRequest = void 0;
const messages_1 = __webpack_require__(29);
/**
 * A request to show a document. This request might open an
 * external program depending on the value of the URI to open.
 * For example a request to open `https://code.visualstudio.com/`
 * will very likely open the URI in a WEB browser.
 *
 * @since 3.16.0
*/
var ShowDocumentRequest;
(function (ShowDocumentRequest) {
    ShowDocumentRequest.method = 'window/showDocument';
    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);
})(ShowDocumentRequest = exports.ShowDocumentRequest || (exports.ShowDocumentRequest = {}));
//# sourceMappingURL=protocol.showDocument.js.map

/***/ }),
/* 44 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinkedEditingRangeRequest = void 0;
const messages_1 = __webpack_require__(29);
/**
 * A request to provide ranges that can be edited together.
 *
 * @since 3.16.0
 */
var LinkedEditingRangeRequest;
(function (LinkedEditingRangeRequest) {
    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';
    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);
})(LinkedEditingRangeRequest = exports.LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = {}));
//# sourceMappingURL=protocol.linkedEditingRange.js.map

/***/ }),
/* 45 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = void 0;
const messages_1 = __webpack_require__(29);
/**
 * A pattern kind describing if a glob pattern matches a file a folder or
 * both.
 *
 * @since 3.16.0
 */
var FileOperationPatternKind;
(function (FileOperationPatternKind) {
    /**
     * The pattern matches a file only.
     */
    FileOperationPatternKind.file = 'file';
    /**
     * The pattern matches a folder only.
     */
    FileOperationPatternKind.folder = 'folder';
})(FileOperationPatternKind = exports.FileOperationPatternKind || (exports.FileOperationPatternKind = {}));
/**
 * The will create files request is sent from the client to the server before files are actually
 * created as long as the creation is triggered from within the client.
 *
 * @since 3.16.0
 */
var WillCreateFilesRequest;
(function (WillCreateFilesRequest) {
    WillCreateFilesRequest.method = 'workspace/willCreateFiles';
    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);
})(WillCreateFilesRequest = exports.WillCreateFilesRequest || (exports.WillCreateFilesRequest = {}));
/**
 * The did create files notification is sent from the client to the server when
 * files were created from within the client.
 *
 * @since 3.16.0
 */
var DidCreateFilesNotification;
(function (DidCreateFilesNotification) {
    DidCreateFilesNotification.method = 'workspace/didCreateFiles';
    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);
})(DidCreateFilesNotification = exports.DidCreateFilesNotification || (exports.DidCreateFilesNotification = {}));
/**
 * The will rename files request is sent from the client to the server before files are actually
 * renamed as long as the rename is triggered from within the client.
 *
 * @since 3.16.0
 */
var WillRenameFilesRequest;
(function (WillRenameFilesRequest) {
    WillRenameFilesRequest.method = 'workspace/willRenameFiles';
    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);
})(WillRenameFilesRequest = exports.WillRenameFilesRequest || (exports.WillRenameFilesRequest = {}));
/**
 * The did rename files notification is sent from the client to the server when
 * files were renamed from within the client.
 *
 * @since 3.16.0
 */
var DidRenameFilesNotification;
(function (DidRenameFilesNotification) {
    DidRenameFilesNotification.method = 'workspace/didRenameFiles';
    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);
})(DidRenameFilesNotification = exports.DidRenameFilesNotification || (exports.DidRenameFilesNotification = {}));
/**
 * The will delete files request is sent from the client to the server before files are actually
 * deleted as long as the deletion is triggered from within the client.
 *
 * @since 3.16.0
 */
var DidDeleteFilesNotification;
(function (DidDeleteFilesNotification) {
    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';
    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);
})(DidDeleteFilesNotification = exports.DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = {}));
/**
 * The did delete files notification is sent from the client to the server when
 * files were deleted from within the client.
 *
 * @since 3.16.0
 */
var WillDeleteFilesRequest;
(function (WillDeleteFilesRequest) {
    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';
    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);
})(WillDeleteFilesRequest = exports.WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = {}));
//# sourceMappingURL=protocol.fileOperations.js.map

/***/ }),
/* 46 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = void 0;
const messages_1 = __webpack_require__(29);
/**
 * Moniker uniqueness level to define scope of the moniker.
 *
 * @since 3.16.0
 */
var UniquenessLevel;
(function (UniquenessLevel) {
    /**
     * The moniker is only unique inside a document
     */
    UniquenessLevel["document"] = "document";
    /**
     * The moniker is unique inside a project for which a dump got created
     */
    UniquenessLevel["project"] = "project";
    /**
     * The moniker is unique inside the group to which a project belongs
     */
    UniquenessLevel["group"] = "group";
    /**
     * The moniker is unique inside the moniker scheme.
     */
    UniquenessLevel["scheme"] = "scheme";
    /**
     * The moniker is globally unique
     */
    UniquenessLevel["global"] = "global";
})(UniquenessLevel = exports.UniquenessLevel || (exports.UniquenessLevel = {}));
/**
 * The moniker kind.
 *
 * @since 3.16.0
 */
var MonikerKind;
(function (MonikerKind) {
    /**
     * The moniker represent a symbol that is imported into a project
     */
    MonikerKind["import"] = "import";
    /**
     * The moniker represents a symbol that is exported from a project
     */
    MonikerKind["export"] = "export";
    /**
     * The moniker represents a symbol that is local to a project (e.g. a local
     * variable of a function, a class not visible outside the project, ...)
     */
    MonikerKind["local"] = "local";
})(MonikerKind = exports.MonikerKind || (exports.MonikerKind = {}));
/**
 * A request to get the moniker of a symbol at a given text document position.
 * The request parameter is of type [TextDocumentPositionParams](#TextDocumentPositionParams).
 * The response is of type [Moniker[]](#Moniker[]) or `null`.
 */
var MonikerRequest;
(function (MonikerRequest) {
    MonikerRequest.method = 'textDocument/moniker';
    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);
})(MonikerRequest = exports.MonikerRequest || (exports.MonikerRequest = {}));
//# sourceMappingURL=protocol.moniker.js.map

/***/ }),
/* 47 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createProtocolConnection = void 0;
const vscode_jsonrpc_1 = __webpack_require__(7);
function createProtocolConnection(input, output, logger, options) {
    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return vscode_jsonrpc_1.createMessageConnection(input, output, logger, options);
}
exports.createProtocolConnection = createProtocolConnection;
//# sourceMappingURL=connection.js.map

/***/ }),
/* 48 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateUuid = exports.parse = exports.isUUID = exports.v4 = exports.empty = void 0;
class ValueUUID {
    constructor(_value) {
        this._value = _value;
        // empty
    }
    asHex() {
        return this._value;
    }
    equals(other) {
        return this.asHex() === other.asHex();
    }
}
class V4UUID extends ValueUUID {
    constructor() {
        super([
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            '4',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._oneOf(V4UUID._timeHighBits),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
        ].join(''));
    }
    static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
    }
    static _randomHex() {
        return V4UUID._oneOf(V4UUID._chars);
    }
}
V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
/**
 * An empty UUID that contains only zeros.
 */
exports.empty = new ValueUUID('00000000-0000-0000-0000-000000000000');
function v4() {
    return new V4UUID();
}
exports.v4 = v4;
const _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function isUUID(value) {
    return _UUIDPattern.test(value);
}
exports.isUUID = isUUID;
/**
 * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
 * @param value A uuid string.
 */
function parse(value) {
    if (!isUUID(value)) {
        throw new Error('invalid uuid');
    }
    return new ValueUUID(value);
}
exports.parse = parse;
function generateUuid() {
    return v4().asHex();
}
exports.generateUuid = generateUuid;
//# sourceMappingURL=uuid.js.map

/***/ }),
/* 49 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.attachPartialResult = exports.ProgressFeature = exports.attachWorkDone = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(5);
const uuid_1 = __webpack_require__(48);
class WorkDoneProgressReporterImpl {
    constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
        WorkDoneProgressReporterImpl.Instances.set(this._token, this);
    }
    begin(title, percentage, message, cancellable) {
        let param = {
            kind: 'begin',
            title,
            percentage,
            message,
            cancellable
        };
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
    }
    report(arg0, arg1) {
        let param = {
            kind: 'report'
        };
        if (typeof arg0 === 'number') {
            param.percentage = arg0;
            if (arg1 !== undefined) {
                param.message = arg1;
            }
        }
        else {
            param.message = arg0;
        }
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
    }
    done() {
        WorkDoneProgressReporterImpl.Instances.delete(this._token);
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: 'end' });
    }
}
WorkDoneProgressReporterImpl.Instances = new Map();
class WorkDoneProgressServerReporterImpl extends WorkDoneProgressReporterImpl {
    constructor(connection, token) {
        super(connection, token);
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
    }
    get token() {
        return this._source.token;
    }
    done() {
        this._source.dispose();
        super.done();
    }
    cancel() {
        this._source.cancel();
    }
}
class NullProgressReporter {
    constructor() {
    }
    begin() {
    }
    report() {
    }
    done() {
    }
}
class NullProgressServerReporter extends NullProgressReporter {
    constructor() {
        super();
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
    }
    get token() {
        return this._source.token;
    }
    done() {
        this._source.dispose();
    }
    cancel() {
        this._source.cancel();
    }
}
function attachWorkDone(connection, params) {
    if (params === undefined || params.workDoneToken === undefined) {
        return new NullProgressReporter();
    }
    const token = params.workDoneToken;
    delete params.workDoneToken;
    return new WorkDoneProgressReporterImpl(connection, token);
}
exports.attachWorkDone = attachWorkDone;
const ProgressFeature = (Base) => {
    return class extends Base {
        constructor() {
            super();
            this._progressSupported = false;
        }
        initialize(capabilities) {
            var _a;
            if (((_a = capabilities === null || capabilities === void 0 ? void 0 : capabilities.window) === null || _a === void 0 ? void 0 : _a.workDoneProgress) === true) {
                this._progressSupported = true;
                this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
                    let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
                    if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
                        progress.cancel();
                    }
                });
            }
        }
        attachWorkDoneProgress(token) {
            if (token === undefined) {
                return new NullProgressReporter();
            }
            else {
                return new WorkDoneProgressReporterImpl(this.connection, token);
            }
        }
        createWorkDoneProgress() {
            if (this._progressSupported) {
                const token = uuid_1.generateUuid();
                return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {
                    const result = new WorkDoneProgressServerReporterImpl(this.connection, token);
                    return result;
                });
            }
            else {
                return Promise.resolve(new NullProgressServerReporter());
            }
        }
    };
};
exports.ProgressFeature = ProgressFeature;
var ResultProgress;
(function (ResultProgress) {
    ResultProgress.type = new vscode_languageserver_protocol_1.ProgressType();
})(ResultProgress || (ResultProgress = {}));
class ResultProgressReporterImpl {
    constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
    }
    report(data) {
        this._connection.sendProgress(ResultProgress.type, this._token, data);
    }
}
function attachPartialResult(connection, params) {
    if (params === undefined || params.partialResultToken === undefined) {
        return undefined;
    }
    const token = params.partialResultToken;
    delete params.partialResultToken;
    return new ResultProgressReporterImpl(connection, token);
}
exports.attachPartialResult = attachPartialResult;
//# sourceMappingURL=progress.js.map

/***/ }),
/* 50 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigurationFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(5);
const Is = __webpack_require__(3);
const ConfigurationFeature = (Base) => {
    return class extends Base {
        getConfiguration(arg) {
            if (!arg) {
                return this._getConfiguration({});
            }
            else if (Is.string(arg)) {
                return this._getConfiguration({ section: arg });
            }
            else {
                return this._getConfiguration(arg);
            }
        }
        _getConfiguration(arg) {
            let params = {
                items: Array.isArray(arg) ? arg : [arg]
            };
            return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
                return Array.isArray(arg) ? result : result[0];
            });
        }
    };
};
exports.ConfigurationFeature = ConfigurationFeature;
//# sourceMappingURL=configuration.js.map

/***/ }),
/* 51 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceFoldersFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(5);
const WorkspaceFoldersFeature = (Base) => {
    return class extends Base {
        initialize(capabilities) {
            let workspaceCapabilities = capabilities.workspace;
            if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
                this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
                this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
                    this._onDidChangeWorkspaceFolders.fire(params.event);
                });
            }
        }
        getWorkspaceFolders() {
            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
        }
        get onDidChangeWorkspaceFolders() {
            if (!this._onDidChangeWorkspaceFolders) {
                throw new Error('Client doesn\'t support sending workspace folder change events.');
            }
            if (!this._unregistration) {
                this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
            }
            return this._onDidChangeWorkspaceFolders.event;
        }
    };
};
exports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
//# sourceMappingURL=workspaceFolders.js.map

/***/ }),
/* 52 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallHierarchyFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(5);
const CallHierarchyFeature = (Base) => {
    return class extends Base {
        get callHierarchy() {
            return {
                onPrepare: (handler) => {
                    this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);
                    });
                },
                onIncomingCalls: (handler) => {
                    const type = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
                onOutgoingCalls: (handler) => {
                    const type = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                }
            };
        }
    };
};
exports.CallHierarchyFeature = CallHierarchyFeature;
//# sourceMappingURL=callHierarchy.js.map

/***/ }),
/* 53 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SemanticTokensBuilder = exports.SemanticTokensFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(5);
const SemanticTokensFeature = (Base) => {
    return class extends Base {
        get semanticTokens() {
            return {
                on: (handler) => {
                    const type = vscode_languageserver_protocol_1.SemanticTokensRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
                onDelta: (handler) => {
                    const type = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
                onRange: (handler) => {
                    const type = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                }
            };
        }
    };
};
exports.SemanticTokensFeature = SemanticTokensFeature;
class SemanticTokensBuilder {
    constructor() {
        this._prevData = undefined;
        this.initialize();
    }
    initialize() {
        this._id = Date.now();
        this._prevLine = 0;
        this._prevChar = 0;
        this._data = [];
        this._dataLen = 0;
    }
    push(line, char, length, tokenType, tokenModifiers) {
        let pushLine = line;
        let pushChar = char;
        if (this._dataLen > 0) {
            pushLine -= this._prevLine;
            if (pushLine === 0) {
                pushChar -= this._prevChar;
            }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
    }
    get id() {
        return this._id.toString();
    }
    previousResult(id) {
        if (this.id === id) {
            this._prevData = this._data;
        }
        this.initialize();
    }
    build() {
        this._prevData = undefined;
        return {
            resultId: this.id,
            data: this._data
        };
    }
    canBuildEdits() {
        return this._prevData !== undefined;
    }
    buildEdits() {
        if (this._prevData !== undefined) {
            const prevDataLength = this._prevData.length;
            const dataLength = this._data.length;
            let startIndex = 0;
            while (startIndex < dataLength && startIndex < prevDataLength && this._prevData[startIndex] === this._data[startIndex]) {
                startIndex++;
            }
            if (startIndex < dataLength && startIndex < prevDataLength) {
                // Find end index
                let endIndex = 0;
                while (endIndex < dataLength && endIndex < prevDataLength && this._prevData[prevDataLength - 1 - endIndex] === this._data[dataLength - 1 - endIndex]) {
                    endIndex++;
                }
                const newData = this._data.slice(startIndex, dataLength - endIndex);
                const result = {
                    resultId: this.id,
                    edits: [
                        { start: startIndex, deleteCount: prevDataLength - endIndex - startIndex, data: newData }
                    ]
                };
                return result;
            }
            else if (startIndex < dataLength) {
                return { resultId: this.id, edits: [
                        { start: startIndex, deleteCount: 0, data: this._data.slice(startIndex) }
                    ] };
            }
            else if (startIndex < prevDataLength) {
                return { resultId: this.id, edits: [
                        { start: startIndex, deleteCount: prevDataLength - startIndex }
                    ] };
            }
            else {
                return { resultId: this.id, edits: [] };
            }
        }
        else {
            return this.build();
        }
    }
}
exports.SemanticTokensBuilder = SemanticTokensBuilder;
//# sourceMappingURL=semanticTokens.js.map

/***/ }),
/* 54 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShowDocumentFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(5);
const ShowDocumentFeature = (Base) => {
    return class extends Base {
        showDocument(params) {
            return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);
        }
    };
};
exports.ShowDocumentFeature = ShowDocumentFeature;
//# sourceMappingURL=showDocument.js.map

/***/ }),
/* 55 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileOperationsFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(5);
const FileOperationsFeature = (Base) => {
    return class extends Base {
        onDidCreateFiles(handler) {
            this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {
                handler(params);
            });
        }
        onDidRenameFiles(handler) {
            this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {
                handler(params);
            });
        }
        onDidDeleteFiles(handler) {
            this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {
                handler(params);
            });
        }
        onWillCreateFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {
                return handler(params, cancel);
            });
        }
        onWillRenameFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {
                return handler(params, cancel);
            });
        }
        onWillDeleteFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {
                return handler(params, cancel);
            });
        }
    };
};
exports.FileOperationsFeature = FileOperationsFeature;
//# sourceMappingURL=fileOperations.js.map

/***/ }),
/* 56 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinkedEditingRangeFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(5);
const LinkedEditingRangeFeature = (Base) => {
    return class extends Base {
        onLinkedEditingRange(handler) {
            this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);
            });
        }
    };
};
exports.LinkedEditingRangeFeature = LinkedEditingRangeFeature;
//# sourceMappingURL=linkedEditingRange.js.map

/***/ }),
/* 57 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonikerFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(5);
const MonikerFeature = (Base) => {
    return class extends Base {
        get moniker() {
            return {
                on: (handler) => {
                    const type = vscode_languageserver_protocol_1.MonikerRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
            };
        }
    };
};
exports.MonikerFeature = MonikerFeature;
//# sourceMappingURL=moniker.js.map

/***/ }),
/* 58 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveModulePath = exports.FileSystem = exports.resolveGlobalYarnPath = exports.resolveGlobalNodePath = exports.resolve = exports.uriToFilePath = void 0;
const url = __webpack_require__(59);
const path = __webpack_require__(23);
const fs = __webpack_require__(60);
const child_process_1 = __webpack_require__(61);
/**
 * @deprecated Use the `vscode-uri` npm module which provides a more
 * complete implementation of handling VS Code URIs.
 */
function uriToFilePath(uri) {
    let parsed = url.parse(uri);
    if (parsed.protocol !== 'file:' || !parsed.path) {
        return undefined;
    }
    let segments = parsed.path.split('/');
    for (var i = 0, len = segments.length; i < len; i++) {
        segments[i] = decodeURIComponent(segments[i]);
    }
    if (process.platform === 'win32' && segments.length > 1) {
        let first = segments[0];
        let second = segments[1];
        // Do we have a drive letter and we started with a / which is the
        // case if the first segement is empty (see split above)
        if (first.length === 0 && second.length > 1 && second[1] === ':') {
            // Remove first slash
            segments.shift();
        }
    }
    return path.normalize(segments.join('/'));
}
exports.uriToFilePath = uriToFilePath;
function isWindows() {
    return process.platform === 'win32';
}
function resolve(moduleName, nodePath, cwd, tracer) {
    const nodePathKey = 'NODE_PATH';
    const app = [
        'var p = process;',
        'p.on(\'message\',function(m){',
        'if(m.c===\'e\'){',
        'p.exit(0);',
        '}',
        'else if(m.c===\'rs\'){',
        'try{',
        'var r=require.resolve(m.a);',
        'p.send({c:\'r\',s:true,r:r});',
        '}',
        'catch(err){',
        'p.send({c:\'r\',s:false});',
        '}',
        '}',
        '});'
    ].join('');
    return new Promise((resolve, reject) => {
        let env = process.env;
        let newEnv = Object.create(null);
        Object.keys(env).forEach(key => newEnv[key] = env[key]);
        if (nodePath && fs.existsSync(nodePath) /* see issue 545 */) {
            if (newEnv[nodePathKey]) {
                newEnv[nodePathKey] = nodePath + path.delimiter + newEnv[nodePathKey];
            }
            else {
                newEnv[nodePathKey] = nodePath;
            }
            if (tracer) {
                tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);
            }
        }
        newEnv['ELECTRON_RUN_AS_NODE'] = '1';
        try {
            let cp = child_process_1.fork('', [], {
                cwd: cwd,
                env: newEnv,
                execArgv: ['-e', app]
            });
            if (cp.pid === void 0) {
                reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));
                return;
            }
            cp.on('error', (error) => {
                reject(error);
            });
            cp.on('message', (message) => {
                if (message.c === 'r') {
                    cp.send({ c: 'e' });
                    if (message.s) {
                        resolve(message.r);
                    }
                    else {
                        reject(new Error(`Failed to resolve module: ${moduleName}`));
                    }
                }
            });
            let message = {
                c: 'rs',
                a: moduleName
            };
            cp.send(message);
        }
        catch (error) {
            reject(error);
        }
    });
}
exports.resolve = resolve;
/**
 * Resolve the global npm package path.
 * @deprecated Since this depends on the used package manager and their version the best is that servers
 * implement this themselves since they know best what kind of package managers to support.
 * @param tracer the tracer to use
 */
function resolveGlobalNodePath(tracer) {
    let npmCommand = 'npm';
    const env = Object.create(null);
    Object.keys(process.env).forEach(key => env[key] = process.env[key]);
    env['NO_UPDATE_NOTIFIER'] = 'true';
    const options = {
        encoding: 'utf8',
        env
    };
    if (isWindows()) {
        npmCommand = 'npm.cmd';
        options.shell = true;
    }
    let handler = () => { };
    try {
        process.on('SIGPIPE', handler);
        let stdout = child_process_1.spawnSync(npmCommand, ['config', 'get', 'prefix'], options).stdout;
        if (!stdout) {
            if (tracer) {
                tracer(`'npm config get prefix' didn't return a value.`);
            }
            return undefined;
        }
        let prefix = stdout.trim();
        if (tracer) {
            tracer(`'npm config get prefix' value is: ${prefix}`);
        }
        if (prefix.length > 0) {
            if (isWindows()) {
                return path.join(prefix, 'node_modules');
            }
            else {
                return path.join(prefix, 'lib', 'node_modules');
            }
        }
        return undefined;
    }
    catch (err) {
        return undefined;
    }
    finally {
        process.removeListener('SIGPIPE', handler);
    }
}
exports.resolveGlobalNodePath = resolveGlobalNodePath;
/*
 * Resolve the global yarn pakage path.
 * @deprecated Since this depends on the used package manager and their version the best is that servers
 * implement this themselves since they know best what kind of package managers to support.
 * @param tracer the tracer to use
 */
function resolveGlobalYarnPath(tracer) {
    let yarnCommand = 'yarn';
    let options = {
        encoding: 'utf8'
    };
    if (isWindows()) {
        yarnCommand = 'yarn.cmd';
        options.shell = true;
    }
    let handler = () => { };
    try {
        process.on('SIGPIPE', handler);
        let results = child_process_1.spawnSync(yarnCommand, ['global', 'dir', '--json'], options);
        let stdout = results.stdout;
        if (!stdout) {
            if (tracer) {
                tracer(`'yarn global dir' didn't return a value.`);
                if (results.stderr) {
                    tracer(results.stderr);
                }
            }
            return undefined;
        }
        let lines = stdout.trim().split(/\r?\n/);
        for (let line of lines) {
            try {
                let yarn = JSON.parse(line);
                if (yarn.type === 'log') {
                    return path.join(yarn.data, 'node_modules');
                }
            }
            catch (e) {
                // Do nothing. Ignore the line
            }
        }
        return undefined;
    }
    catch (err) {
        return undefined;
    }
    finally {
        process.removeListener('SIGPIPE', handler);
    }
}
exports.resolveGlobalYarnPath = resolveGlobalYarnPath;
var FileSystem;
(function (FileSystem) {
    let _isCaseSensitive = undefined;
    function isCaseSensitive() {
        if (_isCaseSensitive !== void 0) {
            return _isCaseSensitive;
        }
        if (process.platform === 'win32') {
            _isCaseSensitive = false;
        }
        else {
            // convert current file name to upper case / lower case and check if file exists
            // (guards against cases when name is already all uppercase or lowercase)
            _isCaseSensitive = !fs.existsSync(__filename.toUpperCase()) || !fs.existsSync(__filename.toLowerCase());
        }
        return _isCaseSensitive;
    }
    FileSystem.isCaseSensitive = isCaseSensitive;
    function isParent(parent, child) {
        if (isCaseSensitive()) {
            return path.normalize(child).indexOf(path.normalize(parent)) === 0;
        }
        else {
            return path.normalize(child).toLowerCase().indexOf(path.normalize(parent).toLowerCase()) === 0;
        }
    }
    FileSystem.isParent = isParent;
})(FileSystem = exports.FileSystem || (exports.FileSystem = {}));
function resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {
    if (nodePath) {
        if (!path.isAbsolute(nodePath)) {
            nodePath = path.join(workspaceRoot, nodePath);
        }
        return resolve(moduleName, nodePath, nodePath, tracer).then((value) => {
            if (FileSystem.isParent(nodePath, value)) {
                return value;
            }
            else {
                return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));
            }
        }).then(undefined, (_error) => {
            return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
        });
    }
    else {
        return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
    }
}
exports.resolveModulePath = resolveModulePath;
//# sourceMappingURL=files.js.map

/***/ }),
/* 59 */
/***/ ((module) => {

"use strict";
module.exports = require("url");;

/***/ }),
/* 60 */
/***/ ((module) => {

"use strict";
module.exports = require("fs");;

/***/ }),
/* 61 */
/***/ ((module) => {

"use strict";
module.exports = require("child_process");;

/***/ }),
/* 62 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(5);

/***/ }),
/* 63 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProposedFeatures = exports.SemanticTokensBuilder = void 0;
const semanticTokens_1 = __webpack_require__(53);
Object.defineProperty(exports, "SemanticTokensBuilder", ({ enumerable: true, get: function () { return semanticTokens_1.SemanticTokensBuilder; } }));
__exportStar(__webpack_require__(5), exports);
__exportStar(__webpack_require__(4), exports);
var ProposedFeatures;
(function (ProposedFeatures) {
    ProposedFeatures.all = {
        __brand: 'features'
    };
})(ProposedFeatures = exports.ProposedFeatures || (exports.ProposedFeatures = {}));
//# sourceMappingURL=api.js.map

/***/ }),
/* 64 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.projectRootPatterns = exports.sortTexts = void 0;
exports.sortTexts = {
    one: "00001",
    two: "00002",
    three: "00003",
    four: "00004",
};
exports.projectRootPatterns = [".git", "autoload", "plugin"];


/***/ }),
/* 65 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.completionProvider = void 0;
var vscode_languageserver_1 = __webpack_require__(2);
var util_1 = __webpack_require__(66);
var config_1 = __importDefault(__webpack_require__(73));
var documents_1 = __webpack_require__(74);
__webpack_require__(76);
__webpack_require__(161);
__webpack_require__(162);
__webpack_require__(163);
__webpack_require__(165);
__webpack_require__(166);
__webpack_require__(170);
__webpack_require__(171);
__webpack_require__(172);
__webpack_require__(173);
__webpack_require__(174);
__webpack_require__(175);
var provider_1 = __webpack_require__(159);
var provider = provider_1.getProvider();
var completionProvider = function (params) {
    var textDocument = params.textDocument, position = params.position;
    var textDoc = documents_1.documents.get(textDocument.uri);
    if (textDoc) {
        var line = textDoc.getText(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(position.line, 0), position));
        var words = util_1.getWordFromPosition(textDoc, { line: position.line, character: position.character - 1 });
        var word = words && words.word || "";
        if (word === "" && words && words.wordRight.trim() === ":") {
            word = ":";
        }
        // options items start with &
        var invalidLength = word.replace(/^&/, "").length;
        var completionItems = provider(line, textDoc.uri, position, word, invalidLength, []);
        if (!config_1.default.snippetSupport) {
            return {
                isIncomplete: true,
                items: util_1.removeSnippets(completionItems)
            };
        }
        return {
            isIncomplete: true,
            items: completionItems
        };
    }
    return [];
};
exports.completionProvider = completionProvider;


/***/ }),
/* 66 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.delay = exports.getRealPath = exports.isSymbolLink = exports.removeSnippets = exports.handleParse = exports.getWordFromPosition = exports.markupSnippets = exports.findProjectRoot = exports.pcb = exports.executeFile = exports.isSomeMatchPattern = void 0;
var child_process_1 = __webpack_require__(61);
var findup_1 = __importDefault(__webpack_require__(67));
var fs_1 = __importDefault(__webpack_require__(60));
var path_1 = __importDefault(__webpack_require__(23));
var vscode_languageserver_1 = __webpack_require__(2);
var vimparser_1 = __webpack_require__(71);
var patterns_1 = __webpack_require__(72);
var config_1 = __importDefault(__webpack_require__(73));
// FIXME vimlparser missing update builtin_commands
if (vimparser_1.VimLParser.prototype) {
    (_a = vimparser_1.VimLParser.prototype.builtin_commands) === null || _a === void 0 ? void 0 : _a.push({
        name: 'balt',
        minlen: 4,
        flags: 'NEEDARG|FILE1|EDITCMD|TRLBAR|CMDWIN',
        parser: 'parse_cmd_common'
    });
}
function isSomeMatchPattern(patterns, line) {
    return patterns.some(function (p) { return p.test(line); });
}
exports.isSomeMatchPattern = isSomeMatchPattern;
function executeFile(input, command, args, option) {
    return new Promise(function (resolve, reject) {
        var stdout = "";
        var stderr = "";
        var error;
        var isPassAsText = false;
        args = (args || []).map(function (arg) {
            if (/%text/.test(arg)) {
                isPassAsText = true;
                return arg.replace(/%text/g, input.toString());
            }
            return arg;
        });
        var cp = child_process_1.spawn(command, args, option);
        cp.stdout.on("data", function (data) {
            stdout += data;
        });
        cp.stderr.on("data", function (data) {
            stderr += data;
        });
        cp.on("error", function (err) {
            error = err;
            reject(error);
        });
        cp.on("close", function (code) {
            if (!error) {
                resolve({ code: code, stdout: stdout, stderr: stderr });
            }
        });
        // error will occur when cp get error
        if (!isPassAsText) {
            input.pipe(cp.stdin).on("error", function () { return; });
        }
    });
}
exports.executeFile = executeFile;
// cover cb type async function to promise
function pcb(cb) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return new Promise(function (resolve) {
            cb.apply(void 0, __spreadArray(__spreadArray([], args), [function () {
                    var params = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        params[_i] = arguments[_i];
                    }
                    resolve(params);
                }]));
        });
    };
}
exports.pcb = pcb;
// find work dirname by root patterns
function findProjectRoot(filePath, rootPatterns) {
    return __awaiter(this, void 0, void 0, function () {
        var dirname, patterns, dirCandidate, _i, patterns_2, pattern, _a, err, dir;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    dirname = path_1.default.dirname(filePath);
                    patterns = [].concat(rootPatterns);
                    dirCandidate = "";
                    _i = 0, patterns_2 = patterns;
                    _b.label = 1;
                case 1:
                    if (!(_i < patterns_2.length)) return [3 /*break*/, 4];
                    pattern = patterns_2[_i];
                    return [4 /*yield*/, pcb(findup_1.default)(dirname, pattern)];
                case 2:
                    _a = _b.sent(), err = _a[0], dir = _a[1];
                    if (!err && dir && dir !== "/" && dir.length > dirCandidate.length) {
                        dirCandidate = dir;
                    }
                    _b.label = 3;
                case 3:
                    _i++;
                    return [3 /*break*/, 1];
                case 4:
                    if (dirCandidate.length) {
                        return [2 /*return*/, dirCandidate];
                    }
                    return [2 /*return*/, dirname];
            }
        });
    });
}
exports.findProjectRoot = findProjectRoot;
function markupSnippets(snippets) {
    return [
        "```vim",
        snippets.replace(/\$\{[0-9]+(:([^}]+))?\}/g, "$2"),
        "```",
    ].join("\n");
}
exports.markupSnippets = markupSnippets;
function getWordFromPosition(doc, position) {
    if (!doc) {
        return;
    }
    // invalid character which less than 0
    if (position.character < 0) {
        return;
    }
    var character = doc.getText(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(position.line, position.character), vscode_languageserver_1.Position.create(position.line, position.character + 1)));
    // not keyword position
    if (!character || !patterns_1.keywordPattern.test(character)) {
        return;
    }
    var currentLine = doc.getText(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(position.line, 0), vscode_languageserver_1.Position.create(position.line + 1, 0)));
    // comment line
    if (patterns_1.commentPattern.test(currentLine)) {
        return;
    }
    var preSegment = currentLine.slice(0, position.character);
    var nextSegment = currentLine.slice(position.character);
    var wordLeft = preSegment.match(patterns_1.wordPrePattern);
    var wordRight = nextSegment.match(patterns_1.wordNextPattern);
    var word = "" + (wordLeft && wordLeft[1] || "") + (wordRight && wordRight[1] || "");
    return {
        word: word,
        left: wordLeft && wordLeft[1] || "",
        right: wordRight && wordRight[1] || "",
        wordLeft: wordLeft && wordLeft[1]
            ? preSegment.replace(new RegExp(wordLeft[1] + "$"), word)
            : "" + preSegment + word,
        wordRight: wordRight && wordRight[1]
            ? nextSegment.replace(new RegExp("^" + wordRight[1]), word)
            : "" + word + nextSegment,
    };
}
exports.getWordFromPosition = getWordFromPosition;
// parse vim buffer
function handleParse(textDoc) {
    return __awaiter(this, void 0, void 0, function () {
        var text, tokens, node;
        return __generator(this, function (_a) {
            text = textDoc instanceof Object ? textDoc.getText() : textDoc;
            tokens = new vimparser_1.StringReader(text.split(/\r\n|\r|\n/));
            try {
                node = new vimparser_1.VimLParser(config_1.default.isNeovim).parse(tokens);
                return [2 /*return*/, [node, ""]];
            }
            catch (error) {
                return [2 /*return*/, [null, error]];
            }
            return [2 /*return*/];
        });
    });
}
exports.handleParse = handleParse;
// remove snippets of completionItem
function removeSnippets(completionItems) {
    if (completionItems === void 0) { completionItems = []; }
    return completionItems.map(function (item) {
        if (item.insertTextFormat === vscode_languageserver_1.InsertTextFormat.Snippet) {
            return __assign(__assign({}, item), { insertText: item.label, insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText });
        }
        return item;
    });
}
exports.removeSnippets = removeSnippets;
var isSymbolLink = function (filePath) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        return [2 /*return*/, new Promise(function (resolve) {
                fs_1.default.lstat(filePath, function (err, stats) {
                    resolve({
                        err: err,
                        stats: stats && stats.isSymbolicLink(),
                    });
                });
            })];
    });
}); };
exports.isSymbolLink = isSymbolLink;
var getRealPath = function (filePath) { return __awaiter(void 0, void 0, void 0, function () {
    var _a, err, stats;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0: return [4 /*yield*/, exports.isSymbolLink(filePath)];
            case 1:
                _a = _b.sent(), err = _a.err, stats = _a.stats;
                if (!err && stats) {
                    return [2 /*return*/, new Promise(function (resolve) {
                            fs_1.default.realpath(filePath, function (error, realPath) {
                                if (error) {
                                    return resolve(filePath);
                                }
                                resolve(realPath);
                            });
                        })];
                }
                return [2 /*return*/, filePath];
        }
    });
}); };
exports.getRealPath = getRealPath;
var delay = function (ms) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, new Promise(function (res) {
                    setTimeout(function () {
                        res();
                    }, ms);
                })];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    });
}); };
exports.delay = delay;


/***/ }),
/* 67 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs   = __webpack_require__(60),
  Path   = __webpack_require__(23),
  util   = __webpack_require__(10),
  colors = __webpack_require__(68),
  EE     = __webpack_require__(70).EventEmitter,
  fsExists = fs.exists ? fs.exists : Path.exists,
  fsExistsSync = fs.existsSync ? fs.existsSync : Path.existsSync;

module.exports = function(dir, iterator, options, callback){
  return FindUp(dir, iterator, options, callback);
};

function FindUp(dir, iterator, options, callback){
  if (!(this instanceof FindUp)) {
    return new FindUp(dir, iterator, options, callback);
  }
  if(typeof options === 'function'){
    callback = options;
    options = {};
  }
  options = options || {};

  EE.call(this);
  this.found = false;
  this.stopPlease = false;
  var self = this;

  if(typeof iterator === 'string'){
    var file = iterator;
    iterator = function(dir, cb){
      return fsExists(Path.join(dir, file), cb);
    };
  }

  if(callback) {
    this.on('found', function(dir){
      if(options.verbose) console.log(('found '+ dir ).green);
      callback(null, dir);
      self.stop();
    });

    this.on('end', function(){
      if(options.verbose) console.log('end'.grey);
      if(!self.found) callback(new Error('not found'));
    });

    this.on('error', function(err){
      if(options.verbose) console.log('error'.red, err);
      callback(err);
    });
  }

  this._find(dir, iterator, options, callback);
}
util.inherits(FindUp, EE);

FindUp.prototype._find = function(dir, iterator, options, callback){
  var self = this;

  iterator(dir, function(exists){
    if(options.verbose) console.log(('traverse '+ dir).grey);
    if(exists) {
      self.found = true;
      self.emit('found', dir);
    }

    var parentDir = Path.join(dir, '..');
    if (self.stopPlease) return self.emit('end');
    if (dir === parentDir) return self.emit('end');
    if(dir.indexOf('../../') !== -1 ) return self.emit('error', new Error(dir + ' is not correct.'));
    self._find(parentDir, iterator, options, callback);
  });
};

FindUp.prototype.stop = function(){
  this.stopPlease = true;
};

module.exports.FindUp = FindUp;

module.exports.sync = function(dir, iteratorSync){
  if(typeof iteratorSync === 'string'){
    var file = iteratorSync;
    iteratorSync = function(dir){
      return fsExistsSync(Path.join(dir, file));
    };
  }
  var initialDir = dir;
  while(dir !== Path.join(dir, '..')){
    if(dir.indexOf('../../') !== -1 ) throw new Error(initialDir + ' is not correct.');
    if(iteratorSync(dir)) return dir;
    dir = Path.join(dir, '..');
  }
  throw new Error('not found');
};


/***/ }),
/* 68 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/*
colors.js

Copyright (c) 2010

Marak Squires
Alexis Sellier (cloudhead)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var isHeadless = false;

if (typeof module !== 'undefined') {
  isHeadless = true;
}

if (!isHeadless) {
  var exports = {};
  var module = {};
  var colors = exports;
  exports.mode = "browser";
} else {
  exports.mode = "console";
}

//
// Prototypes the string object to have additional method calls that add terminal colors
//
var addProperty = function (color, func) {
  exports[color] = function (str) {
    return func.apply(str);
  };
  String.prototype.__defineGetter__(color, func);
};

function stylize(str, style) {

  var styles;

  if (exports.mode === 'console') {
    styles = {
      //styles
      'bold'      : ['\x1B[1m',  '\x1B[22m'],
      'italic'    : ['\x1B[3m',  '\x1B[23m'],
      'underline' : ['\x1B[4m',  '\x1B[24m'],
      'inverse'   : ['\x1B[7m',  '\x1B[27m'],
      'strikethrough' : ['\x1B[9m',  '\x1B[29m'],
      //text colors
      //grayscale
      'white'     : ['\x1B[37m', '\x1B[39m'],
      'grey'      : ['\x1B[90m', '\x1B[39m'],
      'black'     : ['\x1B[30m', '\x1B[39m'],
      //colors
      'blue'      : ['\x1B[34m', '\x1B[39m'],
      'cyan'      : ['\x1B[36m', '\x1B[39m'],
      'green'     : ['\x1B[32m', '\x1B[39m'],
      'magenta'   : ['\x1B[35m', '\x1B[39m'],
      'red'       : ['\x1B[31m', '\x1B[39m'],
      'yellow'    : ['\x1B[33m', '\x1B[39m'],
      //background colors
      //grayscale
      'whiteBG'     : ['\x1B[47m', '\x1B[49m'],
      'greyBG'      : ['\x1B[49;5;8m', '\x1B[49m'],
      'blackBG'     : ['\x1B[40m', '\x1B[49m'],
      //colors
      'blueBG'      : ['\x1B[44m', '\x1B[49m'],
      'cyanBG'      : ['\x1B[46m', '\x1B[49m'],
      'greenBG'     : ['\x1B[42m', '\x1B[49m'],
      'magentaBG'   : ['\x1B[45m', '\x1B[49m'],
      'redBG'       : ['\x1B[41m', '\x1B[49m'],
      'yellowBG'    : ['\x1B[43m', '\x1B[49m']
    };
  } else if (exports.mode === 'browser') {
    styles = {
      //styles
      'bold'      : ['<b>',  '</b>'],
      'italic'    : ['<i>',  '</i>'],
      'underline' : ['<u>',  '</u>'],
      'inverse'   : ['<span style="background-color:black;color:white;">',  '</span>'],
      'strikethrough' : ['<del>',  '</del>'],
      //text colors
      //grayscale
      'white'     : ['<span style="color:white;">',   '</span>'],
      'grey'      : ['<span style="color:gray;">',    '</span>'],
      'black'     : ['<span style="color:black;">',   '</span>'],
      //colors
      'blue'      : ['<span style="color:blue;">',    '</span>'],
      'cyan'      : ['<span style="color:cyan;">',    '</span>'],
      'green'     : ['<span style="color:green;">',   '</span>'],
      'magenta'   : ['<span style="color:magenta;">', '</span>'],
      'red'       : ['<span style="color:red;">',     '</span>'],
      'yellow'    : ['<span style="color:yellow;">',  '</span>'],
      //background colors
      //grayscale
      'whiteBG'     : ['<span style="background-color:white;">',   '</span>'],
      'greyBG'      : ['<span style="background-color:gray;">',    '</span>'],
      'blackBG'     : ['<span style="background-color:black;">',   '</span>'],
      //colors
      'blueBG'      : ['<span style="background-color:blue;">',    '</span>'],
      'cyanBG'      : ['<span style="background-color:cyan;">',    '</span>'],
      'greenBG'     : ['<span style="background-color:green;">',   '</span>'],
      'magentaBG'   : ['<span style="background-color:magenta;">', '</span>'],
      'redBG'       : ['<span style="background-color:red;">',     '</span>'],
      'yellowBG'    : ['<span style="background-color:yellow;">',  '</span>']
    };
  } else if (exports.mode === 'none') {
    return str + '';
  } else {
    console.log('unsupported mode, try "browser", "console" or "none"');
  }
  return styles[style][0] + str + styles[style][1];
}

function applyTheme(theme) {

  //
  // Remark: This is a list of methods that exist
  // on String that you should not overwrite.
  //
  var stringPrototypeBlacklist = [
    '__defineGetter__', '__defineSetter__', '__lookupGetter__', '__lookupSetter__', 'charAt', 'constructor',
    'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf', 'charCodeAt',
    'indexOf', 'lastIndexof', 'length', 'localeCompare', 'match', 'replace', 'search', 'slice', 'split', 'substring',
    'toLocaleLowerCase', 'toLocaleUpperCase', 'toLowerCase', 'toUpperCase', 'trim', 'trimLeft', 'trimRight'
  ];

  Object.keys(theme).forEach(function (prop) {
    if (stringPrototypeBlacklist.indexOf(prop) !== -1) {
      console.log('warn: '.red + ('String.prototype' + prop).magenta + ' is probably something you don\'t want to override. Ignoring style name');
    }
    else {
      if (typeof(theme[prop]) === 'string') {
        addProperty(prop, function () {
          return exports[theme[prop]](this);
        });
      }
      else {
        addProperty(prop, function () {
          var ret = this;
          for (var t = 0; t < theme[prop].length; t++) {
            ret = exports[theme[prop][t]](ret);
          }
          return ret;
        });
      }
    }
  });
}


//
// Iterate through all default styles and colors
//
var x = ['bold', 'underline', 'strikethrough', 'italic', 'inverse', 'grey', 'black', 'yellow', 'red', 'green', 'blue', 'white', 'cyan', 'magenta', 'greyBG', 'blackBG', 'yellowBG', 'redBG', 'greenBG', 'blueBG', 'whiteBG', 'cyanBG', 'magentaBG'];
x.forEach(function (style) {

  // __defineGetter__ at the least works in more browsers
  // http://robertnyman.com/javascript/javascript-getters-setters.html
  // Object.defineProperty only works in Chrome
  addProperty(style, function () {
    return stylize(this, style);
  });
});

function sequencer(map) {
  return function () {
    if (!isHeadless) {
      return this.replace(/( )/, '$1');
    }
    var exploded = this.split(""), i = 0;
    exploded = exploded.map(map);
    return exploded.join("");
  };
}

var rainbowMap = (function () {
  var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta']; //RoY G BiV
  return function (letter, i, exploded) {
    if (letter === " ") {
      return letter;
    } else {
      return stylize(letter, rainbowColors[i++ % rainbowColors.length]);
    }
  };
})();

exports.themes = {};

exports.addSequencer = function (name, map) {
  addProperty(name, sequencer(map));
};

exports.addSequencer('rainbow', rainbowMap);
exports.addSequencer('zebra', function (letter, i, exploded) {
  return i % 2 === 0 ? letter : letter.inverse;
});

exports.setTheme = function (theme) {
  if (typeof theme === 'string') {
    try {
      exports.themes[theme] = __webpack_require__(69)(theme);
      applyTheme(exports.themes[theme]);
      return exports.themes[theme];
    } catch (err) {
      console.log(err);
      return err;
    }
  } else {
    applyTheme(theme);
  }
};


addProperty('stripColors', function () {
  return ("" + this).replace(/\x1B\[\d+m/g, '');
});

// please no
function zalgo(text, options) {
  var soul = {
    "up" : [
      '̍', '̎', '̄', '̅',
      '̿', '̑', '̆', '̐',
      '͒', '͗', '͑', '̇',
      '̈', '̊', '͂', '̓',
      '̈', '͊', '͋', '͌',
      '̃', '̂', '̌', '͐',
      '̀', '́', '̋', '̏',
      '̒', '̓', '̔', '̽',
      '̉', 'ͣ', 'ͤ', 'ͥ',
      'ͦ', 'ͧ', 'ͨ', 'ͩ',
      'ͪ', 'ͫ', 'ͬ', 'ͭ',
      'ͮ', 'ͯ', '̾', '͛',
      '͆', '̚'
    ],
    "down" : [
      '̖', '̗', '̘', '̙',
      '̜', '̝', '̞', '̟',
      '̠', '̤', '̥', '̦',
      '̩', '̪', '̫', '̬',
      '̭', '̮', '̯', '̰',
      '̱', '̲', '̳', '̹',
      '̺', '̻', '̼', 'ͅ',
      '͇', '͈', '͉', '͍',
      '͎', '͓', '͔', '͕',
      '͖', '͙', '͚', '̣'
    ],
    "mid" : [
      '̕', '̛', '̀', '́',
      '͘', '̡', '̢', '̧',
      '̨', '̴', '̵', '̶',
      '͜', '͝', '͞',
      '͟', '͠', '͢', '̸',
      '̷', '͡', ' ҉'
    ]
  },
  all = [].concat(soul.up, soul.down, soul.mid),
  zalgo = {};

  function randomNumber(range) {
    var r = Math.floor(Math.random() * range);
    return r;
  }

  function is_char(character) {
    var bool = false;
    all.filter(function (i) {
      bool = (i === character);
    });
    return bool;
  }

  function heComes(text, options) {
    var result = '', counts, l;
    options = options || {};
    options["up"] = options["up"] || true;
    options["mid"] = options["mid"] || true;
    options["down"] = options["down"] || true;
    options["size"] = options["size"] || "maxi";
    text = text.split('');
    for (l in text) {
      if (is_char(l)) {
        continue;
      }
      result = result + text[l];
      counts = {"up" : 0, "down" : 0, "mid" : 0};
      switch (options.size) {
      case 'mini':
        counts.up = randomNumber(8);
        counts.min = randomNumber(2);
        counts.down = randomNumber(8);
        break;
      case 'maxi':
        counts.up = randomNumber(16) + 3;
        counts.min = randomNumber(4) + 1;
        counts.down = randomNumber(64) + 3;
        break;
      default:
        counts.up = randomNumber(8) + 1;
        counts.mid = randomNumber(6) / 2;
        counts.down = randomNumber(8) + 1;
        break;
      }

      var arr = ["up", "mid", "down"];
      for (var d in arr) {
        var index = arr[d];
        for (var i = 0 ; i <= counts[index]; i++) {
          if (options[index]) {
            result = result + soul[index][randomNumber(soul[index].length)];
          }
        }
      }
    }
    return result;
  }
  return heComes(text);
}


// don't summon zalgo
addProperty('zalgo', function () {
  return zalgo(this);
});


/***/ }),
/* 69 */
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 69;
module.exports = webpackEmptyContext;

/***/ }),
/* 70 */
/***/ ((module) => {

"use strict";
module.exports = require("events");;

/***/ }),
/* 71 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
//!/usr/bin/env nodejs
// usage: nodejs vimlparser.js [--neovim] foo.vim

var fs = __webpack_require__(60);
var util = __webpack_require__(10);

function main() {
    var neovim = false;
    var fpath = ''
    var args = process.argv;
    if (args.length == 4) {
        if (args[2] == '--neovim') {
            neovim = true;
        }
        fpath = args[3];
    } else if (args.length == 3) {
        neovim = false;
        fpath = args[2]
    }
    var r = new StringReader(viml_readfile(fpath));
    var p = new VimLParser(neovim);
    var c = new Compiler();
    try {
        var lines = c.compile(p.parse(r));
        for (var i in lines) {
            process.stdout.write(lines[i] + "\n");
        }
    } catch (e) {
        process.stdout.write(e + '\n');
    }
}

var pat_vim2js = {
  "[0-9a-zA-Z]" : "[0-9a-zA-Z]",
  "[@*!=><&~#]" : "[@*!=><&~#]",
  "\\<ARGOPT\\>" : "\\bARGOPT\\b",
  "\\<BANG\\>" : "\\bBANG\\b",
  "\\<EDITCMD\\>" : "\\bEDITCMD\\b",
  "\\<NOTRLCOM\\>" : "\\bNOTRLCOM\\b",
  "\\<TRLBAR\\>" : "\\bTRLBAR\\b",
  "\\<USECTRLV\\>" : "\\bUSECTRLV\\b",
  "\\<USERCMD\\>" : "\\bUSERCMD\\b",
  "\\<\\(XFILE\\|FILES\\|FILE1\\)\\>" : "\\b(XFILE|FILES|FILE1)\\b",
  "\\S" : "\\S",
  "\\a" : "[A-Za-z]",
  "\\d" : "\\d",
  "\\h" : "[A-Za-z_]",
  "\\s" : "\\s",
  "\\v^d%[elete][lp]$" : "^d(elete|elet|ele|el|e)[lp]$",
  "\\v^s%(c[^sr][^i][^p]|g|i[^mlg]|I|r[^e])" : "^s(c[^sr][^i][^p]|g|i[^mlg]|I|r[^e])",
  "\\w" : "[0-9A-Za-z_]",
  "\\w\\|[:#]" : "[0-9A-Za-z_]|[:#]",
  "\\x" : "[0-9A-Fa-f]",
  "^++" : "^\+\+",
  "^++bad=\\(keep\\|drop\\|.\\)\\>" : "^\\+\\+bad=(keep|drop|.)\\b",
  "^++bad=drop" : "^\\+\\+bad=drop",
  "^++bad=keep" : "^\\+\\+bad=keep",
  "^++bin\\>" : "^\\+\\+bin\\b",
  "^++edit\\>" : "^\\+\\+edit\\b",
  "^++enc=\\S" : "^\\+\\+enc=\\S",
  "^++encoding=\\S" : "^\\+\\+encoding=\\S",
  "^++ff=\\(dos\\|unix\\|mac\\)\\>" : "^\\+\\+ff=(dos|unix|mac)\\b",
  "^++fileformat=\\(dos\\|unix\\|mac\\)\\>" : "^\\+\\+fileformat=(dos|unix|mac)\\b",
  "^++nobin\\>" : "^\\+\\+nobin\\b",
  "^[A-Z]" : "^[A-Z]",
  "^\\$\\w\\+" : "^\\$[0-9A-Za-z_]+",
  "^\\(!\\|global\\|vglobal\\)$" : "^(!|global|vglobal)$",
  "^\\(WHILE\\|FOR\\)$" : "^(WHILE|FOR)$",
  "^\\(vimgrep\\|vimgrepadd\\|lvimgrep\\|lvimgrepadd\\)$" : "^(vimgrep|vimgrepadd|lvimgrep|lvimgrepadd)$",
  "^\\d" : "^\\d",
  "^\\h" : "^[A-Za-z_]",
  "^\\s" : "^\\s",
  "^\\s*\\\\" : "^\\s*\\\\",
  "^[ \\t]$" : "^[ \\t]$",
  "^[A-Za-z]$" : "^[A-Za-z]$",
  "^[0-9A-Za-z]$" : "^[0-9A-Za-z]$",
  "^[0-9]$" : "^[0-9]$",
  "^[0-9A-Fa-f]$" : "^[0-9A-Fa-f]$",
  "^[0-9A-Za-z_]$" : "^[0-9A-Za-z_]$",
  "^[A-Za-z_]$" : "^[A-Za-z_]$",
  "^[0-9A-Za-z_:#]$" : "^[0-9A-Za-z_:#]$",
  "^[A-Za-z_][0-9A-Za-z_]*$" : "^[A-Za-z_][0-9A-Za-z_]*$",
  "^[A-Z]$" : "^[A-Z]$",
  "^[a-z]$" : "^[a-z]$",
  "^[vgslabwt]:$\\|^\\([vgslabwt]:\\)\\?[A-Za-z_][0-9A-Za-z_#]*$" : "^[vgslabwt]:$|^([vgslabwt]:)?[A-Za-z_][0-9A-Za-z_#]*$",
  "^[0-7]$" : "^[0-7]$",
  "^[0-9A-Fa-f][0-9A-Fa-f]$" : "^[0-9A-Fa-f][0-9A-Fa-f]$",
  "^\\.[0-9A-Fa-f]$" : "^\\.[0-9A-Fa-f]$",
  "^[0-9A-Fa-f][^0-9A-Fa-f]$" : "^[0-9A-Fa-f][^0-9A-Fa-f]$",
}

function viml_add(lst, item) {
    lst.push(item);
}

function viml_call(func, args) {
    return func.apply(null, args);
}

function viml_char2nr(c) {
  return c.charCodeAt(0);
}

function viml_empty(obj) {
    return obj.length == 0;
}

function viml_equalci(a, b) {
    return a.toLowerCase() == b.toLowerCase();
}

function viml_eqreg(s, reg) {
    var mx = new RegExp(pat_vim2js[reg]);
    return mx.exec(s) != null;
}

function viml_eqregh(s, reg) {
    var mx = new RegExp(pat_vim2js[reg]);
    return mx.exec(s) != null;
}

function viml_eqregq(s, reg) {
    var mx = new RegExp(pat_vim2js[reg], "i");
    return mx.exec(s) != null;
}

function viml_escape(s, chars) {
    var r = '';
    for (var i = 0; i < s.length; ++i) {
        if (chars.indexOf(s.charAt(i)) != -1) {
            r = r + "\\" + s.charAt(i);
        } else {
            r = r + s.charAt(i);
        }
    }
    return r;
}

function viml_extend(obj, item) {
    obj.push.apply(obj, item);
}

function viml_insert(lst, item) {
    var idx = arguments.length >= 3 ? arguments[2] : 0;
    lst.splice(0, 0, item);
}

function viml_join(lst, sep) {
    return lst.join(sep);
}

function viml_keys(obj) {
    return Object.keys(obj);
}

function viml_len(obj) {
    if (typeof obj === 'string') {
      var len = 0;
      for (var i = 0; i < obj.length; i++) {
          var c = obj.charCodeAt(i);
          len += c < 128 ? 1 : ((c > 127) && (c < 2048)) ? 2 : 3;
      }
      return len;
    }
    return obj.length;
}

function viml_printf() {
    var a000 = Array.prototype.slice.call(arguments, 0);
    if (a000.length == 1) {
        return a000[0];
    } else {
        return util.format.apply(null, a000);
    }
}

function viml_range(start) {
    var end = arguments.length >= 2 ? arguments[1] : null;
    if (end == null) {
        var x = [];
        for (var i = 0; i < start; ++i) {
            x.push(i);
        }
        return x;
    } else {
        var x = []
        for (var i = start; i <= end; ++i) {
            x.push(i);
        }
        return x;
    }
}

function viml_readfile(path) {
    // FIXME: newline?
    return fs.readFileSync(path, 'utf-8').split(/\r\n|\r|\n/);
}

function viml_remove(lst, idx) {
    lst.splice(idx, 1);
}

function viml_split(s, sep) {
    if (sep == "\\zs") {
        return s.split("");
    }
    throw "NotImplemented";
}

function viml_str2nr(s) {
    var base = arguments.length >= 2 ? arguments[1] : 10;
    return parseInt(s, base);
}

function viml_string(obj) {
    return obj.toString();
}

function viml_has_key(obj, key) {
    return obj[key] !== undefined;
}

function viml_stridx(a, b) {
    return a.indexOf(b);
}

var NIL = [];
var TRUE = 1;
var FALSE = 0;
var NODE_TOPLEVEL = 1;
var NODE_COMMENT = 2;
var NODE_EXCMD = 3;
var NODE_FUNCTION = 4;
var NODE_ENDFUNCTION = 5;
var NODE_DELFUNCTION = 6;
var NODE_RETURN = 7;
var NODE_EXCALL = 8;
var NODE_LET = 9;
var NODE_UNLET = 10;
var NODE_LOCKVAR = 11;
var NODE_UNLOCKVAR = 12;
var NODE_IF = 13;
var NODE_ELSEIF = 14;
var NODE_ELSE = 15;
var NODE_ENDIF = 16;
var NODE_WHILE = 17;
var NODE_ENDWHILE = 18;
var NODE_FOR = 19;
var NODE_ENDFOR = 20;
var NODE_CONTINUE = 21;
var NODE_BREAK = 22;
var NODE_TRY = 23;
var NODE_CATCH = 24;
var NODE_FINALLY = 25;
var NODE_ENDTRY = 26;
var NODE_THROW = 27;
var NODE_ECHO = 28;
var NODE_ECHON = 29;
var NODE_ECHOHL = 30;
var NODE_ECHOMSG = 31;
var NODE_ECHOERR = 32;
var NODE_EXECUTE = 33;
var NODE_TERNARY = 34;
var NODE_OR = 35;
var NODE_AND = 36;
var NODE_EQUAL = 37;
var NODE_EQUALCI = 38;
var NODE_EQUALCS = 39;
var NODE_NEQUAL = 40;
var NODE_NEQUALCI = 41;
var NODE_NEQUALCS = 42;
var NODE_GREATER = 43;
var NODE_GREATERCI = 44;
var NODE_GREATERCS = 45;
var NODE_GEQUAL = 46;
var NODE_GEQUALCI = 47;
var NODE_GEQUALCS = 48;
var NODE_SMALLER = 49;
var NODE_SMALLERCI = 50;
var NODE_SMALLERCS = 51;
var NODE_SEQUAL = 52;
var NODE_SEQUALCI = 53;
var NODE_SEQUALCS = 54;
var NODE_MATCH = 55;
var NODE_MATCHCI = 56;
var NODE_MATCHCS = 57;
var NODE_NOMATCH = 58;
var NODE_NOMATCHCI = 59;
var NODE_NOMATCHCS = 60;
var NODE_IS = 61;
var NODE_ISCI = 62;
var NODE_ISCS = 63;
var NODE_ISNOT = 64;
var NODE_ISNOTCI = 65;
var NODE_ISNOTCS = 66;
var NODE_ADD = 67;
var NODE_SUBTRACT = 68;
var NODE_CONCAT = 69;
var NODE_MULTIPLY = 70;
var NODE_DIVIDE = 71;
var NODE_REMAINDER = 72;
var NODE_NOT = 73;
var NODE_MINUS = 74;
var NODE_PLUS = 75;
var NODE_SUBSCRIPT = 76;
var NODE_SLICE = 77;
var NODE_CALL = 78;
var NODE_DOT = 79;
var NODE_NUMBER = 80;
var NODE_STRING = 81;
var NODE_LIST = 82;
var NODE_DICT = 83;
var NODE_OPTION = 85;
var NODE_IDENTIFIER = 86;
var NODE_CURLYNAME = 87;
var NODE_ENV = 88;
var NODE_REG = 89;
var NODE_CURLYNAMEPART = 90;
var NODE_CURLYNAMEEXPR = 91;
var NODE_LAMBDA = 92;
var NODE_BLOB = 93;
var NODE_CONST = 94;
var NODE_EVAL = 95;
var NODE_HEREDOC = 96;
var NODE_METHOD = 97;
var NODE_ECHOCONSOLE = 98;
var TOKEN_EOF = 1;
var TOKEN_EOL = 2;
var TOKEN_SPACE = 3;
var TOKEN_OROR = 4;
var TOKEN_ANDAND = 5;
var TOKEN_EQEQ = 6;
var TOKEN_EQEQCI = 7;
var TOKEN_EQEQCS = 8;
var TOKEN_NEQ = 9;
var TOKEN_NEQCI = 10;
var TOKEN_NEQCS = 11;
var TOKEN_GT = 12;
var TOKEN_GTCI = 13;
var TOKEN_GTCS = 14;
var TOKEN_GTEQ = 15;
var TOKEN_GTEQCI = 16;
var TOKEN_GTEQCS = 17;
var TOKEN_LT = 18;
var TOKEN_LTCI = 19;
var TOKEN_LTCS = 20;
var TOKEN_LTEQ = 21;
var TOKEN_LTEQCI = 22;
var TOKEN_LTEQCS = 23;
var TOKEN_MATCH = 24;
var TOKEN_MATCHCI = 25;
var TOKEN_MATCHCS = 26;
var TOKEN_NOMATCH = 27;
var TOKEN_NOMATCHCI = 28;
var TOKEN_NOMATCHCS = 29;
var TOKEN_IS = 30;
var TOKEN_ISCI = 31;
var TOKEN_ISCS = 32;
var TOKEN_ISNOT = 33;
var TOKEN_ISNOTCI = 34;
var TOKEN_ISNOTCS = 35;
var TOKEN_PLUS = 36;
var TOKEN_MINUS = 37;
var TOKEN_DOT = 38;
var TOKEN_STAR = 39;
var TOKEN_SLASH = 40;
var TOKEN_PERCENT = 41;
var TOKEN_NOT = 42;
var TOKEN_QUESTION = 43;
var TOKEN_COLON = 44;
var TOKEN_POPEN = 45;
var TOKEN_PCLOSE = 46;
var TOKEN_SQOPEN = 47;
var TOKEN_SQCLOSE = 48;
var TOKEN_COPEN = 49;
var TOKEN_CCLOSE = 50;
var TOKEN_COMMA = 51;
var TOKEN_NUMBER = 52;
var TOKEN_SQUOTE = 53;
var TOKEN_DQUOTE = 54;
var TOKEN_OPTION = 55;
var TOKEN_IDENTIFIER = 56;
var TOKEN_ENV = 57;
var TOKEN_REG = 58;
var TOKEN_EQ = 59;
var TOKEN_OR = 60;
var TOKEN_SEMICOLON = 61;
var TOKEN_BACKTICK = 62;
var TOKEN_DOTDOTDOT = 63;
var TOKEN_SHARP = 64;
var TOKEN_ARROW = 65;
var TOKEN_BLOB = 66;
var TOKEN_LITCOPEN = 67;
var TOKEN_DOTDOT = 68;
var TOKEN_HEREDOC = 69;
var MAX_FUNC_ARGS = 20;
function isalpha(c) {
    return viml_eqregh(c, "^[A-Za-z]$");
}

function isalnum(c) {
    return viml_eqregh(c, "^[0-9A-Za-z]$");
}

function isdigit(c) {
    return viml_eqregh(c, "^[0-9]$");
}

function isodigit(c) {
    return viml_eqregh(c, "^[0-7]$");
}

function isxdigit(c) {
    return viml_eqregh(c, "^[0-9A-Fa-f]$");
}

function iswordc(c) {
    return viml_eqregh(c, "^[0-9A-Za-z_]$");
}

function iswordc1(c) {
    return viml_eqregh(c, "^[A-Za-z_]$");
}

function iswhite(c) {
    return viml_eqregh(c, "^[ \\t]$");
}

function isnamec(c) {
    return viml_eqregh(c, "^[0-9A-Za-z_:#]$");
}

function isnamec1(c) {
    return viml_eqregh(c, "^[A-Za-z_]$");
}

function isargname(s) {
    return viml_eqregh(s, "^[A-Za-z_][0-9A-Za-z_]*$");
}

function isvarname(s) {
    return viml_eqregh(s, "^[vgslabwt]:$\\|^\\([vgslabwt]:\\)\\?[A-Za-z_][0-9A-Za-z_#]*$");
}

// FIXME:
function isidc(c) {
    return viml_eqregh(c, "^[0-9A-Za-z_]$");
}

function isupper(c) {
    return viml_eqregh(c, "^[A-Z]$");
}

function islower(c) {
    return viml_eqregh(c, "^[a-z]$");
}

function ExArg() {
    var ea = {};
    ea.forceit = FALSE;
    ea.addr_count = 0;
    ea.line1 = 0;
    ea.line2 = 0;
    ea.flags = 0;
    ea.do_ecmd_cmd = "";
    ea.do_ecmd_lnum = 0;
    ea.append = 0;
    ea.usefilter = FALSE;
    ea.amount = 0;
    ea.regname = 0;
    ea.force_bin = 0;
    ea.read_edit = 0;
    ea.force_ff = 0;
    ea.force_enc = 0;
    ea.bad_char = 0;
    ea.linepos = {};
    ea.cmdpos = [];
    ea.argpos = [];
    ea.cmd = {};
    ea.modifiers = [];
    ea.range = [];
    ea.argopt = {};
    ea.argcmd = {};
    return ea;
}

// struct node {
//   int     type
//   pos     pos
//   node    left
//   node    right
//   node    cond
//   node    rest
//   node[]  list
//   node[]  rlist
//   node[]  default_args
//   node[]  body
//   string  op
//   string  str
//   int     depth
//   variant value
// }
// TOPLEVEL .body
// COMMENT .str
// EXCMD .ea .str
// FUNCTION .ea .body .left .rlist .default_args .attr .endfunction
// ENDFUNCTION .ea
// DELFUNCTION .ea .left
// RETURN .ea .left
// EXCALL .ea .left
// LET .ea .op .left .list .rest .right
// CONST .ea .op .left .list .rest .right
// UNLET .ea .list
// LOCKVAR .ea .depth .list
// UNLOCKVAR .ea .depth .list
// IF .ea .body .cond .elseif .else .endif
// ELSEIF .ea .body .cond
// ELSE .ea .body
// ENDIF .ea
// WHILE .ea .body .cond .endwhile
// ENDWHILE .ea
// FOR .ea .body .left .list .rest .right .endfor
// ENDFOR .ea
// CONTINUE .ea
// BREAK .ea
// TRY .ea .body .catch .finally .endtry
// CATCH .ea .body .pattern
// FINALLY .ea .body
// ENDTRY .ea
// THROW .ea .left
// EVAL .ea .left
// ECHO .ea .list
// ECHON .ea .list
// ECHOHL .ea .str
// ECHOMSG .ea .list
// ECHOERR .ea .list
// EXECUTE .ea .list
// TERNARY .cond .left .right
// OR .left .right
// AND .left .right
// EQUAL .left .right
// EQUALCI .left .right
// EQUALCS .left .right
// NEQUAL .left .right
// NEQUALCI .left .right
// NEQUALCS .left .right
// GREATER .left .right
// GREATERCI .left .right
// GREATERCS .left .right
// GEQUAL .left .right
// GEQUALCI .left .right
// GEQUALCS .left .right
// SMALLER .left .right
// SMALLERCI .left .right
// SMALLERCS .left .right
// SEQUAL .left .right
// SEQUALCI .left .right
// SEQUALCS .left .right
// MATCH .left .right
// MATCHCI .left .right
// MATCHCS .left .right
// NOMATCH .left .right
// NOMATCHCI .left .right
// NOMATCHCS .left .right
// IS .left .right
// ISCI .left .right
// ISCS .left .right
// ISNOT .left .right
// ISNOTCI .left .right
// ISNOTCS .left .right
// ADD .left .right
// SUBTRACT .left .right
// CONCAT .left .right
// MULTIPLY .left .right
// DIVIDE .left .right
// REMAINDER .left .right
// NOT .left
// MINUS .left
// PLUS .left
// SUBSCRIPT .left .right
// SLICE .left .rlist
// METHOD .left .right
// CALL .left .rlist
// DOT .left .right
// NUMBER .value
// STRING .value
// LIST .value
// DICT .value
// BLOB .value
// NESTING .left
// OPTION .value
// IDENTIFIER .value
// CURLYNAME .value
// ENV .value
// REG .value
// CURLYNAMEPART .value
// CURLYNAMEEXPR .value
// LAMBDA .rlist .left
// HEREDOC .rlist .op .body
function Node(type) {
    return {"type":type};
}

function Err(msg, pos) {
    return viml_printf("vimlparser: %s: line %d col %d", msg, pos.lnum, pos.col);
}

function VimLParser() { this.__init__.apply(this, arguments); }
VimLParser.prototype.__init__ = function() {
    var a000 = Array.prototype.slice.call(arguments, 0);
    if (viml_len(a000) > 0) {
        this.neovim = a000[0];
    }
    else {
        this.neovim = 0;
    }
    this.find_command_cache = {};
}

VimLParser.prototype.push_context = function(node) {
    viml_insert(this.context, node);
}

VimLParser.prototype.pop_context = function() {
    viml_remove(this.context, 0);
}

VimLParser.prototype.find_context = function(type) {
    var i = 0;
    var __c3 = this.context;
    for (var __i3 = 0; __i3 < __c3.length; ++__i3) {
        var node = __c3[__i3];
        if (node.type == type) {
            return i;
        }
        i += 1;
    }
    return -1;
}

VimLParser.prototype.add_node = function(node) {
    viml_add(this.context[0].body, node);
}

VimLParser.prototype.check_missing_endfunction = function(ends, pos) {
    if (this.context[0].type == NODE_FUNCTION) {
        throw Err(viml_printf("E126: Missing :endfunction:    %s", ends), pos);
    }
}

VimLParser.prototype.check_missing_endif = function(ends, pos) {
    if (this.context[0].type == NODE_IF || this.context[0].type == NODE_ELSEIF || this.context[0].type == NODE_ELSE) {
        throw Err(viml_printf("E171: Missing :endif:    %s", ends), pos);
    }
}

VimLParser.prototype.check_missing_endtry = function(ends, pos) {
    if (this.context[0].type == NODE_TRY || this.context[0].type == NODE_CATCH || this.context[0].type == NODE_FINALLY) {
        throw Err(viml_printf("E600: Missing :endtry:    %s", ends), pos);
    }
}

VimLParser.prototype.check_missing_endwhile = function(ends, pos) {
    if (this.context[0].type == NODE_WHILE) {
        throw Err(viml_printf("E170: Missing :endwhile:    %s", ends), pos);
    }
}

VimLParser.prototype.check_missing_endfor = function(ends, pos) {
    if (this.context[0].type == NODE_FOR) {
        throw Err(viml_printf("E170: Missing :endfor:    %s", ends), pos);
    }
}

VimLParser.prototype.parse = function(reader) {
    this.reader = reader;
    this.context = [];
    var toplevel = Node(NODE_TOPLEVEL);
    toplevel.pos = this.reader.getpos();
    toplevel.body = [];
    this.push_context(toplevel);
    while (this.reader.peek() != "<EOF>") {
        this.parse_one_cmd();
    }
    this.check_missing_endfunction("TOPLEVEL", this.reader.getpos());
    this.check_missing_endif("TOPLEVEL", this.reader.getpos());
    this.check_missing_endtry("TOPLEVEL", this.reader.getpos());
    this.check_missing_endwhile("TOPLEVEL", this.reader.getpos());
    this.check_missing_endfor("TOPLEVEL", this.reader.getpos());
    this.pop_context();
    return toplevel;
}

VimLParser.prototype.parse_one_cmd = function() {
    this.ea = ExArg();
    if (this.reader.peekn(2) == "#!") {
        this.parse_hashbang();
        this.reader.get();
        return;
    }
    this.reader.skip_white_and_colon();
    if (this.reader.peekn(1) == "") {
        this.reader.get();
        return;
    }
    if (this.reader.peekn(1) == "\"") {
        this.parse_comment();
        this.reader.get();
        return;
    }
    this.ea.linepos = this.reader.getpos();
    this.parse_command_modifiers();
    this.parse_range();
    this.parse_command();
    this.parse_trail();
}

// FIXME:
VimLParser.prototype.parse_command_modifiers = function() {
    var modifiers = [];
    while (TRUE) {
        var pos = this.reader.tell();
        var d = "";
        if (isdigit(this.reader.peekn(1))) {
            var d = this.reader.read_digit();
            this.reader.skip_white();
        }
        var k = this.reader.read_alpha();
        var c = this.reader.peekn(1);
        this.reader.skip_white();
        if (viml_stridx("aboveleft", k) == 0 && viml_len(k) >= 3) {
            // abo\%[veleft]
            viml_add(modifiers, {"name":"aboveleft"});
        }
        else if (viml_stridx("belowright", k) == 0 && viml_len(k) >= 3) {
            // bel\%[owright]
            viml_add(modifiers, {"name":"belowright"});
        }
        else if (viml_stridx("browse", k) == 0 && viml_len(k) >= 3) {
            // bro\%[wse]
            viml_add(modifiers, {"name":"browse"});
        }
        else if (viml_stridx("botright", k) == 0 && viml_len(k) >= 2) {
            // bo\%[tright]
            viml_add(modifiers, {"name":"botright"});
        }
        else if (viml_stridx("confirm", k) == 0 && viml_len(k) >= 4) {
            // conf\%[irm]
            viml_add(modifiers, {"name":"confirm"});
        }
        else if (viml_stridx("keepmarks", k) == 0 && viml_len(k) >= 3) {
            // kee\%[pmarks]
            viml_add(modifiers, {"name":"keepmarks"});
        }
        else if (viml_stridx("keepalt", k) == 0 && viml_len(k) >= 5) {
            // keepa\%[lt]
            viml_add(modifiers, {"name":"keepalt"});
        }
        else if (viml_stridx("keepjumps", k) == 0 && viml_len(k) >= 5) {
            // keepj\%[umps]
            viml_add(modifiers, {"name":"keepjumps"});
        }
        else if (viml_stridx("keeppatterns", k) == 0 && viml_len(k) >= 5) {
            // keepp\%[atterns]
            viml_add(modifiers, {"name":"keeppatterns"});
        }
        else if (viml_stridx("hide", k) == 0 && viml_len(k) >= 3) {
            // hid\%[e]
            if (this.ends_excmds(c)) {
                break;
            }
            viml_add(modifiers, {"name":"hide"});
        }
        else if (viml_stridx("lockmarks", k) == 0 && viml_len(k) >= 3) {
            // loc\%[kmarks]
            viml_add(modifiers, {"name":"lockmarks"});
        }
        else if (viml_stridx("leftabove", k) == 0 && viml_len(k) >= 5) {
            // lefta\%[bove]
            viml_add(modifiers, {"name":"leftabove"});
        }
        else if (viml_stridx("noautocmd", k) == 0 && viml_len(k) >= 3) {
            // noa\%[utocmd]
            viml_add(modifiers, {"name":"noautocmd"});
        }
        else if (viml_stridx("noswapfile", k) == 0 && viml_len(k) >= 3) {
            // :nos\%[wapfile]
            viml_add(modifiers, {"name":"noswapfile"});
        }
        else if (viml_stridx("rightbelow", k) == 0 && viml_len(k) >= 6) {
            // rightb\%[elow]
            viml_add(modifiers, {"name":"rightbelow"});
        }
        else if (viml_stridx("sandbox", k) == 0 && viml_len(k) >= 3) {
            // san\%[dbox]
            viml_add(modifiers, {"name":"sandbox"});
        }
        else if (viml_stridx("silent", k) == 0 && viml_len(k) >= 3) {
            // sil\%[ent]
            if (c == "!") {
                this.reader.get();
                viml_add(modifiers, {"name":"silent", "bang":1});
            }
            else {
                viml_add(modifiers, {"name":"silent", "bang":0});
            }
        }
        else if (k == "tab") {
            // tab
            if (d != "") {
                viml_add(modifiers, {"name":"tab", "count":viml_str2nr(d, 10)});
            }
            else {
                viml_add(modifiers, {"name":"tab"});
            }
        }
        else if (viml_stridx("topleft", k) == 0 && viml_len(k) >= 2) {
            // to\%[pleft]
            viml_add(modifiers, {"name":"topleft"});
        }
        else if (viml_stridx("unsilent", k) == 0 && viml_len(k) >= 3) {
            // uns\%[ilent]
            viml_add(modifiers, {"name":"unsilent"});
        }
        else if (viml_stridx("vertical", k) == 0 && viml_len(k) >= 4) {
            // vert\%[ical]
            viml_add(modifiers, {"name":"vertical"});
        }
        else if (viml_stridx("verbose", k) == 0 && viml_len(k) >= 4) {
            // verb\%[ose]
            if (d != "") {
                viml_add(modifiers, {"name":"verbose", "count":viml_str2nr(d, 10)});
            }
            else {
                viml_add(modifiers, {"name":"verbose", "count":1});
            }
        }
        else {
            this.reader.seek_set(pos);
            break;
        }
    }
    this.ea.modifiers = modifiers;
}

// FIXME:
VimLParser.prototype.parse_range = function() {
    var tokens = [];
    while (TRUE) {
        while (TRUE) {
            this.reader.skip_white();
            var c = this.reader.peekn(1);
            if (c == "") {
                break;
            }
            if (c == ".") {
                viml_add(tokens, this.reader.getn(1));
            }
            else if (c == "$") {
                viml_add(tokens, this.reader.getn(1));
            }
            else if (c == "'") {
                this.reader.getn(1);
                var m = this.reader.getn(1);
                if (m == "") {
                    break;
                }
                viml_add(tokens, "'" + m);
            }
            else if (c == "/") {
                this.reader.getn(1);
                var __tmp = this.parse_pattern(c);
                var pattern = __tmp[0];
                var _ = __tmp[1];
                viml_add(tokens, pattern);
            }
            else if (c == "?") {
                this.reader.getn(1);
                var __tmp = this.parse_pattern(c);
                var pattern = __tmp[0];
                var _ = __tmp[1];
                viml_add(tokens, pattern);
            }
            else if (c == "\\") {
                var m = this.reader.p(1);
                if (m == "&" || m == "?" || m == "/") {
                    this.reader.seek_cur(2);
                    viml_add(tokens, "\\" + m);
                }
                else {
                    throw Err("E10: \\\\ should be followed by /, ? or &", this.reader.getpos());
                }
            }
            else if (isdigit(c)) {
                viml_add(tokens, this.reader.read_digit());
            }
            while (TRUE) {
                this.reader.skip_white();
                if (this.reader.peekn(1) == "") {
                    break;
                }
                var n = this.reader.read_integer();
                if (n == "") {
                    break;
                }
                viml_add(tokens, n);
            }
            if (this.reader.p(0) != "/" && this.reader.p(0) != "?") {
                break;
            }
        }
        if (this.reader.peekn(1) == "%") {
            viml_add(tokens, this.reader.getn(1));
        }
        else if (this.reader.peekn(1) == "*") {
            // && &cpoptions !~ '\*'
            viml_add(tokens, this.reader.getn(1));
        }
        if (this.reader.peekn(1) == ";") {
            viml_add(tokens, this.reader.getn(1));
            continue;
        }
        else if (this.reader.peekn(1) == ",") {
            viml_add(tokens, this.reader.getn(1));
            continue;
        }
        break;
    }
    this.ea.range = tokens;
}

// FIXME:
VimLParser.prototype.parse_pattern = function(delimiter) {
    var pattern = "";
    var endc = "";
    var inbracket = 0;
    while (TRUE) {
        var c = this.reader.getn(1);
        if (c == "") {
            break;
        }
        if (c == delimiter && inbracket == 0) {
            var endc = c;
            break;
        }
        pattern += c;
        if (c == "\\") {
            var c = this.reader.peekn(1);
            if (c == "") {
                throw Err("E682: Invalid search pattern or delimiter", this.reader.getpos());
            }
            this.reader.getn(1);
            pattern += c;
        }
        else if (c == "[") {
            inbracket += 1;
        }
        else if (c == "]") {
            inbracket -= 1;
        }
    }
    return [pattern, endc];
}

VimLParser.prototype.parse_command = function() {
    this.reader.skip_white_and_colon();
    this.ea.cmdpos = this.reader.getpos();
    if (this.reader.peekn(1) == "" || this.reader.peekn(1) == "\"") {
        if (!viml_empty(this.ea.modifiers) || !viml_empty(this.ea.range)) {
            this.parse_cmd_modifier_range();
        }
        return;
    }
    this.ea.cmd = this.find_command();
    if (this.ea.cmd === NIL) {
        this.reader.setpos(this.ea.cmdpos);
        throw Err(viml_printf("E492: Not an editor command: %s", this.reader.peekline()), this.ea.cmdpos);
    }
    if (this.reader.peekn(1) == "!" && this.ea.cmd.name != "substitute" && this.ea.cmd.name != "smagic" && this.ea.cmd.name != "snomagic") {
        this.reader.getn(1);
        this.ea.forceit = TRUE;
    }
    else {
        this.ea.forceit = FALSE;
    }
    if (!viml_eqregh(this.ea.cmd.flags, "\\<BANG\\>") && this.ea.forceit && !viml_eqregh(this.ea.cmd.flags, "\\<USERCMD\\>")) {
        throw Err("E477: No ! allowed", this.ea.cmdpos);
    }
    if (this.ea.cmd.name != "!") {
        this.reader.skip_white();
    }
    this.ea.argpos = this.reader.getpos();
    if (viml_eqregh(this.ea.cmd.flags, "\\<ARGOPT\\>")) {
        this.parse_argopt();
    }
    if (this.ea.cmd.name == "write" || this.ea.cmd.name == "update") {
        if (this.reader.p(0) == ">") {
            if (this.reader.p(1) != ">") {
                throw Err("E494: Use w or w>>", this.ea.cmdpos);
            }
            this.reader.seek_cur(2);
            this.reader.skip_white();
            this.ea.append = 1;
        }
        else if (this.reader.peekn(1) == "!" && this.ea.cmd.name == "write") {
            this.reader.getn(1);
            this.ea.usefilter = TRUE;
        }
    }
    if (this.ea.cmd.name == "read") {
        if (this.ea.forceit) {
            this.ea.usefilter = TRUE;
            this.ea.forceit = FALSE;
        }
        else if (this.reader.peekn(1) == "!") {
            this.reader.getn(1);
            this.ea.usefilter = TRUE;
        }
    }
    if (this.ea.cmd.name == "<" || this.ea.cmd.name == ">") {
        this.ea.amount = 1;
        while (this.reader.peekn(1) == this.ea.cmd.name) {
            this.reader.getn(1);
            this.ea.amount += 1;
        }
        this.reader.skip_white();
    }
    if (viml_eqregh(this.ea.cmd.flags, "\\<EDITCMD\\>") && !this.ea.usefilter) {
        this.parse_argcmd();
    }
    this._parse_command(this.ea.cmd.parser);
}

// TODO: self[a:parser]
VimLParser.prototype._parse_command = function(parser) {
    if (parser == "parse_cmd_append") {
        this.parse_cmd_append();
    }
    else if (parser == "parse_cmd_break") {
        this.parse_cmd_break();
    }
    else if (parser == "parse_cmd_call") {
        this.parse_cmd_call();
    }
    else if (parser == "parse_cmd_catch") {
        this.parse_cmd_catch();
    }
    else if (parser == "parse_cmd_common") {
        this.parse_cmd_common();
    }
    else if (parser == "parse_cmd_continue") {
        this.parse_cmd_continue();
    }
    else if (parser == "parse_cmd_delfunction") {
        this.parse_cmd_delfunction();
    }
    else if (parser == "parse_cmd_echo") {
        this.parse_cmd_echo();
    }
    else if (parser == "parse_cmd_echoconsole") {
        this.parse_cmd_echoconsole();
    }
    else if (parser == "parse_cmd_echoerr") {
        this.parse_cmd_echoerr();
    }
    else if (parser == "parse_cmd_echohl") {
        this.parse_cmd_echohl();
    }
    else if (parser == "parse_cmd_echomsg") {
        this.parse_cmd_echomsg();
    }
    else if (parser == "parse_cmd_echon") {
        this.parse_cmd_echon();
    }
    else if (parser == "parse_cmd_else") {
        this.parse_cmd_else();
    }
    else if (parser == "parse_cmd_elseif") {
        this.parse_cmd_elseif();
    }
    else if (parser == "parse_cmd_endfor") {
        this.parse_cmd_endfor();
    }
    else if (parser == "parse_cmd_endfunction") {
        this.parse_cmd_endfunction();
    }
    else if (parser == "parse_cmd_endif") {
        this.parse_cmd_endif();
    }
    else if (parser == "parse_cmd_endtry") {
        this.parse_cmd_endtry();
    }
    else if (parser == "parse_cmd_endwhile") {
        this.parse_cmd_endwhile();
    }
    else if (parser == "parse_cmd_execute") {
        this.parse_cmd_execute();
    }
    else if (parser == "parse_cmd_finally") {
        this.parse_cmd_finally();
    }
    else if (parser == "parse_cmd_finish") {
        this.parse_cmd_finish();
    }
    else if (parser == "parse_cmd_for") {
        this.parse_cmd_for();
    }
    else if (parser == "parse_cmd_function") {
        this.parse_cmd_function();
    }
    else if (parser == "parse_cmd_if") {
        this.parse_cmd_if();
    }
    else if (parser == "parse_cmd_insert") {
        this.parse_cmd_insert();
    }
    else if (parser == "parse_cmd_let") {
        this.parse_cmd_let();
    }
    else if (parser == "parse_cmd_const") {
        this.parse_cmd_const();
    }
    else if (parser == "parse_cmd_loadkeymap") {
        this.parse_cmd_loadkeymap();
    }
    else if (parser == "parse_cmd_lockvar") {
        this.parse_cmd_lockvar();
    }
    else if (parser == "parse_cmd_lua") {
        this.parse_cmd_lua();
    }
    else if (parser == "parse_cmd_modifier_range") {
        this.parse_cmd_modifier_range();
    }
    else if (parser == "parse_cmd_mzscheme") {
        this.parse_cmd_mzscheme();
    }
    else if (parser == "parse_cmd_perl") {
        this.parse_cmd_perl();
    }
    else if (parser == "parse_cmd_python") {
        this.parse_cmd_python();
    }
    else if (parser == "parse_cmd_python3") {
        this.parse_cmd_python3();
    }
    else if (parser == "parse_cmd_return") {
        this.parse_cmd_return();
    }
    else if (parser == "parse_cmd_ruby") {
        this.parse_cmd_ruby();
    }
    else if (parser == "parse_cmd_tcl") {
        this.parse_cmd_tcl();
    }
    else if (parser == "parse_cmd_throw") {
        this.parse_cmd_throw();
    }
    else if (parser == "parse_cmd_eval") {
        this.parse_cmd_eval();
    }
    else if (parser == "parse_cmd_try") {
        this.parse_cmd_try();
    }
    else if (parser == "parse_cmd_unlet") {
        this.parse_cmd_unlet();
    }
    else if (parser == "parse_cmd_unlockvar") {
        this.parse_cmd_unlockvar();
    }
    else if (parser == "parse_cmd_usercmd") {
        this.parse_cmd_usercmd();
    }
    else if (parser == "parse_cmd_while") {
        this.parse_cmd_while();
    }
    else if (parser == "parse_wincmd") {
        this.parse_wincmd();
    }
    else if (parser == "parse_cmd_syntax") {
        this.parse_cmd_syntax();
    }
    else {
        throw viml_printf("unknown parser: %s", viml_string(parser));
    }
}

VimLParser.prototype.find_command = function() {
    var c = this.reader.peekn(1);
    var name = "";
    if (c == "k") {
        this.reader.getn(1);
        var name = "k";
    }
    else if (c == "s" && viml_eqregh(this.reader.peekn(5), "\\v^s%(c[^sr][^i][^p]|g|i[^mlg]|I|r[^e])")) {
        this.reader.getn(1);
        var name = "substitute";
    }
    else if (viml_eqregh(c, "[@*!=><&~#]")) {
        this.reader.getn(1);
        var name = c;
    }
    else if (this.reader.peekn(2) == "py") {
        var name = this.reader.read_alnum();
    }
    else {
        var pos = this.reader.tell();
        var name = this.reader.read_alpha();
        if (name != "del" && viml_eqregh(name, "\\v^d%[elete][lp]$")) {
            this.reader.seek_set(pos);
            var name = this.reader.getn(viml_len(name) - 1);
        }
    }
    if (name == "") {
        return NIL;
    }
    if (viml_has_key(this.find_command_cache, name)) {
        return this.find_command_cache[name];
    }
    var cmd = NIL;
    var __c4 = this.builtin_commands;
    for (var __i4 = 0; __i4 < __c4.length; ++__i4) {
        var x = __c4[__i4];
        if (viml_stridx(x.name, name) == 0 && viml_len(name) >= x.minlen) {
            delete cmd;
            var cmd = x;
            break;
        }
    }
    if (this.neovim) {
        var __c5 = this.neovim_additional_commands;
        for (var __i5 = 0; __i5 < __c5.length; ++__i5) {
            var x = __c5[__i5];
            if (viml_stridx(x.name, name) == 0 && viml_len(name) >= x.minlen) {
                delete cmd;
                var cmd = x;
                break;
            }
        }
        var __c6 = this.neovim_removed_commands;
        for (var __i6 = 0; __i6 < __c6.length; ++__i6) {
            var x = __c6[__i6];
            if (viml_stridx(x.name, name) == 0 && viml_len(name) >= x.minlen) {
                delete cmd;
                var cmd = NIL;
                break;
            }
        }
    }
    // FIXME: user defined command
    if ((cmd === NIL || cmd.name == "Print") && viml_eqregh(name, "^[A-Z]")) {
        name += this.reader.read_alnum();
        delete cmd;
        var cmd = {"name":name, "flags":"USERCMD", "parser":"parse_cmd_usercmd"};
    }
    this.find_command_cache[name] = cmd;
    return cmd;
}

// TODO:
VimLParser.prototype.parse_hashbang = function() {
    this.reader.getn(-1);
}

// TODO:
// ++opt=val
VimLParser.prototype.parse_argopt = function() {
    while (this.reader.p(0) == "+" && this.reader.p(1) == "+") {
        var s = this.reader.peekn(20);
        if (viml_eqregh(s, "^++bin\\>")) {
            this.reader.getn(5);
            this.ea.force_bin = 1;
        }
        else if (viml_eqregh(s, "^++nobin\\>")) {
            this.reader.getn(7);
            this.ea.force_bin = 2;
        }
        else if (viml_eqregh(s, "^++edit\\>")) {
            this.reader.getn(6);
            this.ea.read_edit = 1;
        }
        else if (viml_eqregh(s, "^++ff=\\(dos\\|unix\\|mac\\)\\>")) {
            this.reader.getn(5);
            this.ea.force_ff = this.reader.read_alpha();
        }
        else if (viml_eqregh(s, "^++fileformat=\\(dos\\|unix\\|mac\\)\\>")) {
            this.reader.getn(13);
            this.ea.force_ff = this.reader.read_alpha();
        }
        else if (viml_eqregh(s, "^++enc=\\S")) {
            this.reader.getn(6);
            this.ea.force_enc = this.reader.read_nonwhite();
        }
        else if (viml_eqregh(s, "^++encoding=\\S")) {
            this.reader.getn(11);
            this.ea.force_enc = this.reader.read_nonwhite();
        }
        else if (viml_eqregh(s, "^++bad=\\(keep\\|drop\\|.\\)\\>")) {
            this.reader.getn(6);
            if (viml_eqregh(s, "^++bad=keep")) {
                this.ea.bad_char = this.reader.getn(4);
            }
            else if (viml_eqregh(s, "^++bad=drop")) {
                this.ea.bad_char = this.reader.getn(4);
            }
            else {
                this.ea.bad_char = this.reader.getn(1);
            }
        }
        else if (viml_eqregh(s, "^++")) {
            throw Err("E474: Invalid Argument", this.reader.getpos());
        }
        else {
            break;
        }
        this.reader.skip_white();
    }
}

// TODO:
// +command
VimLParser.prototype.parse_argcmd = function() {
    if (this.reader.peekn(1) == "+") {
        this.reader.getn(1);
        if (this.reader.peekn(1) == " ") {
            this.ea.do_ecmd_cmd = "$";
        }
        else {
            this.ea.do_ecmd_cmd = this.read_cmdarg();
        }
    }
}

VimLParser.prototype.read_cmdarg = function() {
    var r = "";
    while (TRUE) {
        var c = this.reader.peekn(1);
        if (c == "" || iswhite(c)) {
            break;
        }
        this.reader.getn(1);
        if (c == "\\") {
            var c = this.reader.getn(1);
        }
        r += c;
    }
    return r;
}

VimLParser.prototype.parse_comment = function() {
    var npos = this.reader.getpos();
    var c = this.reader.get();
    if (c != "\"") {
        throw Err(viml_printf("unexpected character: %s", c), npos);
    }
    var node = Node(NODE_COMMENT);
    node.pos = npos;
    node.str = this.reader.getn(-1);
    this.add_node(node);
}

VimLParser.prototype.parse_trail = function() {
    this.reader.skip_white();
    var c = this.reader.peek();
    if (c == "<EOF>") {
        // pass
    }
    else if (c == "<EOL>") {
        this.reader.get();
    }
    else if (c == "|") {
        this.reader.get();
    }
    else if (c == "\"") {
        this.parse_comment();
        this.reader.get();
    }
    else {
        throw Err(viml_printf("E488: Trailing characters: %s", c), this.reader.getpos());
    }
}

// modifier or range only command line
VimLParser.prototype.parse_cmd_modifier_range = function() {
    var node = Node(NODE_EXCMD);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.str = this.reader.getstr(this.ea.linepos, this.reader.getpos());
    this.add_node(node);
}

// TODO:
VimLParser.prototype.parse_cmd_common = function() {
    var end = this.reader.getpos();
    if (viml_eqregh(this.ea.cmd.flags, "\\<TRLBAR\\>") && !this.ea.usefilter) {
        var end = this.separate_nextcmd();
    }
    else if (this.ea.cmd.name == "!" || this.ea.cmd.name == "global" || this.ea.cmd.name == "vglobal" || this.ea.usefilter) {
        while (TRUE) {
            var end = this.reader.getpos();
            if (this.reader.getn(1) == "") {
                break;
            }
        }
    }
    else {
        while (TRUE) {
            var end = this.reader.getpos();
            if (this.reader.getn(1) == "") {
                break;
            }
        }
    }
    var node = Node(NODE_EXCMD);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.str = this.reader.getstr(this.ea.linepos, end);
    this.add_node(node);
}

VimLParser.prototype.separate_nextcmd = function() {
    if (this.ea.cmd.name == "vimgrep" || this.ea.cmd.name == "vimgrepadd" || this.ea.cmd.name == "lvimgrep" || this.ea.cmd.name == "lvimgrepadd") {
        this.skip_vimgrep_pat();
    }
    var pc = "";
    var end = this.reader.getpos();
    var nospend = end;
    while (TRUE) {
        var end = this.reader.getpos();
        if (!iswhite(pc)) {
            var nospend = end;
        }
        var c = this.reader.peek();
        if (c == "<EOF>" || c == "<EOL>") {
            break;
        }
        else if (c == "\x16") {
            // <C-V>
            this.reader.get();
            var end = this.reader.getpos();
            var nospend = this.reader.getpos();
            var c = this.reader.peek();
            if (c == "<EOF>" || c == "<EOL>") {
                break;
            }
            this.reader.get();
        }
        else if (this.reader.peekn(2) == "`=" && viml_eqregh(this.ea.cmd.flags, "\\<\\(XFILE\\|FILES\\|FILE1\\)\\>")) {
            this.reader.getn(2);
            this.parse_expr();
            var c = this.reader.peekn(1);
            if (c != "`") {
                throw Err(viml_printf("unexpected character: %s", c), this.reader.getpos());
            }
            this.reader.getn(1);
        }
        else if (c == "|" || c == "\n" || c == "\"" && !viml_eqregh(this.ea.cmd.flags, "\\<NOTRLCOM\\>") && (this.ea.cmd.name != "@" && this.ea.cmd.name != "*" || this.reader.getpos() != this.ea.argpos) && (this.ea.cmd.name != "redir" || this.reader.getpos().i != this.ea.argpos.i + 1 || pc != "@")) {
            var has_cpo_bar = FALSE;
            // &cpoptions =~ 'b'
            if ((!has_cpo_bar || !viml_eqregh(this.ea.cmd.flags, "\\<USECTRLV\\>")) && pc == "\\") {
                this.reader.get();
            }
            else {
                break;
            }
        }
        else {
            this.reader.get();
        }
        var pc = c;
    }
    if (!viml_eqregh(this.ea.cmd.flags, "\\<NOTRLCOM\\>")) {
        var end = nospend;
    }
    return end;
}

// FIXME
VimLParser.prototype.skip_vimgrep_pat = function() {
    if (this.reader.peekn(1) == "") {
        // pass
    }
    else if (isidc(this.reader.peekn(1))) {
        // :vimgrep pattern fname
        this.reader.read_nonwhite();
    }
    else {
        // :vimgrep /pattern/[g][j] fname
        var c = this.reader.getn(1);
        var __tmp = this.parse_pattern(c);
        var _ = __tmp[0];
        var endc = __tmp[1];
        if (c != endc) {
            return;
        }
        while (this.reader.p(0) == "g" || this.reader.p(0) == "j") {
            this.reader.getn(1);
        }
    }
}

VimLParser.prototype.parse_cmd_append = function() {
    this.reader.setpos(this.ea.linepos);
    var cmdline = this.reader.readline();
    var lines = [cmdline];
    var m = ".";
    while (TRUE) {
        if (this.reader.peek() == "<EOF>") {
            break;
        }
        var line = this.reader.getn(-1);
        viml_add(lines, line);
        if (line == m) {
            break;
        }
        this.reader.get();
    }
    var node = Node(NODE_EXCMD);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.str = viml_join(lines, "\n");
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_insert = function() {
    this.parse_cmd_append();
}

VimLParser.prototype.parse_cmd_loadkeymap = function() {
    this.reader.setpos(this.ea.linepos);
    var cmdline = this.reader.readline();
    var lines = [cmdline];
    while (TRUE) {
        if (this.reader.peek() == "<EOF>") {
            break;
        }
        var line = this.reader.readline();
        viml_add(lines, line);
    }
    var node = Node(NODE_EXCMD);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.str = viml_join(lines, "\n");
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_lua = function() {
    var lines = [];
    this.reader.skip_white();
    if (this.reader.peekn(2) == "<<") {
        this.reader.getn(2);
        this.reader.skip_white();
        var m = this.reader.readline();
        if (m == "") {
            var m = ".";
        }
        this.reader.setpos(this.ea.linepos);
        var cmdline = this.reader.getn(-1);
        var lines = [cmdline];
        this.reader.get();
        while (TRUE) {
            if (this.reader.peek() == "<EOF>") {
                break;
            }
            var line = this.reader.getn(-1);
            viml_add(lines, line);
            if (line == m) {
                break;
            }
            this.reader.get();
        }
    }
    else {
        this.reader.setpos(this.ea.linepos);
        var cmdline = this.reader.getn(-1);
        var lines = [cmdline];
    }
    var node = Node(NODE_EXCMD);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.str = viml_join(lines, "\n");
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_mzscheme = function() {
    this.parse_cmd_lua();
}

VimLParser.prototype.parse_cmd_perl = function() {
    this.parse_cmd_lua();
}

VimLParser.prototype.parse_cmd_python = function() {
    this.parse_cmd_lua();
}

VimLParser.prototype.parse_cmd_python3 = function() {
    this.parse_cmd_lua();
}

VimLParser.prototype.parse_cmd_ruby = function() {
    this.parse_cmd_lua();
}

VimLParser.prototype.parse_cmd_tcl = function() {
    this.parse_cmd_lua();
}

VimLParser.prototype.parse_cmd_finish = function() {
    this.parse_cmd_common();
    if (this.context[0].type == NODE_TOPLEVEL) {
        this.reader.seek_end(0);
    }
}

// FIXME
VimLParser.prototype.parse_cmd_usercmd = function() {
    this.parse_cmd_common();
}

VimLParser.prototype.parse_cmd_function = function() {
    var pos = this.reader.tell();
    this.reader.skip_white();
    // :function
    if (this.ends_excmds(this.reader.peek())) {
        this.reader.seek_set(pos);
        this.parse_cmd_common();
        return;
    }
    // :function /pattern
    if (this.reader.peekn(1) == "/") {
        this.reader.seek_set(pos);
        this.parse_cmd_common();
        return;
    }
    var left = this.parse_lvalue_func();
    this.reader.skip_white();
    if (left.type == NODE_IDENTIFIER) {
        var s = left.value;
        var ss = viml_split(s, "\\zs");
        if (ss[0] != "<" && ss[0] != "_" && !isupper(ss[0]) && viml_stridx(s, ":") == -1 && viml_stridx(s, "#") == -1) {
            throw Err(viml_printf("E128: Function name must start with a capital or contain a colon: %s", s), left.pos);
        }
    }
    // :function {name}
    if (this.reader.peekn(1) != "(") {
        this.reader.seek_set(pos);
        this.parse_cmd_common();
        return;
    }
    // :function[!] {name}([arguments]) [range] [abort] [dict] [closure]
    var node = Node(NODE_FUNCTION);
    node.pos = this.ea.cmdpos;
    node.body = [];
    node.ea = this.ea;
    node.left = left;
    node.rlist = [];
    node.default_args = [];
    node.attr = {"range":0, "abort":0, "dict":0, "closure":0};
    node.endfunction = NIL;
    this.reader.getn(1);
    var tokenizer = new ExprTokenizer(this.reader);
    if (tokenizer.peek().type == TOKEN_PCLOSE) {
        tokenizer.get();
    }
    else {
        var named = {};
        while (TRUE) {
            var varnode = Node(NODE_IDENTIFIER);
            var token = tokenizer.get();
            if (token.type == TOKEN_IDENTIFIER) {
                if (!isargname(token.value) || token.value == "firstline" || token.value == "lastline") {
                    throw Err(viml_printf("E125: Illegal argument: %s", token.value), token.pos);
                }
                else if (viml_has_key(named, token.value)) {
                    throw Err(viml_printf("E853: Duplicate argument name: %s", token.value), token.pos);
                }
                named[token.value] = 1;
                varnode.pos = token.pos;
                varnode.value = token.value;
                viml_add(node.rlist, varnode);
                if (tokenizer.peek().type == TOKEN_EQ) {
                    tokenizer.get();
                    viml_add(node.default_args, this.parse_expr());
                }
                else if (viml_len(node.default_args) > 0) {
                    throw Err("E989: Non-default argument follows default argument", varnode.pos);
                }
                // XXX: Vim doesn't skip white space before comma.  F(a ,b) => E475
                if (iswhite(this.reader.p(0)) && tokenizer.peek().type == TOKEN_COMMA) {
                    throw Err("E475: Invalid argument: White space is not allowed before comma", this.reader.getpos());
                }
                var token = tokenizer.get();
                if (token.type == TOKEN_COMMA) {
                    // XXX: Vim allows last comma.  F(a, b, ) => OK
                    if (tokenizer.peek().type == TOKEN_PCLOSE) {
                        tokenizer.get();
                        break;
                    }
                }
                else if (token.type == TOKEN_PCLOSE) {
                    break;
                }
                else {
                    throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
                }
            }
            else if (token.type == TOKEN_DOTDOTDOT) {
                varnode.pos = token.pos;
                varnode.value = token.value;
                viml_add(node.rlist, varnode);
                var token = tokenizer.get();
                if (token.type == TOKEN_PCLOSE) {
                    break;
                }
                else {
                    throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
                }
            }
            else {
                throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
            }
        }
    }
    while (TRUE) {
        this.reader.skip_white();
        var epos = this.reader.getpos();
        var key = this.reader.read_alpha();
        if (key == "") {
            break;
        }
        else if (key == "range") {
            node.attr.range = TRUE;
        }
        else if (key == "abort") {
            node.attr.abort = TRUE;
        }
        else if (key == "dict") {
            node.attr.dict = TRUE;
        }
        else if (key == "closure") {
            node.attr.closure = TRUE;
        }
        else {
            throw Err(viml_printf("unexpected token: %s", key), epos);
        }
    }
    this.add_node(node);
    this.push_context(node);
}

VimLParser.prototype.parse_cmd_endfunction = function() {
    this.check_missing_endif("ENDFUNCTION", this.ea.cmdpos);
    this.check_missing_endtry("ENDFUNCTION", this.ea.cmdpos);
    this.check_missing_endwhile("ENDFUNCTION", this.ea.cmdpos);
    this.check_missing_endfor("ENDFUNCTION", this.ea.cmdpos);
    if (this.context[0].type != NODE_FUNCTION) {
        throw Err("E193: :endfunction not inside a function", this.ea.cmdpos);
    }
    this.reader.getn(-1);
    var node = Node(NODE_ENDFUNCTION);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    this.context[0].endfunction = node;
    this.pop_context();
}

VimLParser.prototype.parse_cmd_delfunction = function() {
    var node = Node(NODE_DELFUNCTION);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.left = this.parse_lvalue_func();
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_return = function() {
    if (this.find_context(NODE_FUNCTION) == -1) {
        throw Err("E133: :return not inside a function", this.ea.cmdpos);
    }
    var node = Node(NODE_RETURN);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.left = NIL;
    this.reader.skip_white();
    var c = this.reader.peek();
    if (c == "\"" || !this.ends_excmds(c)) {
        node.left = this.parse_expr();
    }
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_call = function() {
    var node = Node(NODE_EXCALL);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    this.reader.skip_white();
    var c = this.reader.peek();
    if (this.ends_excmds(c)) {
        throw Err("E471: Argument required", this.reader.getpos());
    }
    node.left = this.parse_expr();
    if (node.left.type != NODE_CALL) {
        throw Err("Not an function call", node.left.pos);
    }
    this.add_node(node);
}

VimLParser.prototype.parse_heredoc = function(prefix) {
    var node = Node(NODE_HEREDOC);
    node.pos = this.ea.cmdpos;
    node.op = "";
    node.rlist = [];
    node.body = [];
    // allow prefix to precede heredoc end marker if true
    var is_trim = FALSE;
    while (TRUE) {
        this.reader.skip_white();
        var pos = this.reader.getpos();
        var key = this.reader.read_word();
        if (key == "") {
            break;
        }
        if (!islower(key[0])) {
            node.op = key;
            break;
        }
        else {
            var keynode = Node(NODE_STRING);
            keynode.pos = pos;
            keynode.value = key;
            viml_add(node.rlist, keynode);
            if (key == "trim") {
                var is_trim = TRUE;
            }
        }
    }
    if (node.op == "") {
        throw Err("E172: Missing marker", this.reader.getpos());
    }
    this.parse_trail();
    while (TRUE) {
        if (this.reader.peek() == "<EOF>") {
            break;
        }
        var pos = this.reader.getpos();
        var line = this.reader.getn(-1);
        if (line == node.op || is_trim && line == prefix + node.op) {
            return node;
        }
        var linenode = Node(NODE_STRING);
        linenode.pos = pos;
        linenode.value = line;
        viml_add(node.body, linenode);
        this.reader.get();
    }
    throw Err(viml_printf("E990: Missing end marker '%s'", node.op), this.reader.getpos());
}

VimLParser.prototype.parse_cmd_let = function() {
    var pos = this.reader.tell();
    this.reader.skip_white();
    // :let
    if (this.ends_excmds(this.reader.peek())) {
        this.reader.seek_set(pos);
        this.parse_cmd_common();
        return;
    }
    var lhs = this.parse_letlhs();
    this.reader.skip_white();
    var s1 = this.reader.peekn(1);
    var s2 = this.reader.peekn(2);
    // TODO check scriptversion?
    if (s2 == "..") {
        var s2 = this.reader.peekn(3);
    }
    else if (s2 == "=<") {
        var s2 = this.reader.peekn(3);
    }
    // :let {var-name} ..
    if (this.ends_excmds(s1) || s2 != "+=" && s2 != "-=" && s2 != ".=" && s2 != "..=" && s2 != "*=" && s2 != "/=" && s2 != "%=" && s2 != "=<<" && s1 != "=") {
        this.reader.seek_set(pos);
        this.parse_cmd_common();
        return;
    }
    // :let left op right
    var node = Node(NODE_LET);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.op = "";
    node.left = lhs.left;
    node.list = lhs.list;
    node.rest = lhs.rest;
    node.right = NIL;
    if (s2 == "+=" || s2 == "-=" || s2 == ".=" || s2 == "..=" || s2 == "*=" || s2 == "/=" || s2 == "%=") {
        this.reader.getn(viml_len(s2));
        node.op = s2;
    }
    else if (s2 == "=<<") {
        this.reader.getn(viml_len(s2));
        this.reader.skip_white();
        node.op = s2;
        // compute allowed prefix for heredoc end marker (e.g. EOF)
        var pos = this.reader.tell();
        while (this.reader.tell() > 0) {
            if (this.reader.peek() == "<EOL>") {
                this.reader.seek_cur(1);
                break;
            }
            this.reader.seek_cur(-1);
        }
        var prefix = "";
        while (TRUE) {
            var c = this.reader.getn(1);
            if (c == ":") {
                // any presence of leading ':' disables prefix for heredoc end marker
                var prefix = "";
                break;
            }
            else if (!iswhite(c)) {
                break;
            }
            prefix += c;
        }
        this.reader.seek_set(pos);
        node.right = this.parse_heredoc(prefix);
        this.add_node(node);
        return;
    }
    else if (s1 == "=") {
        this.reader.getn(1);
        node.op = s1;
    }
    else {
        throw "NOT REACHED";
    }
    node.right = this.parse_expr();
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_const = function() {
    var pos = this.reader.tell();
    this.reader.skip_white();
    // :const
    if (this.ends_excmds(this.reader.peek())) {
        this.reader.seek_set(pos);
        this.parse_cmd_common();
        return;
    }
    var lhs = this.parse_constlhs();
    this.reader.skip_white();
    var s1 = this.reader.peekn(1);
    // :const {var-name}
    if (this.ends_excmds(s1) || s1 != "=") {
        this.reader.seek_set(pos);
        this.parse_cmd_common();
        return;
    }
    // :const left op right
    var node = Node(NODE_CONST);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    this.reader.getn(1);
    node.op = s1;
    node.left = lhs.left;
    node.list = lhs.list;
    node.rest = lhs.rest;
    node.right = this.parse_expr();
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_unlet = function() {
    var node = Node(NODE_UNLET);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.list = this.parse_lvaluelist();
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_lockvar = function() {
    var node = Node(NODE_LOCKVAR);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.depth = NIL;
    node.list = [];
    this.reader.skip_white();
    if (isdigit(this.reader.peekn(1))) {
        node.depth = viml_str2nr(this.reader.read_digit(), 10);
    }
    node.list = this.parse_lvaluelist();
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_unlockvar = function() {
    var node = Node(NODE_UNLOCKVAR);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.depth = NIL;
    node.list = [];
    this.reader.skip_white();
    if (isdigit(this.reader.peekn(1))) {
        node.depth = viml_str2nr(this.reader.read_digit(), 10);
    }
    node.list = this.parse_lvaluelist();
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_if = function() {
    var node = Node(NODE_IF);
    node.pos = this.ea.cmdpos;
    node.body = [];
    node.ea = this.ea;
    node.cond = this.parse_expr();
    node.elseif = [];
    node._else = NIL;
    node.endif = NIL;
    this.add_node(node);
    this.push_context(node);
}

VimLParser.prototype.parse_cmd_elseif = function() {
    if (this.context[0].type != NODE_IF && this.context[0].type != NODE_ELSEIF) {
        throw Err("E582: :elseif without :if", this.ea.cmdpos);
    }
    if (this.context[0].type != NODE_IF) {
        this.pop_context();
    }
    var node = Node(NODE_ELSEIF);
    node.pos = this.ea.cmdpos;
    node.body = [];
    node.ea = this.ea;
    node.cond = this.parse_expr();
    viml_add(this.context[0].elseif, node);
    this.push_context(node);
}

VimLParser.prototype.parse_cmd_else = function() {
    if (this.context[0].type != NODE_IF && this.context[0].type != NODE_ELSEIF) {
        throw Err("E581: :else without :if", this.ea.cmdpos);
    }
    if (this.context[0].type != NODE_IF) {
        this.pop_context();
    }
    var node = Node(NODE_ELSE);
    node.pos = this.ea.cmdpos;
    node.body = [];
    node.ea = this.ea;
    this.context[0]._else = node;
    this.push_context(node);
}

VimLParser.prototype.parse_cmd_endif = function() {
    if (this.context[0].type != NODE_IF && this.context[0].type != NODE_ELSEIF && this.context[0].type != NODE_ELSE) {
        throw Err("E580: :endif without :if", this.ea.cmdpos);
    }
    if (this.context[0].type != NODE_IF) {
        this.pop_context();
    }
    var node = Node(NODE_ENDIF);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    this.context[0].endif = node;
    this.pop_context();
}

VimLParser.prototype.parse_cmd_while = function() {
    var node = Node(NODE_WHILE);
    node.pos = this.ea.cmdpos;
    node.body = [];
    node.ea = this.ea;
    node.cond = this.parse_expr();
    node.endwhile = NIL;
    this.add_node(node);
    this.push_context(node);
}

VimLParser.prototype.parse_cmd_endwhile = function() {
    if (this.context[0].type != NODE_WHILE) {
        throw Err("E588: :endwhile without :while", this.ea.cmdpos);
    }
    var node = Node(NODE_ENDWHILE);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    this.context[0].endwhile = node;
    this.pop_context();
}

VimLParser.prototype.parse_cmd_for = function() {
    var node = Node(NODE_FOR);
    node.pos = this.ea.cmdpos;
    node.body = [];
    node.ea = this.ea;
    node.left = NIL;
    node.right = NIL;
    node.endfor = NIL;
    var lhs = this.parse_letlhs();
    node.left = lhs.left;
    node.list = lhs.list;
    node.rest = lhs.rest;
    this.reader.skip_white();
    var epos = this.reader.getpos();
    if (this.reader.read_alpha() != "in") {
        throw Err("Missing \"in\" after :for", epos);
    }
    node.right = this.parse_expr();
    this.add_node(node);
    this.push_context(node);
}

VimLParser.prototype.parse_cmd_endfor = function() {
    if (this.context[0].type != NODE_FOR) {
        throw Err("E588: :endfor without :for", this.ea.cmdpos);
    }
    var node = Node(NODE_ENDFOR);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    this.context[0].endfor = node;
    this.pop_context();
}

VimLParser.prototype.parse_cmd_continue = function() {
    if (this.find_context(NODE_WHILE) == -1 && this.find_context(NODE_FOR) == -1) {
        throw Err("E586: :continue without :while or :for", this.ea.cmdpos);
    }
    var node = Node(NODE_CONTINUE);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_break = function() {
    if (this.find_context(NODE_WHILE) == -1 && this.find_context(NODE_FOR) == -1) {
        throw Err("E587: :break without :while or :for", this.ea.cmdpos);
    }
    var node = Node(NODE_BREAK);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_try = function() {
    var node = Node(NODE_TRY);
    node.pos = this.ea.cmdpos;
    node.body = [];
    node.ea = this.ea;
    node.catch = [];
    node._finally = NIL;
    node.endtry = NIL;
    this.add_node(node);
    this.push_context(node);
}

VimLParser.prototype.parse_cmd_catch = function() {
    if (this.context[0].type == NODE_FINALLY) {
        throw Err("E604: :catch after :finally", this.ea.cmdpos);
    }
    else if (this.context[0].type != NODE_TRY && this.context[0].type != NODE_CATCH) {
        throw Err("E603: :catch without :try", this.ea.cmdpos);
    }
    if (this.context[0].type != NODE_TRY) {
        this.pop_context();
    }
    var node = Node(NODE_CATCH);
    node.pos = this.ea.cmdpos;
    node.body = [];
    node.ea = this.ea;
    node.pattern = NIL;
    this.reader.skip_white();
    if (!this.ends_excmds(this.reader.peek())) {
        var __tmp = this.parse_pattern(this.reader.get());
        node.pattern = __tmp[0];
        var _ = __tmp[1];
    }
    viml_add(this.context[0].catch, node);
    this.push_context(node);
}

VimLParser.prototype.parse_cmd_finally = function() {
    if (this.context[0].type != NODE_TRY && this.context[0].type != NODE_CATCH) {
        throw Err("E606: :finally without :try", this.ea.cmdpos);
    }
    if (this.context[0].type != NODE_TRY) {
        this.pop_context();
    }
    var node = Node(NODE_FINALLY);
    node.pos = this.ea.cmdpos;
    node.body = [];
    node.ea = this.ea;
    this.context[0]._finally = node;
    this.push_context(node);
}

VimLParser.prototype.parse_cmd_endtry = function() {
    if (this.context[0].type != NODE_TRY && this.context[0].type != NODE_CATCH && this.context[0].type != NODE_FINALLY) {
        throw Err("E602: :endtry without :try", this.ea.cmdpos);
    }
    if (this.context[0].type != NODE_TRY) {
        this.pop_context();
    }
    var node = Node(NODE_ENDTRY);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    this.context[0].endtry = node;
    this.pop_context();
}

VimLParser.prototype.parse_cmd_throw = function() {
    var node = Node(NODE_THROW);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.left = this.parse_expr();
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_eval = function() {
    var node = Node(NODE_EVAL);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.left = this.parse_expr();
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_echo = function() {
    var node = Node(NODE_ECHO);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.list = this.parse_exprlist();
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_echon = function() {
    var node = Node(NODE_ECHON);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.list = this.parse_exprlist();
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_echohl = function() {
    var node = Node(NODE_ECHOHL);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.str = "";
    while (!this.ends_excmds(this.reader.peek())) {
        node.str += this.reader.get();
    }
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_echomsg = function() {
    var node = Node(NODE_ECHOMSG);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.list = this.parse_exprlist();
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_echoerr = function() {
    var node = Node(NODE_ECHOERR);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.list = this.parse_exprlist();
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_echoconsole = function() {
    var node = Node(NODE_ECHOCONSOLE);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.list = this.parse_exprlist();
    this.add_node(node);
}

VimLParser.prototype.parse_cmd_execute = function() {
    var node = Node(NODE_EXECUTE);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.list = this.parse_exprlist();
    this.add_node(node);
}

VimLParser.prototype.parse_expr = function() {
    return new ExprParser(this.reader).parse();
}

VimLParser.prototype.parse_exprlist = function() {
    var list = [];
    while (TRUE) {
        this.reader.skip_white();
        var c = this.reader.peek();
        if (c != "\"" && this.ends_excmds(c)) {
            break;
        }
        var node = this.parse_expr();
        viml_add(list, node);
    }
    return list;
}

VimLParser.prototype.parse_lvalue_func = function() {
    var p = new LvalueParser(this.reader);
    var node = p.parse();
    if (node.type == NODE_IDENTIFIER || node.type == NODE_CURLYNAME || node.type == NODE_SUBSCRIPT || node.type == NODE_DOT || node.type == NODE_OPTION || node.type == NODE_ENV || node.type == NODE_REG) {
        return node;
    }
    throw Err("Invalid Expression", node.pos);
}

// FIXME:
VimLParser.prototype.parse_lvalue = function() {
    var p = new LvalueParser(this.reader);
    var node = p.parse();
    if (node.type == NODE_IDENTIFIER) {
        if (!isvarname(node.value)) {
            throw Err(viml_printf("E461: Illegal variable name: %s", node.value), node.pos);
        }
    }
    if (node.type == NODE_IDENTIFIER || node.type == NODE_CURLYNAME || node.type == NODE_SUBSCRIPT || node.type == NODE_SLICE || node.type == NODE_DOT || node.type == NODE_OPTION || node.type == NODE_ENV || node.type == NODE_REG) {
        return node;
    }
    throw Err("Invalid Expression", node.pos);
}

// TODO: merge with s:VimLParser.parse_lvalue()
VimLParser.prototype.parse_constlvalue = function() {
    var p = new LvalueParser(this.reader);
    var node = p.parse();
    if (node.type == NODE_IDENTIFIER) {
        if (!isvarname(node.value)) {
            throw Err(viml_printf("E461: Illegal variable name: %s", node.value), node.pos);
        }
    }
    if (node.type == NODE_IDENTIFIER || node.type == NODE_CURLYNAME) {
        return node;
    }
    else if (node.type == NODE_SUBSCRIPT || node.type == NODE_SLICE || node.type == NODE_DOT) {
        throw Err("E996: Cannot lock a list or dict", node.pos);
    }
    else if (node.type == NODE_OPTION) {
        throw Err("E996: Cannot lock an option", node.pos);
    }
    else if (node.type == NODE_ENV) {
        throw Err("E996: Cannot lock an environment variable", node.pos);
    }
    else if (node.type == NODE_REG) {
        throw Err("E996: Cannot lock a register", node.pos);
    }
    throw Err("Invalid Expression", node.pos);
}

VimLParser.prototype.parse_lvaluelist = function() {
    var list = [];
    var node = this.parse_expr();
    viml_add(list, node);
    while (TRUE) {
        this.reader.skip_white();
        if (this.ends_excmds(this.reader.peek())) {
            break;
        }
        var node = this.parse_lvalue();
        viml_add(list, node);
    }
    return list;
}

// FIXME:
VimLParser.prototype.parse_letlhs = function() {
    var lhs = {"left":NIL, "list":NIL, "rest":NIL};
    var tokenizer = new ExprTokenizer(this.reader);
    if (tokenizer.peek().type == TOKEN_SQOPEN) {
        tokenizer.get();
        lhs.list = [];
        while (TRUE) {
            var node = this.parse_lvalue();
            viml_add(lhs.list, node);
            var token = tokenizer.get();
            if (token.type == TOKEN_SQCLOSE) {
                break;
            }
            else if (token.type == TOKEN_COMMA) {
                continue;
            }
            else if (token.type == TOKEN_SEMICOLON) {
                var node = this.parse_lvalue();
                lhs.rest = node;
                var token = tokenizer.get();
                if (token.type == TOKEN_SQCLOSE) {
                    break;
                }
                else {
                    throw Err(viml_printf("E475 Invalid argument: %s", token.value), token.pos);
                }
            }
            else {
                throw Err(viml_printf("E475 Invalid argument: %s", token.value), token.pos);
            }
        }
    }
    else {
        lhs.left = this.parse_lvalue();
    }
    return lhs;
}

// TODO: merge with s:VimLParser.parse_letlhs() ?
VimLParser.prototype.parse_constlhs = function() {
    var lhs = {"left":NIL, "list":NIL, "rest":NIL};
    var tokenizer = new ExprTokenizer(this.reader);
    if (tokenizer.peek().type == TOKEN_SQOPEN) {
        tokenizer.get();
        lhs.list = [];
        while (TRUE) {
            var node = this.parse_lvalue();
            viml_add(lhs.list, node);
            var token = tokenizer.get();
            if (token.type == TOKEN_SQCLOSE) {
                break;
            }
            else if (token.type == TOKEN_COMMA) {
                continue;
            }
            else if (token.type == TOKEN_SEMICOLON) {
                var node = this.parse_lvalue();
                lhs.rest = node;
                var token = tokenizer.get();
                if (token.type == TOKEN_SQCLOSE) {
                    break;
                }
                else {
                    throw Err(viml_printf("E475 Invalid argument: %s", token.value), token.pos);
                }
            }
            else {
                throw Err(viml_printf("E475 Invalid argument: %s", token.value), token.pos);
            }
        }
    }
    else {
        lhs.left = this.parse_constlvalue();
    }
    return lhs;
}

VimLParser.prototype.ends_excmds = function(c) {
    return c == "" || c == "|" || c == "\"" || c == "<EOF>" || c == "<EOL>";
}

// FIXME: validate argument
VimLParser.prototype.parse_wincmd = function() {
    var c = this.reader.getn(1);
    if (c == "") {
        throw Err("E471: Argument required", this.reader.getpos());
    }
    else if (c == "g" || c == "\x07") {
        // <C-G>
        var c2 = this.reader.getn(1);
        if (c2 == "" || iswhite(c2)) {
            throw Err("E474: Invalid Argument", this.reader.getpos());
        }
    }
    var end = this.reader.getpos();
    this.reader.skip_white();
    if (!this.ends_excmds(this.reader.peek())) {
        throw Err("E474: Invalid Argument", this.reader.getpos());
    }
    var node = Node(NODE_EXCMD);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.str = this.reader.getstr(this.ea.linepos, end);
    this.add_node(node);
}

// FIXME: validate argument
VimLParser.prototype.parse_cmd_syntax = function() {
    var end = this.reader.getpos();
    while (TRUE) {
        var end = this.reader.getpos();
        var c = this.reader.peek();
        if (c == "/" || c == "'" || c == "\"") {
            this.reader.getn(1);
            this.parse_pattern(c);
        }
        else if (c == "=") {
            this.reader.getn(1);
            this.parse_pattern(" ");
        }
        else if (this.ends_excmds(c)) {
            break;
        }
        this.reader.getn(1);
    }
    var node = Node(NODE_EXCMD);
    node.pos = this.ea.cmdpos;
    node.ea = this.ea;
    node.str = this.reader.getstr(this.ea.linepos, end);
    this.add_node(node);
}

VimLParser.prototype.neovim_additional_commands = [{"name":"rshada", "minlen":3, "flags":"BANG|FILE1|TRLBAR|CMDWIN", "parser":"parse_cmd_common"}, {"name":"wshada", "minlen":3, "flags":"BANG|FILE1|TRLBAR|CMDWIN", "parser":"parse_cmd_common"}];
VimLParser.prototype.neovim_removed_commands = [{"name":"Print", "minlen":1, "flags":"RANGE|WHOLEFOLD|COUNT|EXFLAGS|TRLBAR|CMDWIN", "parser":"parse_cmd_common"}, {"name":"fixdel", "minlen":3, "flags":"TRLBAR|CMDWIN", "parser":"parse_cmd_common"}, {"name":"helpfind", "minlen":5, "flags":"EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"open", "minlen":1, "flags":"RANGE|BANG|EXTRA", "parser":"parse_cmd_common"}, {"name":"shell", "minlen":2, "flags":"TRLBAR|CMDWIN", "parser":"parse_cmd_common"}, {"name":"tearoff", "minlen":2, "flags":"NEEDARG|EXTRA|TRLBAR|NOTRLCOM|CMDWIN", "parser":"parse_cmd_common"}, {"name":"gvim", "minlen":2, "flags":"BANG|FILES|EDITCMD|ARGOPT|TRLBAR|CMDWIN", "parser":"parse_cmd_common"}];
// To find new builtin_commands, run the below script.
// $ scripts/update_builtin_commands.sh /path/to/vim/src/ex_cmds.h
VimLParser.prototype.builtin_commands = [{"name":"append", "minlen":1, "flags":"BANG|RANGE|ZEROR|TRLBAR|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_append"}, {"name":"abbreviate", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"abclear", "minlen":3, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"aboveleft", "minlen":3, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"abstract", "minlen":3, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"all", "minlen":2, "flags":"BANG|RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"amenu", "minlen":2, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"anoremenu", "minlen":2, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"args", "minlen":2, "flags":"BANG|FILES|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"argadd", "minlen":4, "flags":"BANG|RANGE|ZEROR|FILES|TRLBAR", "parser":"parse_cmd_common"}, {"name":"argdelete", "minlen":4, "flags":"BANG|RANGE|FILES|TRLBAR", "parser":"parse_cmd_common"}, {"name":"argdo", "minlen":5, "flags":"BANG|NEEDARG|EXTRA|NOTRLCOM|RANGE|DFLALL|EXPAND", "parser":"parse_cmd_common"}, {"name":"argdedupe", "minlen":6, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"argedit", "minlen":4, "flags":"BANG|NEEDARG|RANGE|ZEROR|FILES|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"argglobal", "minlen":4, "flags":"BANG|FILES|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"arglocal", "minlen":4, "flags":"BANG|FILES|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"argument", "minlen":4, "flags":"BANG|RANGE|COUNT|EXTRA|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"ascii", "minlen":2, "flags":"TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"autocmd", "minlen":2, "flags":"BANG|EXTRA|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"augroup", "minlen":3, "flags":"BANG|WORD1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"aunmenu", "minlen":3, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"buffer", "minlen":1, "flags":"BANG|RANGE|BUFNAME|BUFUNL|COUNT|EXTRA|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"bNext", "minlen":2, "flags":"BANG|RANGE|COUNT|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"ball", "minlen":2, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"badd", "minlen":3, "flags":"NEEDARG|FILE1|CMDARG|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"balt", "minlen":4, "flags":"NEEDARG|FILE1|CMDARG|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"bdelete", "minlen":2, "flags":"BANG|RANGE|BUFNAME|COUNT|EXTRA|TRLBAR", "parser":"parse_cmd_common"}, {"name":"behave", "minlen":2, "flags":"BANG|NEEDARG|WORD1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"belowright", "minlen":3, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"bfirst", "minlen":2, "flags":"BANG|RANGE|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"blast", "minlen":2, "flags":"BANG|RANGE|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"bmodified", "minlen":2, "flags":"BANG|RANGE|COUNT|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"bnext", "minlen":2, "flags":"BANG|RANGE|COUNT|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"botright", "minlen":2, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"bprevious", "minlen":2, "flags":"BANG|RANGE|COUNT|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"brewind", "minlen":2, "flags":"BANG|RANGE|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"break", "minlen":4, "flags":"TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_break"}, {"name":"breakadd", "minlen":6, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"breakdel", "minlen":6, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"breaklist", "minlen":6, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"browse", "minlen":3, "flags":"NEEDARG|EXTRA|NOTRLCOM|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"buffers", "minlen":7, "flags":"BANG|EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"bufdo", "minlen":4, "flags":"BANG|NEEDARG|EXTRA|NOTRLCOM|RANGE|DFLALL|EXPAND", "parser":"parse_cmd_common"}, {"name":"bunload", "minlen":3, "flags":"BANG|RANGE|BUFNAME|COUNT|EXTRA|TRLBAR", "parser":"parse_cmd_common"}, {"name":"bwipeout", "minlen":2, "flags":"BANG|RANGE|BUFNAME|BUFUNL|COUNT|EXTRA|TRLBAR", "parser":"parse_cmd_common"}, {"name":"change", "minlen":1, "flags":"BANG|WHOLEFOLD|RANGE|COUNT|TRLBAR|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"cNext", "minlen":2, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"cNfile", "minlen":3, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"cabbrev", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"cabclear", "minlen":4, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"cabove", "minlen":4, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"caddbuffer", "minlen":3, "flags":"RANGE|WORD1|TRLBAR", "parser":"parse_cmd_common"}, {"name":"caddexpr", "minlen":5, "flags":"NEEDARG|WORD1|NOTRLCOM|EXPR_ARG", "parser":"parse_cmd_common"}, {"name":"caddfile", "minlen":5, "flags":"TRLBAR|FILE1", "parser":"parse_cmd_common"}, {"name":"cafter", "minlen":3, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"call", "minlen":3, "flags":"RANGE|NEEDARG|EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_call"}, {"name":"catch", "minlen":3, "flags":"EXTRA|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_catch"}, {"name":"cbuffer", "minlen":2, "flags":"BANG|RANGE|WORD1|TRLBAR", "parser":"parse_cmd_common"}, {"name":"cbefore", "minlen":3, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"cbelow", "minlen":4, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"cbottom", "minlen":3, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"cc", "minlen":2, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"cclose", "minlen":3, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"cd", "minlen":2, "flags":"BANG|FILE1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"cdo", "minlen":3, "flags":"BANG|NEEDARG|EXTRA|NOTRLCOM|RANGE|DFLALL|EXPAND", "parser":"parse_cmd_common"}, {"name":"center", "minlen":2, "flags":"TRLBAR|RANGE|WHOLEFOLD|EXTRA|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"cexpr", "minlen":3, "flags":"NEEDARG|WORD1|NOTRLCOM|EXPR_ARG|BANG", "parser":"parse_cmd_common"}, {"name":"cfile", "minlen":2, "flags":"TRLBAR|FILE1|BANG", "parser":"parse_cmd_common"}, {"name":"cfdo", "minlen":3, "flags":"BANG|NEEDARG|EXTRA|NOTRLCOM|RANGE|DFLALL|EXPAND", "parser":"parse_cmd_common"}, {"name":"cfirst", "minlen":4, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"cgetfile", "minlen":2, "flags":"TRLBAR|FILE1", "parser":"parse_cmd_common"}, {"name":"cgetbuffer", "minlen":5, "flags":"RANGE|WORD1|TRLBAR", "parser":"parse_cmd_common"}, {"name":"cgetexpr", "minlen":5, "flags":"NEEDARG|WORD1|NOTRLCOM|EXPR_ARG", "parser":"parse_cmd_common"}, {"name":"chdir", "minlen":3, "flags":"BANG|FILE1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"changes", "minlen":7, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"checkpath", "minlen":3, "flags":"TRLBAR|BANG|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"checktime", "minlen":6, "flags":"RANGE|BUFNAME|COUNT|EXTRA|TRLBAR", "parser":"parse_cmd_common"}, {"name":"chistory", "minlen":3, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"clist", "minlen":2, "flags":"BANG|EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"clast", "minlen":3, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"class", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"close", "minlen":3, "flags":"BANG|RANGE|COUNT|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"clearjumps", "minlen":3, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"cmap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"cmapclear", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"cmenu", "minlen":3, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"cnext", "minlen":2, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"cnewer", "minlen":4, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"cnfile", "minlen":3, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"cnoremap", "minlen":3, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"cnoreabbrev", "minlen":6, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"cnoremenu", "minlen":7, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"copy", "minlen":2, "flags":"RANGE|WHOLEFOLD|EXTRA|TRLBAR|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"colder", "minlen":3, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"colorscheme", "minlen":4, "flags":"WORD1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"command", "minlen":3, "flags":"EXTRA|BANG|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"comclear", "minlen":4, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"compiler", "minlen":4, "flags":"BANG|TRLBAR|WORD1|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"continue", "minlen":3, "flags":"TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_continue"}, {"name":"confirm", "minlen":4, "flags":"NEEDARG|EXTRA|NOTRLCOM|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"const", "minlen":4, "flags":"EXTRA|BANG|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_const"}, {"name":"copen", "minlen":4, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"cprevious", "minlen":2, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"cpfile", "minlen":3, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"cquit", "minlen":2, "flags":"RANGE|COUNT|ZEROR|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"crewind", "minlen":2, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"cscope", "minlen":2, "flags":"EXTRA|NOTRLCOM|XFILE", "parser":"parse_cmd_common"}, {"name":"cstag", "minlen":3, "flags":"BANG|TRLBAR|WORD1", "parser":"parse_cmd_common"}, {"name":"cunmap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"cunabbrev", "minlen":4, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"cunmenu", "minlen":5, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"cwindow", "minlen":2, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"delete", "minlen":1, "flags":"RANGE|WHOLEFOLD|REGSTR|COUNT|TRLBAR|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"delmarks", "minlen":4, "flags":"BANG|EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"debug", "minlen":3, "flags":"NEEDARG|EXTRA|NOTRLCOM|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"debuggreedy", "minlen":6, "flags":"RANGE|ZEROR|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"def", "minlen":3, "flags":"EXTRA|BANG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"defer", "minlen":4, "flags":"NEEDARG|EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"defcompile", "minlen":4, "flags":"SBOXOK|CMDWIN|LOCK_OK|TRLBAR", "parser":"parse_cmd_common"}, {"name":"delcommand", "minlen":4, "flags":"NEEDARG|WORD1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"delfunction", "minlen":4, "flags":"BANG|NEEDARG|WORD1|CMDWIN|LOCK_OK", "parser":"parse_cmd_delfunction"}, {"name":"display", "minlen":2, "flags":"EXTRA|NOTRLCOM|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"diffupdate", "minlen":3, "flags":"BANG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"diffget", "minlen":5, "flags":"RANGE|EXTRA|TRLBAR|MODIFY", "parser":"parse_cmd_common"}, {"name":"diffoff", "minlen":5, "flags":"BANG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"diffpatch", "minlen":5, "flags":"EXTRA|FILE1|TRLBAR|MODIFY", "parser":"parse_cmd_common"}, {"name":"diffput", "minlen":6, "flags":"RANGE|EXTRA|TRLBAR", "parser":"parse_cmd_common"}, {"name":"diffsplit", "minlen":5, "flags":"EXTRA|FILE1|TRLBAR", "parser":"parse_cmd_common"}, {"name":"diffthis", "minlen":5, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"digraphs", "minlen":3, "flags":"BANG|EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"disassemble", "minlen":4, "flags":"BANG|EXTRA|NEEDARG|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"djump", "minlen":2, "flags":"BANG|RANGE|DFLALL|WHOLEFOLD|EXTRA", "parser":"parse_cmd_common"}, {"name":"dlist", "minlen":2, "flags":"BANG|RANGE|DFLALL|WHOLEFOLD|EXTRA|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"doautocmd", "minlen":2, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"doautoall", "minlen":7, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"drop", "minlen":2, "flags":"FILES|CMDARG|NEEDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"dsearch", "minlen":2, "flags":"BANG|RANGE|DFLALL|WHOLEFOLD|EXTRA|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"dsplit", "minlen":3, "flags":"BANG|RANGE|DFLALL|WHOLEFOLD|EXTRA", "parser":"parse_cmd_common"}, {"name":"edit", "minlen":1, "flags":"BANG|FILE1|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"earlier", "minlen":2, "flags":"TRLBAR|EXTRA|NOSPC|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"echo", "minlen":2, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_echo"}, {"name":"echoerr", "minlen":5, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_echoerr"}, {"name":"echohl", "minlen":5, "flags":"EXTRA|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_echohl"}, {"name":"echomsg", "minlen":5, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_echomsg"}, {"name":"echoconsole", "minlen":5, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_echoconsole"}, {"name":"echowindow", "minlen":5, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"echon", "minlen":5, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_echon"}, {"name":"else", "minlen":2, "flags":"TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_else"}, {"name":"elseif", "minlen":5, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_elseif"}, {"name":"emenu", "minlen":2, "flags":"NEEDARG|EXTRA|TRLBAR|NOTRLCOM|RANGE|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"endif", "minlen":2, "flags":"TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_endif"}, {"name":"endinterface", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"endclass", "minlen":4, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"enddef", "minlen":4, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"endenum", "minlen":4, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"endfunction", "minlen":4, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_endfunction"}, {"name":"endfor", "minlen":5, "flags":"TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_endfor"}, {"name":"endtry", "minlen":4, "flags":"TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_endtry"}, {"name":"endwhile", "minlen":4, "flags":"TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_endwhile"}, {"name":"enew", "minlen":3, "flags":"BANG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"enum", "minlen":3, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"eval", "minlen":2, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_eval"}, {"name":"ex", "minlen":2, "flags":"BANG|FILE1|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"execute", "minlen":3, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_execute"}, {"name":"exit", "minlen":3, "flags":"RANGE|WHOLEFOLD|BANG|FILE1|ARGOPT|DFLALL|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"export", "minlen":3, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"exusage", "minlen":3, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"file", "minlen":1, "flags":"RANGE|ZEROR|BANG|FILE1|TRLBAR", "parser":"parse_cmd_common"}, {"name":"files", "minlen":5, "flags":"BANG|EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"filetype", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"filter", "minlen":4, "flags":"BANG|NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"find", "minlen":3, "flags":"RANGE|BANG|FILE1|CMDARG|ARGOPT|TRLBAR|NEEDARG", "parser":"parse_cmd_common"}, {"name":"final", "minlen":4, "flags":"EXTRA|NOTRLCOM|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"finally", "minlen":6, "flags":"TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_finally"}, {"name":"finish", "minlen":4, "flags":"TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_finish"}, {"name":"first", "minlen":3, "flags":"EXTRA|BANG|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"fixdel", "minlen":3, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"fold", "minlen":2, "flags":"RANGE|WHOLEFOLD|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"foldclose", "minlen":5, "flags":"RANGE|BANG|WHOLEFOLD|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"folddoopen", "minlen":5, "flags":"RANGE|DFLALL|NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"folddoclosed", "minlen":7, "flags":"RANGE|DFLALL|NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"foldopen", "minlen":5, "flags":"RANGE|BANG|WHOLEFOLD|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"for", "minlen":3, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_for"}, {"name":"function", "minlen":2, "flags":"EXTRA|BANG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_function"}, {"name":"global", "minlen":1, "flags":"RANGE|WHOLEFOLD|BANG|EXTRA|DFLALL|SBOXOK|CMDWIN|LOCK_OK|NONWHITE_OK", "parser":"parse_cmd_common"}, {"name":"goto", "minlen":2, "flags":"RANGE|COUNT|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"grep", "minlen":2, "flags":"RANGE|BANG|NEEDARG|EXTRA|NOTRLCOM|TRLBAR|XFILE", "parser":"parse_cmd_common"}, {"name":"grepadd", "minlen":5, "flags":"RANGE|BANG|NEEDARG|EXTRA|NOTRLCOM|TRLBAR|XFILE", "parser":"parse_cmd_common"}, {"name":"gui", "minlen":2, "flags":"BANG|FILES|CMDARG|ARGOPT|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"gvim", "minlen":2, "flags":"BANG|FILES|CMDARG|ARGOPT|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"help", "minlen":1, "flags":"BANG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"helpclose", "minlen":5, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"helpfind", "minlen":5, "flags":"EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"helpgrep", "minlen":5, "flags":"EXTRA|NOTRLCOM|NEEDARG", "parser":"parse_cmd_common"}, {"name":"helptags", "minlen":5, "flags":"NEEDARG|FILES|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"hardcopy", "minlen":2, "flags":"RANGE|COUNT|EXTRA|EXPAND|TRLBAR|DFLALL|BANG", "parser":"parse_cmd_common"}, {"name":"highlight", "minlen":2, "flags":"BANG|EXTRA|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"hide", "minlen":3, "flags":"BANG|RANGE|COUNT|EXTRA|TRLBAR", "parser":"parse_cmd_common"}, {"name":"history", "minlen":3, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"horizontal", "minlen":2, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"insert", "minlen":1, "flags":"BANG|RANGE|TRLBAR|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_insert"}, {"name":"iabbrev", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"iabclear", "minlen":4, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"if", "minlen":2, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_if"}, {"name":"ijump", "minlen":2, "flags":"BANG|RANGE|DFLALL|WHOLEFOLD|EXTRA", "parser":"parse_cmd_common"}, {"name":"ilist", "minlen":2, "flags":"BANG|RANGE|DFLALL|WHOLEFOLD|EXTRA|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"imap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"imapclear", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"imenu", "minlen":3, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"import", "minlen":3, "flags":"EXTRA|NOTRLCOM|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"inoremap", "minlen":3, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"inoreabbrev", "minlen":6, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"inoremenu", "minlen":7, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"intro", "minlen":3, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"interface", "minlen":4, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"isearch", "minlen":2, "flags":"BANG|RANGE|DFLALL|WHOLEFOLD|EXTRA|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"isplit", "minlen":3, "flags":"BANG|RANGE|DFLALL|WHOLEFOLD|EXTRA", "parser":"parse_cmd_common"}, {"name":"iunmap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"iunabbrev", "minlen":4, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"iunmenu", "minlen":5, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"join", "minlen":1, "flags":"BANG|RANGE|WHOLEFOLD|COUNT|FLAGS|TRLBAR|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"jumps", "minlen":2, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"k", "minlen":1, "flags":"RANGE|WORD1|TRLBAR|SBOXOK|CMDWIN|LOCK_OK|NONWHITE_OK", "parser":"parse_cmd_common"}, {"name":"keepmarks", "minlen":2, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"keepjumps", "minlen":5, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"keeppatterns", "minlen":5, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"keepalt", "minlen":5, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"list", "minlen":1, "flags":"RANGE|WHOLEFOLD|COUNT|FLAGS|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"lNext", "minlen":2, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"lNfile", "minlen":3, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"last", "minlen":2, "flags":"EXTRA|BANG|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"labove", "minlen":3, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"language", "minlen":3, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"laddexpr", "minlen":3, "flags":"NEEDARG|WORD1|NOTRLCOM|EXPR_ARG", "parser":"parse_cmd_common"}, {"name":"laddbuffer", "minlen":5, "flags":"RANGE|WORD1|TRLBAR", "parser":"parse_cmd_common"}, {"name":"laddfile", "minlen":5, "flags":"TRLBAR|FILE1", "parser":"parse_cmd_common"}, {"name":"lafter", "minlen":3, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"later", "minlen":3, "flags":"TRLBAR|EXTRA|NOSPC|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"lbuffer", "minlen":2, "flags":"BANG|RANGE|WORD1|TRLBAR", "parser":"parse_cmd_common"}, {"name":"lbefore", "minlen":3, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"lbelow", "minlen":4, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"lbottom", "minlen":3, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"lcd", "minlen":2, "flags":"BANG|FILE1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"lchdir", "minlen":3, "flags":"BANG|FILE1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"lclose", "minlen":3, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"lcscope", "minlen":3, "flags":"EXTRA|NOTRLCOM|XFILE", "parser":"parse_cmd_common"}, {"name":"ldo", "minlen":2, "flags":"BANG|NEEDARG|EXTRA|NOTRLCOM|RANGE|DFLALL|EXPAND", "parser":"parse_cmd_common"}, {"name":"left", "minlen":2, "flags":"TRLBAR|RANGE|WHOLEFOLD|EXTRA|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"leftabove", "minlen":5, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"let", "minlen":3, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_let"}, {"name":"lexpr", "minlen":3, "flags":"NEEDARG|WORD1|NOTRLCOM|EXPR_ARG|BANG", "parser":"parse_cmd_common"}, {"name":"legacy", "minlen":3, "flags":"NEEDARG|EXTRA|NOTRLCOM|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"lfile", "minlen":2, "flags":"TRLBAR|FILE1|BANG", "parser":"parse_cmd_common"}, {"name":"lfdo", "minlen":3, "flags":"BANG|NEEDARG|EXTRA|NOTRLCOM|RANGE|DFLALL|EXPAND", "parser":"parse_cmd_common"}, {"name":"lfirst", "minlen":4, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"lgetfile", "minlen":2, "flags":"TRLBAR|FILE1", "parser":"parse_cmd_common"}, {"name":"lgetbuffer", "minlen":5, "flags":"RANGE|WORD1|TRLBAR", "parser":"parse_cmd_common"}, {"name":"lgetexpr", "minlen":5, "flags":"NEEDARG|WORD1|NOTRLCOM|EXPR_ARG", "parser":"parse_cmd_common"}, {"name":"lgrep", "minlen":3, "flags":"RANGE|BANG|NEEDARG|EXTRA|NOTRLCOM|TRLBAR|XFILE", "parser":"parse_cmd_common"}, {"name":"lgrepadd", "minlen":6, "flags":"RANGE|BANG|NEEDARG|EXTRA|NOTRLCOM|TRLBAR|XFILE", "parser":"parse_cmd_common"}, {"name":"lhelpgrep", "minlen":2, "flags":"EXTRA|NOTRLCOM|NEEDARG", "parser":"parse_cmd_common"}, {"name":"lhistory", "minlen":3, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"ll", "minlen":2, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"llast", "minlen":3, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"llist", "minlen":3, "flags":"BANG|EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"lmap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"lmapclear", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"lmake", "minlen":4, "flags":"BANG|EXTRA|NOTRLCOM|TRLBAR|XFILE", "parser":"parse_cmd_common"}, {"name":"lnoremap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"lnext", "minlen":3, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"lnewer", "minlen":4, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"lnfile", "minlen":3, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"loadview", "minlen":2, "flags":"FILE1|TRLBAR", "parser":"parse_cmd_common"}, {"name":"loadkeymap", "minlen":5, "flags":"CMDWIN|LOCK_OK", "parser":"parse_cmd_loadkeymap"}, {"name":"lockmarks", "minlen":3, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"lockvar", "minlen":5, "flags":"BANG|EXTRA|NEEDARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_lockvar"}, {"name":"lolder", "minlen":3, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"lopen", "minlen":3, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"lprevious", "minlen":2, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"lpfile", "minlen":3, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"lrewind", "minlen":2, "flags":"RANGE|COUNT|TRLBAR|BANG", "parser":"parse_cmd_common"}, {"name":"ltag", "minlen":2, "flags":"TRLBAR|BANG|WORD1", "parser":"parse_cmd_common"}, {"name":"lunmap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"lua", "minlen":3, "flags":"RANGE|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_lua"}, {"name":"luado", "minlen":4, "flags":"RANGE|DFLALL|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"luafile", "minlen":4, "flags":"RANGE|FILE1|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"lvimgrep", "minlen":2, "flags":"RANGE|BANG|NEEDARG|EXTRA|NOTRLCOM|TRLBAR|XFILE|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"lvimgrepadd", "minlen":9, "flags":"RANGE|BANG|NEEDARG|EXTRA|NOTRLCOM|TRLBAR|XFILE|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"lwindow", "minlen":2, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"ls", "minlen":2, "flags":"BANG|EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"move", "minlen":1, "flags":"RANGE|WHOLEFOLD|EXTRA|TRLBAR|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"mark", "minlen":2, "flags":"RANGE|WORD1|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"make", "minlen":3, "flags":"BANG|EXTRA|NOTRLCOM|TRLBAR|XFILE", "parser":"parse_cmd_common"}, {"name":"map", "minlen":3, "flags":"BANG|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"mapclear", "minlen":4, "flags":"EXTRA|BANG|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"marks", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"match", "minlen":3, "flags":"RANGE|EXTRA|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"menu", "minlen":2, "flags":"RANGE|ZEROR|BANG|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"menutranslate", "minlen":5, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"messages", "minlen":3, "flags":"EXTRA|TRLBAR|RANGE|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"mkexrc", "minlen":2, "flags":"BANG|FILE1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"mksession", "minlen":3, "flags":"BANG|FILE1|TRLBAR", "parser":"parse_cmd_common"}, {"name":"mkspell", "minlen":4, "flags":"BANG|NEEDARG|EXTRA|NOTRLCOM|TRLBAR|XFILE", "parser":"parse_cmd_common"}, {"name":"mkvimrc", "minlen":3, "flags":"BANG|FILE1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"mkview", "minlen":5, "flags":"BANG|FILE1|TRLBAR", "parser":"parse_cmd_common"}, {"name":"mode", "minlen":3, "flags":"WORD1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"mzscheme", "minlen":2, "flags":"RANGE|EXTRA|DFLALL|NEEDARG|CMDWIN|LOCK_OK|SBOXOK|RESTRICT", "parser":"parse_cmd_mzscheme"}, {"name":"mzfile", "minlen":3, "flags":"RANGE|FILE1|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"next", "minlen":1, "flags":"RANGE|BANG|FILES|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"nbkey", "minlen":2, "flags":"EXTRA|NEEDARG", "parser":"parse_cmd_common"}, {"name":"nbclose", "minlen":3, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"nbstart", "minlen":3, "flags":"WORD1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"new", "minlen":3, "flags":"BANG|FILE1|RANGE|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"nmap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"nmapclear", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"nmenu", "minlen":3, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"nnoremap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"nnoremenu", "minlen":7, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"noremap", "minlen":2, "flags":"BANG|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"noautocmd", "minlen":3, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"nohlsearch", "minlen":3, "flags":"TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"noreabbrev", "minlen":5, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"noremenu", "minlen":6, "flags":"RANGE|ZEROR|BANG|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"noswapfile", "minlen":3, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"normal", "minlen":4, "flags":"RANGE|BANG|EXTRA|NEEDARG|NOTRLCOM|CTRLV|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"number", "minlen":2, "flags":"RANGE|WHOLEFOLD|COUNT|FLAGS|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"nunmap", "minlen":3, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"nunmenu", "minlen":5, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"open", "minlen":1, "flags":"RANGE|BANG|EXTRA", "parser":"parse_cmd_common"}, {"name":"oldfiles", "minlen":2, "flags":"BANG|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"omap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"omapclear", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"omenu", "minlen":3, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"only", "minlen":2, "flags":"BANG|RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"onoremap", "minlen":3, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"onoremenu", "minlen":7, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"options", "minlen":3, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"ounmap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"ounmenu", "minlen":5, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"ownsyntax", "minlen":2, "flags":"EXTRA|NOTRLCOM|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"print", "minlen":1, "flags":"RANGE|WHOLEFOLD|COUNT|FLAGS|TRLBAR|CMDWIN|LOCK_OK|SBOXOK", "parser":"parse_cmd_common"}, {"name":"packadd", "minlen":2, "flags":"BANG|FILE1|NEEDARG|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"packloadall", "minlen":5, "flags":"BANG|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"pclose", "minlen":2, "flags":"BANG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"perl", "minlen":2, "flags":"RANGE|EXTRA|DFLALL|NEEDARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_perl"}, {"name":"perldo", "minlen":5, "flags":"RANGE|EXTRA|DFLALL|NEEDARG|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"pedit", "minlen":3, "flags":"BANG|FILE1|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"pop", "minlen":2, "flags":"RANGE|BANG|COUNT|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"popup", "minlen":4, "flags":"NEEDARG|EXTRA|BANG|TRLBAR|NOTRLCOM|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"ppop", "minlen":2, "flags":"RANGE|BANG|COUNT|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"preserve", "minlen":3, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"previous", "minlen":4, "flags":"EXTRA|RANGE|COUNT|BANG|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"promptfind", "minlen":3, "flags":"EXTRA|NOTRLCOM|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"promptrepl", "minlen":7, "flags":"EXTRA|NOTRLCOM|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"profile", "minlen":4, "flags":"BANG|EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"profdel", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"psearch", "minlen":2, "flags":"BANG|RANGE|WHOLEFOLD|DFLALL|EXTRA", "parser":"parse_cmd_common"}, {"name":"ptag", "minlen":2, "flags":"RANGE|BANG|WORD1|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"ptNext", "minlen":3, "flags":"RANGE|BANG|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"ptfirst", "minlen":3, "flags":"RANGE|BANG|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"ptjump", "minlen":3, "flags":"BANG|TRLBAR|WORD1", "parser":"parse_cmd_common"}, {"name":"ptlast", "minlen":3, "flags":"BANG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"ptnext", "minlen":3, "flags":"RANGE|BANG|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"ptprevious", "minlen":3, "flags":"RANGE|BANG|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"ptrewind", "minlen":3, "flags":"RANGE|BANG|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"ptselect", "minlen":3, "flags":"BANG|TRLBAR|WORD1", "parser":"parse_cmd_common"}, {"name":"put", "minlen":2, "flags":"RANGE|WHOLEFOLD|BANG|REGSTR|TRLBAR|ZEROR|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"pwd", "minlen":2, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"python", "minlen":2, "flags":"RANGE|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_python"}, {"name":"pydo", "minlen":3, "flags":"RANGE|DFLALL|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"pyfile", "minlen":3, "flags":"RANGE|FILE1|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"py3", "minlen":3, "flags":"RANGE|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_python3"}, {"name":"py3do", "minlen":4, "flags":"RANGE|DFLALL|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"python3", "minlen":7, "flags":"RANGE|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_python3"}, {"name":"py3file", "minlen":4, "flags":"RANGE|FILE1|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"pyx", "minlen":3, "flags":"RANGE|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"pyxdo", "minlen":4, "flags":"RANGE|DFLALL|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"pythonx", "minlen":7, "flags":"RANGE|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"pyxfile", "minlen":4, "flags":"RANGE|FILE1|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"quit", "minlen":1, "flags":"BANG|RANGE|COUNT|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"quitall", "minlen":5, "flags":"BANG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"qall", "minlen":2, "flags":"BANG|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"read", "minlen":1, "flags":"BANG|RANGE|WHOLEFOLD|FILE1|ARGOPT|TRLBAR|ZEROR|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"recover", "minlen":3, "flags":"BANG|FILE1|TRLBAR", "parser":"parse_cmd_common"}, {"name":"redo", "minlen":3, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"redir", "minlen":4, "flags":"BANG|FILES|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"redraw", "minlen":4, "flags":"BANG|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"redrawstatus", "minlen":7, "flags":"BANG|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"redrawtabline", "minlen":7, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"registers", "minlen":3, "flags":"EXTRA|NOTRLCOM|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"resize", "minlen":3, "flags":"RANGE|TRLBAR|WORD1|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"retab", "minlen":3, "flags":"TRLBAR|RANGE|WHOLEFOLD|DFLALL|BANG|WORD1|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"return", "minlen":4, "flags":"EXTRA|NOTRLCOM|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_return"}, {"name":"rewind", "minlen":3, "flags":"EXTRA|BANG|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"right", "minlen":2, "flags":"TRLBAR|RANGE|WHOLEFOLD|EXTRA|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"rightbelow", "minlen":6, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"runtime", "minlen":2, "flags":"BANG|NEEDARG|FILES|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"ruby", "minlen":3, "flags":"RANGE|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_ruby"}, {"name":"rubydo", "minlen":5, "flags":"RANGE|DFLALL|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"rubyfile", "minlen":5, "flags":"RANGE|FILE1|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"rundo", "minlen":4, "flags":"NEEDARG|FILE1", "parser":"parse_cmd_common"}, {"name":"rviminfo", "minlen":2, "flags":"BANG|FILE1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"substitute", "minlen":1, "flags":"RANGE|WHOLEFOLD|EXTRA|CMDWIN|LOCK_OK|NONWHITE_OK", "parser":"parse_cmd_common"}, {"name":"sNext", "minlen":2, "flags":"EXTRA|RANGE|COUNT|BANG|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sargument", "minlen":2, "flags":"BANG|RANGE|COUNT|EXTRA|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sall", "minlen":3, "flags":"BANG|RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sandbox", "minlen":3, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"saveas", "minlen":3, "flags":"BANG|FILE1|ARGOPT|CMDWIN|LOCK_OK|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sbuffer", "minlen":2, "flags":"BANG|RANGE|BUFNAME|BUFUNL|COUNT|EXTRA|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sbNext", "minlen":3, "flags":"RANGE|COUNT|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sball", "minlen":3, "flags":"RANGE|COUNT|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sbfirst", "minlen":3, "flags":"CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sblast", "minlen":3, "flags":"CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sbmodified", "minlen":3, "flags":"RANGE|COUNT|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sbnext", "minlen":3, "flags":"RANGE|COUNT|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sbprevious", "minlen":3, "flags":"RANGE|COUNT|CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sbrewind", "minlen":3, "flags":"CMDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"scriptnames", "minlen":2, "flags":"BANG|RANGE|COUNT|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"scriptencoding", "minlen":7, "flags":"WORD1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"scriptversion", "minlen":7, "flags":"WORD1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"scscope", "minlen":3, "flags":"EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"set", "minlen":2, "flags":"BANG|TRLBAR|EXTRA|CMDWIN|LOCK_OK|SBOXOK", "parser":"parse_cmd_common"}, {"name":"setfiletype", "minlen":4, "flags":"TRLBAR|EXTRA|NEEDARG|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"setglobal", "minlen":4, "flags":"BANG|TRLBAR|EXTRA|CMDWIN|LOCK_OK|SBOXOK", "parser":"parse_cmd_common"}, {"name":"setlocal", "minlen":4, "flags":"BANG|TRLBAR|EXTRA|CMDWIN|LOCK_OK|SBOXOK", "parser":"parse_cmd_common"}, {"name":"sfind", "minlen":2, "flags":"BANG|FILE1|RANGE|CMDARG|ARGOPT|TRLBAR|NEEDARG", "parser":"parse_cmd_common"}, {"name":"sfirst", "minlen":4, "flags":"EXTRA|BANG|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"shell", "minlen":2, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"simalt", "minlen":2, "flags":"NEEDARG|WORD1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"sign", "minlen":3, "flags":"NEEDARG|RANGE|EXTRA|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"silent", "minlen":3, "flags":"NEEDARG|EXTRA|BANG|NOTRLCOM|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"sleep", "minlen":2, "flags":"BANG|RANGE|COUNT|EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"slast", "minlen":3, "flags":"EXTRA|BANG|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"smagic", "minlen":2, "flags":"RANGE|WHOLEFOLD|EXTRA|CMDWIN|LOCK_OK|NONWHITE_OK", "parser":"parse_cmd_common"}, {"name":"smap", "minlen":4, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"smapclear", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"smenu", "minlen":3, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"snext", "minlen":2, "flags":"RANGE|BANG|FILES|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"snomagic", "minlen":3, "flags":"RANGE|WHOLEFOLD|EXTRA|CMDWIN|LOCK_OK|NONWHITE_OK", "parser":"parse_cmd_common"}, {"name":"snoremap", "minlen":4, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"snoremenu", "minlen":7, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"source", "minlen":2, "flags":"BANG|FILE1|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"sort", "minlen":3, "flags":"RANGE|DFLALL|WHOLEFOLD|BANG|EXTRA|NOTRLCOM|MODIFY", "parser":"parse_cmd_common"}, {"name":"split", "minlen":2, "flags":"BANG|FILE1|RANGE|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"spellgood", "minlen":3, "flags":"BANG|RANGE|NEEDARG|EXTRA|TRLBAR", "parser":"parse_cmd_common"}, {"name":"spelldump", "minlen":6, "flags":"BANG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"spellinfo", "minlen":6, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"spellrepall", "minlen":6, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"spellrare", "minlen":7, "flags":"BANG|RANGE|NEEDARG|EXTRA|TRLBAR", "parser":"parse_cmd_common"}, {"name":"spellundo", "minlen":6, "flags":"BANG|RANGE|NEEDARG|EXTRA|TRLBAR", "parser":"parse_cmd_common"}, {"name":"spellwrong", "minlen":6, "flags":"BANG|RANGE|NEEDARG|EXTRA|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sprevious", "minlen":3, "flags":"EXTRA|RANGE|COUNT|BANG|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"srewind", "minlen":2, "flags":"EXTRA|BANG|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"stop", "minlen":2, "flags":"TRLBAR|BANG|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"stag", "minlen":3, "flags":"RANGE|BANG|WORD1|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"startinsert", "minlen":4, "flags":"BANG|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"startgreplace", "minlen":6, "flags":"BANG|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"startreplace", "minlen":6, "flags":"BANG|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"static", "minlen":4, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"stopinsert", "minlen":5, "flags":"BANG|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"stjump", "minlen":3, "flags":"BANG|TRLBAR|WORD1", "parser":"parse_cmd_common"}, {"name":"stselect", "minlen":3, "flags":"BANG|TRLBAR|WORD1", "parser":"parse_cmd_common"}, {"name":"sunhide", "minlen":3, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"sunmap", "minlen":4, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"sunmenu", "minlen":5, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"suspend", "minlen":3, "flags":"TRLBAR|BANG|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"sview", "minlen":2, "flags":"BANG|FILE1|RANGE|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"swapname", "minlen":2, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"syntax", "minlen":2, "flags":"EXTRA|NOTRLCOM|CMDWIN|LOCK_OK", "parser":"parse_cmd_syntax"}, {"name":"syntime", "minlen":5, "flags":"NEEDARG|WORD1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"syncbind", "minlen":4, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"smile", "minlen":3, "flags":"TRLBAR|CMDWIN|LOCK_OK|SBOXOK", "parser":"parse_cmd_common"}, {"name":"t", "minlen":1, "flags":"RANGE|WHOLEFOLD|EXTRA|TRLBAR|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"tNext", "minlen":2, "flags":"RANGE|BANG|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"tag", "minlen":2, "flags":"RANGE|BANG|WORD1|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"tags", "minlen":4, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tab", "minlen":3, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"tabclose", "minlen":4, "flags":"BANG|RANGE|ZEROR|EXTRA|NOSPC|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tabdo", "minlen":4, "flags":"NEEDARG|EXTRA|NOTRLCOM|RANGE|DFLALL|EXPAND", "parser":"parse_cmd_common"}, {"name":"tabedit", "minlen":4, "flags":"BANG|FILE1|RANGE|ZEROR|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"tabfind", "minlen":4, "flags":"BANG|FILE1|RANGE|ZEROR|CMDARG|ARGOPT|NEEDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"tabfirst", "minlen":6, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"tabmove", "minlen":4, "flags":"RANGE|ZEROR|EXTRA|NOSPC|TRLBAR", "parser":"parse_cmd_common"}, {"name":"tablast", "minlen":4, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"tabnext", "minlen":4, "flags":"RANGE|ZEROR|EXTRA|NOSPC|TRLBAR", "parser":"parse_cmd_common"}, {"name":"tabnew", "minlen":6, "flags":"BANG|FILE1|RANGE|ZEROR|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"tabonly", "minlen":4, "flags":"BANG|RANGE|ZEROR|EXTRA|NOSPC|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tabprevious", "minlen":4, "flags":"RANGE|ZEROR|EXTRA|NOSPC|TRLBAR", "parser":"parse_cmd_common"}, {"name":"tabNext", "minlen":4, "flags":"RANGE|ZEROR|EXTRA|NOSPC|TRLBAR", "parser":"parse_cmd_common"}, {"name":"tabrewind", "minlen":4, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"tabs", "minlen":4, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tcd", "minlen":2, "flags":"BANG|FILE1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tchdir", "minlen":3, "flags":"BANG|FILE1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tcl", "minlen":3, "flags":"RANGE|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_tcl"}, {"name":"tcldo", "minlen":4, "flags":"RANGE|DFLALL|EXTRA|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"tclfile", "minlen":4, "flags":"RANGE|FILE1|NEEDARG|CMDWIN|LOCK_OK|RESTRICT", "parser":"parse_cmd_common"}, {"name":"tearoff", "minlen":2, "flags":"NEEDARG|EXTRA|TRLBAR|NOTRLCOM|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"terminal", "minlen":3, "flags":"RANGE|BANG|FILES|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tfirst", "minlen":2, "flags":"RANGE|BANG|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"throw", "minlen":2, "flags":"EXTRA|NEEDARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_throw"}, {"name":"tjump", "minlen":2, "flags":"BANG|TRLBAR|WORD1", "parser":"parse_cmd_common"}, {"name":"tlast", "minlen":2, "flags":"BANG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"tlmenu", "minlen":3, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tlnoremenu", "minlen":3, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tlunmenu", "minlen":3, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tmenu", "minlen":2, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tmap", "minlen":3, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tmapclear", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tnext", "minlen":2, "flags":"RANGE|BANG|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"tnoremap", "minlen":3, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"topleft", "minlen":2, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"tprevious", "minlen":2, "flags":"RANGE|BANG|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"trewind", "minlen":2, "flags":"RANGE|BANG|TRLBAR|ZEROR", "parser":"parse_cmd_common"}, {"name":"try", "minlen":3, "flags":"TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_try"}, {"name":"tselect", "minlen":2, "flags":"BANG|TRLBAR|WORD1", "parser":"parse_cmd_common"}, {"name":"tunmenu", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"tunmap", "minlen":5, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"type", "minlen":2, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"undo", "minlen":1, "flags":"RANGE|COUNT|ZEROR|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"undojoin", "minlen":5, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"undolist", "minlen":5, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"unabbreviate", "minlen":3, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"unhide", "minlen":3, "flags":"RANGE|COUNT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"unlet", "minlen":3, "flags":"BANG|EXTRA|NEEDARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_unlet"}, {"name":"unlockvar", "minlen":4, "flags":"BANG|EXTRA|NEEDARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_unlockvar"}, {"name":"unmap", "minlen":3, "flags":"BANG|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"unmenu", "minlen":4, "flags":"BANG|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"unsilent", "minlen":3, "flags":"NEEDARG|EXTRA|NOTRLCOM|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"update", "minlen":2, "flags":"RANGE|WHOLEFOLD|BANG|FILE1|ARGOPT|DFLALL|TRLBAR", "parser":"parse_cmd_common"}, {"name":"vglobal", "minlen":1, "flags":"RANGE|WHOLEFOLD|EXTRA|DFLALL|CMDWIN|LOCK_OK|NONWHITE_OK", "parser":"parse_cmd_common"}, {"name":"var", "minlen":2, "flags":"EXTRA|NOTRLCOM|EXPR_ARG|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"version", "minlen":2, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"verbose", "minlen":4, "flags":"NEEDARG|RANGE|EXTRA|NOTRLCOM|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"vertical", "minlen":4, "flags":"NEEDARG|EXTRA|NOTRLCOM", "parser":"parse_cmd_common"}, {"name":"visual", "minlen":2, "flags":"BANG|FILE1|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"view", "minlen":3, "flags":"BANG|FILE1|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"vimgrep", "minlen":3, "flags":"RANGE|BANG|NEEDARG|EXTRA|NOTRLCOM|TRLBAR|XFILE|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"vimgrepadd", "minlen":8, "flags":"RANGE|BANG|NEEDARG|EXTRA|NOTRLCOM|TRLBAR|XFILE|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"vim9cmd", "minlen":4, "flags":"NEEDARG|EXTRA|NOTRLCOM|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"vim9script", "minlen":5, "flags":"WORD1|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"viusage", "minlen":3, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"vmap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"vmapclear", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"vmenu", "minlen":3, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"vnoremap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"vnew", "minlen":3, "flags":"BANG|FILE1|RANGE|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"vnoremenu", "minlen":7, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"vsplit", "minlen":2, "flags":"BANG|FILE1|RANGE|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"vunmap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"vunmenu", "minlen":5, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"write", "minlen":1, "flags":"RANGE|WHOLEFOLD|BANG|FILE1|ARGOPT|DFLALL|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"wNext", "minlen":2, "flags":"RANGE|WHOLEFOLD|BANG|FILE1|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"wall", "minlen":2, "flags":"BANG|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"while", "minlen":2, "flags":"EXTRA|NOTRLCOM|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_while"}, {"name":"winsize", "minlen":2, "flags":"EXTRA|NEEDARG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"wincmd", "minlen":4, "flags":"NEEDARG|WORD1|RANGE|CMDWIN|LOCK_OK", "parser":"parse_wincmd"}, {"name":"windo", "minlen":4, "flags":"NEEDARG|EXTRA|NOTRLCOM|RANGE|DFLALL|EXPAND", "parser":"parse_cmd_common"}, {"name":"winpos", "minlen":4, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"wnext", "minlen":2, "flags":"RANGE|BANG|FILE1|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"wprevious", "minlen":2, "flags":"RANGE|BANG|FILE1|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"wq", "minlen":2, "flags":"RANGE|WHOLEFOLD|BANG|FILE1|ARGOPT|DFLALL|TRLBAR", "parser":"parse_cmd_common"}, {"name":"wqall", "minlen":3, "flags":"BANG|FILE1|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"wundo", "minlen":2, "flags":"BANG|NEEDARG|FILE1", "parser":"parse_cmd_common"}, {"name":"wviminfo", "minlen":2, "flags":"BANG|FILE1|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"xit", "minlen":1, "flags":"RANGE|WHOLEFOLD|BANG|FILE1|ARGOPT|DFLALL|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"xall", "minlen":2, "flags":"BANG|TRLBAR", "parser":"parse_cmd_common"}, {"name":"xmap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"xmapclear", "minlen":5, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"xmenu", "minlen":3, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"xnoremap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"xnoremenu", "minlen":7, "flags":"RANGE|ZEROR|EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"xrestore", "minlen":2, "flags":"EXTRA|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"xunmap", "minlen":2, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"xunmenu", "minlen":5, "flags":"EXTRA|TRLBAR|NOTRLCOM|CTRLV|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"yank", "minlen":1, "flags":"RANGE|WHOLEFOLD|REGSTR|COUNT|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"z", "minlen":1, "flags":"RANGE|WHOLEFOLD|BANG|EXTRA|FLAGS|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"!", "minlen":1, "flags":"RANGE|WHOLEFOLD|BANG|FILES|CMDWIN|LOCK_OK|NONWHITE_OK", "parser":"parse_cmd_common"}, {"name":"#", "minlen":1, "flags":"RANGE|WHOLEFOLD|COUNT|FLAGS|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"&", "minlen":1, "flags":"RANGE|WHOLEFOLD|EXTRA|CMDWIN|LOCK_OK|MODIFY|NONWHITE_OK", "parser":"parse_cmd_common"}, {"name":"*", "minlen":1, "flags":"RANGE|WHOLEFOLD|EXTRA|TRLBAR|CMDWIN|LOCK_OK|NONWHITE_OK", "parser":"parse_cmd_common"}, {"name":"<", "minlen":1, "flags":"RANGE|WHOLEFOLD|COUNT|FLAGS|TRLBAR|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"=", "minlen":1, "flags":"RANGE|TRLBAR|DFLALL|FLAGS|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":">", "minlen":1, "flags":"RANGE|WHOLEFOLD|COUNT|FLAGS|TRLBAR|CMDWIN|LOCK_OK|MODIFY", "parser":"parse_cmd_common"}, {"name":"@", "minlen":1, "flags":"RANGE|WHOLEFOLD|EXTRA|TRLBAR|CMDWIN|LOCK_OK|NONWHITE_OK", "parser":"parse_cmd_common"}, {"name":"{", "minlen":1, "flags":"TRLBAR|LOCK_OK|CMDWIN", "parser":"parse_cmd_common"}, {"name":"}", "minlen":1, "flags":"TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"~", "minlen":1, "flags":"RANGE|WHOLEFOLD|EXTRA|CMDWIN|LOCK_OK|MODIFY|NONWHITE_OK", "parser":"parse_cmd_common"}, {"name":"Next", "minlen":1, "flags":"EXTRA|RANGE|COUNT|BANG|CMDARG|ARGOPT|TRLBAR", "parser":"parse_cmd_common"}, {"name":"Print", "minlen":1, "flags":"RANGE|WHOLEFOLD|COUNT|FLAGS|TRLBAR|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"X", "minlen":1, "flags":"TRLBAR", "parser":"parse_cmd_common"}, {"name":"++", "minlen":1, "flags":"EXTRA|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}, {"name":"--", "minlen":1, "flags":"EXTRA|TRLBAR|SBOXOK|CMDWIN|LOCK_OK", "parser":"parse_cmd_common"}];
// To find new builtin_functions, run the below script.
// $ scripts/update_builtin_functions.sh /path/to/vim/src/evalfunc.c
VimLParser.prototype.builtin_functions = [{"name":"abs", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"acos", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"add", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"and", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"append", "min_argc":2, "max_argc":2, "argtype":"FEARG_2"}, {"name":"appendbufline", "min_argc":3, "max_argc":3, "argtype":"FEARG_3"}, {"name":"argc", "min_argc":0, "max_argc":1, "argtype":"0"}, {"name":"argidx", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"arglistid", "min_argc":0, "max_argc":2, "argtype":"0"}, {"name":"argv", "min_argc":0, "max_argc":2, "argtype":"0"}, {"name":"asin", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"assert_beeps", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"assert_equal", "min_argc":2, "max_argc":3, "argtype":"FEARG_2"}, {"name":"assert_equalfile", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"assert_exception", "min_argc":1, "max_argc":2, "argtype":"0"}, {"name":"assert_fails", "min_argc":1, "max_argc":5, "argtype":"FEARG_1"}, {"name":"assert_false", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"assert_inrange", "min_argc":3, "max_argc":4, "argtype":"FEARG_3"}, {"name":"assert_match", "min_argc":2, "max_argc":3, "argtype":"FEARG_2"}, {"name":"assert_nobeep", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"assert_notequal", "min_argc":2, "max_argc":3, "argtype":"FEARG_2"}, {"name":"assert_notmatch", "min_argc":2, "max_argc":3, "argtype":"FEARG_2"}, {"name":"assert_report", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"assert_true", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"atan", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"atan2", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"autocmd_add", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"autocmd_delete", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"autocmd_get", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"balloon_gettext", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"balloon_show", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"balloon_split", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"blob2list", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"browse", "min_argc":4, "max_argc":4, "argtype":"0"}, {"name":"browsedir", "min_argc":2, "max_argc":2, "argtype":"0"}, {"name":"bufadd", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"bufexists", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"buffer_exists", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"buffer_name", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"buffer_number", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"buflisted", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"bufload", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"bufloaded", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"bufname", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"bufnr", "min_argc":0, "max_argc":2, "argtype":"FEARG_1"}, {"name":"bufwinid", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"bufwinnr", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"byte2line", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"byteidx", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"byteidxcomp", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"call", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"ceil", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"ch_canread", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"ch_close", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"ch_close_in", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"ch_evalexpr", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"ch_evalraw", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"ch_getbufnr", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"ch_getjob", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"ch_info", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"ch_log", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"ch_logfile", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"ch_open", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"ch_read", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"ch_readblob", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"ch_readraw", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"ch_sendexpr", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"ch_sendraw", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"ch_setoptions", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"ch_status", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"changenr", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"char2nr", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"charclass", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"charcol", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"charidx", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"chdir", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"cindent", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"clearmatches", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"col", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"complete", "min_argc":2, "max_argc":2, "argtype":"FEARG_2"}, {"name":"complete_add", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"complete_check", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"complete_info", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"confirm", "min_argc":1, "max_argc":4, "argtype":"FEARG_1"}, {"name":"copy", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"cos", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"cosh", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"count", "min_argc":2, "max_argc":4, "argtype":"FEARG_1"}, {"name":"cscope_connection", "min_argc":0, "max_argc":3, "argtype":"0"}, {"name":"cursor", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"debugbreak", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"deepcopy", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"delete", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"deletebufline", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"did_filetype", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"diff_filler", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"diff_hlID", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"digraph_get", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"digraph_getlist", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"digraph_set", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"digraph_setlist", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"echoraw", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"empty", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"environ", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"escape", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"eval", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"eventhandler", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"executable", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"execute", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"exepath", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"exists", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"exists_compiled", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"exp", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"expand", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"expandcmd", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"extend", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"extendnew", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"feedkeys", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"file_readable", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"filereadable", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"filewritable", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"filter", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"finddir", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"findfile", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"flatten", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"flattennew", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"float2nr", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"floor", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"fmod", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"fnameescape", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"fnamemodify", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"foldclosed", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"foldclosedend", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"foldlevel", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"foldtext", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"foldtextresult", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"foreground", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"fullcommand", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"funcref", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"function", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"garbagecollect", "min_argc":0, "max_argc":1, "argtype":"0"}, {"name":"get", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"getbufinfo", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getbufline", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"getbufvar", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"getchangelist", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getchar", "min_argc":0, "max_argc":1, "argtype":"0"}, {"name":"getcharmod", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"getcharpos", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getcharsearch", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"getcharstr", "min_argc":0, "max_argc":1, "argtype":"0"}, {"name":"getcmdcompltype", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"getcmdline", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"getcmdpos", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"getcmdscreenpos", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"getcmdtype", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"getcmdwintype", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"getcompletion", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"getcurpos", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getcursorcharpos", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getcwd", "min_argc":0, "max_argc":2, "argtype":"FEARG_1"}, {"name":"getenv", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getfontname", "min_argc":0, "max_argc":1, "argtype":"0"}, {"name":"getfperm", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getfsize", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getftime", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getftype", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getimstatus", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"getjumplist", "min_argc":0, "max_argc":2, "argtype":"FEARG_1"}, {"name":"getline", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"getloclist", "min_argc":1, "max_argc":2, "argtype":"0"}, {"name":"getmarklist", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getmatches", "min_argc":0, "max_argc":1, "argtype":"0"}, {"name":"getmousepos", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"getpid", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"getpos", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getqflist", "min_argc":0, "max_argc":1, "argtype":"0"}, {"name":"getreg", "min_argc":0, "max_argc":3, "argtype":"FEARG_1"}, {"name":"getreginfo", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getregtype", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getscriptinfo", "min_argc":0, "max_argc":1, "argtype":"0"}, {"name":"gettabinfo", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"gettabvar", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"gettabwinvar", "min_argc":3, "max_argc":4, "argtype":"FEARG_1"}, {"name":"gettagstack", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"gettext", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getwininfo", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getwinpos", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"getwinposx", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"getwinposy", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"getwinvar", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"glob", "min_argc":1, "max_argc":4, "argtype":"FEARG_1"}, {"name":"glob2regpat", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"globpath", "min_argc":2, "max_argc":5, "argtype":"FEARG_2"}, {"name":"has", "min_argc":1, "max_argc":2, "argtype":"0"}, {"name":"has_key", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"haslocaldir", "min_argc":0, "max_argc":2, "argtype":"FEARG_1"}, {"name":"hasmapto", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"highlightID", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"highlight_exists", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"histadd", "min_argc":2, "max_argc":2, "argtype":"FEARG_2"}, {"name":"histdel", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"histget", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"histnr", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"hlID", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"hlexists", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"hlget", "min_argc":0, "max_argc":2, "argtype":"FEARG_1"}, {"name":"hlset", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"hostname", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"iconv", "min_argc":3, "max_argc":3, "argtype":"FEARG_1"}, {"name":"indent", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"index", "min_argc":2, "max_argc":4, "argtype":"FEARG_1"}, {"name":"indexof", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"input", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"inputdialog", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"inputlist", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"inputrestore", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"inputsave", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"inputsecret", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"insert", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"interrupt", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"invert", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"isabsolutepath", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"isdirectory", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"isinf", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"islocked", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"isnan", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"items", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"job_getchannel", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"job_info", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"job_setoptions", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"job_start", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"job_status", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"job_stop", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"join", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"js_decode", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"js_encode", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"json_decode", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"json_encode", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"keys", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"last_buffer_nr", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"len", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"libcall", "min_argc":3, "max_argc":3, "argtype":"FEARG_3"}, {"name":"libcallnr", "min_argc":3, "max_argc":3, "argtype":"FEARG_3"}, {"name":"line", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"line2byte", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"lispindent", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"list2blob", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"list2str", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"listener_add", "min_argc":1, "max_argc":2, "argtype":"FEARG_2"}, {"name":"listener_flush", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"listener_remove", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"localtime", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"log", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"log10", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"luaeval", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"map", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"maparg", "min_argc":1, "max_argc":4, "argtype":"FEARG_1"}, {"name":"mapcheck", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"maplist", "min_argc":0, "max_argc":1, "argtype":"0"}, {"name":"mapnew", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"mapset", "min_argc":3, "max_argc":3, "argtype":"FEARG_1"}, {"name":"match", "min_argc":2, "max_argc":4, "argtype":"FEARG_1"}, {"name":"matchadd", "min_argc":2, "max_argc":5, "argtype":"FEARG_1"}, {"name":"matchaddpos", "min_argc":2, "max_argc":5, "argtype":"FEARG_1"}, {"name":"matcharg", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"matchdelete", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"matchend", "min_argc":2, "max_argc":4, "argtype":"FEARG_1"}, {"name":"matchfuzzy", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"matchfuzzypos", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"matchlist", "min_argc":2, "max_argc":4, "argtype":"FEARG_1"}, {"name":"matchstr", "min_argc":2, "max_argc":4, "argtype":"FEARG_1"}, {"name":"matchstrpos", "min_argc":2, "max_argc":4, "argtype":"FEARG_1"}, {"name":"max", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"menu_info", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"min", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"mkdir", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"mode", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"mzeval", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"nextnonblank", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"nr2char", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"or", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"pathshorten", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"perleval", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"popup_atcursor", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"popup_beval", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"popup_clear", "min_argc":0, "max_argc":1, "argtype":"0"}, {"name":"popup_close", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"popup_create", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"popup_dialog", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"popup_filter_menu", "min_argc":2, "max_argc":2, "argtype":"0"}, {"name":"popup_filter_yesno", "min_argc":2, "max_argc":2, "argtype":"0"}, {"name":"popup_findinfo", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"popup_findpreview", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"popup_getoptions", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"popup_getpos", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"popup_hide", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"popup_list", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"popup_locate", "min_argc":2, "max_argc":2, "argtype":"0"}, {"name":"popup_menu", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"popup_move", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"popup_notification", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"popup_setoptions", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"popup_settext", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"popup_show", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"pow", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"prevnonblank", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"printf", "min_argc":1, "max_argc":19, "argtype":"FEARG_2"}, {"name":"prompt_getprompt", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"prompt_setcallback", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"prompt_setinterrupt", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"prompt_setprompt", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"prop_add", "min_argc":3, "max_argc":3, "argtype":"FEARG_1"}, {"name":"prop_add_list", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"prop_clear", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"prop_find", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"prop_list", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"prop_remove", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"prop_type_add", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"prop_type_change", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"prop_type_delete", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"prop_type_get", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"prop_type_list", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"pum_getpos", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"pumvisible", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"py3eval", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"pyeval", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"pyxeval", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"rand", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"range", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"readblob", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"readdir", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"readdirex", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"readfile", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"reduce", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"reg_executing", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"reg_recording", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"reltime", "min_argc":0, "max_argc":2, "argtype":"FEARG_1"}, {"name":"reltimefloat", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"reltimestr", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"remote_expr", "min_argc":2, "max_argc":4, "argtype":"FEARG_1"}, {"name":"remote_foreground", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"remote_peek", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"remote_read", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"remote_send", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"remote_startserver", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"remove", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"rename", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"repeat", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"resolve", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"reverse", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"round", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"rubyeval", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"screenattr", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"screenchar", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"screenchars", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"screencol", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"screenpos", "min_argc":3, "max_argc":3, "argtype":"FEARG_1"}, {"name":"screenrow", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"screenstring", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"search", "min_argc":1, "max_argc":5, "argtype":"FEARG_1"}, {"name":"searchcount", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"searchdecl", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"searchpair", "min_argc":3, "max_argc":7, "argtype":"0"}, {"name":"searchpairpos", "min_argc":3, "max_argc":7, "argtype":"0"}, {"name":"searchpos", "min_argc":1, "max_argc":5, "argtype":"FEARG_1"}, {"name":"server2client", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"serverlist", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"setbufline", "min_argc":3, "max_argc":3, "argtype":"FEARG_3"}, {"name":"setbufvar", "min_argc":3, "max_argc":3, "argtype":"FEARG_3"}, {"name":"setcellwidths", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"setcharpos", "min_argc":2, "max_argc":2, "argtype":"FEARG_2"}, {"name":"setcharsearch", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"setcmdline", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"setcmdpos", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"setcursorcharpos", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"setenv", "min_argc":2, "max_argc":2, "argtype":"FEARG_2"}, {"name":"setfperm", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"setline", "min_argc":2, "max_argc":2, "argtype":"FEARG_2"}, {"name":"setloclist", "min_argc":2, "max_argc":4, "argtype":"FEARG_2"}, {"name":"setmatches", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"setpos", "min_argc":2, "max_argc":2, "argtype":"FEARG_2"}, {"name":"setqflist", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"setreg", "min_argc":2, "max_argc":3, "argtype":"FEARG_2"}, {"name":"settabvar", "min_argc":3, "max_argc":3, "argtype":"FEARG_3"}, {"name":"settabwinvar", "min_argc":4, "max_argc":4, "argtype":"FEARG_4"}, {"name":"settagstack", "min_argc":2, "max_argc":3, "argtype":"FEARG_2"}, {"name":"setwinvar", "min_argc":3, "max_argc":3, "argtype":"FEARG_3"}, {"name":"sha256", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"shellescape", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"shiftwidth", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"sign_define", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"sign_getdefined", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"sign_getplaced", "min_argc":0, "max_argc":2, "argtype":"FEARG_1"}, {"name":"sign_jump", "min_argc":3, "max_argc":3, "argtype":"FEARG_1"}, {"name":"sign_place", "min_argc":4, "max_argc":5, "argtype":"FEARG_1"}, {"name":"sign_placelist", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"sign_undefine", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"sign_unplace", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"sign_unplacelist", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"simplify", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"sin", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"sinh", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"slice", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"sort", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"sound_clear", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"sound_playevent", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"sound_playfile", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"sound_stop", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"soundfold", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"spellbadword", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"spellsuggest", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"split", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"sqrt", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"srand", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"state", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"str2float", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"str2list", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"str2nr", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"strcharlen", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"strcharpart", "min_argc":2, "max_argc":4, "argtype":"FEARG_1"}, {"name":"strchars", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"strdisplaywidth", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"strftime", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"strgetchar", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"stridx", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"string", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"strlen", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"strpart", "min_argc":2, "max_argc":4, "argtype":"FEARG_1"}, {"name":"strptime", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"strridx", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"strtrans", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"strwidth", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"submatch", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"substitute", "min_argc":4, "max_argc":4, "argtype":"FEARG_1"}, {"name":"swapinfo", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"swapname", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"synID", "min_argc":3, "max_argc":3, "argtype":"0"}, {"name":"synIDattr", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"synIDtrans", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"synconcealed", "min_argc":2, "max_argc":2, "argtype":"0"}, {"name":"synstack", "min_argc":2, "max_argc":2, "argtype":"0"}, {"name":"system", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"systemlist", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"tabpagebuflist", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"tabpagenr", "min_argc":0, "max_argc":1, "argtype":"0"}, {"name":"tabpagewinnr", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"tagfiles", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"taglist", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"tan", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"tanh", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"tempname", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"term_dumpdiff", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"term_dumpload", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"term_dumpwrite", "min_argc":2, "max_argc":3, "argtype":"FEARG_2"}, {"name":"term_getaltscreen", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"term_getansicolors", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"term_getattr", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"term_getcursor", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"term_getjob", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"term_getline", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"term_getscrolled", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"term_getsize", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"term_getstatus", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"term_gettitle", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"term_gettty", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"term_list", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"term_scrape", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"term_sendkeys", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"term_setansicolors", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"term_setapi", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"term_setkill", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"term_setrestore", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"term_setsize", "min_argc":3, "max_argc":3, "argtype":"FEARG_1"}, {"name":"term_start", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"term_wait", "min_argc":1, "max_argc":2, "argtype":"FEARG_1"}, {"name":"terminalprops", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"test_alloc_fail", "min_argc":3, "max_argc":3, "argtype":"FEARG_1"}, {"name":"test_autochdir", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"test_feedinput", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"test_garbagecollect_now", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"test_garbagecollect_soon", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"test_getvalue", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"test_gui_drop_files", "min_argc":4, "max_argc":4, "argtype":"0"}, {"name":"test_gui_event", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"test_gui_mouse_event", "min_argc":5, "max_argc":5, "argtype":"0"}, {"name":"test_ignore_error", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"test_null_blob", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"test_null_channel", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"test_null_dict", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"test_null_function", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"test_null_job", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"test_null_list", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"test_null_partial", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"test_null_string", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"test_option_not_set", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"test_override", "min_argc":2, "max_argc":2, "argtype":"FEARG_2"}, {"name":"test_refcount", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"test_scrollbar", "min_argc":3, "max_argc":3, "argtype":"FEARG_2"}, {"name":"test_setmouse", "min_argc":2, "max_argc":2, "argtype":"0"}, {"name":"test_settime", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"test_srand_seed", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"test_unknown", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"test_void", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"timer_info", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"timer_pause", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"timer_start", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"timer_stop", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"timer_stopall", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"tolower", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"toupper", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"tr", "min_argc":3, "max_argc":3, "argtype":"FEARG_1"}, {"name":"trim", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"trunc", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"type", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"typename", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"undofile", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"undotree", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"uniq", "min_argc":1, "max_argc":3, "argtype":"FEARG_1"}, {"name":"values", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"virtcol", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"virtcol2col", "min_argc":3, "max_argc":3, "argtype":"FEARG_1"}, {"name":"visualmode", "min_argc":0, "max_argc":1, "argtype":"0"}, {"name":"wildmenumode", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"win_execute", "min_argc":2, "max_argc":3, "argtype":"FEARG_2"}, {"name":"win_findbuf", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"win_getid", "min_argc":0, "max_argc":2, "argtype":"FEARG_1"}, {"name":"win_gettype", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"win_gotoid", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"win_id2tabwin", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"win_id2win", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"win_move_separator", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"win_move_statusline", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}, {"name":"win_screenpos", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"win_splitmove", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"winbufnr", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"wincol", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"windowsversion", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"winheight", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"winlayout", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"winline", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"winnr", "min_argc":0, "max_argc":1, "argtype":"FEARG_1"}, {"name":"winrestcmd", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"winrestview", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"winsaveview", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"winwidth", "min_argc":1, "max_argc":1, "argtype":"FEARG_1"}, {"name":"wordcount", "min_argc":0, "max_argc":0, "argtype":"0"}, {"name":"writefile", "min_argc":2, "max_argc":3, "argtype":"FEARG_1"}, {"name":"xor", "min_argc":2, "max_argc":2, "argtype":"FEARG_1"}];
function ExprTokenizer() { this.__init__.apply(this, arguments); }
ExprTokenizer.prototype.__init__ = function(reader) {
    this.reader = reader;
    this.cache = {};
}

ExprTokenizer.prototype.token = function(type, value, pos) {
    return {"type":type, "value":value, "pos":pos};
}

ExprTokenizer.prototype.peek = function() {
    var pos = this.reader.tell();
    var r = this.get();
    this.reader.seek_set(pos);
    return r;
}

ExprTokenizer.prototype.get = function() {
    // FIXME: remove dirty hack
    if (viml_has_key(this.cache, this.reader.tell())) {
        var x = this.cache[this.reader.tell()];
        this.reader.seek_set(x[0]);
        return x[1];
    }
    var pos = this.reader.tell();
    this.reader.skip_white();
    var r = this.get2();
    this.cache[pos] = [this.reader.tell(), r];
    return r;
}

ExprTokenizer.prototype.get2 = function() {
    var r = this.reader;
    var pos = r.getpos();
    var c = r.peek();
    if (c == "<EOF>") {
        return this.token(TOKEN_EOF, c, pos);
    }
    else if (c == "<EOL>") {
        r.seek_cur(1);
        return this.token(TOKEN_EOL, c, pos);
    }
    else if (iswhite(c)) {
        var s = r.read_white();
        return this.token(TOKEN_SPACE, s, pos);
    }
    else if (c == "0" && (r.p(1) == "X" || r.p(1) == "x") && isxdigit(r.p(2))) {
        var s = r.getn(3);
        s += r.read_xdigit();
        return this.token(TOKEN_NUMBER, s, pos);
    }
    else if (c == "0" && (r.p(1) == "B" || r.p(1) == "b") && (r.p(2) == "0" || r.p(2) == "1")) {
        var s = r.getn(3);
        s += r.read_bdigit();
        return this.token(TOKEN_NUMBER, s, pos);
    }
    else if (c == "0" && (r.p(1) == "Z" || r.p(1) == "z") && r.p(2) != ".") {
        var s = r.getn(2);
        s += r.read_blob();
        return this.token(TOKEN_BLOB, s, pos);
    }
    else if (isdigit(c)) {
        var s = r.read_digit();
        if (r.p(0) == "." && isdigit(r.p(1))) {
            s += r.getn(1);
            s += r.read_digit();
            if ((r.p(0) == "E" || r.p(0) == "e") && (isdigit(r.p(1)) || (r.p(1) == "-" || r.p(1) == "+") && isdigit(r.p(2)))) {
                s += r.getn(2);
                s += r.read_digit();
            }
        }
        return this.token(TOKEN_NUMBER, s, pos);
    }
    else if (c == "i" && r.p(1) == "s" && !isidc(r.p(2))) {
        if (r.p(2) == "?") {
            r.seek_cur(3);
            return this.token(TOKEN_ISCI, "is?", pos);
        }
        else if (r.p(2) == "#") {
            r.seek_cur(3);
            return this.token(TOKEN_ISCS, "is#", pos);
        }
        else {
            r.seek_cur(2);
            return this.token(TOKEN_IS, "is", pos);
        }
    }
    else if (c == "i" && r.p(1) == "s" && r.p(2) == "n" && r.p(3) == "o" && r.p(4) == "t" && !isidc(r.p(5))) {
        if (r.p(5) == "?") {
            r.seek_cur(6);
            return this.token(TOKEN_ISNOTCI, "isnot?", pos);
        }
        else if (r.p(5) == "#") {
            r.seek_cur(6);
            return this.token(TOKEN_ISNOTCS, "isnot#", pos);
        }
        else {
            r.seek_cur(5);
            return this.token(TOKEN_ISNOT, "isnot", pos);
        }
    }
    else if (isnamec1(c)) {
        var s = r.read_name();
        return this.token(TOKEN_IDENTIFIER, s, pos);
    }
    else if (c == "|" && r.p(1) == "|") {
        r.seek_cur(2);
        return this.token(TOKEN_OROR, "||", pos);
    }
    else if (c == "&" && r.p(1) == "&") {
        r.seek_cur(2);
        return this.token(TOKEN_ANDAND, "&&", pos);
    }
    else if (c == "=" && r.p(1) == "=") {
        if (r.p(2) == "?") {
            r.seek_cur(3);
            return this.token(TOKEN_EQEQCI, "==?", pos);
        }
        else if (r.p(2) == "#") {
            r.seek_cur(3);
            return this.token(TOKEN_EQEQCS, "==#", pos);
        }
        else {
            r.seek_cur(2);
            return this.token(TOKEN_EQEQ, "==", pos);
        }
    }
    else if (c == "!" && r.p(1) == "=") {
        if (r.p(2) == "?") {
            r.seek_cur(3);
            return this.token(TOKEN_NEQCI, "!=?", pos);
        }
        else if (r.p(2) == "#") {
            r.seek_cur(3);
            return this.token(TOKEN_NEQCS, "!=#", pos);
        }
        else {
            r.seek_cur(2);
            return this.token(TOKEN_NEQ, "!=", pos);
        }
    }
    else if (c == ">" && r.p(1) == "=") {
        if (r.p(2) == "?") {
            r.seek_cur(3);
            return this.token(TOKEN_GTEQCI, ">=?", pos);
        }
        else if (r.p(2) == "#") {
            r.seek_cur(3);
            return this.token(TOKEN_GTEQCS, ">=#", pos);
        }
        else {
            r.seek_cur(2);
            return this.token(TOKEN_GTEQ, ">=", pos);
        }
    }
    else if (c == "<" && r.p(1) == "=") {
        if (r.p(2) == "?") {
            r.seek_cur(3);
            return this.token(TOKEN_LTEQCI, "<=?", pos);
        }
        else if (r.p(2) == "#") {
            r.seek_cur(3);
            return this.token(TOKEN_LTEQCS, "<=#", pos);
        }
        else {
            r.seek_cur(2);
            return this.token(TOKEN_LTEQ, "<=", pos);
        }
    }
    else if (c == "=" && r.p(1) == "~") {
        if (r.p(2) == "?") {
            r.seek_cur(3);
            return this.token(TOKEN_MATCHCI, "=~?", pos);
        }
        else if (r.p(2) == "#") {
            r.seek_cur(3);
            return this.token(TOKEN_MATCHCS, "=~#", pos);
        }
        else {
            r.seek_cur(2);
            return this.token(TOKEN_MATCH, "=~", pos);
        }
    }
    else if (c == "!" && r.p(1) == "~") {
        if (r.p(2) == "?") {
            r.seek_cur(3);
            return this.token(TOKEN_NOMATCHCI, "!~?", pos);
        }
        else if (r.p(2) == "#") {
            r.seek_cur(3);
            return this.token(TOKEN_NOMATCHCS, "!~#", pos);
        }
        else {
            r.seek_cur(2);
            return this.token(TOKEN_NOMATCH, "!~", pos);
        }
    }
    else if (c == ">") {
        if (r.p(1) == "?") {
            r.seek_cur(2);
            return this.token(TOKEN_GTCI, ">?", pos);
        }
        else if (r.p(1) == "#") {
            r.seek_cur(2);
            return this.token(TOKEN_GTCS, ">#", pos);
        }
        else {
            r.seek_cur(1);
            return this.token(TOKEN_GT, ">", pos);
        }
    }
    else if (c == "<") {
        if (r.p(1) == "?") {
            r.seek_cur(2);
            return this.token(TOKEN_LTCI, "<?", pos);
        }
        else if (r.p(1) == "#") {
            r.seek_cur(2);
            return this.token(TOKEN_LTCS, "<#", pos);
        }
        else {
            r.seek_cur(1);
            return this.token(TOKEN_LT, "<", pos);
        }
    }
    else if (c == "+") {
        r.seek_cur(1);
        return this.token(TOKEN_PLUS, "+", pos);
    }
    else if (c == "-") {
        if (r.p(1) == ">") {
            r.seek_cur(2);
            return this.token(TOKEN_ARROW, "->", pos);
        }
        else {
            r.seek_cur(1);
            return this.token(TOKEN_MINUS, "-", pos);
        }
    }
    else if (c == ".") {
        if (r.p(1) == "." && r.p(2) == ".") {
            r.seek_cur(3);
            return this.token(TOKEN_DOTDOTDOT, "...", pos);
        }
        else if (r.p(1) == ".") {
            r.seek_cur(2);
            return this.token(TOKEN_DOTDOT, "..", pos);
            // TODO check scriptversion?
        }
        else {
            r.seek_cur(1);
            return this.token(TOKEN_DOT, ".", pos);
            // TODO check scriptversion?
        }
    }
    else if (c == "*") {
        r.seek_cur(1);
        return this.token(TOKEN_STAR, "*", pos);
    }
    else if (c == "/") {
        r.seek_cur(1);
        return this.token(TOKEN_SLASH, "/", pos);
    }
    else if (c == "%") {
        r.seek_cur(1);
        return this.token(TOKEN_PERCENT, "%", pos);
    }
    else if (c == "!") {
        r.seek_cur(1);
        return this.token(TOKEN_NOT, "!", pos);
    }
    else if (c == "?") {
        r.seek_cur(1);
        return this.token(TOKEN_QUESTION, "?", pos);
    }
    else if (c == ":") {
        r.seek_cur(1);
        return this.token(TOKEN_COLON, ":", pos);
    }
    else if (c == "#") {
        if (r.p(1) == "{") {
            r.seek_cur(2);
            return this.token(TOKEN_LITCOPEN, "#{", pos);
        }
        else {
            r.seek_cur(1);
            return this.token(TOKEN_SHARP, "#", pos);
        }
    }
    else if (c == "(") {
        r.seek_cur(1);
        return this.token(TOKEN_POPEN, "(", pos);
    }
    else if (c == ")") {
        r.seek_cur(1);
        return this.token(TOKEN_PCLOSE, ")", pos);
    }
    else if (c == "[") {
        r.seek_cur(1);
        return this.token(TOKEN_SQOPEN, "[", pos);
    }
    else if (c == "]") {
        r.seek_cur(1);
        return this.token(TOKEN_SQCLOSE, "]", pos);
    }
    else if (c == "{") {
        r.seek_cur(1);
        return this.token(TOKEN_COPEN, "{", pos);
    }
    else if (c == "}") {
        r.seek_cur(1);
        return this.token(TOKEN_CCLOSE, "}", pos);
    }
    else if (c == ",") {
        r.seek_cur(1);
        return this.token(TOKEN_COMMA, ",", pos);
    }
    else if (c == "'") {
        r.seek_cur(1);
        return this.token(TOKEN_SQUOTE, "'", pos);
    }
    else if (c == "\"") {
        r.seek_cur(1);
        return this.token(TOKEN_DQUOTE, "\"", pos);
    }
    else if (c == "$") {
        var s = r.getn(1);
        s += r.read_word();
        return this.token(TOKEN_ENV, s, pos);
    }
    else if (c == "@") {
        // @<EOL> is treated as @"
        return this.token(TOKEN_REG, r.getn(2), pos);
    }
    else if (c == "&") {
        var s = "";
        if ((r.p(1) == "g" || r.p(1) == "l") && r.p(2) == ":") {
            var s = r.getn(3) + r.read_word();
        }
        else {
            var s = r.getn(1) + r.read_word();
        }
        return this.token(TOKEN_OPTION, s, pos);
    }
    else if (c == "=") {
        r.seek_cur(1);
        return this.token(TOKEN_EQ, "=", pos);
    }
    else if (c == "|") {
        r.seek_cur(1);
        return this.token(TOKEN_OR, "|", pos);
    }
    else if (c == ";") {
        r.seek_cur(1);
        return this.token(TOKEN_SEMICOLON, ";", pos);
    }
    else if (c == "`") {
        r.seek_cur(1);
        return this.token(TOKEN_BACKTICK, "`", pos);
    }
    else {
        throw Err(viml_printf("unexpected character: %s", c), this.reader.getpos());
    }
}

ExprTokenizer.prototype.get_sstring = function() {
    this.reader.skip_white();
    var c = this.reader.p(0);
    if (c != "'") {
        throw Err(viml_printf("unexpected character: %s", c), this.reader.getpos());
    }
    this.reader.seek_cur(1);
    var s = "";
    while (TRUE) {
        var c = this.reader.p(0);
        if (c == "<EOF>" || c == "<EOL>") {
            throw Err("unexpected EOL", this.reader.getpos());
        }
        else if (c == "'") {
            this.reader.seek_cur(1);
            if (this.reader.p(0) == "'") {
                this.reader.seek_cur(1);
                s += "''";
            }
            else {
                break;
            }
        }
        else {
            this.reader.seek_cur(1);
            s += c;
        }
    }
    return s;
}

ExprTokenizer.prototype.get_dstring = function() {
    this.reader.skip_white();
    var c = this.reader.p(0);
    if (c != "\"") {
        throw Err(viml_printf("unexpected character: %s", c), this.reader.getpos());
    }
    this.reader.seek_cur(1);
    var s = "";
    while (TRUE) {
        var c = this.reader.p(0);
        if (c == "<EOF>" || c == "<EOL>") {
            throw Err("unexpectd EOL", this.reader.getpos());
        }
        else if (c == "\"") {
            this.reader.seek_cur(1);
            break;
        }
        else if (c == "\\") {
            this.reader.seek_cur(1);
            s += c;
            var c = this.reader.p(0);
            if (c == "<EOF>" || c == "<EOL>") {
                throw Err("ExprTokenizer: unexpected EOL", this.reader.getpos());
            }
            this.reader.seek_cur(1);
            s += c;
        }
        else {
            this.reader.seek_cur(1);
            s += c;
        }
    }
    return s;
}

ExprTokenizer.prototype.parse_dict_literal_key = function() {
    this.reader.skip_white();
    var c = this.reader.peek();
    if (!isalnum(c) && c != "_" && c != "-") {
        throw Err(viml_printf("unexpected character: %s", c), this.reader.getpos());
    }
    var node = Node(NODE_STRING);
    var s = c;
    this.reader.seek_cur(1);
    node.pos = this.reader.getpos();
    while (TRUE) {
        var c = this.reader.p(0);
        if (c == "<EOF>" || c == "<EOL>") {
            throw Err("unexpectd EOL", this.reader.getpos());
        }
        if (!isalnum(c) && c != "_" && c != "-") {
            break;
        }
        this.reader.seek_cur(1);
        s += c;
    }
    node.value = "'" + s + "'";
    return node;
}

function ExprParser() { this.__init__.apply(this, arguments); }
ExprParser.prototype.__init__ = function(reader) {
    this.reader = reader;
    this.tokenizer = new ExprTokenizer(reader);
}

ExprParser.prototype.parse = function() {
    return this.parse_expr1();
}

// expr1: expr2 ? expr1 : expr1
ExprParser.prototype.parse_expr1 = function() {
    var left = this.parse_expr2();
    var pos = this.reader.tell();
    var token = this.tokenizer.get();
    if (token.type == TOKEN_QUESTION) {
        var node = Node(NODE_TERNARY);
        node.pos = token.pos;
        node.cond = left;
        node.left = this.parse_expr1();
        var token = this.tokenizer.get();
        if (token.type != TOKEN_COLON) {
            throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
        }
        node.right = this.parse_expr1();
        var left = node;
    }
    else {
        this.reader.seek_set(pos);
    }
    return left;
}

// expr2: expr3 || expr3 ..
ExprParser.prototype.parse_expr2 = function() {
    var left = this.parse_expr3();
    while (TRUE) {
        var pos = this.reader.tell();
        var token = this.tokenizer.get();
        if (token.type == TOKEN_OROR) {
            var node = Node(NODE_OR);
            node.pos = token.pos;
            node.left = left;
            node.right = this.parse_expr3();
            var left = node;
        }
        else {
            this.reader.seek_set(pos);
            break;
        }
    }
    return left;
}

// expr3: expr4 && expr4
ExprParser.prototype.parse_expr3 = function() {
    var left = this.parse_expr4();
    while (TRUE) {
        var pos = this.reader.tell();
        var token = this.tokenizer.get();
        if (token.type == TOKEN_ANDAND) {
            var node = Node(NODE_AND);
            node.pos = token.pos;
            node.left = left;
            node.right = this.parse_expr4();
            var left = node;
        }
        else {
            this.reader.seek_set(pos);
            break;
        }
    }
    return left;
}

// expr4: expr5 == expr5
//        expr5 != expr5
//        expr5 >  expr5
//        expr5 >= expr5
//        expr5 <  expr5
//        expr5 <= expr5
//        expr5 =~ expr5
//        expr5 !~ expr5
//
//        expr5 ==? expr5
//        expr5 ==# expr5
//        etc.
//
//        expr5 is expr5
//        expr5 isnot expr5
ExprParser.prototype.parse_expr4 = function() {
    var left = this.parse_expr5();
    var pos = this.reader.tell();
    var token = this.tokenizer.get();
    if (token.type == TOKEN_EQEQ) {
        var node = Node(NODE_EQUAL);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_EQEQCI) {
        var node = Node(NODE_EQUALCI);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_EQEQCS) {
        var node = Node(NODE_EQUALCS);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_NEQ) {
        var node = Node(NODE_NEQUAL);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_NEQCI) {
        var node = Node(NODE_NEQUALCI);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_NEQCS) {
        var node = Node(NODE_NEQUALCS);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_GT) {
        var node = Node(NODE_GREATER);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_GTCI) {
        var node = Node(NODE_GREATERCI);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_GTCS) {
        var node = Node(NODE_GREATERCS);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_GTEQ) {
        var node = Node(NODE_GEQUAL);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_GTEQCI) {
        var node = Node(NODE_GEQUALCI);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_GTEQCS) {
        var node = Node(NODE_GEQUALCS);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_LT) {
        var node = Node(NODE_SMALLER);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_LTCI) {
        var node = Node(NODE_SMALLERCI);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_LTCS) {
        var node = Node(NODE_SMALLERCS);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_LTEQ) {
        var node = Node(NODE_SEQUAL);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_LTEQCI) {
        var node = Node(NODE_SEQUALCI);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_LTEQCS) {
        var node = Node(NODE_SEQUALCS);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_MATCH) {
        var node = Node(NODE_MATCH);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_MATCHCI) {
        var node = Node(NODE_MATCHCI);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_MATCHCS) {
        var node = Node(NODE_MATCHCS);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_NOMATCH) {
        var node = Node(NODE_NOMATCH);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_NOMATCHCI) {
        var node = Node(NODE_NOMATCHCI);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_NOMATCHCS) {
        var node = Node(NODE_NOMATCHCS);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_IS) {
        var node = Node(NODE_IS);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_ISCI) {
        var node = Node(NODE_ISCI);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_ISCS) {
        var node = Node(NODE_ISCS);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_ISNOT) {
        var node = Node(NODE_ISNOT);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_ISNOTCI) {
        var node = Node(NODE_ISNOTCI);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else if (token.type == TOKEN_ISNOTCS) {
        var node = Node(NODE_ISNOTCS);
        node.pos = token.pos;
        node.left = left;
        node.right = this.parse_expr5();
        var left = node;
    }
    else {
        this.reader.seek_set(pos);
    }
    return left;
}

// expr5: expr6 + expr6 ..
//        expr6 - expr6 ..
//        expr6 . expr6 ..
//        expr6 .. expr6 ..
ExprParser.prototype.parse_expr5 = function() {
    var left = this.parse_expr6();
    while (TRUE) {
        var pos = this.reader.tell();
        var token = this.tokenizer.get();
        if (token.type == TOKEN_PLUS) {
            var node = Node(NODE_ADD);
            node.pos = token.pos;
            node.left = left;
            node.right = this.parse_expr6();
            var left = node;
        }
        else if (token.type == TOKEN_MINUS) {
            var node = Node(NODE_SUBTRACT);
            node.pos = token.pos;
            node.left = left;
            node.right = this.parse_expr6();
            var left = node;
        }
        else if (token.type == TOKEN_DOTDOT) {
            // TODO check scriptversion?
            var node = Node(NODE_CONCAT);
            node.pos = token.pos;
            node.left = left;
            node.right = this.parse_expr6();
            var left = node;
        }
        else if (token.type == TOKEN_DOT) {
            // TODO check scriptversion?
            var node = Node(NODE_CONCAT);
            node.pos = token.pos;
            node.left = left;
            node.right = this.parse_expr6();
            var left = node;
        }
        else {
            this.reader.seek_set(pos);
            break;
        }
    }
    return left;
}

// expr6: expr7 * expr7 ..
//        expr7 / expr7 ..
//        expr7 % expr7 ..
ExprParser.prototype.parse_expr6 = function() {
    var left = this.parse_expr7();
    while (TRUE) {
        var pos = this.reader.tell();
        var token = this.tokenizer.get();
        if (token.type == TOKEN_STAR) {
            var node = Node(NODE_MULTIPLY);
            node.pos = token.pos;
            node.left = left;
            node.right = this.parse_expr7();
            var left = node;
        }
        else if (token.type == TOKEN_SLASH) {
            var node = Node(NODE_DIVIDE);
            node.pos = token.pos;
            node.left = left;
            node.right = this.parse_expr7();
            var left = node;
        }
        else if (token.type == TOKEN_PERCENT) {
            var node = Node(NODE_REMAINDER);
            node.pos = token.pos;
            node.left = left;
            node.right = this.parse_expr7();
            var left = node;
        }
        else {
            this.reader.seek_set(pos);
            break;
        }
    }
    return left;
}

// expr7: ! expr7
//        - expr7
//        + expr7
ExprParser.prototype.parse_expr7 = function() {
    var pos = this.reader.tell();
    var token = this.tokenizer.get();
    if (token.type == TOKEN_NOT) {
        var node = Node(NODE_NOT);
        node.pos = token.pos;
        node.left = this.parse_expr7();
        return node;
    }
    else if (token.type == TOKEN_MINUS) {
        var node = Node(NODE_MINUS);
        node.pos = token.pos;
        node.left = this.parse_expr7();
        return node;
    }
    else if (token.type == TOKEN_PLUS) {
        var node = Node(NODE_PLUS);
        node.pos = token.pos;
        node.left = this.parse_expr7();
        return node;
    }
    else {
        this.reader.seek_set(pos);
        var node = this.parse_expr8();
        return node;
    }
}

// expr8: expr8[expr1]
//        expr8[expr1 : expr1]
//        expr8.name
//        expr8->name(expr1, ...)
//        expr8->s:user_func(expr1, ...)
//        expr8->{lambda}(expr1, ...)
//        expr8(expr1, ...)
ExprParser.prototype.parse_expr8 = function() {
    var left = this.parse_expr9();
    while (TRUE) {
        var pos = this.reader.tell();
        var c = this.reader.peek();
        var token = this.tokenizer.get();
        if (!iswhite(c) && token.type == TOKEN_SQOPEN) {
            var npos = token.pos;
            if (this.tokenizer.peek().type == TOKEN_COLON) {
                this.tokenizer.get();
                var node = Node(NODE_SLICE);
                node.pos = npos;
                node.left = left;
                node.rlist = [NIL, NIL];
                var token = this.tokenizer.peek();
                if (token.type != TOKEN_SQCLOSE) {
                    node.rlist[1] = this.parse_expr1();
                }
                var token = this.tokenizer.get();
                if (token.type != TOKEN_SQCLOSE) {
                    throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
                }
                var left = node;
            }
            else {
                var right = this.parse_expr1();
                if (this.tokenizer.peek().type == TOKEN_COLON) {
                    this.tokenizer.get();
                    var node = Node(NODE_SLICE);
                    node.pos = npos;
                    node.left = left;
                    node.rlist = [right, NIL];
                    var token = this.tokenizer.peek();
                    if (token.type != TOKEN_SQCLOSE) {
                        node.rlist[1] = this.parse_expr1();
                    }
                    var token = this.tokenizer.get();
                    if (token.type != TOKEN_SQCLOSE) {
                        throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
                    }
                    var left = node;
                }
                else {
                    var node = Node(NODE_SUBSCRIPT);
                    node.pos = npos;
                    node.left = left;
                    node.right = right;
                    var token = this.tokenizer.get();
                    if (token.type != TOKEN_SQCLOSE) {
                        throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
                    }
                    var left = node;
                }
            }
            delete node;
        }
        else if (token.type == TOKEN_ARROW) {
            var funcname_or_lambda = this.parse_expr9();
            var token = this.tokenizer.get();
            if (token.type != TOKEN_POPEN) {
                throw Err("E107: Missing parentheses: lambda", token.pos);
            }
            var right = Node(NODE_CALL);
            right.pos = token.pos;
            right.left = funcname_or_lambda;
            right.rlist = this.parse_rlist();
            var node = Node(NODE_METHOD);
            node.pos = token.pos;
            node.left = left;
            node.right = right;
            var left = node;
            delete node;
        }
        else if (token.type == TOKEN_POPEN) {
            var node = Node(NODE_CALL);
            node.pos = token.pos;
            node.left = left;
            node.rlist = this.parse_rlist();
            var left = node;
            delete node;
        }
        else if (!iswhite(c) && token.type == TOKEN_DOT) {
            // TODO check scriptversion?
            var node = this.parse_dot(token, left);
            if (node === NIL) {
                this.reader.seek_set(pos);
                break;
            }
            var left = node;
            delete node;
        }
        else {
            this.reader.seek_set(pos);
            break;
        }
    }
    return left;
}

ExprParser.prototype.parse_rlist = function() {
    var rlist = [];
    var token = this.tokenizer.peek();
    if (this.tokenizer.peek().type == TOKEN_PCLOSE) {
        this.tokenizer.get();
    }
    else {
        while (TRUE) {
            viml_add(rlist, this.parse_expr1());
            var token = this.tokenizer.get();
            if (token.type == TOKEN_COMMA) {
                // XXX: Vim allows foo(a, b, ).  Lint should warn it.
                if (this.tokenizer.peek().type == TOKEN_PCLOSE) {
                    this.tokenizer.get();
                    break;
                }
            }
            else if (token.type == TOKEN_PCLOSE) {
                break;
            }
            else {
                throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
            }
        }
    }
    if (viml_len(rlist) > MAX_FUNC_ARGS) {
        // TODO: funcname E740: Too many arguments for function: %s
        throw Err("E740: Too many arguments for function", token.pos);
    }
    return rlist;
}

// expr9: number
//        "string"
//        'string'
//        [expr1, ...]
//        {expr1: expr1, ...}
//        #{literal_key1: expr1, ...}
//        {args -> expr1}
//        &option
//        (expr1)
//        variable
//        var{ria}ble
//        $VAR
//        @r
//        function(expr1, ...)
//        func{ti}on(expr1, ...)
ExprParser.prototype.parse_expr9 = function() {
    var pos = this.reader.tell();
    var token = this.tokenizer.get();
    var node = Node(-1);
    if (token.type == TOKEN_NUMBER) {
        var node = Node(NODE_NUMBER);
        node.pos = token.pos;
        node.value = token.value;
    }
    else if (token.type == TOKEN_BLOB) {
        var node = Node(NODE_BLOB);
        node.pos = token.pos;
        node.value = token.value;
    }
    else if (token.type == TOKEN_DQUOTE) {
        this.reader.seek_set(pos);
        var node = Node(NODE_STRING);
        node.pos = token.pos;
        node.value = "\"" + this.tokenizer.get_dstring() + "\"";
    }
    else if (token.type == TOKEN_SQUOTE) {
        this.reader.seek_set(pos);
        var node = Node(NODE_STRING);
        node.pos = token.pos;
        node.value = "'" + this.tokenizer.get_sstring() + "'";
    }
    else if (token.type == TOKEN_SQOPEN) {
        var node = Node(NODE_LIST);
        node.pos = token.pos;
        node.value = [];
        var token = this.tokenizer.peek();
        if (token.type == TOKEN_SQCLOSE) {
            this.tokenizer.get();
        }
        else {
            while (TRUE) {
                viml_add(node.value, this.parse_expr1());
                var token = this.tokenizer.peek();
                if (token.type == TOKEN_COMMA) {
                    this.tokenizer.get();
                    if (this.tokenizer.peek().type == TOKEN_SQCLOSE) {
                        this.tokenizer.get();
                        break;
                    }
                }
                else if (token.type == TOKEN_SQCLOSE) {
                    this.tokenizer.get();
                    break;
                }
                else {
                    throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
                }
            }
        }
    }
    else if (token.type == TOKEN_COPEN || token.type == TOKEN_LITCOPEN) {
        var is_litdict = token.type == TOKEN_LITCOPEN;
        var savepos = this.reader.tell();
        var nodepos = token.pos;
        var token = this.tokenizer.get();
        var lambda = token.type == TOKEN_ARROW;
        if (!lambda && !(token.type == TOKEN_SQUOTE || token.type == TOKEN_DQUOTE)) {
            // if the token type is stirng, we cannot peek next token and we can
            // assume it's not lambda.
            var token2 = this.tokenizer.peek();
            var lambda = token2.type == TOKEN_ARROW || token2.type == TOKEN_COMMA;
        }
        // fallback to dict or {expr} if true
        var fallback = FALSE;
        if (lambda) {
            // lambda {token,...} {->...} {token->...}
            var node = Node(NODE_LAMBDA);
            node.pos = nodepos;
            node.rlist = [];
            var named = {};
            while (TRUE) {
                if (token.type == TOKEN_ARROW) {
                    break;
                }
                else if (token.type == TOKEN_IDENTIFIER) {
                    if (!isargname(token.value)) {
                        throw Err(viml_printf("E125: Illegal argument: %s", token.value), token.pos);
                    }
                    else if (viml_has_key(named, token.value)) {
                        throw Err(viml_printf("E853: Duplicate argument name: %s", token.value), token.pos);
                    }
                    named[token.value] = 1;
                    var varnode = Node(NODE_IDENTIFIER);
                    varnode.pos = token.pos;
                    varnode.value = token.value;
                    // XXX: Vim doesn't skip white space before comma.  {a ,b -> ...} => E475
                    if (iswhite(this.reader.p(0)) && this.tokenizer.peek().type == TOKEN_COMMA) {
                        throw Err("E475: Invalid argument: White space is not allowed before comma", this.reader.getpos());
                    }
                    var token = this.tokenizer.get();
                    viml_add(node.rlist, varnode);
                    if (token.type == TOKEN_COMMA) {
                        // XXX: Vim allows last comma.  {a, b, -> ...} => OK
                        var token = this.tokenizer.peek();
                        if (token.type == TOKEN_ARROW) {
                            this.tokenizer.get();
                            break;
                        }
                    }
                    else if (token.type == TOKEN_ARROW) {
                        break;
                    }
                    else {
                        throw Err(viml_printf("unexpected token: %s, type: %d", token.value, token.type), token.pos);
                    }
                }
                else if (token.type == TOKEN_DOTDOTDOT) {
                    var varnode = Node(NODE_IDENTIFIER);
                    varnode.pos = token.pos;
                    varnode.value = token.value;
                    viml_add(node.rlist, varnode);
                    var token = this.tokenizer.peek();
                    if (token.type == TOKEN_ARROW) {
                        this.tokenizer.get();
                        break;
                    }
                    else {
                        throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
                    }
                }
                else {
                    var fallback = TRUE;
                    break;
                }
                var token = this.tokenizer.get();
            }
            if (!fallback) {
                node.left = this.parse_expr1();
                var token = this.tokenizer.get();
                if (token.type != TOKEN_CCLOSE) {
                    throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
                }
                return node;
            }
        }
        // dict
        var node = Node(NODE_DICT);
        node.pos = nodepos;
        node.value = [];
        this.reader.seek_set(savepos);
        var token = this.tokenizer.peek();
        if (token.type == TOKEN_CCLOSE) {
            this.tokenizer.get();
            return node;
        }
        while (1) {
            var key = is_litdict ? this.tokenizer.parse_dict_literal_key() : this.parse_expr1();
            var token = this.tokenizer.get();
            if (token.type == TOKEN_CCLOSE) {
                if (!viml_empty(node.value)) {
                    throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
                }
                this.reader.seek_set(pos);
                var node = this.parse_identifier();
                break;
            }
            if (token.type != TOKEN_COLON) {
                throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
            }
            var val = this.parse_expr1();
            viml_add(node.value, [key, val]);
            var token = this.tokenizer.get();
            if (token.type == TOKEN_COMMA) {
                if (this.tokenizer.peek().type == TOKEN_CCLOSE) {
                    this.tokenizer.get();
                    break;
                }
            }
            else if (token.type == TOKEN_CCLOSE) {
                break;
            }
            else {
                throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
            }
        }
        return node;
    }
    else if (token.type == TOKEN_POPEN) {
        var node = this.parse_expr1();
        var token = this.tokenizer.get();
        if (token.type != TOKEN_PCLOSE) {
            throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
        }
    }
    else if (token.type == TOKEN_OPTION) {
        var node = Node(NODE_OPTION);
        node.pos = token.pos;
        node.value = token.value;
    }
    else if (token.type == TOKEN_IDENTIFIER) {
        this.reader.seek_set(pos);
        var node = this.parse_identifier();
    }
    else if (FALSE && (token.type == TOKEN_COLON || token.type == TOKEN_SHARP)) {
        // XXX: no parse error but invalid expression
        this.reader.seek_set(pos);
        var node = this.parse_identifier();
    }
    else if (token.type == TOKEN_LT && viml_equalci(this.reader.peekn(4), "SID>")) {
        this.reader.seek_set(pos);
        var node = this.parse_identifier();
    }
    else if (token.type == TOKEN_IS || token.type == TOKEN_ISCS || token.type == TOKEN_ISNOT || token.type == TOKEN_ISNOTCS) {
        this.reader.seek_set(pos);
        var node = this.parse_identifier();
    }
    else if (token.type == TOKEN_ENV) {
        var node = Node(NODE_ENV);
        node.pos = token.pos;
        node.value = token.value;
    }
    else if (token.type == TOKEN_REG) {
        var node = Node(NODE_REG);
        node.pos = token.pos;
        node.value = token.value;
    }
    else {
        throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
    }
    return node;
}

// SUBSCRIPT or CONCAT
//   dict "." [0-9A-Za-z_]+ => (subscript dict key)
//   str  "." expr6         => (concat str expr6)
ExprParser.prototype.parse_dot = function(token, left) {
    if (left.type != NODE_IDENTIFIER && left.type != NODE_CURLYNAME && left.type != NODE_DICT && left.type != NODE_SUBSCRIPT && left.type != NODE_CALL && left.type != NODE_DOT) {
        return NIL;
    }
    if (!iswordc(this.reader.p(0))) {
        return NIL;
    }
    var pos = this.reader.getpos();
    var name = this.reader.read_word();
    if (isnamec(this.reader.p(0))) {
        // XXX: foo is str => ok, foo is obj => invalid expression
        // foo.s:bar or foo.bar#baz
        return NIL;
    }
    var node = Node(NODE_DOT);
    node.pos = token.pos;
    node.left = left;
    node.right = Node(NODE_IDENTIFIER);
    node.right.pos = pos;
    node.right.value = name;
    return node;
}

// CONCAT
//   str  ".." expr6         => (concat str expr6)
ExprParser.prototype.parse_concat = function(token, left) {
    if (left.type != NODE_IDENTIFIER && left.type != NODE_CURLYNAME && left.type != NODE_DICT && left.type != NODE_SUBSCRIPT && left.type != NODE_CALL && left.type != NODE_DOT) {
        return NIL;
    }
    if (!iswordc(this.reader.p(0))) {
        return NIL;
    }
    var pos = this.reader.getpos();
    var name = this.reader.read_word();
    if (isnamec(this.reader.p(0))) {
        // XXX: foo is str => ok, foo is obj => invalid expression
        // foo.s:bar or foo.bar#baz
        return NIL;
    }
    var node = Node(NODE_CONCAT);
    node.pos = token.pos;
    node.left = left;
    node.right = Node(NODE_IDENTIFIER);
    node.right.pos = pos;
    node.right.value = name;
    return node;
}

ExprParser.prototype.parse_identifier = function() {
    this.reader.skip_white();
    var npos = this.reader.getpos();
    var curly_parts = this.parse_curly_parts();
    if (viml_len(curly_parts) == 1 && curly_parts[0].type == NODE_CURLYNAMEPART) {
        var node = Node(NODE_IDENTIFIER);
        node.pos = npos;
        node.value = curly_parts[0].value;
        return node;
    }
    else {
        var node = Node(NODE_CURLYNAME);
        node.pos = npos;
        node.value = curly_parts;
        return node;
    }
}

ExprParser.prototype.parse_curly_parts = function() {
    var curly_parts = [];
    var c = this.reader.peek();
    var pos = this.reader.getpos();
    if (c == "<" && viml_equalci(this.reader.peekn(5), "<SID>")) {
        var name = this.reader.getn(5);
        var node = Node(NODE_CURLYNAMEPART);
        node.curly = FALSE;
        // Keep backword compatibility for the curly attribute
        node.pos = pos;
        node.value = name;
        viml_add(curly_parts, node);
    }
    while (TRUE) {
        var c = this.reader.peek();
        if (isnamec(c)) {
            var pos = this.reader.getpos();
            var name = this.reader.read_name();
            var node = Node(NODE_CURLYNAMEPART);
            node.curly = FALSE;
            // Keep backword compatibility for the curly attribute
            node.pos = pos;
            node.value = name;
            viml_add(curly_parts, node);
        }
        else if (c == "{") {
            this.reader.get();
            var pos = this.reader.getpos();
            var node = Node(NODE_CURLYNAMEEXPR);
            node.curly = TRUE;
            // Keep backword compatibility for the curly attribute
            node.pos = pos;
            node.value = this.parse_expr1();
            viml_add(curly_parts, node);
            this.reader.skip_white();
            var c = this.reader.p(0);
            if (c != "}") {
                throw Err(viml_printf("unexpected token: %s", c), this.reader.getpos());
            }
            this.reader.seek_cur(1);
        }
        else {
            break;
        }
    }
    return curly_parts;
}

function LvalueParser() { ExprParser.apply(this, arguments); this.__init__.apply(this, arguments); }
LvalueParser.prototype = Object.create(ExprParser.prototype);
LvalueParser.prototype.parse = function() {
    return this.parse_lv8();
}

// expr8: expr8[expr1]
//        expr8[expr1 : expr1]
//        expr8.name
LvalueParser.prototype.parse_lv8 = function() {
    var left = this.parse_lv9();
    while (TRUE) {
        var pos = this.reader.tell();
        var c = this.reader.peek();
        var token = this.tokenizer.get();
        if (!iswhite(c) && token.type == TOKEN_SQOPEN) {
            var npos = token.pos;
            var node = Node(-1);
            if (this.tokenizer.peek().type == TOKEN_COLON) {
                this.tokenizer.get();
                var node = Node(NODE_SLICE);
                node.pos = npos;
                node.left = left;
                node.rlist = [NIL, NIL];
                var token = this.tokenizer.peek();
                if (token.type != TOKEN_SQCLOSE) {
                    node.rlist[1] = this.parse_expr1();
                }
                var token = this.tokenizer.get();
                if (token.type != TOKEN_SQCLOSE) {
                    throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
                }
            }
            else {
                var right = this.parse_expr1();
                if (this.tokenizer.peek().type == TOKEN_COLON) {
                    this.tokenizer.get();
                    var node = Node(NODE_SLICE);
                    node.pos = npos;
                    node.left = left;
                    node.rlist = [right, NIL];
                    var token = this.tokenizer.peek();
                    if (token.type != TOKEN_SQCLOSE) {
                        node.rlist[1] = this.parse_expr1();
                    }
                    var token = this.tokenizer.get();
                    if (token.type != TOKEN_SQCLOSE) {
                        throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
                    }
                }
                else {
                    var node = Node(NODE_SUBSCRIPT);
                    node.pos = npos;
                    node.left = left;
                    node.right = right;
                    var token = this.tokenizer.get();
                    if (token.type != TOKEN_SQCLOSE) {
                        throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
                    }
                }
            }
            var left = node;
            delete node;
        }
        else if (!iswhite(c) && token.type == TOKEN_DOT) {
            var node = this.parse_dot(token, left);
            if (node === NIL) {
                this.reader.seek_set(pos);
                break;
            }
            var left = node;
            delete node;
        }
        else {
            this.reader.seek_set(pos);
            break;
        }
    }
    return left;
}

// expr9: &option
//        variable
//        var{ria}ble
//        $VAR
//        @r
LvalueParser.prototype.parse_lv9 = function() {
    var pos = this.reader.tell();
    var token = this.tokenizer.get();
    var node = Node(-1);
    if (token.type == TOKEN_COPEN) {
        this.reader.seek_set(pos);
        var node = this.parse_identifier();
    }
    else if (token.type == TOKEN_OPTION) {
        var node = Node(NODE_OPTION);
        node.pos = token.pos;
        node.value = token.value;
    }
    else if (token.type == TOKEN_IDENTIFIER) {
        this.reader.seek_set(pos);
        var node = this.parse_identifier();
    }
    else if (token.type == TOKEN_LT && viml_equalci(this.reader.peekn(4), "SID>")) {
        this.reader.seek_set(pos);
        var node = this.parse_identifier();
    }
    else if (token.type == TOKEN_ENV) {
        var node = Node(NODE_ENV);
        node.pos = token.pos;
        node.value = token.value;
    }
    else if (token.type == TOKEN_REG) {
        var node = Node(NODE_REG);
        node.pos = token.pos;
        node.pos = token.pos;
        node.value = token.value;
    }
    else {
        throw Err(viml_printf("unexpected token: %s", token.value), token.pos);
    }
    return node;
}

function StringReader() { this.__init__.apply(this, arguments); }
StringReader.prototype.__init__ = function(lines) {
    this.buf = [];
    this.pos = [];
    var lnum = 0;
    var offset = 0;
    while (lnum < viml_len(lines)) {
        var col = 0;
        var __c7 = viml_split(lines[lnum], "\\zs");
        for (var __i7 = 0; __i7 < __c7.length; ++__i7) {
            var c = __c7[__i7];
            viml_add(this.buf, c);
            viml_add(this.pos, [lnum + 1, col + 1, offset]);
            col += viml_len(c);
            offset += viml_len(c);
        }
        while (lnum + 1 < viml_len(lines) && viml_eqregh(lines[lnum + 1], "^\\s*\\\\")) {
            var skip = TRUE;
            var col = 0;
            var __c8 = viml_split(lines[lnum + 1], "\\zs");
            for (var __i8 = 0; __i8 < __c8.length; ++__i8) {
                var c = __c8[__i8];
                if (skip) {
                    if (c == "\\") {
                        var skip = FALSE;
                    }
                }
                else {
                    viml_add(this.buf, c);
                    viml_add(this.pos, [lnum + 2, col + 1, offset]);
                }
                col += viml_len(c);
                offset += viml_len(c);
            }
            lnum += 1;
            offset += 1;
        }
        viml_add(this.buf, "<EOL>");
        viml_add(this.pos, [lnum + 1, col + 1, offset]);
        lnum += 1;
        offset += 1;
    }
    // for <EOF>
    viml_add(this.pos, [lnum + 1, 0, offset]);
    this.i = 0;
}

StringReader.prototype.eof = function() {
    return this.i >= viml_len(this.buf);
}

StringReader.prototype.tell = function() {
    return this.i;
}

StringReader.prototype.seek_set = function(i) {
    this.i = i;
}

StringReader.prototype.seek_cur = function(i) {
    this.i = this.i + i;
}

StringReader.prototype.seek_end = function(i) {
    this.i = viml_len(this.buf) + i;
}

StringReader.prototype.p = function(i) {
    if (this.i >= viml_len(this.buf)) {
        return "<EOF>";
    }
    return this.buf[this.i + i];
}

StringReader.prototype.peek = function() {
    if (this.i >= viml_len(this.buf)) {
        return "<EOF>";
    }
    return this.buf[this.i];
}

StringReader.prototype.get = function() {
    if (this.i >= viml_len(this.buf)) {
        return "<EOF>";
    }
    this.i += 1;
    return this.buf[this.i - 1];
}

StringReader.prototype.peekn = function(n) {
    var pos = this.tell();
    var r = this.getn(n);
    this.seek_set(pos);
    return r;
}

StringReader.prototype.getn = function(n) {
    var r = "";
    var j = 0;
    while (this.i < viml_len(this.buf) && (n < 0 || j < n)) {
        var c = this.buf[this.i];
        if (c == "<EOL>") {
            break;
        }
        r += c;
        this.i += 1;
        j += 1;
    }
    return r;
}

StringReader.prototype.peekline = function() {
    return this.peekn(-1);
}

StringReader.prototype.readline = function() {
    var r = this.getn(-1);
    this.get();
    return r;
}

StringReader.prototype.getstr = function(begin, end) {
    var r = "";
    var __c9 = viml_range(begin.i, end.i - 1);
    for (var __i9 = 0; __i9 < __c9.length; ++__i9) {
        var i = __c9[__i9];
        if (i >= viml_len(this.buf)) {
            break;
        }
        var c = this.buf[i];
        if (c == "<EOL>") {
            var c = "\n";
        }
        r += c;
    }
    return r;
}

StringReader.prototype.getpos = function() {
    var __tmp = this.pos[this.i];
    var lnum = __tmp[0];
    var col = __tmp[1];
    var offset = __tmp[2];
    return {"i":this.i, "lnum":lnum, "col":col, "offset":offset};
}

StringReader.prototype.setpos = function(pos) {
    this.i = pos.i;
}

StringReader.prototype.read_alpha = function() {
    var r = "";
    while (isalpha(this.peekn(1))) {
        r += this.getn(1);
    }
    return r;
}

StringReader.prototype.read_alnum = function() {
    var r = "";
    while (isalnum(this.peekn(1))) {
        r += this.getn(1);
    }
    return r;
}

StringReader.prototype.read_digit = function() {
    var r = "";
    while (isdigit(this.peekn(1))) {
        r += this.getn(1);
    }
    return r;
}

StringReader.prototype.read_odigit = function() {
    var r = "";
    while (isodigit(this.peekn(1))) {
        r += this.getn(1);
    }
    return r;
}

StringReader.prototype.read_blob = function() {
    var r = "";
    while (1) {
        var s = this.peekn(2);
        if (viml_eqregh(s, "^[0-9A-Fa-f][0-9A-Fa-f]$")) {
            r += this.getn(2);
        }
        else if (viml_eqregh(s, "^\\.[0-9A-Fa-f]$")) {
            r += this.getn(1);
        }
        else if (viml_eqregh(s, "^[0-9A-Fa-f][^0-9A-Fa-f]$")) {
            throw Err("E973: Blob literal should have an even number of hex characters:" + s, this.getpos());
        }
        else {
            break;
        }
    }
    return r;
}

StringReader.prototype.read_xdigit = function() {
    var r = "";
    while (isxdigit(this.peekn(1))) {
        r += this.getn(1);
    }
    return r;
}

StringReader.prototype.read_bdigit = function() {
    var r = "";
    while (this.peekn(1) == "0" || this.peekn(1) == "1") {
        r += this.getn(1);
    }
    return r;
}

StringReader.prototype.read_integer = function() {
    var r = "";
    var c = this.peekn(1);
    if (c == "-" || c == "+") {
        var r = this.getn(1);
    }
    return r + this.read_digit();
}

StringReader.prototype.read_word = function() {
    var r = "";
    while (iswordc(this.peekn(1))) {
        r += this.getn(1);
    }
    return r;
}

StringReader.prototype.read_white = function() {
    var r = "";
    while (iswhite(this.peekn(1))) {
        r += this.getn(1);
    }
    return r;
}

StringReader.prototype.read_nonwhite = function() {
    var r = "";
    var ch = this.peekn(1);
    while (!iswhite(ch) && ch != "") {
        r += this.getn(1);
        var ch = this.peekn(1);
    }
    return r;
}

StringReader.prototype.read_name = function() {
    var r = "";
    while (isnamec(this.peekn(1))) {
        r += this.getn(1);
    }
    return r;
}

StringReader.prototype.skip_white = function() {
    while (iswhite(this.peekn(1))) {
        this.seek_cur(1);
    }
}

StringReader.prototype.skip_white_and_colon = function() {
    while (TRUE) {
        var c = this.peekn(1);
        if (!iswhite(c) && c != ":") {
            break;
        }
        this.seek_cur(1);
    }
}

function Compiler() { this.__init__.apply(this, arguments); }
Compiler.prototype.__init__ = function() {
    this.indent = [""];
    this.lines = [];
}

Compiler.prototype.out = function() {
    var a000 = Array.prototype.slice.call(arguments, 0);
    if (viml_len(a000) == 1) {
        if (a000[0][0] == ")") {
            this.lines[this.lines.length - 1] += a000[0];
        }
        else {
            viml_add(this.lines, this.indent[0] + a000[0]);
        }
    }
    else {
        viml_add(this.lines, this.indent[0] + viml_printf.apply(null, a000));
    }
}

Compiler.prototype.incindent = function(s) {
    viml_insert(this.indent, this.indent[0] + s);
}

Compiler.prototype.decindent = function() {
    viml_remove(this.indent, 0);
}

Compiler.prototype.compile = function(node) {
    if (node.type == NODE_TOPLEVEL) {
        return this.compile_toplevel(node);
    }
    else if (node.type == NODE_COMMENT) {
        this.compile_comment(node);
        return NIL;
    }
    else if (node.type == NODE_EXCMD) {
        this.compile_excmd(node);
        return NIL;
    }
    else if (node.type == NODE_FUNCTION) {
        this.compile_function(node);
        return NIL;
    }
    else if (node.type == NODE_DELFUNCTION) {
        this.compile_delfunction(node);
        return NIL;
    }
    else if (node.type == NODE_RETURN) {
        this.compile_return(node);
        return NIL;
    }
    else if (node.type == NODE_EXCALL) {
        this.compile_excall(node);
        return NIL;
    }
    else if (node.type == NODE_EVAL) {
        this.compile_eval(node);
        return NIL;
    }
    else if (node.type == NODE_LET) {
        this.compile_let(node);
        return NIL;
    }
    else if (node.type == NODE_CONST) {
        this.compile_const(node);
        return NIL;
    }
    else if (node.type == NODE_UNLET) {
        this.compile_unlet(node);
        return NIL;
    }
    else if (node.type == NODE_LOCKVAR) {
        this.compile_lockvar(node);
        return NIL;
    }
    else if (node.type == NODE_UNLOCKVAR) {
        this.compile_unlockvar(node);
        return NIL;
    }
    else if (node.type == NODE_IF) {
        this.compile_if(node);
        return NIL;
    }
    else if (node.type == NODE_WHILE) {
        this.compile_while(node);
        return NIL;
    }
    else if (node.type == NODE_FOR) {
        this.compile_for(node);
        return NIL;
    }
    else if (node.type == NODE_CONTINUE) {
        this.compile_continue(node);
        return NIL;
    }
    else if (node.type == NODE_BREAK) {
        this.compile_break(node);
        return NIL;
    }
    else if (node.type == NODE_TRY) {
        this.compile_try(node);
        return NIL;
    }
    else if (node.type == NODE_THROW) {
        this.compile_throw(node);
        return NIL;
    }
    else if (node.type == NODE_ECHO) {
        this.compile_echo(node);
        return NIL;
    }
    else if (node.type == NODE_ECHON) {
        this.compile_echon(node);
        return NIL;
    }
    else if (node.type == NODE_ECHOHL) {
        this.compile_echohl(node);
        return NIL;
    }
    else if (node.type == NODE_ECHOMSG) {
        this.compile_echomsg(node);
        return NIL;
    }
    else if (node.type == NODE_ECHOERR) {
        this.compile_echoerr(node);
        return NIL;
    }
    else if (node.type == NODE_ECHOCONSOLE) {
        this.compile_echoconsole(node);
        return NIL;
    }
    else if (node.type == NODE_EXECUTE) {
        this.compile_execute(node);
        return NIL;
    }
    else if (node.type == NODE_TERNARY) {
        return this.compile_ternary(node);
    }
    else if (node.type == NODE_OR) {
        return this.compile_or(node);
    }
    else if (node.type == NODE_AND) {
        return this.compile_and(node);
    }
    else if (node.type == NODE_EQUAL) {
        return this.compile_equal(node);
    }
    else if (node.type == NODE_EQUALCI) {
        return this.compile_equalci(node);
    }
    else if (node.type == NODE_EQUALCS) {
        return this.compile_equalcs(node);
    }
    else if (node.type == NODE_NEQUAL) {
        return this.compile_nequal(node);
    }
    else if (node.type == NODE_NEQUALCI) {
        return this.compile_nequalci(node);
    }
    else if (node.type == NODE_NEQUALCS) {
        return this.compile_nequalcs(node);
    }
    else if (node.type == NODE_GREATER) {
        return this.compile_greater(node);
    }
    else if (node.type == NODE_GREATERCI) {
        return this.compile_greaterci(node);
    }
    else if (node.type == NODE_GREATERCS) {
        return this.compile_greatercs(node);
    }
    else if (node.type == NODE_GEQUAL) {
        return this.compile_gequal(node);
    }
    else if (node.type == NODE_GEQUALCI) {
        return this.compile_gequalci(node);
    }
    else if (node.type == NODE_GEQUALCS) {
        return this.compile_gequalcs(node);
    }
    else if (node.type == NODE_SMALLER) {
        return this.compile_smaller(node);
    }
    else if (node.type == NODE_SMALLERCI) {
        return this.compile_smallerci(node);
    }
    else if (node.type == NODE_SMALLERCS) {
        return this.compile_smallercs(node);
    }
    else if (node.type == NODE_SEQUAL) {
        return this.compile_sequal(node);
    }
    else if (node.type == NODE_SEQUALCI) {
        return this.compile_sequalci(node);
    }
    else if (node.type == NODE_SEQUALCS) {
        return this.compile_sequalcs(node);
    }
    else if (node.type == NODE_MATCH) {
        return this.compile_match(node);
    }
    else if (node.type == NODE_MATCHCI) {
        return this.compile_matchci(node);
    }
    else if (node.type == NODE_MATCHCS) {
        return this.compile_matchcs(node);
    }
    else if (node.type == NODE_NOMATCH) {
        return this.compile_nomatch(node);
    }
    else if (node.type == NODE_NOMATCHCI) {
        return this.compile_nomatchci(node);
    }
    else if (node.type == NODE_NOMATCHCS) {
        return this.compile_nomatchcs(node);
    }
    else if (node.type == NODE_IS) {
        return this.compile_is(node);
    }
    else if (node.type == NODE_ISCI) {
        return this.compile_isci(node);
    }
    else if (node.type == NODE_ISCS) {
        return this.compile_iscs(node);
    }
    else if (node.type == NODE_ISNOT) {
        return this.compile_isnot(node);
    }
    else if (node.type == NODE_ISNOTCI) {
        return this.compile_isnotci(node);
    }
    else if (node.type == NODE_ISNOTCS) {
        return this.compile_isnotcs(node);
    }
    else if (node.type == NODE_ADD) {
        return this.compile_add(node);
    }
    else if (node.type == NODE_SUBTRACT) {
        return this.compile_subtract(node);
    }
    else if (node.type == NODE_CONCAT) {
        return this.compile_concat(node);
    }
    else if (node.type == NODE_MULTIPLY) {
        return this.compile_multiply(node);
    }
    else if (node.type == NODE_DIVIDE) {
        return this.compile_divide(node);
    }
    else if (node.type == NODE_REMAINDER) {
        return this.compile_remainder(node);
    }
    else if (node.type == NODE_NOT) {
        return this.compile_not(node);
    }
    else if (node.type == NODE_PLUS) {
        return this.compile_plus(node);
    }
    else if (node.type == NODE_MINUS) {
        return this.compile_minus(node);
    }
    else if (node.type == NODE_SUBSCRIPT) {
        return this.compile_subscript(node);
    }
    else if (node.type == NODE_SLICE) {
        return this.compile_slice(node);
    }
    else if (node.type == NODE_DOT) {
        return this.compile_dot(node);
    }
    else if (node.type == NODE_METHOD) {
        return this.compile_method(node);
    }
    else if (node.type == NODE_CALL) {
        return this.compile_call(node);
    }
    else if (node.type == NODE_NUMBER) {
        return this.compile_number(node);
    }
    else if (node.type == NODE_BLOB) {
        return this.compile_blob(node);
    }
    else if (node.type == NODE_STRING) {
        return this.compile_string(node);
    }
    else if (node.type == NODE_LIST) {
        return this.compile_list(node);
    }
    else if (node.type == NODE_DICT) {
        return this.compile_dict(node);
    }
    else if (node.type == NODE_OPTION) {
        return this.compile_option(node);
    }
    else if (node.type == NODE_IDENTIFIER) {
        return this.compile_identifier(node);
    }
    else if (node.type == NODE_CURLYNAME) {
        return this.compile_curlyname(node);
    }
    else if (node.type == NODE_ENV) {
        return this.compile_env(node);
    }
    else if (node.type == NODE_REG) {
        return this.compile_reg(node);
    }
    else if (node.type == NODE_CURLYNAMEPART) {
        return this.compile_curlynamepart(node);
    }
    else if (node.type == NODE_CURLYNAMEEXPR) {
        return this.compile_curlynameexpr(node);
    }
    else if (node.type == NODE_LAMBDA) {
        return this.compile_lambda(node);
    }
    else if (node.type == NODE_HEREDOC) {
        return this.compile_heredoc(node);
    }
    else {
        throw viml_printf("Compiler: unknown node: %s", viml_string(node));
    }
    return NIL;
}

Compiler.prototype.compile_body = function(body) {
    var __c10 = body;
    for (var __i10 = 0; __i10 < __c10.length; ++__i10) {
        var node = __c10[__i10];
        this.compile(node);
    }
}

Compiler.prototype.compile_toplevel = function(node) {
    this.compile_body(node.body);
    return this.lines;
}

Compiler.prototype.compile_comment = function(node) {
    this.out(";%s", node.str);
}

Compiler.prototype.compile_excmd = function(node) {
    this.out("(excmd \"%s\")", viml_escape(node.str, "\\\""));
}

Compiler.prototype.compile_function = function(node) {
    var left = this.compile(node.left);
    var rlist = node.rlist.map((function(vval) { return this.compile(vval); }).bind(this));
    var default_args = node.default_args.map((function(vval) { return this.compile(vval); }).bind(this));
    if (!viml_empty(rlist)) {
        var remaining = FALSE;
        if (rlist[rlist.length - 1] == "...") {
            viml_remove(rlist, -1);
            var remaining = TRUE;
        }
        var __c11 = viml_range(viml_len(rlist));
        for (var __i11 = 0; __i11 < __c11.length; ++__i11) {
            var i = __c11[__i11];
            if (i < viml_len(rlist) - viml_len(default_args)) {
                left += viml_printf(" %s", rlist[i]);
            }
            else {
                left += viml_printf(" (%s %s)", rlist[i], default_args[i + viml_len(default_args) - viml_len(rlist)]);
            }
        }
        if (remaining) {
            left += " . ...";
        }
    }
    this.out("(function (%s)", left);
    this.incindent("  ");
    this.compile_body(node.body);
    this.out(")");
    this.decindent();
}

Compiler.prototype.compile_delfunction = function(node) {
    this.out("(delfunction %s)", this.compile(node.left));
}

Compiler.prototype.compile_return = function(node) {
    if (node.left === NIL) {
        this.out("(return)");
    }
    else {
        this.out("(return %s)", this.compile(node.left));
    }
}

Compiler.prototype.compile_excall = function(node) {
    this.out("(call %s)", this.compile(node.left));
}

Compiler.prototype.compile_eval = function(node) {
    this.out("(eval %s)", this.compile(node.left));
}

Compiler.prototype.compile_let = function(node) {
    var left = "";
    if (node.left !== NIL) {
        var left = this.compile(node.left);
    }
    else {
        var left = viml_join(node.list.map((function(vval) { return this.compile(vval); }).bind(this)), " ");
        if (node.rest !== NIL) {
            left += " . " + this.compile(node.rest);
        }
        var left = "(" + left + ")";
    }
    var right = this.compile(node.right);
    this.out("(let %s %s %s)", node.op, left, right);
}

// TODO: merge with s:Compiler.compile_let() ?
Compiler.prototype.compile_const = function(node) {
    var left = "";
    if (node.left !== NIL) {
        var left = this.compile(node.left);
    }
    else {
        var left = viml_join(node.list.map((function(vval) { return this.compile(vval); }).bind(this)), " ");
        if (node.rest !== NIL) {
            left += " . " + this.compile(node.rest);
        }
        var left = "(" + left + ")";
    }
    var right = this.compile(node.right);
    this.out("(const %s %s %s)", node.op, left, right);
}

Compiler.prototype.compile_unlet = function(node) {
    var list = node.list.map((function(vval) { return this.compile(vval); }).bind(this));
    this.out("(unlet %s)", viml_join(list, " "));
}

Compiler.prototype.compile_lockvar = function(node) {
    var list = node.list.map((function(vval) { return this.compile(vval); }).bind(this));
    if (node.depth === NIL) {
        this.out("(lockvar %s)", viml_join(list, " "));
    }
    else {
        this.out("(lockvar %d %s)", node.depth, viml_join(list, " "));
    }
}

Compiler.prototype.compile_unlockvar = function(node) {
    var list = node.list.map((function(vval) { return this.compile(vval); }).bind(this));
    if (node.depth === NIL) {
        this.out("(unlockvar %s)", viml_join(list, " "));
    }
    else {
        this.out("(unlockvar %d %s)", node.depth, viml_join(list, " "));
    }
}

Compiler.prototype.compile_if = function(node) {
    this.out("(if %s", this.compile(node.cond));
    this.incindent("  ");
    this.compile_body(node.body);
    this.decindent();
    var __c12 = node.elseif;
    for (var __i12 = 0; __i12 < __c12.length; ++__i12) {
        var enode = __c12[__i12];
        this.out(" elseif %s", this.compile(enode.cond));
        this.incindent("  ");
        this.compile_body(enode.body);
        this.decindent();
    }
    if (node._else !== NIL) {
        this.out(" else");
        this.incindent("  ");
        this.compile_body(node._else.body);
        this.decindent();
    }
    this.incindent("  ");
    this.out(")");
    this.decindent();
}

Compiler.prototype.compile_while = function(node) {
    this.out("(while %s", this.compile(node.cond));
    this.incindent("  ");
    this.compile_body(node.body);
    this.out(")");
    this.decindent();
}

Compiler.prototype.compile_for = function(node) {
    var left = "";
    if (node.left !== NIL) {
        var left = this.compile(node.left);
    }
    else {
        var left = viml_join(node.list.map((function(vval) { return this.compile(vval); }).bind(this)), " ");
        if (node.rest !== NIL) {
            left += " . " + this.compile(node.rest);
        }
        var left = "(" + left + ")";
    }
    var right = this.compile(node.right);
    this.out("(for %s %s", left, right);
    this.incindent("  ");
    this.compile_body(node.body);
    this.out(")");
    this.decindent();
}

Compiler.prototype.compile_continue = function(node) {
    this.out("(continue)");
}

Compiler.prototype.compile_break = function(node) {
    this.out("(break)");
}

Compiler.prototype.compile_try = function(node) {
    this.out("(try");
    this.incindent("  ");
    this.compile_body(node.body);
    var __c13 = node.catch;
    for (var __i13 = 0; __i13 < __c13.length; ++__i13) {
        var cnode = __c13[__i13];
        if (cnode.pattern !== NIL) {
            this.decindent();
            this.out(" catch /%s/", cnode.pattern);
            this.incindent("  ");
            this.compile_body(cnode.body);
        }
        else {
            this.decindent();
            this.out(" catch");
            this.incindent("  ");
            this.compile_body(cnode.body);
        }
    }
    if (node._finally !== NIL) {
        this.decindent();
        this.out(" finally");
        this.incindent("  ");
        this.compile_body(node._finally.body);
    }
    this.out(")");
    this.decindent();
}

Compiler.prototype.compile_throw = function(node) {
    this.out("(throw %s)", this.compile(node.left));
}

Compiler.prototype.compile_echo = function(node) {
    var list = node.list.map((function(vval) { return this.compile(vval); }).bind(this));
    this.out("(echo %s)", viml_join(list, " "));
}

Compiler.prototype.compile_echon = function(node) {
    var list = node.list.map((function(vval) { return this.compile(vval); }).bind(this));
    this.out("(echon %s)", viml_join(list, " "));
}

Compiler.prototype.compile_echohl = function(node) {
    this.out("(echohl \"%s\")", viml_escape(node.str, "\\\""));
}

Compiler.prototype.compile_echomsg = function(node) {
    var list = node.list.map((function(vval) { return this.compile(vval); }).bind(this));
    this.out("(echomsg %s)", viml_join(list, " "));
}

Compiler.prototype.compile_echoerr = function(node) {
    var list = node.list.map((function(vval) { return this.compile(vval); }).bind(this));
    this.out("(echoerr %s)", viml_join(list, " "));
}

Compiler.prototype.compile_echoconsole = function(node) {
    var list = node.list.map((function(vval) { return this.compile(vval); }).bind(this));
    this.out("(echoconsole %s)", viml_join(list, " "));
}

Compiler.prototype.compile_execute = function(node) {
    var list = node.list.map((function(vval) { return this.compile(vval); }).bind(this));
    this.out("(execute %s)", viml_join(list, " "));
}

Compiler.prototype.compile_ternary = function(node) {
    return viml_printf("(?: %s %s %s)", this.compile(node.cond), this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_or = function(node) {
    return viml_printf("(|| %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_and = function(node) {
    return viml_printf("(&& %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_equal = function(node) {
    return viml_printf("(== %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_equalci = function(node) {
    return viml_printf("(==? %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_equalcs = function(node) {
    return viml_printf("(==# %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_nequal = function(node) {
    return viml_printf("(!= %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_nequalci = function(node) {
    return viml_printf("(!=? %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_nequalcs = function(node) {
    return viml_printf("(!=# %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_greater = function(node) {
    return viml_printf("(> %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_greaterci = function(node) {
    return viml_printf("(>? %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_greatercs = function(node) {
    return viml_printf("(># %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_gequal = function(node) {
    return viml_printf("(>= %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_gequalci = function(node) {
    return viml_printf("(>=? %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_gequalcs = function(node) {
    return viml_printf("(>=# %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_smaller = function(node) {
    return viml_printf("(< %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_smallerci = function(node) {
    return viml_printf("(<? %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_smallercs = function(node) {
    return viml_printf("(<# %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_sequal = function(node) {
    return viml_printf("(<= %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_sequalci = function(node) {
    return viml_printf("(<=? %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_sequalcs = function(node) {
    return viml_printf("(<=# %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_match = function(node) {
    return viml_printf("(=~ %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_matchci = function(node) {
    return viml_printf("(=~? %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_matchcs = function(node) {
    return viml_printf("(=~# %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_nomatch = function(node) {
    return viml_printf("(!~ %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_nomatchci = function(node) {
    return viml_printf("(!~? %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_nomatchcs = function(node) {
    return viml_printf("(!~# %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_is = function(node) {
    return viml_printf("(is %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_isci = function(node) {
    return viml_printf("(is? %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_iscs = function(node) {
    return viml_printf("(is# %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_isnot = function(node) {
    return viml_printf("(isnot %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_isnotci = function(node) {
    return viml_printf("(isnot? %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_isnotcs = function(node) {
    return viml_printf("(isnot# %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_add = function(node) {
    return viml_printf("(+ %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_subtract = function(node) {
    return viml_printf("(- %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_concat = function(node) {
    return viml_printf("(concat %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_multiply = function(node) {
    return viml_printf("(* %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_divide = function(node) {
    return viml_printf("(/ %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_remainder = function(node) {
    return viml_printf("(%% %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_not = function(node) {
    return viml_printf("(! %s)", this.compile(node.left));
}

Compiler.prototype.compile_plus = function(node) {
    return viml_printf("(+ %s)", this.compile(node.left));
}

Compiler.prototype.compile_minus = function(node) {
    return viml_printf("(- %s)", this.compile(node.left));
}

Compiler.prototype.compile_subscript = function(node) {
    return viml_printf("(subscript %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_slice = function(node) {
    var r0 = node.rlist[0] === NIL ? "nil" : this.compile(node.rlist[0]);
    var r1 = node.rlist[1] === NIL ? "nil" : this.compile(node.rlist[1]);
    return viml_printf("(slice %s %s %s)", this.compile(node.left), r0, r1);
}

Compiler.prototype.compile_dot = function(node) {
    return viml_printf("(dot %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_method = function(node) {
    return viml_printf("(method %s %s)", this.compile(node.left), this.compile(node.right));
}

Compiler.prototype.compile_call = function(node) {
    var rlist = node.rlist.map((function(vval) { return this.compile(vval); }).bind(this));
    if (viml_empty(rlist)) {
        return viml_printf("(%s)", this.compile(node.left));
    }
    else {
        return viml_printf("(%s %s)", this.compile(node.left), viml_join(rlist, " "));
    }
}

Compiler.prototype.compile_number = function(node) {
    return node.value;
}

Compiler.prototype.compile_blob = function(node) {
    return node.value;
}

Compiler.prototype.compile_string = function(node) {
    return node.value;
}

Compiler.prototype.compile_list = function(node) {
    var value = node.value.map((function(vval) { return this.compile(vval); }).bind(this));
    if (viml_empty(value)) {
        return "(list)";
    }
    else {
        return viml_printf("(list %s)", viml_join(value, " "));
    }
}

Compiler.prototype.compile_dict = function(node) {
    var value = node.value.map((function(vval) { return "(" + this.compile(vval[0]) + " " + this.compile(vval[1]) + ")"; }).bind(this));
    if (viml_empty(value)) {
        return "(dict)";
    }
    else {
        return viml_printf("(dict %s)", viml_join(value, " "));
    }
}

Compiler.prototype.compile_option = function(node) {
    return node.value;
}

Compiler.prototype.compile_identifier = function(node) {
    return node.value;
}

Compiler.prototype.compile_curlyname = function(node) {
    return viml_join(node.value.map((function(vval) { return this.compile(vval); }).bind(this)), "");
}

Compiler.prototype.compile_env = function(node) {
    return node.value;
}

Compiler.prototype.compile_reg = function(node) {
    return node.value;
}

Compiler.prototype.compile_curlynamepart = function(node) {
    return node.value;
}

Compiler.prototype.compile_curlynameexpr = function(node) {
    return "{" + this.compile(node.value) + "}";
}

Compiler.prototype.escape_string = function(str) {
    var m = {"\n":"\\n", "\t":"\\t", "\r":"\\r"};
    var out = "\"";
    var __c14 = viml_range(viml_len(str));
    for (var __i14 = 0; __i14 < __c14.length; ++__i14) {
        var i = __c14[__i14];
        var c = str[i];
        if (viml_has_key(m, c)) {
            out += m[c];
        }
        else {
            out += c;
        }
    }
    out += "\"";
    return out;
}

Compiler.prototype.compile_lambda = function(node) {
    var rlist = node.rlist.map((function(vval) { return this.compile(vval); }).bind(this));
    return viml_printf("(lambda (%s) %s)", viml_join(rlist, " "), this.compile(node.left));
}

Compiler.prototype.compile_heredoc = function(node) {
    if (viml_empty(node.rlist)) {
        var rlist = "(list)";
    }
    else {
        var rlist = "(list " + viml_join(node.rlist.map((function(vval) { return this.escape_string(vval.value); }).bind(this)), " ") + ")";
    }
    if (viml_empty(node.body)) {
        var body = "(list)";
    }
    else {
        var body = "(list " + viml_join(node.body.map((function(vval) { return this.escape_string(vval.value); }).bind(this)), " ") + ")";
    }
    var op = this.escape_string(node.op);
    return viml_printf("(heredoc %s %s %s)", rlist, op, body);
}

// TODO: under construction
function RegexpParser() { this.__init__.apply(this, arguments); }
RegexpParser.prototype.RE_VERY_NOMAGIC = 1;
RegexpParser.prototype.RE_NOMAGIC = 2;
RegexpParser.prototype.RE_MAGIC = 3;
RegexpParser.prototype.RE_VERY_MAGIC = 4;
RegexpParser.prototype.__init__ = function(reader, cmd, delim) {
    this.reader = reader;
    this.cmd = cmd;
    this.delim = delim;
    this.reg_magic = this.RE_MAGIC;
}

RegexpParser.prototype.isend = function(c) {
    return c == "<EOF>" || c == "<EOL>" || c == this.delim;
}

RegexpParser.prototype.parse_regexp = function() {
    var prevtoken = "";
    var ntoken = "";
    var ret = [];
    if (this.reader.peekn(4) == "\\%#=") {
        var epos = this.reader.getpos();
        var token = this.reader.getn(5);
        if (token != "\\%#=0" && token != "\\%#=1" && token != "\\%#=2") {
            throw Err("E864: \\%#= can only be followed by 0, 1, or 2", epos);
        }
        viml_add(ret, token);
    }
    while (!this.isend(this.reader.peek())) {
        var prevtoken = ntoken;
        var __tmp = this.get_token();
        var token = __tmp[0];
        var ntoken = __tmp[1];
        if (ntoken == "\\m") {
            this.reg_magic = this.RE_MAGIC;
        }
        else if (ntoken == "\\M") {
            this.reg_magic = this.RE_NOMAGIC;
        }
        else if (ntoken == "\\v") {
            this.reg_magic = this.RE_VERY_MAGIC;
        }
        else if (ntoken == "\\V") {
            this.reg_magic = this.RE_VERY_NOMAGIC;
        }
        else if (ntoken == "\\*") {
            // '*' is not magic as the very first character.
            if (prevtoken == "" || prevtoken == "\\^" || prevtoken == "\\&" || prevtoken == "\\|" || prevtoken == "\\(") {
                var ntoken = "*";
            }
        }
        else if (ntoken == "\\^") {
            // '^' is only magic as the very first character.
            if (this.reg_magic != this.RE_VERY_MAGIC && prevtoken != "" && prevtoken != "\\&" && prevtoken != "\\|" && prevtoken != "\\n" && prevtoken != "\\(" && prevtoken != "\\%(") {
                var ntoken = "^";
            }
        }
        else if (ntoken == "\\$") {
            // '$' is only magic as the very last character
            var pos = this.reader.tell();
            if (this.reg_magic != this.RE_VERY_MAGIC) {
                while (!this.isend(this.reader.peek())) {
                    var __tmp = this.get_token();
                    var t = __tmp[0];
                    var n = __tmp[1];
                    // XXX: Vim doesn't check \v and \V?
                    if (n == "\\c" || n == "\\C" || n == "\\m" || n == "\\M" || n == "\\Z") {
                        continue;
                    }
                    if (n != "\\|" && n != "\\&" && n != "\\n" && n != "\\)") {
                        var ntoken = "$";
                    }
                    break;
                }
            }
            this.reader.seek_set(pos);
        }
        else if (ntoken == "\\?") {
            // '?' is literal in '?' command.
            if (this.cmd == "?") {
                var ntoken = "?";
            }
        }
        viml_add(ret, ntoken);
    }
    return ret;
}

// @return [actual_token, normalized_token]
RegexpParser.prototype.get_token = function() {
    if (this.reg_magic == this.RE_VERY_MAGIC) {
        return this.get_token_very_magic();
    }
    else if (this.reg_magic == this.RE_MAGIC) {
        return this.get_token_magic();
    }
    else if (this.reg_magic == this.RE_NOMAGIC) {
        return this.get_token_nomagic();
    }
    else if (this.reg_magic == this.RE_VERY_NOMAGIC) {
        return this.get_token_very_nomagic();
    }
}

RegexpParser.prototype.get_token_very_magic = function() {
    if (this.isend(this.reader.peek())) {
        return ["<END>", "<END>"];
    }
    var c = this.reader.get();
    if (c == "\\") {
        return this.get_token_backslash_common();
    }
    else if (c == "*") {
        return ["*", "\\*"];
    }
    else if (c == "+") {
        return ["+", "\\+"];
    }
    else if (c == "=") {
        return ["=", "\\="];
    }
    else if (c == "?") {
        return ["?", "\\?"];
    }
    else if (c == "{") {
        return this.get_token_brace("{");
    }
    else if (c == "@") {
        return this.get_token_at("@");
    }
    else if (c == "^") {
        return ["^", "\\^"];
    }
    else if (c == "$") {
        return ["$", "\\$"];
    }
    else if (c == ".") {
        return [".", "\\."];
    }
    else if (c == "<") {
        return ["<", "\\<"];
    }
    else if (c == ">") {
        return [">", "\\>"];
    }
    else if (c == "%") {
        return this.get_token_percent("%");
    }
    else if (c == "[") {
        return this.get_token_sq("[");
    }
    else if (c == "~") {
        return ["~", "\\~"];
    }
    else if (c == "|") {
        return ["|", "\\|"];
    }
    else if (c == "&") {
        return ["&", "\\&"];
    }
    else if (c == "(") {
        return ["(", "\\("];
    }
    else if (c == ")") {
        return [")", "\\)"];
    }
    return [c, c];
}

RegexpParser.prototype.get_token_magic = function() {
    if (this.isend(this.reader.peek())) {
        return ["<END>", "<END>"];
    }
    var c = this.reader.get();
    if (c == "\\") {
        var pos = this.reader.tell();
        var c = this.reader.get();
        if (c == "+") {
            return ["\\+", "\\+"];
        }
        else if (c == "=") {
            return ["\\=", "\\="];
        }
        else if (c == "?") {
            return ["\\?", "\\?"];
        }
        else if (c == "{") {
            return this.get_token_brace("\\{");
        }
        else if (c == "@") {
            return this.get_token_at("\\@");
        }
        else if (c == "<") {
            return ["\\<", "\\<"];
        }
        else if (c == ">") {
            return ["\\>", "\\>"];
        }
        else if (c == "%") {
            return this.get_token_percent("\\%");
        }
        else if (c == "|") {
            return ["\\|", "\\|"];
        }
        else if (c == "&") {
            return ["\\&", "\\&"];
        }
        else if (c == "(") {
            return ["\\(", "\\("];
        }
        else if (c == ")") {
            return ["\\)", "\\)"];
        }
        this.reader.seek_set(pos);
        return this.get_token_backslash_common();
    }
    else if (c == "*") {
        return ["*", "\\*"];
    }
    else if (c == "^") {
        return ["^", "\\^"];
    }
    else if (c == "$") {
        return ["$", "\\$"];
    }
    else if (c == ".") {
        return [".", "\\."];
    }
    else if (c == "[") {
        return this.get_token_sq("[");
    }
    else if (c == "~") {
        return ["~", "\\~"];
    }
    return [c, c];
}

RegexpParser.prototype.get_token_nomagic = function() {
    if (this.isend(this.reader.peek())) {
        return ["<END>", "<END>"];
    }
    var c = this.reader.get();
    if (c == "\\") {
        var pos = this.reader.tell();
        var c = this.reader.get();
        if (c == "*") {
            return ["\\*", "\\*"];
        }
        else if (c == "+") {
            return ["\\+", "\\+"];
        }
        else if (c == "=") {
            return ["\\=", "\\="];
        }
        else if (c == "?") {
            return ["\\?", "\\?"];
        }
        else if (c == "{") {
            return this.get_token_brace("\\{");
        }
        else if (c == "@") {
            return this.get_token_at("\\@");
        }
        else if (c == ".") {
            return ["\\.", "\\."];
        }
        else if (c == "<") {
            return ["\\<", "\\<"];
        }
        else if (c == ">") {
            return ["\\>", "\\>"];
        }
        else if (c == "%") {
            return this.get_token_percent("\\%");
        }
        else if (c == "~") {
            return ["\\~", "\\^"];
        }
        else if (c == "[") {
            return this.get_token_sq("\\[");
        }
        else if (c == "|") {
            return ["\\|", "\\|"];
        }
        else if (c == "&") {
            return ["\\&", "\\&"];
        }
        else if (c == "(") {
            return ["\\(", "\\("];
        }
        else if (c == ")") {
            return ["\\)", "\\)"];
        }
        this.reader.seek_set(pos);
        return this.get_token_backslash_common();
    }
    else if (c == "^") {
        return ["^", "\\^"];
    }
    else if (c == "$") {
        return ["$", "\\$"];
    }
    return [c, c];
}

RegexpParser.prototype.get_token_very_nomagic = function() {
    if (this.isend(this.reader.peek())) {
        return ["<END>", "<END>"];
    }
    var c = this.reader.get();
    if (c == "\\") {
        var pos = this.reader.tell();
        var c = this.reader.get();
        if (c == "*") {
            return ["\\*", "\\*"];
        }
        else if (c == "+") {
            return ["\\+", "\\+"];
        }
        else if (c == "=") {
            return ["\\=", "\\="];
        }
        else if (c == "?") {
            return ["\\?", "\\?"];
        }
        else if (c == "{") {
            return this.get_token_brace("\\{");
        }
        else if (c == "@") {
            return this.get_token_at("\\@");
        }
        else if (c == "^") {
            return ["\\^", "\\^"];
        }
        else if (c == "$") {
            return ["\\$", "\\$"];
        }
        else if (c == "<") {
            return ["\\<", "\\<"];
        }
        else if (c == ">") {
            return ["\\>", "\\>"];
        }
        else if (c == "%") {
            return this.get_token_percent("\\%");
        }
        else if (c == "~") {
            return ["\\~", "\\~"];
        }
        else if (c == "[") {
            return this.get_token_sq("\\[");
        }
        else if (c == "|") {
            return ["\\|", "\\|"];
        }
        else if (c == "&") {
            return ["\\&", "\\&"];
        }
        else if (c == "(") {
            return ["\\(", "\\("];
        }
        else if (c == ")") {
            return ["\\)", "\\)"];
        }
        this.reader.seek_set(pos);
        return this.get_token_backslash_common();
    }
    return [c, c];
}

RegexpParser.prototype.get_token_backslash_common = function() {
    var cclass = "iIkKfFpPsSdDxXoOwWhHaAlLuU";
    var c = this.reader.get();
    if (c == "\\") {
        return ["\\\\", "\\\\"];
    }
    else if (viml_stridx(cclass, c) != -1) {
        return ["\\" + c, "\\" + c];
    }
    else if (c == "_") {
        var epos = this.reader.getpos();
        var c = this.reader.get();
        if (viml_stridx(cclass, c) != -1) {
            return ["\\_" + c, "\\_ . c"];
        }
        else if (c == "^") {
            return ["\\_^", "\\_^"];
        }
        else if (c == "$") {
            return ["\\_$", "\\_$"];
        }
        else if (c == ".") {
            return ["\\_.", "\\_."];
        }
        else if (c == "[") {
            return this.get_token_sq("\\_[");
        }
        throw Err("E63: invalid use of \\_", epos);
    }
    else if (viml_stridx("etrb", c) != -1) {
        return ["\\" + c, "\\" + c];
    }
    else if (viml_stridx("123456789", c) != -1) {
        return ["\\" + c, "\\" + c];
    }
    else if (c == "z") {
        var epos = this.reader.getpos();
        var c = this.reader.get();
        if (viml_stridx("123456789", c) != -1) {
            return ["\\z" + c, "\\z" + c];
        }
        else if (c == "s") {
            return ["\\zs", "\\zs"];
        }
        else if (c == "e") {
            return ["\\ze", "\\ze"];
        }
        else if (c == "(") {
            return ["\\z(", "\\z("];
        }
        throw Err("E68: Invalid character after \\z", epos);
    }
    else if (viml_stridx("cCmMvVZ", c) != -1) {
        return ["\\" + c, "\\" + c];
    }
    else if (c == "%") {
        var epos = this.reader.getpos();
        var c = this.reader.get();
        if (c == "d") {
            var r = this.getdecchrs();
            if (r != "") {
                return ["\\%d" + r, "\\%d" + r];
            }
        }
        else if (c == "o") {
            var r = this.getoctchrs();
            if (r != "") {
                return ["\\%o" + r, "\\%o" + r];
            }
        }
        else if (c == "x") {
            var r = this.gethexchrs(2);
            if (r != "") {
                return ["\\%x" + r, "\\%x" + r];
            }
        }
        else if (c == "u") {
            var r = this.gethexchrs(4);
            if (r != "") {
                return ["\\%u" + r, "\\%u" + r];
            }
        }
        else if (c == "U") {
            var r = this.gethexchrs(8);
            if (r != "") {
                return ["\\%U" + r, "\\%U" + r];
            }
        }
        throw Err("E678: Invalid character after \\%[dxouU]", epos);
    }
    return ["\\" + c, c];
}

// \{}
RegexpParser.prototype.get_token_brace = function(pre) {
    var r = "";
    var minus = "";
    var comma = "";
    var n = "";
    var m = "";
    if (this.reader.p(0) == "-") {
        var minus = this.reader.get();
        r += minus;
    }
    if (isdigit(this.reader.p(0))) {
        var n = this.reader.read_digit();
        r += n;
    }
    if (this.reader.p(0) == ",") {
        var comma = this.rader.get();
        r += comma;
    }
    if (isdigit(this.reader.p(0))) {
        var m = this.reader.read_digit();
        r += m;
    }
    if (this.reader.p(0) == "\\") {
        r += this.reader.get();
    }
    if (this.reader.p(0) != "}") {
        throw Err("E554: Syntax error in \\{...}", this.reader.getpos());
    }
    this.reader.get();
    return [pre + r, "\\{" + minus + n + comma + m + "}"];
}

// \[]
RegexpParser.prototype.get_token_sq = function(pre) {
    var start = this.reader.tell();
    var r = "";
    // Complement of range
    if (this.reader.p(0) == "^") {
        r += this.reader.get();
    }
    // At the start ']' and '-' mean the literal character.
    if (this.reader.p(0) == "]" || this.reader.p(0) == "-") {
        r += this.reader.get();
    }
    while (TRUE) {
        var startc = 0;
        var c = this.reader.p(0);
        if (this.isend(c)) {
            // If there is no matching ']', we assume the '[' is a normal character.
            this.reader.seek_set(start);
            return [pre, "["];
        }
        else if (c == "]") {
            this.reader.seek_cur(1);
            return [pre + r + "]", "\\[" + r + "]"];
        }
        else if (c == "[") {
            var e = this.get_token_sq_char_class();
            if (e == "") {
                var e = this.get_token_sq_equi_class();
                if (e == "") {
                    var e = this.get_token_sq_coll_element();
                    if (e == "") {
                        var __tmp = this.get_token_sq_c();
                        var e = __tmp[0];
                        var startc = __tmp[1];
                    }
                }
            }
            r += e;
        }
        else {
            var __tmp = this.get_token_sq_c();
            var e = __tmp[0];
            var startc = __tmp[1];
            r += e;
        }
        if (startc != 0 && this.reader.p(0) == "-" && !this.isend(this.reader.p(1)) && !(this.reader.p(1) == "\\" && this.reader.p(2) == "n")) {
            this.reader.seek_cur(1);
            r += "-";
            var c = this.reader.p(0);
            if (c == "[") {
                var e = this.get_token_sq_coll_element();
                if (e != "") {
                    var endc = viml_char2nr(e[2]);
                }
                else {
                    var __tmp = this.get_token_sq_c();
                    var e = __tmp[0];
                    var endc = __tmp[1];
                }
                r += e;
            }
            else {
                var __tmp = this.get_token_sq_c();
                var e = __tmp[0];
                var endc = __tmp[1];
                r += e;
            }
            if (startc > endc || endc > startc + 256) {
                throw Err("E16: Invalid range", this.reader.getpos());
            }
        }
    }
}

// [c]
RegexpParser.prototype.get_token_sq_c = function() {
    var c = this.reader.p(0);
    if (c == "\\") {
        this.reader.seek_cur(1);
        var c = this.reader.p(0);
        if (c == "n") {
            this.reader.seek_cur(1);
            return ["\\n", 0];
        }
        else if (c == "r") {
            this.reader.seek_cur(1);
            return ["\\r", 13];
        }
        else if (c == "t") {
            this.reader.seek_cur(1);
            return ["\\t", 9];
        }
        else if (c == "e") {
            this.reader.seek_cur(1);
            return ["\\e", 27];
        }
        else if (c == "b") {
            this.reader.seek_cur(1);
            return ["\\b", 8];
        }
        else if (viml_stridx("]^-\\", c) != -1) {
            this.reader.seek_cur(1);
            return ["\\" + c, viml_char2nr(c)];
        }
        else if (viml_stridx("doxuU", c) != -1) {
            var __tmp = this.get_token_sq_coll_char();
            var c = __tmp[0];
            var n = __tmp[1];
            return [c, n];
        }
        else {
            return ["\\", viml_char2nr("\\")];
        }
    }
    else if (c == "-") {
        this.reader.seek_cur(1);
        return ["-", viml_char2nr("-")];
    }
    else {
        this.reader.seek_cur(1);
        return [c, viml_char2nr(c)];
    }
}

// [\d123]
RegexpParser.prototype.get_token_sq_coll_char = function() {
    var pos = this.reader.tell();
    var c = this.reader.get();
    if (c == "d") {
        var r = this.getdecchrs();
        var n = viml_str2nr(r, 10);
    }
    else if (c == "o") {
        var r = this.getoctchrs();
        var n = viml_str2nr(r, 8);
    }
    else if (c == "x") {
        var r = this.gethexchrs(2);
        var n = viml_str2nr(r, 16);
    }
    else if (c == "u") {
        var r = this.gethexchrs(4);
        var n = viml_str2nr(r, 16);
    }
    else if (c == "U") {
        var r = this.gethexchrs(8);
        var n = viml_str2nr(r, 16);
    }
    else {
        var r = "";
    }
    if (r == "") {
        this.reader.seek_set(pos);
        return "\\";
    }
    return ["\\" + c + r, n];
}

// [[.a.]]
RegexpParser.prototype.get_token_sq_coll_element = function() {
    if (this.reader.p(0) == "[" && this.reader.p(1) == "." && !this.isend(this.reader.p(2)) && this.reader.p(3) == "." && this.reader.p(4) == "]") {
        return this.reader.getn(5);
    }
    return "";
}

// [[=a=]]
RegexpParser.prototype.get_token_sq_equi_class = function() {
    if (this.reader.p(0) == "[" && this.reader.p(1) == "=" && !this.isend(this.reader.p(2)) && this.reader.p(3) == "=" && this.reader.p(4) == "]") {
        return this.reader.getn(5);
    }
    return "";
}

// [[:alpha:]]
RegexpParser.prototype.get_token_sq_char_class = function() {
    var class_names = ["alnum", "alpha", "blank", "cntrl", "digit", "graph", "lower", "print", "punct", "space", "upper", "xdigit", "tab", "return", "backspace", "escape"];
    var pos = this.reader.tell();
    if (this.reader.p(0) == "[" && this.reader.p(1) == ":") {
        this.reader.seek_cur(2);
        var r = this.reader.read_alpha();
        if (this.reader.p(0) == ":" && this.reader.p(1) == "]") {
            this.reader.seek_cur(2);
            var __c15 = class_names;
            for (var __i15 = 0; __i15 < __c15.length; ++__i15) {
                var name = __c15[__i15];
                if (r == name) {
                    return "[:" + name + ":]";
                }
            }
        }
    }
    this.reader.seek_set(pos);
    return "";
}

// \@...
RegexpParser.prototype.get_token_at = function(pre) {
    var epos = this.reader.getpos();
    var c = this.reader.get();
    if (c == ">") {
        return [pre + ">", "\\@>"];
    }
    else if (c == "=") {
        return [pre + "=", "\\@="];
    }
    else if (c == "!") {
        return [pre + "!", "\\@!"];
    }
    else if (c == "<") {
        var c = this.reader.get();
        if (c == "=") {
            return [pre + "<=", "\\@<="];
        }
        else if (c == "!") {
            return [pre + "<!", "\\@<!"];
        }
    }
    throw Err("E64: @ follows nothing", epos);
}

// \%...
RegexpParser.prototype.get_token_percent = function(pre) {
    var c = this.reader.get();
    if (c == "^") {
        return [pre + "^", "\\%^"];
    }
    else if (c == "$") {
        return [pre + "$", "\\%$"];
    }
    else if (c == "V") {
        return [pre + "V", "\\%V"];
    }
    else if (c == "#") {
        return [pre + "#", "\\%#"];
    }
    else if (c == "[") {
        return this.get_token_percent_sq(pre + "[");
    }
    else if (c == "(") {
        return [pre + "(", "\\%("];
    }
    else {
        return this.get_token_mlcv(pre);
    }
}

// \%[]
RegexpParser.prototype.get_token_percent_sq = function(pre) {
    var r = "";
    while (TRUE) {
        var c = this.reader.peek();
        if (this.isend(c)) {
            throw Err("E69: Missing ] after \\%[", this.reader.getpos());
        }
        else if (c == "]") {
            if (r == "") {
                throw Err("E70: Empty \\%[", this.reader.getpos());
            }
            this.reader.seek_cur(1);
            break;
        }
        this.reader.seek_cur(1);
        r += c;
    }
    return [pre + r + "]", "\\%[" + r + "]"];
}

// \%'m \%l \%c \%v
RegexpParser.prototype.get_token_mlvc = function(pre) {
    var r = "";
    var cmp = "";
    if (this.reader.p(0) == "<" || this.reader.p(0) == ">") {
        var cmp = this.reader.get();
        r += cmp;
    }
    if (this.reader.p(0) == "'") {
        r += this.reader.get();
        var c = this.reader.p(0);
        if (this.isend(c)) {
            // FIXME: Should be error?  Vim allow this.
            var c = "";
        }
        else {
            var c = this.reader.get();
        }
        return [pre + r + c, "\\%" + cmp + "'" + c];
    }
    else if (isdigit(this.reader.p(0))) {
        var d = this.reader.read_digit();
        r += d;
        var c = this.reader.p(0);
        if (c == "l") {
            this.reader.get();
            return [pre + r + "l", "\\%" + cmp + d + "l"];
        }
        else if (c == "c") {
            this.reader.get();
            return [pre + r + "c", "\\%" + cmp + d + "c"];
        }
        else if (c == "v") {
            this.reader.get();
            return [pre + r + "v", "\\%" + cmp + d + "v"];
        }
    }
    throw Err("E71: Invalid character after %", this.reader.getpos());
}

RegexpParser.prototype.getdecchrs = function() {
    return this.reader.read_digit();
}

RegexpParser.prototype.getoctchrs = function() {
    return this.reader.read_odigit();
}

RegexpParser.prototype.gethexchrs = function(n) {
    var r = "";
    var __c16 = viml_range(n);
    for (var __i16 = 0; __i16 < __c16.length; ++__i16) {
        var i = __c16[__i16];
        var c = this.reader.peek();
        if (!isxdigit(c)) {
            break;
        }
        r += this.reader.get();
    }
    return r;
}

if (__webpack_require__.c[__webpack_require__.s] === module) {
  main();
}
else {
  module.exports = {
    VimLParser: VimLParser,
    StringReader: StringReader,
    Compiler: Compiler
  };
}


/***/ }),
/* 72 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.notIdentifierPattern = exports.expandPattern = exports.featurePattern = exports.commandPattern = exports.notFunctionPattern = exports.optionPattern = exports.builtinVariablePattern = exports.funcArgIdentifierPattern = exports.localIdentifierPattern = exports.scriptIdentifierPattern = exports.normalIdentifierPattern = exports.globalIdentifierPattern = exports.autocmdPattern = exports.highlightValuePattern = exports.highlightPattern = exports.highlightLinkPattern = exports.mapCommandPattern = exports.colorschemePattern = exports.wordNextPattern = exports.wordPrePattern = exports.builtinFunctionPattern = exports.keywordPattern = exports.commentPattern = exports.errorLinePattern = void 0;
exports.errorLinePattern = /[^:]+:\s*(.+?):\s*line\s*([0-9]+)\s*col\s*([0-9]+)/;
exports.commentPattern = /^[ \t]*("|')/;
exports.keywordPattern = /[\w#&$<>.:]/;
exports.builtinFunctionPattern = /^((<SID>|\b(v|g|b|s|l|a):)?[\w#&]+)[ \t]*\([^)]*\)/;
exports.wordPrePattern = /^.*?(((<SID>|\b(v|g|b|s|l|a):)?[\w#&$.]+)|(<SID>|<SID|<SI|<S|<|\b(v|g|b|s|l|a):))$/;
exports.wordNextPattern = /^((SID>|ID>|D>|>|<SID>|\b(v|g|b|s|l|a):)?[\w#&$.]+|(:[\w#&$.]+)).*?(\r\n|\r|\n)?$/;
exports.colorschemePattern = /\bcolorscheme[ \t]+\w*$/;
exports.mapCommandPattern = /^([ \t]*(\[ \t]*)?)\w*map[ \t]+/;
exports.highlightLinkPattern = /^[ \t]*(hi|highlight)[ \t]+link([ \t]+[^ \t]+)*[ \t]*$/;
exports.highlightPattern = /^[ \t]*(hi|highlight)([ \t]+[^ \t]+)*[ \t]*$/;
exports.highlightValuePattern = /^[ \t]*(hi|highlight)([ \t]+[^ \t]+)*[ \t]+([^ \t=]+)=[^ \t=]*$/;
exports.autocmdPattern = /^[ \t]*(au|autocmd)!?[ \t]+([^ \t,]+,)*[^ \t,]*$/;
exports.globalIdentifierPattern = /^((g|b):\w+(\.\w+)*|(\w+#)+\w*)$/;
exports.normalIdentifierPattern = /^([a-zA-Z_]\w*(\.\w+)*)$/;
exports.scriptIdentifierPattern = /^((s:|<SID>)\w+(\.\w+)*)$/;
exports.localIdentifierPattern = /^(l:\w+(\.\w+)*)$/;
exports.funcArgIdentifierPattern = /^(a:\w+(\.\w+)*)$/;
exports.builtinVariablePattern = [
    /\bv:\w*$/,
];
exports.optionPattern = [
    /(^|[ \t]+)&\w*$/,
    /(^|[ \t]+)set(l|local|g|global)?[ \t]+\w+$/,
];
exports.notFunctionPattern = [
    /^[ \t]*\\$/,
    /^[ \t]*\w+$/,
    /^[ \t]*"/,
    /(let|set|colorscheme)[ \t][^ \t]*$/,
    /[^([,\\ \t\w#>]\w*$/,
    /^[ \t]*(hi|highlight)([ \t]+link)?([ \t]+[^ \t]+)*[ \t]*$/,
    exports.autocmdPattern,
];
exports.commandPattern = [
    /(^|[ \t]):\w+$/,
    /^[ \t]*\w+$/,
    /:?silent!?[ \t]\w+/,
];
exports.featurePattern = [
    /\bhas\([ \t]*["']\w*/,
];
exports.expandPattern = [
    /\bexpand\(['"]<\w*$/,
    /\bexpand\([ \t]*['"]\w*$/,
];
exports.notIdentifierPattern = [
    exports.commentPattern,
    /("|'):\w*$/,
    /^[ \t]*\\$/,
    /^[ \t]*call[ \t]+[^ \t()]*$/,
    /('|"|#|&|\$|<)\w*$/,
];


/***/ }),
/* 73 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var constant_1 = __webpack_require__(64);
var conf;
exports.default = {
    init: function (config) {
        conf = config;
    },
    changeByKey: function (key, value) {
        if (conf) {
            conf[key] = value;
        }
    },
    get isNeovim() {
        return conf && conf.isNeovim || false;
    },
    get iskeyword() {
        return conf && conf.iskeyword || "";
    },
    get vimruntime() {
        return conf && conf.vimruntime || "";
    },
    get runtimepath() {
        return conf && conf.runtimepath || [];
    },
    get diagnostic() {
        return conf && conf.diagnostic || {
            enable: true,
        };
    },
    get snippetSupport() {
        return conf && conf.snippetSupport || false;
    },
    get suggest() {
        return conf && conf.suggest || {
            fromRuntimepath: false,
            fromVimruntime: true,
        };
    },
    get indexes() {
        var defaults = {
            runtimepath: true,
            gap: 100,
            count: 1,
            projectRootPatterns: constant_1.projectRootPatterns,
        };
        if (!conf || !conf.indexes) {
            return defaults;
        }
        if (conf.indexes.gap !== undefined) {
            defaults.gap = conf.indexes.gap;
        }
        if (conf.indexes.count !== undefined) {
            defaults.count = conf.indexes.count;
        }
        if (conf.indexes.projectRootPatterns !== undefined
            && Array.isArray(conf.indexes.projectRootPatterns)
            && conf.indexes.projectRootPatterns.length) {
            defaults.projectRootPatterns = conf.indexes.projectRootPatterns;
        }
        return defaults;
    },
    get capabilities() {
        return conf && conf.capabilities;
    }
};


/***/ }),
/* 74 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.documents = void 0;
var vscode_languageserver_1 = __webpack_require__(2);
var vscode_languageserver_textdocument_1 = __webpack_require__(75);
// text document manager
exports.documents = new vscode_languageserver_1.TextDocuments(vscode_languageserver_textdocument_1.TextDocument);


/***/ }),
/* 75 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextDocument": () => (/* binding */ TextDocument)
/* harmony export */ });
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var FullTextDocument = /** @class */ (function () {
    function FullTextDocument(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    Object.defineProperty(FullTextDocument.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "languageId", {
        get: function () {
            return this._languageId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: true,
        configurable: true
    });
    FullTextDocument.prototype.getText = function (range) {
        if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    };
    FullTextDocument.prototype.update = function (changes, version) {
        for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {
            var change = changes_1[_i];
            if (FullTextDocument.isIncremental(change)) {
                // makes sure start is before end
                var range = getWellformedRange(change.range);
                // update content
                var startOffset = this.offsetAt(range.start);
                var endOffset = this.offsetAt(range.end);
                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                // update the offsets
                var startLine = Math.max(range.start.line, 0);
                var endLine = Math.max(range.end.line, 0);
                var lineOffsets = this._lineOffsets;
                var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                if (endLine - startLine === addedLineOffsets.length) {
                    for (var i = 0, len = addedLineOffsets.length; i < len; i++) {
                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                    }
                }
                else {
                    if (addedLineOffsets.length < 10000) {
                        lineOffsets.splice.apply(lineOffsets, [startLine + 1, endLine - startLine].concat(addedLineOffsets));
                    }
                    else { // avoid too many arguments for splice
                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                    }
                }
                var diff = change.text.length - (endOffset - startOffset);
                if (diff !== 0) {
                    for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                        lineOffsets[i] = lineOffsets[i] + diff;
                    }
                }
            }
            else if (FullTextDocument.isFull(change)) {
                this._content = change.text;
                this._lineOffsets = undefined;
            }
            else {
                throw new Error('Unknown change event received');
            }
        }
        this._version = version;
    };
    FullTextDocument.prototype.getLineOffsets = function () {
        if (this._lineOffsets === undefined) {
            this._lineOffsets = computeLineOffsets(this._content, true);
        }
        return this._lineOffsets;
    };
    FullTextDocument.prototype.positionAt = function (offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
            return { line: 0, character: offset };
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        var line = low - 1;
        return { line: line, character: offset - lineOffsets[line] };
    };
    FullTextDocument.prototype.offsetAt = function (position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
        get: function () {
            return this.getLineOffsets().length;
        },
        enumerable: true,
        configurable: true
    });
    FullTextDocument.isIncremental = function (event) {
        var candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range !== undefined &&
            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
    };
    FullTextDocument.isFull = function (event) {
        var candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
    };
    return FullTextDocument;
}());
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new text document.
     *
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param version The document's initial version number.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Updates a TextDocument by modifing its content.
     *
     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.
     * @param changes the changes to apply to the document.
     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.
     *
     */
    function update(document, changes, version) {
        if (document instanceof FullTextDocument) {
            document.update(changes, version);
            return document;
        }
        else {
            throw new Error('TextDocument.update: document must be created by TextDocument.create');
        }
    }
    TextDocument.update = update;
    function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort(edits.map(getWellformedEdit), function (a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        var lastModifiedOffset = 0;
        var spans = [];
        for (var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++) {
            var e = sortedEdits_1[_i];
            var startOffset = document.offsetAt(e.range.start);
            if (startOffset < lastModifiedOffset) {
                throw new Error('Overlapping edit');
            }
            else if (startOffset > lastModifiedOffset) {
                spans.push(text.substring(lastModifiedOffset, startOffset));
            }
            if (e.newText.length) {
                spans.push(e.newText);
            }
            lastModifiedOffset = document.offsetAt(e.range.end);
        }
        spans.push(text.substr(lastModifiedOffset));
        return spans.join('');
    }
    TextDocument.applyEdits = applyEdits;
})(TextDocument || (TextDocument = {}));
function mergeSort(data, compare) {
    if (data.length <= 1) {
        // sorted
        return data;
    }
    var p = (data.length / 2) | 0;
    var left = data.slice(0, p);
    var right = data.slice(p);
    mergeSort(left, compare);
    mergeSort(right, compare);
    var leftIdx = 0;
    var rightIdx = 0;
    var i = 0;
    while (leftIdx < left.length && rightIdx < right.length) {
        var ret = compare(left[leftIdx], right[rightIdx]);
        if (ret <= 0) {
            // smaller_equal -> take left to preserve order
            data[i++] = left[leftIdx++];
        }
        else {
            // greater -> take right
            data[i++] = right[rightIdx++];
        }
    }
    while (leftIdx < left.length) {
        data[i++] = left[leftIdx++];
    }
    while (rightIdx < right.length) {
        data[i++] = right[rightIdx++];
    }
    return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset) {
    if (textOffset === void 0) { textOffset = 0; }
    var result = isAtLineStart ? [textOffset] : [];
    for (var i = 0; i < text.length; i++) {
        var ch = text.charCodeAt(i);
        if (ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */) {
            if (ch === 13 /* CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* LineFeed */) {
                i++;
            }
            result.push(textOffset + i + 1);
        }
    }
    return result;
}
function getWellformedRange(range) {
    var start = range.start;
    var end = range.end;
    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {
        return { start: end, end: start };
    }
    return range;
}
function getWellformedEdit(textEdit) {
    var range = getWellformedRange(textEdit.range);
    if (range !== textEdit.range) {
        return { newText: textEdit.newText, range: range };
    }
    return textEdit;
}


/***/ }),
/* 76 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var patterns_1 = __webpack_require__(72);
var builtin_1 = __webpack_require__(77);
var provider_1 = __webpack_require__(159);
function provider(line) {
    if (patterns_1.autocmdPattern.test(line)) {
        return builtin_1.builtinDocs.getVimAutocmds().filter(function (item) {
            return line.indexOf(item.label) === -1;
        });
    }
    return [];
}
provider_1.useProvider(provider);


/***/ }),
/* 77 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.builtinDocs = void 0;
/*
 * vim builtin completion items
 *
 * 1. functions
 * 2. options
 * 3. variables
 * 4. commands
 * 5. has features
 * 6. expand Keyword
 * 7. map args
 */
var fast_glob_1 = __importDefault(__webpack_require__(78));
var path_1 = __importDefault(__webpack_require__(23));
var vscode_languageserver_1 = __webpack_require__(2);
var logger_1 = __importDefault(__webpack_require__(155));
var patterns_1 = __webpack_require__(72);
var util_1 = __webpack_require__(66);
var builtin_docs_json_1 = __importDefault(__webpack_require__(158));
var config_1 = __importDefault(__webpack_require__(73));
var log = logger_1.default("builtin");
var Builtin = /** @class */ (function () {
    function Builtin() {
        // completion items
        this.vimPredefinedVariablesItems = [];
        this.vimOptionItems = [];
        this.vimBuiltinFunctionItems = [];
        this.vimBuiltinFunctionMap = {};
        this.vimCommandItems = [];
        this.vimMapArgsItems = [];
        this.vimFeatureItems = [];
        this.vimAutocmdItems = [];
        this.expandKeywordItems = [];
        this.colorschemeItems = [];
        this.highlightArgKeys = [];
        this.highlightArgValues = {};
        // signature help
        this.vimBuiltFunctionSignatureHelp = {};
        // documents
        this.vimBuiltFunctionDocuments = {};
        this.vimOptionDocuments = {};
        this.vimPredefinedVariableDocuments = {};
        this.vimCommandDocuments = {};
        this.vimFeatureDocuments = {};
        this.expandKeywordDocuments = {};
    }
    Builtin.prototype.init = function () {
        this.start();
    };
    Builtin.prototype.getPredefinedVimVariables = function () {
        return this.vimPredefinedVariablesItems;
    };
    Builtin.prototype.getVimOptions = function () {
        return this.vimOptionItems;
    };
    Builtin.prototype.getBuiltinVimFunctions = function () {
        return this.vimBuiltinFunctionItems;
    };
    Builtin.prototype.isBuiltinFunction = function (label) {
        return this.vimBuiltinFunctionMap[label];
    };
    Builtin.prototype.getExpandKeywords = function () {
        return this.expandKeywordItems;
    };
    Builtin.prototype.getVimCommands = function () {
        return this.vimCommandItems;
    };
    Builtin.prototype.getVimMapArgs = function () {
        return this.vimMapArgsItems;
    };
    Builtin.prototype.getVimFeatures = function () {
        return this.vimFeatureItems;
    };
    Builtin.prototype.getVimAutocmds = function () {
        return this.vimAutocmdItems;
    };
    Builtin.prototype.getColorschemes = function () {
        return this.colorschemeItems;
    };
    Builtin.prototype.getHighlightArgKeys = function () {
        return this.highlightArgKeys;
    };
    Builtin.prototype.getHighlightArgValues = function () {
        return this.highlightArgValues;
    };
    Builtin.prototype.getSignatureHelpByName = function (name, idx) {
        var params = this.vimBuiltFunctionSignatureHelp[name];
        if (params) {
            return {
                signatures: [{
                        label: name + "(" + params[0] + ")" + (params[1] ? ": " + params[1] : ""),
                        documentation: this.formatVimDocument(this.vimBuiltFunctionDocuments[name]),
                        parameters: params[0].replace(/[\[\]]/g, "").split(",").map(function (param) {
                            return {
                                label: param.trim(),
                            };
                        }),
                    }],
                activeSignature: 0,
                activeParameter: idx,
            };
        }
        return;
    };
    Builtin.prototype.getDocumentByCompletionItem = function (params) {
        var kind = params.kind;
        switch (kind) {
            case vscode_languageserver_1.CompletionItemKind.Variable:
                if (!this.vimPredefinedVariableDocuments[params.label]) {
                    return params;
                }
                return __assign(__assign({}, params), { documentation: this.formatVimDocument(this.vimPredefinedVariableDocuments[params.label]) });
            case vscode_languageserver_1.CompletionItemKind.Property:
                if (!this.vimOptionDocuments[params.label]) {
                    return params;
                }
                return __assign(__assign({}, params), { documentation: this.formatVimDocument(this.vimOptionDocuments[params.label]) });
            case vscode_languageserver_1.CompletionItemKind.Function:
                if (!this.vimBuiltFunctionDocuments[params.label]) {
                    return params;
                }
                return __assign(__assign({}, params), { documentation: this.formatVimDocument(this.vimBuiltFunctionDocuments[params.label]) });
            case vscode_languageserver_1.CompletionItemKind.EnumMember:
                if (!this.vimFeatureDocuments[params.label]) {
                    return params;
                }
                return __assign(__assign({}, params), { documentation: this.formatVimDocument(this.vimFeatureDocuments[params.label]) });
            case vscode_languageserver_1.CompletionItemKind.Operator:
                if (!this.vimCommandDocuments[params.label]) {
                    return params;
                }
                return __assign(__assign({}, params), { documentation: this.formatVimDocument(this.vimCommandDocuments[params.label]) });
            default:
                return params;
        }
    };
    Builtin.prototype.getHoverDocument = function (name, pre, next) {
        // builtin variables
        if (util_1.isSomeMatchPattern(patterns_1.builtinVariablePattern, pre) && this.vimPredefinedVariableDocuments[name]) {
            return {
                contents: this.formatVimDocument(this.vimPredefinedVariableDocuments[name]),
            };
            // options
        }
        else if (util_1.isSomeMatchPattern(patterns_1.optionPattern, pre)
            && (this.vimOptionDocuments[name] || this.vimOptionDocuments[name.slice(1)])) {
            return {
                contents: this.formatVimDocument(this.vimOptionDocuments[name] || this.vimOptionDocuments[name.slice(1)]),
            };
            // builtin functions
        }
        else if (patterns_1.builtinFunctionPattern.test(next) && this.vimBuiltFunctionDocuments[name]) {
            return {
                contents: this.formatVimDocument(this.vimBuiltFunctionDocuments[name]),
            };
            // has features
        }
        else if (util_1.isSomeMatchPattern(patterns_1.featurePattern, pre) && this.vimFeatureDocuments[name]) {
            return {
                contents: this.formatVimDocument(this.vimFeatureDocuments[name]),
            };
            // expand Keywords
        }
        else if (util_1.isSomeMatchPattern(patterns_1.expandPattern, pre) && this.expandKeywordDocuments["<" + name + ">"]) {
            return {
                contents: this.formatVimDocument(this.expandKeywordDocuments["<" + name + ">"]),
            };
            // command
        }
        else if (util_1.isSomeMatchPattern(patterns_1.commandPattern, pre) && this.vimCommandDocuments[name]) {
            return {
                contents: this.formatVimDocument(this.vimCommandDocuments[name]),
            };
        }
    };
    Builtin.prototype.start = function () {
        return __awaiter(this, void 0, void 0, function () {
            var runtimepath, data;
            var _this = this;
            return __generator(this, function (_a) {
                runtimepath = config_1.default.runtimepath;
                // get colorschemes
                if (runtimepath) {
                    this.resolveColorschemes(runtimepath);
                }
                // get map args
                this.resolveMapArgs();
                // get highlight arg keys
                this.resolveHighlightArgKeys();
                // get highlight arg values
                this.resolveHighlightArgValues();
                try {
                    data = builtin_docs_json_1.default;
                    this.vimBuiltinFunctionItems = data.completionItems.functions;
                    this.vimBuiltinFunctionItems.forEach(function (item) {
                        if (!_this.vimBuiltinFunctionMap[item.label]) {
                            _this.vimBuiltinFunctionMap[item.label] = true;
                        }
                    });
                    this.vimBuiltFunctionDocuments = data.documents.functions;
                    this.vimCommandItems = data.completionItems.commands;
                    this.vimCommandDocuments = data.documents.commands;
                    this.vimPredefinedVariablesItems = data.completionItems.variables;
                    this.vimPredefinedVariableDocuments = data.documents.variables;
                    this.vimOptionItems = data.completionItems.options;
                    this.vimOptionDocuments = data.documents.options;
                    this.vimFeatureItems = data.completionItems.features;
                    this.vimAutocmdItems = data.completionItems.autocmds;
                    this.vimFeatureDocuments = data.documents.features;
                    this.expandKeywordItems = data.completionItems.expandKeywords;
                    this.expandKeywordDocuments = data.documents.expandKeywords;
                    this.vimBuiltFunctionSignatureHelp = data.signatureHelp;
                }
                catch (error) {
                    log.error("[vimls]: parse docs/builtin-doc.json fail => " + (error.message || error));
                }
                return [2 /*return*/];
            });
        });
    };
    // format vim document to markdown
    Builtin.prototype.formatVimDocument = function (document) {
        var indent = 0;
        return {
            kind: vscode_languageserver_1.MarkupKind.Markdown,
            value: __spreadArray(__spreadArray([
                "```help"
            ], document.map(function (line) {
                if (indent === 0) {
                    var m = line.match(/^([ \t]+)/);
                    if (m) {
                        indent = m[1].length;
                    }
                }
                return line.replace(new RegExp("^[ \\t]{" + indent + "}", "g"), "").replace(/\t/g, "  ");
            })), [
                "```",
            ]).join("\n"),
        };
    };
    Builtin.prototype.resolveMapArgs = function () {
        this.vimMapArgsItems = ["<buffer>", "<nowait>", "<silent>", "<script>", "<expr>", "<unique>"]
            .map(function (item) {
            return {
                label: item,
                kind: vscode_languageserver_1.CompletionItemKind.EnumMember,
                documentation: "",
                insertText: item,
                insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
            };
        });
    };
    Builtin.prototype.resolveColorschemes = function (runtimepath) {
        return __awaiter(this, void 0, void 0, function () {
            var list, glob, colorschemes, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        list = runtimepath;
                        if (config_1.default.vimruntime) {
                            list.push(config_1.default.vimruntime);
                        }
                        glob = runtimepath.map(function (p) { return path_1.default.join(p.trim(), "colors/*.vim"); });
                        colorschemes = [];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, fast_glob_1.default(glob, { onlyFiles: false, deep: 0 })];
                    case 2:
                        colorschemes = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        error_1 = _a.sent();
                        log.warn([
                            "Index Colorschemes Error: " + JSON.stringify(glob),
                            "Error => " + (error_1.stack || error_1.message || error_1),
                        ].join("\n"));
                        return [3 /*break*/, 4];
                    case 4:
                        this.colorschemeItems = colorschemes.map(function (p) {
                            var label = path_1.default.basename(p, ".vim");
                            var item = {
                                label: label,
                                kind: vscode_languageserver_1.CompletionItemKind.EnumMember,
                                insertText: label,
                                insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
                            };
                            return item;
                        });
                        return [2 /*return*/];
                }
            });
        });
    };
    Builtin.prototype.resolveHighlightArgKeys = function () {
        this.highlightArgKeys = [
            "cterm",
            "start",
            "stop",
            "ctermfg",
            "ctermbg",
            "gui",
            "font",
            "guifg",
            "guibg",
            "guisp",
            "blend",
        ]
            .map(function (item) {
            return {
                label: item,
                kind: vscode_languageserver_1.CompletionItemKind.EnumMember,
                documentation: "",
                insertText: item + "=${0}",
                insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
            };
        });
    };
    Builtin.prototype.resolveHighlightArgValues = function () {
        var values = {
            "cterm": ["bold", "underline", "undercurl", "reverse", "inverse", "italic", "standout", "NONE"],
            "ctermfg ctermbg": [
                "Black",
                "DarkBlue",
                "DarkGreen",
                "DarkCyan",
                "DarkRed",
                "DarkMagenta",
                "Brown", "DarkYellow",
                "LightGray", "LightGrey", "Gray", "Grey",
                "DarkGray", "DarkGrey",
                "Blue", "LightBlue",
                "Green", "LightGreen",
                "Cyan", "LightCyan",
                "Red", "LightRed",
                "Magenta", "LightMagenta",
                "Yellow", "LightYellow",
                "White",
            ],
            "guifg guibg guisp": [
                "NONE",
                "bg",
                "background",
                "fg",
                "foreground",
                "Red", "LightRed", "DarkRed",
                "Green", "LightGreen", "DarkGreen", "SeaGreen",
                "Blue", "LightBlue", "DarkBlue", "SlateBlue",
                "Cyan", "LightCyan", "DarkCyan",
                "Magenta", "LightMagenta", "DarkMagenta",
                "Yellow", "LightYellow", "Brown", "DarkYellow",
                "Gray", "LightGray", "DarkGray",
                "Black", "White",
                "Orange", "Purple", "Violet",
            ],
        };
        var argValues = {};
        Object.keys(values).forEach(function (key) {
            var items = values[key].map(function (val) { return ({
                label: val,
                kind: vscode_languageserver_1.CompletionItemKind.EnumMember,
                documentation: "",
                insertText: val,
                insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
            }); });
            key.split(" ").forEach(function (name) {
                argValues[name] = items;
            });
        });
        this.highlightArgValues = argValues;
    };
    return Builtin;
}());
exports.builtinDocs = new Builtin();


/***/ }),
/* 78 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const taskManager = __webpack_require__(79);
const async_1 = __webpack_require__(116);
const stream_1 = __webpack_require__(151);
const sync_1 = __webpack_require__(152);
const settings_1 = __webpack_require__(154);
const utils = __webpack_require__(80);
async function FastGlob(source, options) {
    assertPatternsInput(source);
    const works = getWorks(source, async_1.default, options);
    const result = await Promise.all(works);
    return utils.array.flatten(result);
}
// https://github.com/typescript-eslint/typescript-eslint/issues/60
// eslint-disable-next-line no-redeclare
(function (FastGlob) {
    function sync(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options);
        return utils.array.flatten(works);
    }
    FastGlob.sync = sync;
    function stream(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options);
        /**
         * The stream returned by the provider cannot work with an asynchronous iterator.
         * To support asynchronous iterators, regardless of the number of tasks, we always multiplex streams.
         * This affects performance (+25%). I don't see best solution right now.
         */
        return utils.stream.merge(works);
    }
    FastGlob.stream = stream;
    function generateTasks(source, options) {
        assertPatternsInput(source);
        const patterns = [].concat(source);
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
    }
    FastGlob.generateTasks = generateTasks;
    function isDynamicPattern(source, options) {
        assertPatternsInput(source);
        const settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source, settings);
    }
    FastGlob.isDynamicPattern = isDynamicPattern;
    function escapePath(source) {
        assertPatternsInput(source);
        return utils.path.escape(source);
    }
    FastGlob.escapePath = escapePath;
})(FastGlob || (FastGlob = {}));
function getWorks(source, _Provider, options) {
    const patterns = [].concat(source);
    const settings = new settings_1.default(options);
    const tasks = taskManager.generate(patterns, settings);
    const provider = new _Provider(settings);
    return tasks.map(provider.read, provider);
}
function assertPatternsInput(input) {
    const source = [].concat(input);
    const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
    if (!isValidSource) {
        throw new TypeError('Patterns must be a string (non empty) or an array of strings');
    }
}
module.exports = FastGlob;


/***/ }),
/* 79 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = void 0;
const utils = __webpack_require__(80);
function generate(patterns, settings) {
    const positivePatterns = getPositivePatterns(patterns);
    const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);
    const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
    const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
    const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, /* dynamic */ false);
    const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, /* dynamic */ true);
    return staticTasks.concat(dynamicTasks);
}
exports.generate = generate;
function convertPatternsToTasks(positive, negative, dynamic) {
    const positivePatternsGroup = groupPatternsByBaseDirectory(positive);
    // When we have a global group – there is no reason to divide the patterns into independent tasks.
    // In this case, the global task covers the rest.
    if ('.' in positivePatternsGroup) {
        const task = convertPatternGroupToTask('.', positive, negative, dynamic);
        return [task];
    }
    return convertPatternGroupsToTasks(positivePatternsGroup, negative, dynamic);
}
exports.convertPatternsToTasks = convertPatternsToTasks;
function getPositivePatterns(patterns) {
    return utils.pattern.getPositivePatterns(patterns);
}
exports.getPositivePatterns = getPositivePatterns;
function getNegativePatternsAsPositive(patterns, ignore) {
    const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
    const positive = negative.map(utils.pattern.convertToPositivePattern);
    return positive;
}
exports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
function groupPatternsByBaseDirectory(patterns) {
    const group = {};
    return patterns.reduce((collection, pattern) => {
        const base = utils.pattern.getBaseDirectory(pattern);
        if (base in collection) {
            collection[base].push(pattern);
        }
        else {
            collection[base] = [pattern];
        }
        return collection;
    }, group);
}
exports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
function convertPatternGroupsToTasks(positive, negative, dynamic) {
    return Object.keys(positive).map((base) => {
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
    });
}
exports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
function convertPatternGroupToTask(base, positive, negative, dynamic) {
    return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
    };
}
exports.convertPatternGroupToTask = convertPatternGroupToTask;


/***/ }),
/* 80 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.string = exports.stream = exports.pattern = exports.path = exports.fs = exports.errno = exports.array = void 0;
const array = __webpack_require__(81);
exports.array = array;
const errno = __webpack_require__(82);
exports.errno = errno;
const fs = __webpack_require__(83);
exports.fs = fs;
const path = __webpack_require__(84);
exports.path = path;
const pattern = __webpack_require__(85);
exports.pattern = pattern;
const stream = __webpack_require__(112);
exports.stream = stream;
const string = __webpack_require__(115);
exports.string = string;


/***/ }),
/* 81 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.splitWhen = exports.flatten = void 0;
function flatten(items) {
    return items.reduce((collection, item) => [].concat(collection, item), []);
}
exports.flatten = flatten;
function splitWhen(items, predicate) {
    const result = [[]];
    let groupIndex = 0;
    for (const item of items) {
        if (predicate(item)) {
            groupIndex++;
            result[groupIndex] = [];
        }
        else {
            result[groupIndex].push(item);
        }
    }
    return result;
}
exports.splitWhen = splitWhen;


/***/ }),
/* 82 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isEnoentCodeError = void 0;
function isEnoentCodeError(error) {
    return error.code === 'ENOENT';
}
exports.isEnoentCodeError = isEnoentCodeError;


/***/ }),
/* 83 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createDirentFromStats = void 0;
class DirentFromStats {
    constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }
}
function createDirentFromStats(name, stats) {
    return new DirentFromStats(name, stats);
}
exports.createDirentFromStats = createDirentFromStats;


/***/ }),
/* 84 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.removeLeadingDotSegment = exports.escape = exports.makeAbsolute = exports.unixify = void 0;
const path = __webpack_require__(23);
const LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2; // ./ or .\\
const UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
/**
 * Designed to work only with simple paths: `dir\\file`.
 */
function unixify(filepath) {
    return filepath.replace(/\\/g, '/');
}
exports.unixify = unixify;
function makeAbsolute(cwd, filepath) {
    return path.resolve(cwd, filepath);
}
exports.makeAbsolute = makeAbsolute;
function escape(pattern) {
    return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, '\\$2');
}
exports.escape = escape;
function removeLeadingDotSegment(entry) {
    // We do not use `startsWith` because this is 10x slower than current implementation for some cases.
    // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
    if (entry.charAt(0) === '.') {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === '/' || secondCharactery === '\\') {
            return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
    }
    return entry;
}
exports.removeLeadingDotSegment = removeLeadingDotSegment;


/***/ }),
/* 85 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;
const path = __webpack_require__(23);
const globParent = __webpack_require__(86);
const micromatch = __webpack_require__(89);
const picomatch = __webpack_require__(106);
const GLOBSTAR = '**';
const ESCAPE_SYMBOL = '\\';
const COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
const REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[.*]/;
const REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\(.*\|.*\)/;
const GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\(.*\)/;
const BRACE_EXPANSIONS_SYMBOLS_RE = /{.*(?:,|\.\.).*}/;
function isStaticPattern(pattern, options = {}) {
    return !isDynamicPattern(pattern, options);
}
exports.isStaticPattern = isStaticPattern;
function isDynamicPattern(pattern, options = {}) {
    /**
     * A special case with an empty string is necessary for matching patterns that start with a forward slash.
     * An empty string cannot be a dynamic pattern.
     * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.
     */
    if (pattern === '') {
        return false;
    }
    /**
     * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check
     * filepath directly (without read directory).
     */
    if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
    }
    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
    }
    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
    }
    if (options.braceExpansion !== false && BRACE_EXPANSIONS_SYMBOLS_RE.test(pattern)) {
        return true;
    }
    return false;
}
exports.isDynamicPattern = isDynamicPattern;
function convertToPositivePattern(pattern) {
    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
}
exports.convertToPositivePattern = convertToPositivePattern;
function convertToNegativePattern(pattern) {
    return '!' + pattern;
}
exports.convertToNegativePattern = convertToNegativePattern;
function isNegativePattern(pattern) {
    return pattern.startsWith('!') && pattern[1] !== '(';
}
exports.isNegativePattern = isNegativePattern;
function isPositivePattern(pattern) {
    return !isNegativePattern(pattern);
}
exports.isPositivePattern = isPositivePattern;
function getNegativePatterns(patterns) {
    return patterns.filter(isNegativePattern);
}
exports.getNegativePatterns = getNegativePatterns;
function getPositivePatterns(patterns) {
    return patterns.filter(isPositivePattern);
}
exports.getPositivePatterns = getPositivePatterns;
function getBaseDirectory(pattern) {
    return globParent(pattern, { flipBackslashes: false });
}
exports.getBaseDirectory = getBaseDirectory;
function hasGlobStar(pattern) {
    return pattern.includes(GLOBSTAR);
}
exports.hasGlobStar = hasGlobStar;
function endsWithSlashGlobStar(pattern) {
    return pattern.endsWith('/' + GLOBSTAR);
}
exports.endsWithSlashGlobStar = endsWithSlashGlobStar;
function isAffectDepthOfReadingPattern(pattern) {
    const basename = path.basename(pattern);
    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
}
exports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
function expandPatternsWithBraceExpansion(patterns) {
    return patterns.reduce((collection, pattern) => {
        return collection.concat(expandBraceExpansion(pattern));
    }, []);
}
exports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
function expandBraceExpansion(pattern) {
    return micromatch.braces(pattern, {
        expand: true,
        nodupes: true
    });
}
exports.expandBraceExpansion = expandBraceExpansion;
function getPatternParts(pattern, options) {
    let { parts } = picomatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));
    /**
     * The scan method returns an empty array in some cases.
     * See micromatch/picomatch#58 for more details.
     */
    if (parts.length === 0) {
        parts = [pattern];
    }
    /**
     * The scan method does not return an empty part for the pattern with a forward slash.
     * This is another part of micromatch/picomatch#58.
     */
    if (parts[0].startsWith('/')) {
        parts[0] = parts[0].slice(1);
        parts.unshift('');
    }
    return parts;
}
exports.getPatternParts = getPatternParts;
function makeRe(pattern, options) {
    return micromatch.makeRe(pattern, options);
}
exports.makeRe = makeRe;
function convertPatternsToRe(patterns, options) {
    return patterns.map((pattern) => makeRe(pattern, options));
}
exports.convertPatternsToRe = convertPatternsToRe;
function matchAny(entry, patternsRe) {
    return patternsRe.some((patternRe) => patternRe.test(entry));
}
exports.matchAny = matchAny;


/***/ }),
/* 86 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isGlob = __webpack_require__(87);
var pathPosixDirname = __webpack_require__(23).posix.dirname;
var isWin32 = __webpack_require__(24).platform() === 'win32';

var slash = '/';
var backslash = /\\/g;
var enclosure = /[\{\[].*[\}\]]$/;
var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;

/**
 * @param {string} str
 * @param {Object} opts
 * @param {boolean} [opts.flipBackslashes=true]
 * @returns {string}
 */
module.exports = function globParent(str, opts) {
  var options = Object.assign({ flipBackslashes: true }, opts);

  // flip windows path separators
  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
    str = str.replace(backslash, slash);
  }

  // special case for strings ending in enclosure containing path separator
  if (enclosure.test(str)) {
    str += slash;
  }

  // preserves full path in case of trailing path separator
  str += 'a';

  // remove path parts that are globby
  do {
    str = pathPosixDirname(str);
  } while (isGlob(str) || globby.test(str));

  // remove escape chars and return result
  return str.replace(escaped, '$1');
};


/***/ }),
/* 87 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

var isExtglob = __webpack_require__(88);
var chars = { '{': '}', '(': ')', '[': ']'};
var strictRegex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
var relaxedRegex = /\\(.)|(^!|[*?{}()[\]]|\(\?)/;

module.exports = function isGlob(str, options) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  if (isExtglob(str)) {
    return true;
  }

  var regex = strictRegex;
  var match;

  // optionally relax regex
  if (options && options.strict === false) {
    regex = relaxedRegex;
  }

  while ((match = regex.exec(str))) {
    if (match[2]) return true;
    var idx = match.index + match[0].length;

    // if an open bracket/brace/paren is escaped,
    // set the index to the next closing character
    var open = match[1];
    var close = open ? chars[open] : null;
    if (open && close) {
      var n = str.indexOf(close, idx);
      if (n !== -1) {
        idx = n + 1;
      }
    }

    str = str.slice(idx);
  }
  return false;
};


/***/ }),
/* 88 */
/***/ ((module) => {

/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */

module.exports = function isExtglob(str) {
  if (typeof str !== 'string' || str === '') {
    return false;
  }

  var match;
  while ((match = /(\\).|([@?!+*]\(.*\))/g.exec(str))) {
    if (match[2]) return true;
    str = str.slice(match.index + match[0].length);
  }

  return false;
};


/***/ }),
/* 89 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(10);
const braces = __webpack_require__(90);
const picomatch = __webpack_require__(100);
const utils = __webpack_require__(103);
const isEmptyString = val => typeof val === 'string' && (val === '' || val === './');

/**
 * Returns an array of strings that match one or more glob patterns.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm(list, patterns[, options]);
 *
 * console.log(mm(['a.js', 'a.txt'], ['*.js']));
 * //=> [ 'a.js' ]
 * ```
 * @param {String|Array<string>} list List of strings to match.
 * @param {String|Array<string>} patterns One or more glob patterns to use for matching.
 * @param {Object} options See available [options](#options)
 * @return {Array} Returns an array of matches
 * @summary false
 * @api public
 */

const micromatch = (list, patterns, options) => {
  patterns = [].concat(patterns);
  list = [].concat(list);

  let omit = new Set();
  let keep = new Set();
  let items = new Set();
  let negatives = 0;

  let onResult = state => {
    items.add(state.output);
    if (options && options.onResult) {
      options.onResult(state);
    }
  };

  for (let i = 0; i < patterns.length; i++) {
    let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
    if (negated) negatives++;

    for (let item of list) {
      let matched = isMatch(item, true);

      let match = negated ? !matched.isMatch : matched.isMatch;
      if (!match) continue;

      if (negated) {
        omit.add(matched.output);
      } else {
        omit.delete(matched.output);
        keep.add(matched.output);
      }
    }
  }

  let result = negatives === patterns.length ? [...items] : [...keep];
  let matches = result.filter(item => !omit.has(item));

  if (options && matches.length === 0) {
    if (options.failglob === true) {
      throw new Error(`No matches found for "${patterns.join(', ')}"`);
    }

    if (options.nonull === true || options.nullglob === true) {
      return options.unescape ? patterns.map(p => p.replace(/\\/g, '')) : patterns;
    }
  }

  return matches;
};

/**
 * Backwards compatibility
 */

micromatch.match = micromatch;

/**
 * Returns a matcher function from the given glob `pattern` and `options`.
 * The returned function takes a string to match as its only argument and returns
 * true if the string is a match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matcher(pattern[, options]);
 *
 * const isMatch = mm.matcher('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @param {String} `pattern` Glob pattern
 * @param {Object} `options`
 * @return {Function} Returns a matcher function.
 * @api public
 */

micromatch.matcher = (pattern, options) => picomatch(pattern, options);

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.isMatch(string, patterns[, options]);
 *
 * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(mm.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

/**
 * Backwards compatibility
 */

micromatch.any = micromatch.isMatch;

/**
 * Returns a list of strings that _**do not match any**_ of the given `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.not(list, patterns[, options]);
 *
 * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));
 * //=> ['b.b', 'c.c']
 * ```
 * @param {Array} `list` Array of strings to match.
 * @param {String|Array} `patterns` One or more glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Array} Returns an array of strings that **do not match** the given patterns.
 * @api public
 */

micromatch.not = (list, patterns, options = {}) => {
  patterns = [].concat(patterns).map(String);
  let result = new Set();
  let items = [];

  let onResult = state => {
    if (options.onResult) options.onResult(state);
    items.push(state.output);
  };

  let matches = micromatch(list, patterns, { ...options, onResult });

  for (let item of items) {
    if (!matches.includes(item)) {
      result.add(item);
    }
  }
  return [...result];
};

/**
 * Returns true if the given `string` contains the given pattern. Similar
 * to [.isMatch](#isMatch) but the pattern can match any part of the string.
 *
 * ```js
 * var mm = require('micromatch');
 * // mm.contains(string, pattern[, options]);
 *
 * console.log(mm.contains('aa/bb/cc', '*b'));
 * //=> true
 * console.log(mm.contains('aa/bb/cc', '*d'));
 * //=> false
 * ```
 * @param {String} `str` The string to match.
 * @param {String|Array} `patterns` Glob pattern to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if the patter matches any part of `str`.
 * @api public
 */

micromatch.contains = (str, pattern, options) => {
  if (typeof str !== 'string') {
    throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
  }

  if (Array.isArray(pattern)) {
    return pattern.some(p => micromatch.contains(str, p, options));
  }

  if (typeof pattern === 'string') {
    if (isEmptyString(str) || isEmptyString(pattern)) {
      return false;
    }

    if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) {
      return true;
    }
  }

  return micromatch.isMatch(str, pattern, { ...options, contains: true });
};

/**
 * Filter the keys of the given object with the given `glob` pattern
 * and `options`. Does not attempt to match nested keys. If you need this feature,
 * use [glob-object][] instead.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.matchKeys(object, patterns[, options]);
 *
 * const obj = { aa: 'a', ab: 'b', ac: 'c' };
 * console.log(mm.matchKeys(obj, '*b'));
 * //=> { ab: 'b' }
 * ```
 * @param {Object} `object` The object with keys to filter.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Object} Returns an object with only keys that match the given patterns.
 * @api public
 */

micromatch.matchKeys = (obj, patterns, options) => {
  if (!utils.isObject(obj)) {
    throw new TypeError('Expected the first argument to be an object');
  }
  let keys = micromatch(Object.keys(obj), patterns, options);
  let res = {};
  for (let key of keys) res[key] = obj[key];
  return res;
};

/**
 * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.some(list, patterns[, options]);
 *
 * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // true
 * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.some = (list, patterns, options) => {
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) {
    let isMatch = picomatch(String(pattern), options);
    if (items.some(item => isMatch(item))) {
      return true;
    }
  }
  return false;
};

/**
 * Returns true if every string in the given `list` matches
 * any of the given glob `patterns`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.every(list, patterns[, options]);
 *
 * console.log(mm.every('foo.js', ['foo.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));
 * // true
 * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));
 * // false
 * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));
 * // false
 * ```
 * @param {String|Array} `list` The string or array of strings to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.every = (list, patterns, options) => {
  let items = [].concat(list);

  for (let pattern of [].concat(patterns)) {
    let isMatch = picomatch(String(pattern), options);
    if (!items.every(item => isMatch(item))) {
      return false;
    }
  }
  return true;
};

/**
 * Returns true if **all** of the given `patterns` match
 * the specified string.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.all(string, patterns[, options]);
 *
 * console.log(mm.all('foo.js', ['foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', '!foo.js']));
 * // false
 *
 * console.log(mm.all('foo.js', ['*.js', 'foo.js']));
 * // true
 *
 * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));
 * // true
 * ```
 * @param {String|Array} `str` The string to test.
 * @param {String|Array} `patterns` One or more glob patterns to use for matching.
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

micromatch.all = (str, patterns, options) => {
  if (typeof str !== 'string') {
    throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
  }

  return [].concat(patterns).every(p => picomatch(p, options)(str));
};

/**
 * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.capture(pattern, string[, options]);
 *
 * console.log(mm.capture('test/*.js', 'test/foo.js'));
 * //=> ['foo']
 * console.log(mm.capture('test/*.js', 'foo/bar.css'));
 * //=> null
 * ```
 * @param {String} `glob` Glob pattern to use for matching.
 * @param {String} `input` String to match
 * @param {Object} `options` See available [options](#options) for changing how matches are performed
 * @return {Boolean} Returns an array of captures if the input matches the glob pattern, otherwise `null`.
 * @api public
 */

micromatch.capture = (glob, input, options) => {
  let posix = utils.isWindows(options);
  let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
  let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);

  if (match) {
    return match.slice(1).map(v => v === void 0 ? '' : v);
  }
};

/**
 * Create a regular expression from the given glob `pattern`.
 *
 * ```js
 * const mm = require('micromatch');
 * // mm.makeRe(pattern[, options]);
 *
 * console.log(mm.makeRe('*.js'));
 * //=> /^(?:(\.[\\\/])?(?!\.)(?=.)[^\/]*?\.js)$/
 * ```
 * @param {String} `pattern` A glob pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

micromatch.makeRe = (...args) => picomatch.makeRe(...args);

/**
 * Scan a glob pattern to separate the pattern into segments. Used
 * by the [split](#split) method.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm.scan(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */

micromatch.scan = (...args) => picomatch.scan(...args);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const mm = require('micromatch');
 * const state = mm(pattern[, options]);
 * ```
 * @param {String} `glob`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as regex source string.
 * @api public
 */

micromatch.parse = (patterns, options) => {
  let res = [];
  for (let pattern of [].concat(patterns || [])) {
    for (let str of braces(String(pattern), options)) {
      res.push(picomatch.parse(str, options));
    }
  }
  return res;
};

/**
 * Process the given brace `pattern`.
 *
 * ```js
 * const { braces } = require('micromatch');
 * console.log(braces('foo/{a,b,c}/bar'));
 * //=> [ 'foo/(a|b|c)/bar' ]
 *
 * console.log(braces('foo/{a,b,c}/bar', { expand: true }));
 * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]
 * ```
 * @param {String} `pattern` String with brace pattern to process.
 * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.
 * @return {Array}
 * @api public
 */

micromatch.braces = (pattern, options) => {
  if (typeof pattern !== 'string') throw new TypeError('Expected a string');
  if ((options && options.nobrace === true) || !/\{.*\}/.test(pattern)) {
    return [pattern];
  }
  return braces(pattern, options);
};

/**
 * Expand braces
 */

micromatch.braceExpand = (pattern, options) => {
  if (typeof pattern !== 'string') throw new TypeError('Expected a string');
  return micromatch.braces(pattern, { ...options, expand: true });
};

/**
 * Expose micromatch
 */

module.exports = micromatch;


/***/ }),
/* 90 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const stringify = __webpack_require__(91);
const compile = __webpack_require__(93);
const expand = __webpack_require__(97);
const parse = __webpack_require__(98);

/**
 * Expand the given pattern or create a regex-compatible string.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']
 * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {String}
 * @api public
 */

const braces = (input, options = {}) => {
  let output = [];

  if (Array.isArray(input)) {
    for (let pattern of input) {
      let result = braces.create(pattern, options);
      if (Array.isArray(result)) {
        output.push(...result);
      } else {
        output.push(result);
      }
    }
  } else {
    output = [].concat(braces.create(input, options));
  }

  if (options && options.expand === true && options.nodupes === true) {
    output = [...new Set(output)];
  }
  return output;
};

/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * // braces.parse(pattern, [, options]);
 * const ast = braces.parse('a/{b,c}/d');
 * console.log(ast);
 * ```
 * @param {String} pattern Brace pattern to parse
 * @param {Object} options
 * @return {Object} Returns an AST
 * @api public
 */

braces.parse = (input, options = {}) => parse(input, options);

/**
 * Creates a braces string from an AST, or an AST node.
 *
 * ```js
 * const braces = require('braces');
 * let ast = braces.parse('foo/{a,b}/bar');
 * console.log(stringify(ast.nodes[2])); //=> '{a,b}'
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.stringify = (input, options = {}) => {
  if (typeof input === 'string') {
    return stringify(braces.parse(input, options), options);
  }
  return stringify(input, options);
};

/**
 * Compiles a brace pattern into a regex-compatible, optimized string.
 * This method is called by the main [braces](#braces) function by default.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.compile('a/{b,c}/d'));
 * //=> ['a/(b|c)/d']
 * ```
 * @param {String} `input` Brace pattern or AST.
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.compile = (input, options = {}) => {
  if (typeof input === 'string') {
    input = braces.parse(input, options);
  }
  return compile(input, options);
};

/**
 * Expands a brace pattern into an array. This method is called by the
 * main [braces](#braces) function when `options.expand` is true. Before
 * using this method it's recommended that you read the [performance notes](#performance))
 * and advantages of using [.compile](#compile) instead.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.expand('a/{b,c}/d'));
 * //=> ['a/b/d', 'a/c/d'];
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.expand = (input, options = {}) => {
  if (typeof input === 'string') {
    input = braces.parse(input, options);
  }

  let result = expand(input, options);

  // filter out empty strings if specified
  if (options.noempty === true) {
    result = result.filter(Boolean);
  }

  // filter out duplicates if specified
  if (options.nodupes === true) {
    result = [...new Set(result)];
  }

  return result;
};

/**
 * Processes a brace pattern and returns either an expanded array
 * (if `options.expand` is true), a highly optimized regex-compatible string.
 * This method is called by the main [braces](#braces) function.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))
 * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
 * ```
 * @param {String} `pattern` Brace pattern
 * @param {Object} `options`
 * @return {Array} Returns an array of expanded values.
 * @api public
 */

braces.create = (input, options = {}) => {
  if (input === '' || input.length < 3) {
    return [input];
  }

 return options.expand !== true
    ? braces.compile(input, options)
    : braces.expand(input, options);
};

/**
 * Expose "braces"
 */

module.exports = braces;


/***/ }),
/* 91 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const utils = __webpack_require__(92);

module.exports = (ast, options = {}) => {
  let stringify = (node, parent = {}) => {
    let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
    let invalidNode = node.invalid === true && options.escapeInvalid === true;
    let output = '';

    if (node.value) {
      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
        return '\\' + node.value;
      }
      return node.value;
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes) {
      for (let child of node.nodes) {
        output += stringify(child);
      }
    }
    return output;
  };

  return stringify(ast);
};



/***/ }),
/* 92 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.isInteger = num => {
  if (typeof num === 'number') {
    return Number.isInteger(num);
  }
  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isInteger(Number(num));
  }
  return false;
};

/**
 * Find a node of the given type
 */

exports.find = (node, type) => node.nodes.find(node => node.type === type);

/**
 * Find a node of the given type
 */

exports.exceedsLimit = (min, max, step = 1, limit) => {
  if (limit === false) return false;
  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;
  return ((Number(max) - Number(min)) / Number(step)) >= limit;
};

/**
 * Escape the given node with '\\' before node.value
 */

exports.escapeNode = (block, n = 0, type) => {
  let node = block.nodes[n];
  if (!node) return;

  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {
    if (node.escaped !== true) {
      node.value = '\\' + node.value;
      node.escaped = true;
    }
  }
};

/**
 * Returns true if the given brace node should be enclosed in literal braces
 */

exports.encloseBrace = node => {
  if (node.type !== 'brace') return false;
  if ((node.commas >> 0 + node.ranges >> 0) === 0) {
    node.invalid = true;
    return true;
  }
  return false;
};

/**
 * Returns true if a brace node is invalid.
 */

exports.isInvalidBrace = block => {
  if (block.type !== 'brace') return false;
  if (block.invalid === true || block.dollar) return true;
  if ((block.commas >> 0 + block.ranges >> 0) === 0) {
    block.invalid = true;
    return true;
  }
  if (block.open !== true || block.close !== true) {
    block.invalid = true;
    return true;
  }
  return false;
};

/**
 * Returns true if a node is an open or close node
 */

exports.isOpenOrClose = node => {
  if (node.type === 'open' || node.type === 'close') {
    return true;
  }
  return node.open === true || node.close === true;
};

/**
 * Reduce an array of text nodes.
 */

exports.reduce = nodes => nodes.reduce((acc, node) => {
  if (node.type === 'text') acc.push(node.value);
  if (node.type === 'range') node.type = 'text';
  return acc;
}, []);

/**
 * Flatten an array
 */

exports.flatten = (...args) => {
  const result = [];
  const flat = arr => {
    for (let i = 0; i < arr.length; i++) {
      let ele = arr[i];
      Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
    }
    return result;
  };
  flat(args);
  return result;
};


/***/ }),
/* 93 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fill = __webpack_require__(94);
const utils = __webpack_require__(92);

const compile = (ast, options = {}) => {
  let walk = (node, parent = {}) => {
    let invalidBlock = utils.isInvalidBrace(parent);
    let invalidNode = node.invalid === true && options.escapeInvalid === true;
    let invalid = invalidBlock === true || invalidNode === true;
    let prefix = options.escapeInvalid === true ? '\\' : '';
    let output = '';

    if (node.isOpen === true) {
      return prefix + node.value;
    }
    if (node.isClose === true) {
      return prefix + node.value;
    }

    if (node.type === 'open') {
      return invalid ? (prefix + node.value) : '(';
    }

    if (node.type === 'close') {
      return invalid ? (prefix + node.value) : ')';
    }

    if (node.type === 'comma') {
      return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');
    }

    if (node.value) {
      return node.value;
    }

    if (node.nodes && node.ranges > 0) {
      let args = utils.reduce(node.nodes);
      let range = fill(...args, { ...options, wrap: false, toRegex: true });

      if (range.length !== 0) {
        return args.length > 1 && range.length > 1 ? `(${range})` : range;
      }
    }

    if (node.nodes) {
      for (let child of node.nodes) {
        output += walk(child, node);
      }
    }
    return output;
  };

  return walk(ast);
};

module.exports = compile;


/***/ }),
/* 94 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */



const util = __webpack_require__(10);
const toRegexRange = __webpack_require__(95);

const isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);

const transform = toNumber => {
  return value => toNumber === true ? Number(value) : String(value);
};

const isValidValue = value => {
  return typeof value === 'number' || (typeof value === 'string' && value !== '');
};

const isNumber = num => Number.isInteger(+num);

const zeros = input => {
  let value = `${input}`;
  let index = -1;
  if (value[0] === '-') value = value.slice(1);
  if (value === '0') return false;
  while (value[++index] === '0');
  return index > 0;
};

const stringify = (start, end, options) => {
  if (typeof start === 'string' || typeof end === 'string') {
    return true;
  }
  return options.stringify === true;
};

const pad = (input, maxLength, toNumber) => {
  if (maxLength > 0) {
    let dash = input[0] === '-' ? '-' : '';
    if (dash) input = input.slice(1);
    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));
  }
  if (toNumber === false) {
    return String(input);
  }
  return input;
};

const toMaxLen = (input, maxLength) => {
  let negative = input[0] === '-' ? '-' : '';
  if (negative) {
    input = input.slice(1);
    maxLength--;
  }
  while (input.length < maxLength) input = '0' + input;
  return negative ? ('-' + input) : input;
};

const toSequence = (parts, options) => {
  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);

  let prefix = options.capture ? '' : '?:';
  let positives = '';
  let negatives = '';
  let result;

  if (parts.positives.length) {
    positives = parts.positives.join('|');
  }

  if (parts.negatives.length) {
    negatives = `-(${prefix}${parts.negatives.join('|')})`;
  }

  if (positives && negatives) {
    result = `${positives}|${negatives}`;
  } else {
    result = positives || negatives;
  }

  if (options.wrap) {
    return `(${prefix}${result})`;
  }

  return result;
};

const toRange = (a, b, isNumbers, options) => {
  if (isNumbers) {
    return toRegexRange(a, b, { wrap: false, ...options });
  }

  let start = String.fromCharCode(a);
  if (a === b) return start;

  let stop = String.fromCharCode(b);
  return `[${start}-${stop}]`;
};

const toRegex = (start, end, options) => {
  if (Array.isArray(start)) {
    let wrap = options.wrap === true;
    let prefix = options.capture ? '' : '?:';
    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');
  }
  return toRegexRange(start, end, options);
};

const rangeError = (...args) => {
  return new RangeError('Invalid range arguments: ' + util.inspect(...args));
};

const invalidRange = (start, end, options) => {
  if (options.strictRanges === true) throw rangeError([start, end]);
  return [];
};

const invalidStep = (step, options) => {
  if (options.strictRanges === true) {
    throw new TypeError(`Expected step "${step}" to be a number`);
  }
  return [];
};

const fillNumbers = (start, end, step = 1, options = {}) => {
  let a = Number(start);
  let b = Number(end);

  if (!Number.isInteger(a) || !Number.isInteger(b)) {
    if (options.strictRanges === true) throw rangeError([start, end]);
    return [];
  }

  // fix negative zero
  if (a === 0) a = 0;
  if (b === 0) b = 0;

  let descending = a > b;
  let startString = String(start);
  let endString = String(end);
  let stepString = String(step);
  step = Math.max(Math.abs(step), 1);

  let padded = zeros(startString) || zeros(endString) || zeros(stepString);
  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
  let toNumber = padded === false && stringify(start, end, options) === false;
  let format = options.transform || transform(toNumber);

  if (options.toRegex && step === 1) {
    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
  }

  let parts = { negatives: [], positives: [] };
  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));
  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
    if (options.toRegex === true && step > 1) {
      push(a);
    } else {
      range.push(pad(format(a, index), maxLen, toNumber));
    }
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return step > 1
      ? toSequence(parts, options)
      : toRegex(range, null, { wrap: false, ...options });
  }

  return range;
};

const fillLetters = (start, end, step = 1, options = {}) => {
  if ((!isNumber(start) && start.length > 1) || (!isNumber(end) && end.length > 1)) {
    return invalidRange(start, end, options);
  }


  let format = options.transform || (val => String.fromCharCode(val));
  let a = `${start}`.charCodeAt(0);
  let b = `${end}`.charCodeAt(0);

  let descending = a > b;
  let min = Math.min(a, b);
  let max = Math.max(a, b);

  if (options.toRegex && step === 1) {
    return toRange(min, max, false, options);
  }

  let range = [];
  let index = 0;

  while (descending ? a >= b : a <= b) {
    range.push(format(a, index));
    a = descending ? a - step : a + step;
    index++;
  }

  if (options.toRegex === true) {
    return toRegex(range, null, { wrap: false, options });
  }

  return range;
};

const fill = (start, end, step, options = {}) => {
  if (end == null && isValidValue(start)) {
    return [start];
  }

  if (!isValidValue(start) || !isValidValue(end)) {
    return invalidRange(start, end, options);
  }

  if (typeof step === 'function') {
    return fill(start, end, 1, { transform: step });
  }

  if (isObject(step)) {
    return fill(start, end, 0, step);
  }

  let opts = { ...options };
  if (opts.capture === true) opts.wrap = true;
  step = step || opts.step || 1;

  if (!isNumber(step)) {
    if (step != null && !isObject(step)) return invalidStep(step, opts);
    return fill(start, end, 1, step);
  }

  if (isNumber(start) && isNumber(end)) {
    return fillNumbers(start, end, step, opts);
  }

  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
};

module.exports = fill;


/***/ }),
/* 95 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */



const isNumber = __webpack_require__(96);

const toRegexRange = (min, max, options) => {
  if (isNumber(min) === false) {
    throw new TypeError('toRegexRange: expected the first argument to be a number');
  }

  if (max === void 0 || min === max) {
    return String(min);
  }

  if (isNumber(max) === false) {
    throw new TypeError('toRegexRange: expected the second argument to be a number.');
  }

  let opts = { relaxZeros: true, ...options };
  if (typeof opts.strictZeros === 'boolean') {
    opts.relaxZeros = opts.strictZeros === false;
  }

  let relax = String(opts.relaxZeros);
  let shorthand = String(opts.shorthand);
  let capture = String(opts.capture);
  let wrap = String(opts.wrap);
  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;

  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
    return toRegexRange.cache[cacheKey].result;
  }

  let a = Math.min(min, max);
  let b = Math.max(min, max);

  if (Math.abs(a - b) === 1) {
    let result = min + '|' + max;
    if (opts.capture) {
      return `(${result})`;
    }
    if (opts.wrap === false) {
      return result;
    }
    return `(?:${result})`;
  }

  let isPadded = hasPadding(min) || hasPadding(max);
  let state = { min, max, a, b };
  let positives = [];
  let negatives = [];

  if (isPadded) {
    state.isPadded = isPadded;
    state.maxLen = String(state.max).length;
  }

  if (a < 0) {
    let newMin = b < 0 ? Math.abs(b) : 1;
    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
    a = state.a = 0;
  }

  if (b >= 0) {
    positives = splitToPatterns(a, b, state, opts);
  }

  state.negatives = negatives;
  state.positives = positives;
  state.result = collatePatterns(negatives, positives, opts);

  if (opts.capture === true) {
    state.result = `(${state.result})`;
  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {
    state.result = `(?:${state.result})`;
  }

  toRegexRange.cache[cacheKey] = state;
  return state.result;
};

function collatePatterns(neg, pos, options) {
  let onlyNegative = filterPatterns(neg, pos, '-', false, options) || [];
  let onlyPositive = filterPatterns(pos, neg, '', false, options) || [];
  let intersected = filterPatterns(neg, pos, '-?', true, options) || [];
  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join('|');
}

function splitToRanges(min, max) {
  let nines = 1;
  let zeros = 1;

  let stop = countNines(min, nines);
  let stops = new Set([max]);

  while (min <= stop && stop <= max) {
    stops.add(stop);
    nines += 1;
    stop = countNines(min, nines);
  }

  stop = countZeros(max + 1, zeros) - 1;

  while (min < stop && stop <= max) {
    stops.add(stop);
    zeros += 1;
    stop = countZeros(max + 1, zeros) - 1;
  }

  stops = [...stops];
  stops.sort(compare);
  return stops;
}

/**
 * Convert a range to a regex pattern
 * @param {Number} `start`
 * @param {Number} `stop`
 * @return {String}
 */

function rangeToPattern(start, stop, options) {
  if (start === stop) {
    return { pattern: start, count: [], digits: 0 };
  }

  let zipped = zip(start, stop);
  let digits = zipped.length;
  let pattern = '';
  let count = 0;

  for (let i = 0; i < digits; i++) {
    let [startDigit, stopDigit] = zipped[i];

    if (startDigit === stopDigit) {
      pattern += startDigit;

    } else if (startDigit !== '0' || stopDigit !== '9') {
      pattern += toCharacterClass(startDigit, stopDigit, options);

    } else {
      count++;
    }
  }

  if (count) {
    pattern += options.shorthand === true ? '\\d' : '[0-9]';
  }

  return { pattern, count: [count], digits };
}

function splitToPatterns(min, max, tok, options) {
  let ranges = splitToRanges(min, max);
  let tokens = [];
  let start = min;
  let prev;

  for (let i = 0; i < ranges.length; i++) {
    let max = ranges[i];
    let obj = rangeToPattern(String(start), String(max), options);
    let zeros = '';

    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
      if (prev.count.length > 1) {
        prev.count.pop();
      }

      prev.count.push(obj.count[0]);
      prev.string = prev.pattern + toQuantifier(prev.count);
      start = max + 1;
      continue;
    }

    if (tok.isPadded) {
      zeros = padZeros(max, tok, options);
    }

    obj.string = zeros + obj.pattern + toQuantifier(obj.count);
    tokens.push(obj);
    start = max + 1;
    prev = obj;
  }

  return tokens;
}

function filterPatterns(arr, comparison, prefix, intersection, options) {
  let result = [];

  for (let ele of arr) {
    let { string } = ele;

    // only push if _both_ are negative...
    if (!intersection && !contains(comparison, 'string', string)) {
      result.push(prefix + string);
    }

    // or _both_ are positive
    if (intersection && contains(comparison, 'string', string)) {
      result.push(prefix + string);
    }
  }
  return result;
}

/**
 * Zip strings
 */

function zip(a, b) {
  let arr = [];
  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);
  return arr;
}

function compare(a, b) {
  return a > b ? 1 : b > a ? -1 : 0;
}

function contains(arr, key, val) {
  return arr.some(ele => ele[key] === val);
}

function countNines(min, len) {
  return Number(String(min).slice(0, -len) + '9'.repeat(len));
}

function countZeros(integer, zeros) {
  return integer - (integer % Math.pow(10, zeros));
}

function toQuantifier(digits) {
  let [start = 0, stop = ''] = digits;
  if (stop || start > 1) {
    return `{${start + (stop ? ',' + stop : '')}}`;
  }
  return '';
}

function toCharacterClass(a, b, options) {
  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;
}

function hasPadding(str) {
  return /^-?(0+)\d/.test(str);
}

function padZeros(value, tok, options) {
  if (!tok.isPadded) {
    return value;
  }

  let diff = Math.abs(tok.maxLen - String(value).length);
  let relax = options.relaxZeros !== false;

  switch (diff) {
    case 0:
      return '';
    case 1:
      return relax ? '0?' : '0';
    case 2:
      return relax ? '0{0,2}' : '00';
    default: {
      return relax ? `0{0,${diff}}` : `0{${diff}}`;
    }
  }
}

/**
 * Cache
 */

toRegexRange.cache = {};
toRegexRange.clearCache = () => (toRegexRange.cache = {});

/**
 * Expose `toRegexRange`
 */

module.exports = toRegexRange;


/***/ }),
/* 96 */
/***/ ((module) => {

"use strict";
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */



module.exports = function(num) {
  if (typeof num === 'number') {
    return num - num === 0;
  }
  if (typeof num === 'string' && num.trim() !== '') {
    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
  }
  return false;
};


/***/ }),
/* 97 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fill = __webpack_require__(94);
const stringify = __webpack_require__(91);
const utils = __webpack_require__(92);

const append = (queue = '', stash = '', enclose = false) => {
  let result = [];

  queue = [].concat(queue);
  stash = [].concat(stash);

  if (!stash.length) return queue;
  if (!queue.length) {
    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;
  }

  for (let item of queue) {
    if (Array.isArray(item)) {
      for (let value of item) {
        result.push(append(value, stash, enclose));
      }
    } else {
      for (let ele of stash) {
        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;
        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));
      }
    }
  }
  return utils.flatten(result);
};

const expand = (ast, options = {}) => {
  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;

  let walk = (node, parent = {}) => {
    node.queue = [];

    let p = parent;
    let q = parent.queue;

    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {
      p = p.parent;
      q = p.queue;
    }

    if (node.invalid || node.dollar) {
      q.push(append(q.pop(), stringify(node, options)));
      return;
    }

    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {
      q.push(append(q.pop(), ['{}']));
      return;
    }

    if (node.nodes && node.ranges > 0) {
      let args = utils.reduce(node.nodes);

      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');
      }

      let range = fill(...args, options);
      if (range.length === 0) {
        range = stringify(node, options);
      }

      q.push(append(q.pop(), range));
      node.nodes = [];
      return;
    }

    let enclose = utils.encloseBrace(node);
    let queue = node.queue;
    let block = node;

    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {
      block = block.parent;
      queue = block.queue;
    }

    for (let i = 0; i < node.nodes.length; i++) {
      let child = node.nodes[i];

      if (child.type === 'comma' && node.type === 'brace') {
        if (i === 1) queue.push('');
        queue.push('');
        continue;
      }

      if (child.type === 'close') {
        q.push(append(q.pop(), queue, enclose));
        continue;
      }

      if (child.value && child.type !== 'open') {
        queue.push(append(queue.pop(), child.value));
        continue;
      }

      if (child.nodes) {
        walk(child, node);
      }
    }

    return queue;
  };

  return utils.flatten(walk(ast));
};

module.exports = expand;


/***/ }),
/* 98 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const stringify = __webpack_require__(91);

/**
 * Constants
 */

const {
  MAX_LENGTH,
  CHAR_BACKSLASH, /* \ */
  CHAR_BACKTICK, /* ` */
  CHAR_COMMA, /* , */
  CHAR_DOT, /* . */
  CHAR_LEFT_PARENTHESES, /* ( */
  CHAR_RIGHT_PARENTHESES, /* ) */
  CHAR_LEFT_CURLY_BRACE, /* { */
  CHAR_RIGHT_CURLY_BRACE, /* } */
  CHAR_LEFT_SQUARE_BRACKET, /* [ */
  CHAR_RIGHT_SQUARE_BRACKET, /* ] */
  CHAR_DOUBLE_QUOTE, /* " */
  CHAR_SINGLE_QUOTE, /* ' */
  CHAR_NO_BREAK_SPACE,
  CHAR_ZERO_WIDTH_NOBREAK_SPACE
} = __webpack_require__(99);

/**
 * parse
 */

const parse = (input, options = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  let opts = options || {};
  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  if (input.length > max) {
    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
  }

  let ast = { type: 'root', input, nodes: [] };
  let stack = [ast];
  let block = ast;
  let prev = ast;
  let brackets = 0;
  let length = input.length;
  let index = 0;
  let depth = 0;
  let value;
  let memo = {};

  /**
   * Helpers
   */

  const advance = () => input[index++];
  const push = node => {
    if (node.type === 'text' && prev.type === 'dot') {
      prev.type = 'text';
    }

    if (prev && prev.type === 'text' && node.type === 'text') {
      prev.value += node.value;
      return;
    }

    block.nodes.push(node);
    node.parent = block;
    node.prev = prev;
    prev = node;
    return node;
  };

  push({ type: 'bos' });

  while (index < length) {
    block = stack[stack.length - 1];
    value = advance();

    /**
     * Invalid chars
     */

    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
      continue;
    }

    /**
     * Escaped chars
     */

    if (value === CHAR_BACKSLASH) {
      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });
      continue;
    }

    /**
     * Right square bracket (literal): ']'
     */

    if (value === CHAR_RIGHT_SQUARE_BRACKET) {
      push({ type: 'text', value: '\\' + value });
      continue;
    }

    /**
     * Left square bracket: '['
     */

    if (value === CHAR_LEFT_SQUARE_BRACKET) {
      brackets++;

      let closed = true;
      let next;

      while (index < length && (next = advance())) {
        value += next;

        if (next === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          continue;
        }

        if (next === CHAR_BACKSLASH) {
          value += advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          brackets--;

          if (brackets === 0) {
            break;
          }
        }
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Parentheses
     */

    if (value === CHAR_LEFT_PARENTHESES) {
      block = push({ type: 'paren', nodes: [] });
      stack.push(block);
      push({ type: 'text', value });
      continue;
    }

    if (value === CHAR_RIGHT_PARENTHESES) {
      if (block.type !== 'paren') {
        push({ type: 'text', value });
        continue;
      }
      block = stack.pop();
      push({ type: 'text', value });
      block = stack[stack.length - 1];
      continue;
    }

    /**
     * Quotes: '|"|`
     */

    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
      let open = value;
      let next;

      if (options.keepQuotes !== true) {
        value = '';
      }

      while (index < length && (next = advance())) {
        if (next === CHAR_BACKSLASH) {
          value += next + advance();
          continue;
        }

        if (next === open) {
          if (options.keepQuotes === true) value += next;
          break;
        }

        value += next;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Left curly brace: '{'
     */

    if (value === CHAR_LEFT_CURLY_BRACE) {
      depth++;

      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;
      let brace = {
        type: 'brace',
        open: true,
        close: false,
        dollar,
        depth,
        commas: 0,
        ranges: 0,
        nodes: []
      };

      block = push(brace);
      stack.push(block);
      push({ type: 'open', value });
      continue;
    }

    /**
     * Right curly brace: '}'
     */

    if (value === CHAR_RIGHT_CURLY_BRACE) {
      if (block.type !== 'brace') {
        push({ type: 'text', value });
        continue;
      }

      let type = 'close';
      block = stack.pop();
      block.close = true;

      push({ type, value });
      depth--;

      block = stack[stack.length - 1];
      continue;
    }

    /**
     * Comma: ','
     */

    if (value === CHAR_COMMA && depth > 0) {
      if (block.ranges > 0) {
        block.ranges = 0;
        let open = block.nodes.shift();
        block.nodes = [open, { type: 'text', value: stringify(block) }];
      }

      push({ type: 'comma', value });
      block.commas++;
      continue;
    }

    /**
     * Dot: '.'
     */

    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
      let siblings = block.nodes;

      if (depth === 0 || siblings.length === 0) {
        push({ type: 'text', value });
        continue;
      }

      if (prev.type === 'dot') {
        block.range = [];
        prev.value += value;
        prev.type = 'range';

        if (block.nodes.length !== 3 && block.nodes.length !== 5) {
          block.invalid = true;
          block.ranges = 0;
          prev.type = 'text';
          continue;
        }

        block.ranges++;
        block.args = [];
        continue;
      }

      if (prev.type === 'range') {
        siblings.pop();

        let before = siblings[siblings.length - 1];
        before.value += prev.value + value;
        prev = before;
        block.ranges--;
        continue;
      }

      push({ type: 'dot', value });
      continue;
    }

    /**
     * Text
     */

    push({ type: 'text', value });
  }

  // Mark imbalanced braces and brackets as invalid
  do {
    block = stack.pop();

    if (block.type !== 'root') {
      block.nodes.forEach(node => {
        if (!node.nodes) {
          if (node.type === 'open') node.isOpen = true;
          if (node.type === 'close') node.isClose = true;
          if (!node.nodes) node.type = 'text';
          node.invalid = true;
        }
      });

      // get the location of the block on parent.nodes (block's siblings)
      let parent = stack[stack.length - 1];
      let index = parent.nodes.indexOf(block);
      // replace the (invalid) block with it's nodes
      parent.nodes.splice(index, 1, ...block.nodes);
    }
  } while (stack.length > 0);

  push({ type: 'eos' });
  return ast;
};

module.exports = parse;


/***/ }),
/* 99 */
/***/ ((module) => {

"use strict";


module.exports = {
  MAX_LENGTH: 1024 * 64,

  // Digits
  CHAR_0: '0', /* 0 */
  CHAR_9: '9', /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 'A', /* A */
  CHAR_LOWERCASE_A: 'a', /* a */
  CHAR_UPPERCASE_Z: 'Z', /* Z */
  CHAR_LOWERCASE_Z: 'z', /* z */

  CHAR_LEFT_PARENTHESES: '(', /* ( */
  CHAR_RIGHT_PARENTHESES: ')', /* ) */

  CHAR_ASTERISK: '*', /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: '&', /* & */
  CHAR_AT: '@', /* @ */
  CHAR_BACKSLASH: '\\', /* \ */
  CHAR_BACKTICK: '`', /* ` */
  CHAR_CARRIAGE_RETURN: '\r', /* \r */
  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */
  CHAR_COLON: ':', /* : */
  CHAR_COMMA: ',', /* , */
  CHAR_DOLLAR: '$', /* . */
  CHAR_DOT: '.', /* . */
  CHAR_DOUBLE_QUOTE: '"', /* " */
  CHAR_EQUAL: '=', /* = */
  CHAR_EXCLAMATION_MARK: '!', /* ! */
  CHAR_FORM_FEED: '\f', /* \f */
  CHAR_FORWARD_SLASH: '/', /* / */
  CHAR_HASH: '#', /* # */
  CHAR_HYPHEN_MINUS: '-', /* - */
  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */
  CHAR_LEFT_CURLY_BRACE: '{', /* { */
  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */
  CHAR_LINE_FEED: '\n', /* \n */
  CHAR_NO_BREAK_SPACE: '\u00A0', /* \u00A0 */
  CHAR_PERCENT: '%', /* % */
  CHAR_PLUS: '+', /* + */
  CHAR_QUESTION_MARK: '?', /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */
  CHAR_RIGHT_CURLY_BRACE: '}', /* } */
  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */
  CHAR_SEMICOLON: ';', /* ; */
  CHAR_SINGLE_QUOTE: '\'', /* ' */
  CHAR_SPACE: ' ', /*   */
  CHAR_TAB: '\t', /* \t */
  CHAR_UNDERSCORE: '_', /* _ */
  CHAR_VERTICAL_LINE: '|', /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\uFEFF' /* \uFEFF */
};


/***/ }),
/* 100 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(101);


/***/ }),
/* 101 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(23);
const scan = __webpack_require__(102);
const parse = __webpack_require__(105);
const utils = __webpack_require__(103);

/**
 * Creates a matcher function from one or more glob patterns. The
 * returned function takes a string to match as its first argument,
 * and returns true if the string is a match. The returned matcher
 * function also takes a boolean as the second argument that, when true,
 * returns an object with additional information.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch(glob[, options]);
 *
 * const isMatch = picomatch('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @name picomatch
 * @param {String|Array} `globs` One or more glob patterns.
 * @param {Object=} `options`
 * @return {Function=} Returns a matcher function.
 * @api public
 */

const picomatch = (glob, options, returnState = false) => {
  if (Array.isArray(glob)) {
    let fns = glob.map(input => picomatch(input, options, returnState));
    return str => {
      for (let isMatch of fns) {
        let state = isMatch(str);
        if (state) return state;
      }
      return false;
    };
  }

  if (typeof glob !== 'string' || glob === '') {
    throw new TypeError('Expected pattern to be a non-empty string');
  }

  let opts = options || {};
  let posix = utils.isWindows(options);
  let regex = picomatch.makeRe(glob, options, false, true);
  let state = regex.state;
  delete regex.state;

  let isIgnored = () => false;
  if (opts.ignore) {
    let ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
  }

  const matcher = (input, returnObject = false) => {
    let { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
    let result = { glob, state, regex, posix, input, output, match, isMatch };

    if (typeof opts.onResult === 'function') {
      opts.onResult(result);
    }

    if (isMatch === false) {
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (isIgnored(input)) {
      if (typeof opts.onIgnore === 'function') {
        opts.onIgnore(result);
      }
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (typeof opts.onMatch === 'function') {
      opts.onMatch(result);
    }
    return returnObject ? result : true;
  };

  if (returnState) {
    matcher.state = state;
  }

  return matcher;
};

/**
 * Test `input` with the given `regex`. This is used by the main
 * `picomatch()` function to test the input string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.test(input, regex[, options]);
 *
 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp} `regex`
 * @return {Object} Returns an object with matching info.
 * @api public
 */

picomatch.test = (input, regex, options, { glob, posix } = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected input to be a string');
  }

  if (input === '') {
    return { isMatch: false, output: '' };
  }

  let opts = options || {};
  let format = opts.format || (posix ? utils.toPosixSlashes : null);
  let match = input === glob;
  let output = (match && format) ? format(input) : input;

  if (match === false) {
    output = format ? format(input) : input;
    match = output === glob;
  }

  if (match === false || opts.capture === true) {
    if (opts.matchBase === true || opts.basename === true) {
      match = picomatch.matchBase(input, regex, options, posix);
    } else {
      match = regex.exec(output);
    }
  }

  return { isMatch: !!match, match, output };
};

/**
 * Match the basename of a filepath.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.matchBase(input, glob[, options]);
 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
 * @return {Boolean}
 * @api public
 */

picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
  let regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
  return regex.test(path.basename(input));
};

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.isMatch(string, patterns[, options]);
 *
 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String|Array} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const result = picomatch.parse(glob[, options]);
 * ```
 * @param {String} `glob`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
 * @api public
 */

picomatch.parse = (glob, options) => parse(glob, options);

/**
 * Scan a glob pattern to separate the pattern into segments.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.scan(input[, options]);
 *
 * const result = picomatch.scan('!./foo/*.js');
 * console.log(result);
 * // { prefix: '!./',
 * //   input: '!./foo/*.js',
 * //   base: 'foo',
 * //   glob: '*.js',
 * //   negated: true,
 * //   isGlob: true }
 * ```
 * @param {String} `input` Glob pattern to scan.
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */

picomatch.scan = (input, options) => scan(input, options);

/**
 * Create a regular expression from a glob pattern.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.makeRe(input[, options]);
 *
 * console.log(picomatch.makeRe('*.js'));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `input` A glob pattern to convert to regex.
 * @param {Object} `options`
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

picomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {
  if (!input || typeof input !== 'string') {
    throw new TypeError('Expected a non-empty string');
  }

  let opts = options || {};
  let prepend = opts.contains ? '' : '^';
  let append = opts.contains ? '' : '$';
  let state = { negated: false, fastpaths: true };
  let prefix = '';
  let output;

  if (input.startsWith('./')) {
    input = input.slice(2);
    prefix = state.prefix = './';
  }

  if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
    output = parse.fastpaths(input, options);
  }

  if (output === void 0) {
    state = picomatch.parse(input, options);
    state.prefix = prefix + (state.prefix || '');
    output = state.output;
  }

  if (returnOutput === true) {
    return output;
  }

  let source = `${prepend}(?:${output})${append}`;
  if (state && state.negated === true) {
    source = `^(?!${source}).*$`;
  }

  let regex = picomatch.toRegex(source, options);
  if (returnState === true) {
    regex.state = state;
  }

  return regex;
};

/**
 * Create a regular expression from the given regex source string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.toRegex(source[, options]);
 *
 * const { output } = picomatch.parse('*.js');
 * console.log(picomatch.toRegex(output));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `source` Regular expression source string.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

picomatch.toRegex = (source, options) => {
  try {
    let opts = options || {};
    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
  } catch (err) {
    if (options && options.debug === true) throw err;
    return /$^/;
  }
};

/**
 * Picomatch constants.
 * @return {Object}
 */

picomatch.constants = __webpack_require__(104);

/**
 * Expose "picomatch"
 */

module.exports = picomatch;


/***/ }),
/* 102 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const utils = __webpack_require__(103);

const {
  CHAR_ASTERISK,             /* * */
  CHAR_AT,                   /* @ */
  CHAR_BACKWARD_SLASH,       /* \ */
  CHAR_COMMA,                /* , */
  CHAR_DOT,                  /* . */
  CHAR_EXCLAMATION_MARK,     /* ! */
  CHAR_FORWARD_SLASH,        /* / */
  CHAR_LEFT_CURLY_BRACE,     /* { */
  CHAR_LEFT_PARENTHESES,     /* ( */
  CHAR_LEFT_SQUARE_BRACKET,  /* [ */
  CHAR_PLUS,                 /* + */
  CHAR_QUESTION_MARK,        /* ? */
  CHAR_RIGHT_CURLY_BRACE,    /* } */
  CHAR_RIGHT_PARENTHESES,    /* ) */
  CHAR_RIGHT_SQUARE_BRACKET /* ] */
} = __webpack_require__(104);

const isPathSeparator = code => {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
};

/**
 * Quickly scans a glob pattern and returns an object with a handful of
 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
 * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).
 *
 * ```js
 * const pm = require('picomatch');
 * console.log(pm.scan('foo/bar/*.js'));
 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an object with tokens and regex source string.
 * @api public
 */

module.exports = (input, options) => {
  let opts = options || {};
  let length = input.length - 1;
  let index = -1;
  let start = 0;
  let lastIndex = 0;
  let isGlob = false;
  let backslashes = false;
  let negated = false;
  let braces = 0;
  let prev;
  let code;

  let braceEscaped = false;

  let eos = () => index >= length;
  let advance = () => {
    prev = code;
    return input.charCodeAt(++index);
  };

  while (index < length) {
    code = advance();
    let next;

    if (code === CHAR_BACKWARD_SLASH) {
      backslashes = true;
      next = advance();

      if (next === CHAR_LEFT_CURLY_BRACE) {
        braceEscaped = true;
      }
      continue;
    }

    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
      braces++;

      while (!eos() && (next = advance())) {
        if (next === CHAR_BACKWARD_SLASH) {
          backslashes = true;
          next = advance();
          continue;
        }

        if (next === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          continue;
        }

        if (!braceEscaped && next === CHAR_DOT && (next = advance()) === CHAR_DOT) {
          isGlob = true;
          break;
        }

        if (!braceEscaped && next === CHAR_COMMA) {
          isGlob = true;
          break;
        }

        if (next === CHAR_RIGHT_CURLY_BRACE) {
          braces--;
          if (braces === 0) {
            braceEscaped = false;
            break;
          }
        }
      }
    }

    if (code === CHAR_FORWARD_SLASH) {
      if (prev === CHAR_DOT && index === (start + 1)) {
        start += 2;
        continue;
      }

      lastIndex = index + 1;
      continue;
    }

    if (code === CHAR_ASTERISK) {
      isGlob = true;
      break;
    }

    if (code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK) {
      isGlob = true;
      break;
    }

    if (code === CHAR_LEFT_SQUARE_BRACKET) {
      while (!eos() && (next = advance())) {
        if (next === CHAR_BACKWARD_SLASH) {
          backslashes = true;
          next = advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          isGlob = true;
          break;
        }
      }
    }

    let isExtglobChar = code === CHAR_PLUS
      || code === CHAR_AT
      || code === CHAR_EXCLAMATION_MARK;

    if (isExtglobChar && input.charCodeAt(index + 1) === CHAR_LEFT_PARENTHESES) {
      isGlob = true;
      break;
    }

    if (code === CHAR_EXCLAMATION_MARK && index === start) {
      negated = true;
      start++;
      continue;
    }

    if (code === CHAR_LEFT_PARENTHESES) {
      while (!eos() && (next = advance())) {
        if (next === CHAR_BACKWARD_SLASH) {
          backslashes = true;
          next = advance();
          continue;
        }

        if (next === CHAR_RIGHT_PARENTHESES) {
          isGlob = true;
          break;
        }
      }
    }

    if (isGlob) {
      break;
    }
  }

  let prefix = '';
  let orig = input;
  let base = input;
  let glob = '';

  if (start > 0) {
    prefix = input.slice(0, start);
    input = input.slice(start);
    lastIndex -= start;
  }

  if (base && isGlob === true && lastIndex > 0) {
    base = input.slice(0, lastIndex);
    glob = input.slice(lastIndex);
  } else if (isGlob === true) {
    base = '';
    glob = input;
  } else {
    base = input;
  }

  if (base && base !== '' && base !== '/' && base !== input) {
    if (isPathSeparator(base.charCodeAt(base.length - 1))) {
      base = base.slice(0, -1);
    }
  }

  if (opts.unescape === true) {
    if (glob) glob = utils.removeBackslashes(glob);

    if (base && backslashes === true) {
      base = utils.removeBackslashes(base);
    }
  }

  return { prefix, input: orig, base, glob, negated, isGlob };
};


/***/ }),
/* 103 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(23);
const win32 = process.platform === 'win32';
const {
  REGEX_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_GLOBAL,
  REGEX_REMOVE_BACKSLASH
} = __webpack_require__(104);

exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);
exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);
exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
exports.toPosixSlashes = str => str.replace(/\\/g, '/');

exports.removeBackslashes = str => {
  return str.replace(REGEX_REMOVE_BACKSLASH, match => {
    return match === '\\' ? '' : match;
  });
}

exports.supportsLookbehinds = () => {
  let segs = process.version.slice(1).split('.');
  if (segs.length === 3 && +segs[0] >= 9 || (+segs[0] === 8 && +segs[1] >= 10)) {
    return true;
  }
  return false;
};

exports.isWindows = options => {
  if (options && typeof options.windows === 'boolean') {
    return options.windows;
  }
  return win32 === true || path.sep === '\\';
};

exports.escapeLast = (input, char, lastIdx) => {
  let idx = input.lastIndexOf(char, lastIdx);
  if (idx === -1) return input;
  if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
  return input.slice(0, idx) + '\\' + input.slice(idx);
};


/***/ }),
/* 104 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(23);
const WIN_SLASH = '\\\\/';
const WIN_NO_SLASH = `[^${WIN_SLASH}]`;

/**
 * Posix glob regex
 */

const DOT_LITERAL = '\\.';
const PLUS_LITERAL = '\\+';
const QMARK_LITERAL = '\\?';
const SLASH_LITERAL = '\\/';
const ONE_CHAR = '(?=.)';
const QMARK = '[^/]';
const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
const NO_DOT = `(?!${DOT_LITERAL})`;
const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
const STAR = `${QMARK}*?`;

const POSIX_CHARS = {
  DOT_LITERAL,
  PLUS_LITERAL,
  QMARK_LITERAL,
  SLASH_LITERAL,
  ONE_CHAR,
  QMARK,
  END_ANCHOR,
  DOTS_SLASH,
  NO_DOT,
  NO_DOTS,
  NO_DOT_SLASH,
  NO_DOTS_SLASH,
  QMARK_NO_DOT,
  STAR,
  START_ANCHOR
};

/**
 * Windows glob regex
 */

const WINDOWS_CHARS = {
  ...POSIX_CHARS,

  SLASH_LITERAL: `[${WIN_SLASH}]`,
  QMARK: WIN_NO_SLASH,
  STAR: `${WIN_NO_SLASH}*?`,
  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
  NO_DOT: `(?!${DOT_LITERAL})`,
  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
};

/**
 * POSIX Bracket Regex
 */

const POSIX_REGEX_SOURCE = {
  alnum: 'a-zA-Z0-9',
  alpha: 'a-zA-Z',
  ascii: '\\x00-\\x7F',
  blank: ' \\t',
  cntrl: '\\x00-\\x1F\\x7F',
  digit: '0-9',
  graph: '\\x21-\\x7E',
  lower: 'a-z',
  print: '\\x20-\\x7E ',
  punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
  space: ' \\t\\r\\n\\v\\f',
  upper: 'A-Z',
  word: 'A-Za-z0-9_',
  xdigit: 'A-Fa-f0-9'
};

module.exports = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE,

  // regular expressions
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHAR: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,

  // Replace globs with equivalent patterns to reduce parsing time.
  REPLACEMENTS: {
    '***': '*',
    '**/**': '**',
    '**/**/**': '**'
  },

  // Digits
  CHAR_0: 48, /* 0 */
  CHAR_9: 57, /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 65, /* A */
  CHAR_LOWERCASE_A: 97, /* a */
  CHAR_UPPERCASE_Z: 90, /* Z */
  CHAR_LOWERCASE_Z: 122, /* z */

  CHAR_LEFT_PARENTHESES: 40, /* ( */
  CHAR_RIGHT_PARENTHESES: 41, /* ) */

  CHAR_ASTERISK: 42, /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: 38, /* & */
  CHAR_AT: 64, /* @ */
  CHAR_BACKWARD_SLASH: 92, /* \ */
  CHAR_CARRIAGE_RETURN: 13, /* \r */
  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */
  CHAR_COLON: 58, /* : */
  CHAR_COMMA: 44, /* , */
  CHAR_DOT: 46, /* . */
  CHAR_DOUBLE_QUOTE: 34, /* " */
  CHAR_EQUAL: 61, /* = */
  CHAR_EXCLAMATION_MARK: 33, /* ! */
  CHAR_FORM_FEED: 12, /* \f */
  CHAR_FORWARD_SLASH: 47, /* / */
  CHAR_GRAVE_ACCENT: 96, /* ` */
  CHAR_HASH: 35, /* # */
  CHAR_HYPHEN_MINUS: 45, /* - */
  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */
  CHAR_LEFT_CURLY_BRACE: 123, /* { */
  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */
  CHAR_LINE_FEED: 10, /* \n */
  CHAR_NO_BREAK_SPACE: 160, /* \u00A0 */
  CHAR_PERCENT: 37, /* % */
  CHAR_PLUS: 43, /* + */
  CHAR_QUESTION_MARK: 63, /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */
  CHAR_RIGHT_CURLY_BRACE: 125, /* } */
  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */
  CHAR_SEMICOLON: 59, /* ; */
  CHAR_SINGLE_QUOTE: 39, /* ' */
  CHAR_SPACE: 32, /*   */
  CHAR_TAB: 9, /* \t */
  CHAR_UNDERSCORE: 95, /* _ */
  CHAR_VERTICAL_LINE: 124, /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \uFEFF */

  SEP: path.sep,

  /**
   * Create EXTGLOB_CHARS
   */

  extglobChars(chars) {
    return {
      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },
      '?': { type: 'qmark', open: '(?:', close: ')?' },
      '+': { type: 'plus', open: '(?:', close: ')+' },
      '*': { type: 'star', open: '(?:', close: ')*' },
      '@': { type: 'at', open: '(?:', close: ')' }
    };
  },

  /**
   * Create GLOB_CHARS
   */

  globChars(win32) {
    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
  }
};


/***/ }),
/* 105 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const utils = __webpack_require__(103);
const constants = __webpack_require__(104);

/**
 * Constants
 */

const {
  MAX_LENGTH,
  POSIX_REGEX_SOURCE,
  REGEX_NON_SPECIAL_CHAR,
  REGEX_SPECIAL_CHARS_BACKREF,
  REPLACEMENTS
} = constants;

/**
 * Helpers
 */

const expandRange = (args, options) => {
  if (typeof options.expandRange === 'function') {
    return options.expandRange(...args, options);
  }

  args.sort();
  let value = `[${args.join('-')}]`;

  try {
    /* eslint-disable no-new */
    new RegExp(value);
  } catch (ex) {
    return args.map(v => utils.escapeRegex(v)).join('..');
  }

  return value;
};

const negate = state => {
  let count = 1;

  while (state.peek() === '!' && (state.peek(2) !== '(' || state.peek(3) === '?')) {
    state.advance();
    state.start++;
    count++;
  }

  if (count % 2 === 0) {
    return false;
  }

  state.negated = true;
  state.start++;
  return true;
};

/**
 * Create the message for a syntax error
 */

const syntaxError = (type, char) => {
  return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
};

/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */

const parse = (input, options) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  input = REPLACEMENTS[input] || input;

  let opts = { ...options };
  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  let len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  let bos = { type: 'bos', value: '', output: opts.prepend || '' };
  let tokens = [bos];

  let capture = opts.capture ? '' : '?:';
  let win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const PLATFORM_CHARS = constants.globChars(win32);
  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);

  const {
    DOT_LITERAL,
    PLUS_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  } = PLATFORM_CHARS;

  const globstar = (opts) => {
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  let nodot = opts.dot ? '' : NO_DOT;
  let star = opts.bash === true ? globstar(opts) : STAR;
  let qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;

  if (opts.capture) {
    star = `(${star})`;
  }

  // minimatch options support
  if (typeof opts.noext === 'boolean') {
    opts.noextglob = opts.noext;
  }

  let state = {
    index: -1,
    start: 0,
    consumed: '',
    output: '',
    backtrack: false,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    tokens
  };

  let extglobs = [];
  let stack = [];
  let prev = bos;
  let value;

  /**
   * Tokenizing helpers
   */

  const eos = () => state.index === len - 1;
  const peek = state.peek = (n = 1) => input[state.index + n];
  const advance = state.advance = () => input[++state.index];
  const append = token => {
    state.output += token.output != null ? token.output : token.value;
    state.consumed += token.value || '';
  };

  const increment = type => {
    state[type]++;
    stack.push(type);
  };

  const decrement = type => {
    state[type]--;
    stack.pop();
  };

  /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */

  const push = tok => {
    if (prev.type === 'globstar') {
      let isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
      let isExtglob = extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');
      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = 'star';
        prev.value = '*';
        prev.output = star;
        state.output += prev.output;
      }
    }

    if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {
      extglobs[extglobs.length - 1].inner += tok.value;
    }

    if (tok.value || tok.output) append(tok);
    if (prev && prev.type === 'text' && tok.type === 'text') {
      prev.value += tok.value;
      return;
    }

    tok.prev = prev;
    tokens.push(tok);
    prev = tok;
  };

  const extglobOpen = (type, value) => {
    let token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };

    token.prev = prev;
    token.parens = state.parens;
    token.output = state.output;
    let output = (opts.capture ? '(' : '') + token.open;

    push({ type, value, output: state.output ? '' : ONE_CHAR });
    push({ type: 'paren', extglob: true, value: advance(), output });
    increment('parens');
    extglobs.push(token);
  };

  const extglobClose = token => {
    let output = token.close + (opts.capture ? ')' : '');

    if (token.type === 'negate') {
      let extglobStar = star;

      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
        extglobStar = globstar(opts);
      }

      if (extglobStar !== star || eos() || /^\)+$/.test(input.slice(state.index + 1))) {
        output = token.close = ')$))' + extglobStar;
      }

      if (token.prev.type === 'bos' && eos()) {
        state.negatedExtglob = true;
      }
    }

    push({ type: 'paren', extglob: true, value, output });
    decrement('parens');
  };

  if (opts.fastpaths !== false && !/(^[*!]|[/{[()\]}"])/.test(input)) {
    let backslashes = false;

    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
      if (first === '\\') {
        backslashes = true;
        return m;
      }

      if (first === '?') {
        if (esc) {
          return esc + first + (rest ? QMARK.repeat(rest.length) : '');
        }
        if (index === 0) {
          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
        }
        return QMARK.repeat(chars.length);
      }

      if (first === '.') {
        return DOT_LITERAL.repeat(chars.length);
      }

      if (first === '*') {
        if (esc) {
          return esc + first + (rest ? star : '');
        }
        return star;
      }
      return esc ? m : '\\' + m;
    });

    if (backslashes === true) {
      if (opts.unescape === true) {
        output = output.replace(/\\/g, '');
      } else {
        output = output.replace(/\\+/g, m => {
          return m.length % 2 === 0 ? '\\\\' : (m ? '\\' : '');
        });
      }
    }

    state.output = output;
    return state;
  }

  /**
   * Tokenize input until we reach end-of-string
   */

  while (!eos()) {
    value = advance();

    if (value === '\u0000') {
      continue;
    }

    /**
     * Escaped characters
     */

    if (value === '\\') {
      let next = peek();

      if (next === '/' && opts.bash !== true) {
        continue;
      }

      if (next === '.' || next === ';') {
        continue;
      }

      if (!next) {
        value += '\\';
        push({ type: 'text', value });
        continue;
      }

      // collapse slashes to reduce potential for exploits
      let match = /^\\+/.exec(input.slice(state.index + 1));
      let slashes = 0;

      if (match && match[0].length > 2) {
        slashes = match[0].length;
        state.index += slashes;
        if (slashes % 2 !== 0) {
          value += '\\';
        }
      }

      if (opts.unescape === true) {
        value = advance() || '';
      } else {
        value += advance() || '';
      }

      if (state.brackets === 0) {
        push({ type: 'text', value });
        continue;
      }
    }

    /**
     * If we're inside a regex character class, continue
     * until we reach the closing bracket.
     */

    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
      if (opts.posix !== false && value === ':') {
        let inner = prev.value.slice(1);
        if (inner.includes('[')) {
          prev.posix = true;

          if (inner.includes(':')) {
            let idx = prev.value.lastIndexOf('[');
            let pre = prev.value.slice(0, idx);
            let rest = prev.value.slice(idx + 2);
            let posix = POSIX_REGEX_SOURCE[rest];
            if (posix) {
              prev.value = pre + posix;
              state.backtrack = true;
              advance();

              if (!bos.output && tokens.indexOf(prev) === 1) {
                bos.output = ONE_CHAR;
              }
              continue;
            }
          }
        }
      }

      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {
        value = '\\' + value;
      }

      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
        value = '\\' + value;
      }

      if (opts.posix === true && value === '!' && prev.value === '[') {
        value = '^';
      }

      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * If we're inside a quoted string, continue
     * until we reach the closing double quote.
     */

    if (state.quotes === 1 && value !== '"') {
      value = utils.escapeRegex(value);
      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * Double quotes
     */

    if (value === '"') {
      state.quotes = state.quotes === 1 ? 0 : 1;
      if (opts.keepQuotes === true) {
        push({ type: 'text', value });
      }
      continue;
    }

    /**
     * Parentheses
     */

    if (value === '(') {
      push({ type: 'paren', value });
      increment('parens');
      continue;
    }

    if (value === ')') {
      if (state.parens === 0 && opts.strictBrackets === true) {
        throw new SyntaxError(syntaxError('opening', '('));
      }

      let extglob = extglobs[extglobs.length - 1];
      if (extglob && state.parens === extglob.parens + 1) {
        extglobClose(extglobs.pop());
        continue;
      }

      push({ type: 'paren', value, output: state.parens ? ')' : '\\)' });
      decrement('parens');
      continue;
    }

    /**
     * Brackets
     */

    if (value === '[') {
      if (opts.nobracket === true || !input.slice(state.index + 1).includes(']')) {
        if (opts.nobracket !== true && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('closing', ']'));
        }

        value = '\\' + value;
      } else {
        increment('brackets');
      }

      push({ type: 'bracket', value });
      continue;
    }

    if (value === ']') {
      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {
        push({ type: 'text', value, output: '\\' + value });
        continue;
      }

      if (state.brackets === 0) {
        if (opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('opening', '['));
        }

        push({ type: 'text', value, output: '\\' + value });
        continue;
      }

      decrement('brackets');

      let prevValue = prev.value.slice(1);
      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
        value = '/' + value;
      }

      prev.value += value;
      append({ value });

      // when literal brackets are explicitly disabled
      // assume we should match with a regex character class
      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
        continue;
      }

      let escaped = utils.escapeRegex(prev.value);
      state.output = state.output.slice(0, -prev.value.length);

      // when literal brackets are explicitly enabled
      // assume we should escape the brackets to match literal characters
      if (opts.literalBrackets === true) {
        state.output += escaped;
        prev.value = escaped;
        continue;
      }

      // when the user specifies nothing, try to match both
      prev.value = `(${capture}${escaped}|${prev.value})`;
      state.output += prev.value;
      continue;
    }

    /**
     * Braces
     */

    if (value === '{' && opts.nobrace !== true) {
      push({ type: 'brace', value, output: '(' });
      increment('braces');
      continue;
    }

    if (value === '}') {
      if (opts.nobrace === true || state.braces === 0) {
        push({ type: 'text', value, output: '\\' + value });
        continue;
      }

      let output = ')';

      if (state.dots === true) {
        let arr = tokens.slice();
        let range = [];

        for (let i = arr.length - 1; i >= 0; i--) {
          tokens.pop();
          if (arr[i].type === 'brace') {
            break;
          }
          if (arr[i].type !== 'dots') {
            range.unshift(arr[i].value);
          }
        }

        output = expandRange(range, opts);
        state.backtrack = true;
      }

      push({ type: 'brace', value, output });
      decrement('braces');
      continue;
    }

    /**
     * Pipes
     */

    if (value === '|') {
      if (extglobs.length > 0) {
        extglobs[extglobs.length - 1].conditions++;
      }
      push({ type: 'text', value });
      continue;
    }

    /**
     * Commas
     */

    if (value === ',') {
      let output = value;

      if (state.braces > 0 && stack[stack.length - 1] === 'braces') {
        output = '|';
      }

      push({ type: 'comma', value, output });
      continue;
    }

    /**
     * Slashes
     */

    if (value === '/') {
      // if the beginning of the glob is "./", advance the start
      // to the current index, and don't add the "./" characters
      // to the state. This greatly simplifies lookbehinds when
      // checking for BOS characters like "!" and "." (not "./")
      if (prev.type === 'dot' && state.index === 1) {
        state.start = state.index + 1;
        state.consumed = '';
        state.output = '';
        tokens.pop();
        prev = bos; // reset "prev" to the first token
        continue;
      }

      push({ type: 'slash', value, output: SLASH_LITERAL });
      continue;
    }

    /**
     * Dots
     */

    if (value === '.') {
      if (state.braces > 0 && prev.type === 'dot') {
        if (prev.value === '.') prev.output = DOT_LITERAL;
        prev.type = 'dots';
        prev.output += value;
        prev.value += value;
        state.dots = true;
        continue;
      }

      push({ type: 'dot', value, output: DOT_LITERAL });
      continue;
    }

    /**
     * Question marks
     */

    if (value === '?') {
      if (prev && prev.type === 'paren') {
        let next = peek();
        let output = value;

        if (next === '<' && !utils.supportsLookbehinds()) {
          throw new Error('Node.js v10 or higher is required for regex lookbehinds');
        }

        if (prev.value === '(' && !/[!=<:]/.test(next) || (next === '<' && !/[!=]/.test(peek(2)))) {
          output = '\\' + value;
        }

        push({ type: 'text', value, output });
        continue;
      }

      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('qmark', value);
        continue;
      }

      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
        push({ type: 'qmark', value, output: QMARK_NO_DOT });
        continue;
      }

      push({ type: 'qmark', value, output: QMARK });
      continue;
    }

    /**
     * Exclamation
     */

    if (value === '!') {
      if (opts.noextglob !== true && peek() === '(') {
        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
          extglobOpen('negate', value);
          continue;
        }
      }

      if (opts.nonegate !== true && state.index === 0) {
        negate(state);
        continue;
      }
    }

    /**
     * Plus
     */

    if (value === '+') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('plus', value);
        continue;
      }

      if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) {
        let output = prev.extglob === true ? '\\' + value : value;
        push({ type: 'plus', value, output });
        continue;
      }

      // use regex behavior inside parens
      if (state.parens > 0 && opts.regex !== false) {
        push({ type: 'plus', value });
        continue;
      }

      push({ type: 'plus', value: PLUS_LITERAL });
      continue;
    }

    /**
     * Plain text
     */

    if (value === '@') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        push({ type: 'at', value, output: '' });
        continue;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Plain text
     */

    if (value !== '*') {
      if (value === '$' || value === '^') {
        value = '\\' + value;
      }

      let match = REGEX_NON_SPECIAL_CHAR.exec(input.slice(state.index + 1));
      if (match) {
        value += match[0];
        state.index += match[0].length;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Stars
     */

    if (prev && (prev.type === 'globstar' || prev.star === true)) {
      prev.type = 'star';
      prev.star = true;
      prev.value += value;
      prev.output = star;
      state.backtrack = true;
      state.consumed += value;
      continue;
    }

    if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
      extglobOpen('star', value);
      continue;
    }

    if (prev.type === 'star') {
      if (opts.noglobstar === true) {
        state.consumed += value;
        continue;
      }

      let prior = prev.prev;
      let before = prior.prev;
      let isStart = prior.type === 'slash' || prior.type === 'bos';
      let afterStar = before && (before.type === 'star' || before.type === 'globstar');

      if (opts.bash === true && (!isStart || (!eos() && peek() !== '/'))) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      let isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
      let isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      // strip consecutive `/**/`
      while (input.slice(state.index + 1, state.index + 4) === '/**') {
        let after = input[state.index + 4];
        if (after && after !== '/') {
          break;
        }
        state.consumed += '/**';
        state.index += 3;
      }

      if (prior.type === 'bos' && eos()) {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = globstar(opts);
        state.output = prev.output;
        state.consumed += value;
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = '(?:' + prior.output;

        prev.type = 'globstar';
        prev.output = globstar(opts) + '|$)';
        prev.value += value;

        state.output += prior.output + prev.output;
        state.consumed += value;
        continue;
      }

      let next = peek();
      if (prior.type === 'slash' && prior.prev.type !== 'bos' && next === '/') {
        let end = peek(2) !== void 0 ? '|$' : '';

        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = '(?:' + prior.output;

        prev.type = 'globstar';
        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
        prev.value += value;

        state.output += prior.output + prev.output;
        state.consumed += value + advance();

        push({ type: 'slash', value, output: '' });
        continue;
      }

      if (prior.type === 'bos' && next === '/') {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
        state.output = prev.output;
        state.consumed += value + advance();
        push({ type: 'slash', value, output: '' });
        continue;
      }

      // remove single star from output
      state.output = state.output.slice(0, -prev.output.length);

      // reset previous token to globstar
      prev.type = 'globstar';
      prev.output = globstar(opts);
      prev.value += value;

      // reset output with globstar
      state.output += prev.output;
      state.consumed += value;
      continue;
    }

    let token = { type: 'star', value, output: star };

    if (opts.bash === true) {
      token.output = '.*?';
      if (prev.type === 'bos' || prev.type === 'slash') {
        token.output = nodot + token.output;
      }
      push(token);
      continue;
    }

    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
      token.output = value;
      push(token);
      continue;
    }

    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
      if (prev.type === 'dot') {
        state.output += NO_DOT_SLASH;
        prev.output += NO_DOT_SLASH;

      } else if (opts.dot === true) {
        state.output += NO_DOTS_SLASH;
        prev.output += NO_DOTS_SLASH;

      } else {
        state.output += nodot;
        prev.output += nodot;
      }

      if (peek() !== '*') {
        state.output += ONE_CHAR;
        prev.output += ONE_CHAR;
      }
    }

    push(token);
  }

  while (state.brackets > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
    state.output = utils.escapeLast(state.output, '[');
    decrement('brackets');
  }

  while (state.parens > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
    state.output = utils.escapeLast(state.output, '(');
    decrement('parens');
  }

  while (state.braces > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
    state.output = utils.escapeLast(state.output, '{');
    decrement('braces');
  }

  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });
  }

  // rebuild the output if we had to backtrack at any point
  if (state.backtrack === true) {
    state.output = '';

    for (let token of state.tokens) {
      state.output += token.output != null ? token.output : token.value;

      if (token.suffix) {
        state.output += token.suffix;
      }
    }
  }

  return state;
};

/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */

parse.fastpaths = (input, options) => {
  let opts = { ...options };
  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  let len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  input = REPLACEMENTS[input] || input;
  let win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const {
    DOT_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOTS_SLASH,
    STAR,
    START_ANCHOR
  } = constants.globChars(win32);

  let capture = opts.capture ? '' : '?:';
  let star = opts.bash === true ? '.*?' : STAR;
  let nodot = opts.dot ? NO_DOTS : NO_DOT;
  let slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;

  if (opts.capture) {
    star = `(${star})`;
  }

  const globstar = (opts) => {
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const create = str => {
    switch (str) {
      case '*':
        return `${nodot}${ONE_CHAR}${star}`;

      case '.*':
        return `${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*.*':
        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*/*':
        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;

      case '**':
        return nodot + globstar(opts);

      case '**/*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;

      case '**/*.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '**/.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;

      default: {
        let match = /^(.*?)\.(\w+)$/.exec(str);
        if (!match) return;

        let source = create(match[1], options);
        if (!source) return;

        return source + DOT_LITERAL + match[2];
      }
    }
  };

  let output = create(input);
  if (output && opts.strictSlashes !== true) {
    output += `${SLASH_LITERAL}?`;
  }

  return output;
};

module.exports = parse;


/***/ }),
/* 106 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(107);


/***/ }),
/* 107 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(23);
const scan = __webpack_require__(108);
const parse = __webpack_require__(111);
const utils = __webpack_require__(109);
const constants = __webpack_require__(110);
const isObject = val => val && typeof val === 'object' && !Array.isArray(val);

/**
 * Creates a matcher function from one or more glob patterns. The
 * returned function takes a string to match as its first argument,
 * and returns true if the string is a match. The returned matcher
 * function also takes a boolean as the second argument that, when true,
 * returns an object with additional information.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch(glob[, options]);
 *
 * const isMatch = picomatch('*.!(*a)');
 * console.log(isMatch('a.a')); //=> false
 * console.log(isMatch('a.b')); //=> true
 * ```
 * @name picomatch
 * @param {String|Array} `globs` One or more glob patterns.
 * @param {Object=} `options`
 * @return {Function=} Returns a matcher function.
 * @api public
 */

const picomatch = (glob, options, returnState = false) => {
  if (Array.isArray(glob)) {
    const fns = glob.map(input => picomatch(input, options, returnState));
    const arrayMatcher = str => {
      for (const isMatch of fns) {
        const state = isMatch(str);
        if (state) return state;
      }
      return false;
    };
    return arrayMatcher;
  }

  const isState = isObject(glob) && glob.tokens && glob.input;

  if (glob === '' || (typeof glob !== 'string' && !isState)) {
    throw new TypeError('Expected pattern to be a non-empty string');
  }

  const opts = options || {};
  const posix = utils.isWindows(options);
  const regex = isState
    ? picomatch.compileRe(glob, options)
    : picomatch.makeRe(glob, options, false, true);

  const state = regex.state;
  delete regex.state;

  let isIgnored = () => false;
  if (opts.ignore) {
    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
  }

  const matcher = (input, returnObject = false) => {
    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
    const result = { glob, state, regex, posix, input, output, match, isMatch };

    if (typeof opts.onResult === 'function') {
      opts.onResult(result);
    }

    if (isMatch === false) {
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (isIgnored(input)) {
      if (typeof opts.onIgnore === 'function') {
        opts.onIgnore(result);
      }
      result.isMatch = false;
      return returnObject ? result : false;
    }

    if (typeof opts.onMatch === 'function') {
      opts.onMatch(result);
    }
    return returnObject ? result : true;
  };

  if (returnState) {
    matcher.state = state;
  }

  return matcher;
};

/**
 * Test `input` with the given `regex`. This is used by the main
 * `picomatch()` function to test the input string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.test(input, regex[, options]);
 *
 * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\/([^/]*?))$/));
 * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp} `regex`
 * @return {Object} Returns an object with matching info.
 * @api public
 */

picomatch.test = (input, regex, options, { glob, posix } = {}) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected input to be a string');
  }

  if (input === '') {
    return { isMatch: false, output: '' };
  }

  const opts = options || {};
  const format = opts.format || (posix ? utils.toPosixSlashes : null);
  let match = input === glob;
  let output = (match && format) ? format(input) : input;

  if (match === false) {
    output = format ? format(input) : input;
    match = output === glob;
  }

  if (match === false || opts.capture === true) {
    if (opts.matchBase === true || opts.basename === true) {
      match = picomatch.matchBase(input, regex, options, posix);
    } else {
      match = regex.exec(output);
    }
  }

  return { isMatch: Boolean(match), match, output };
};

/**
 * Match the basename of a filepath.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.matchBase(input, glob[, options]);
 * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true
 * ```
 * @param {String} `input` String to test.
 * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).
 * @return {Boolean}
 * @api public
 */

picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
  return regex.test(path.basename(input));
};

/**
 * Returns true if **any** of the given glob `patterns` match the specified `string`.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.isMatch(string, patterns[, options]);
 *
 * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true
 * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false
 * ```
 * @param {String|Array} str The string to test.
 * @param {String|Array} patterns One or more glob patterns to use for matching.
 * @param {Object} [options] See available [options](#options).
 * @return {Boolean} Returns true if any patterns match `str`
 * @api public
 */

picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);

/**
 * Parse a glob pattern to create the source string for a regular
 * expression.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const result = picomatch.parse(pattern[, options]);
 * ```
 * @param {String} `pattern`
 * @param {Object} `options`
 * @return {Object} Returns an object with useful properties and output to be used as a regex source string.
 * @api public
 */

picomatch.parse = (pattern, options) => {
  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));
  return parse(pattern, { ...options, fastpaths: false });
};

/**
 * Scan a glob pattern to separate the pattern into segments.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.scan(input[, options]);
 *
 * const result = picomatch.scan('!./foo/*.js');
 * console.log(result);
 * { prefix: '!./',
 *   input: '!./foo/*.js',
 *   start: 3,
 *   base: 'foo',
 *   glob: '*.js',
 *   isBrace: false,
 *   isBracket: false,
 *   isGlob: true,
 *   isExtglob: false,
 *   isGlobstar: false,
 *   negated: true }
 * ```
 * @param {String} `input` Glob pattern to scan.
 * @param {Object} `options`
 * @return {Object} Returns an object with
 * @api public
 */

picomatch.scan = (input, options) => scan(input, options);

/**
 * Create a regular expression from a parsed glob pattern.
 *
 * ```js
 * const picomatch = require('picomatch');
 * const state = picomatch.parse('*.js');
 * // picomatch.compileRe(state[, options]);
 *
 * console.log(picomatch.compileRe(state));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `state` The object returned from the `.parse` method.
 * @param {Object} `options`
 * @return {RegExp} Returns a regex created from the given pattern.
 * @api public
 */

picomatch.compileRe = (parsed, options, returnOutput = false, returnState = false) => {
  if (returnOutput === true) {
    return parsed.output;
  }

  const opts = options || {};
  const prepend = opts.contains ? '' : '^';
  const append = opts.contains ? '' : '$';

  let source = `${prepend}(?:${parsed.output})${append}`;
  if (parsed && parsed.negated === true) {
    source = `^(?!${source}).*$`;
  }

  const regex = picomatch.toRegex(source, options);
  if (returnState === true) {
    regex.state = parsed;
  }

  return regex;
};

picomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {
  if (!input || typeof input !== 'string') {
    throw new TypeError('Expected a non-empty string');
  }

  const opts = options || {};
  let parsed = { negated: false, fastpaths: true };
  let prefix = '';
  let output;

  if (input.startsWith('./')) {
    input = input.slice(2);
    prefix = parsed.prefix = './';
  }

  if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {
    output = parse.fastpaths(input, options);
  }

  if (output === undefined) {
    parsed = parse(input, options);
    parsed.prefix = prefix + (parsed.prefix || '');
  } else {
    parsed.output = output;
  }

  return picomatch.compileRe(parsed, options, returnOutput, returnState);
};

/**
 * Create a regular expression from the given regex source string.
 *
 * ```js
 * const picomatch = require('picomatch');
 * // picomatch.toRegex(source[, options]);
 *
 * const { output } = picomatch.parse('*.js');
 * console.log(picomatch.toRegex(output));
 * //=> /^(?:(?!\.)(?=.)[^/]*?\.js)$/
 * ```
 * @param {String} `source` Regular expression source string.
 * @param {Object} `options`
 * @return {RegExp}
 * @api public
 */

picomatch.toRegex = (source, options) => {
  try {
    const opts = options || {};
    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));
  } catch (err) {
    if (options && options.debug === true) throw err;
    return /$^/;
  }
};

/**
 * Picomatch constants.
 * @return {Object}
 */

picomatch.constants = constants;

/**
 * Expose "picomatch"
 */

module.exports = picomatch;


/***/ }),
/* 108 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const utils = __webpack_require__(109);
const {
  CHAR_ASTERISK,             /* * */
  CHAR_AT,                   /* @ */
  CHAR_BACKWARD_SLASH,       /* \ */
  CHAR_COMMA,                /* , */
  CHAR_DOT,                  /* . */
  CHAR_EXCLAMATION_MARK,     /* ! */
  CHAR_FORWARD_SLASH,        /* / */
  CHAR_LEFT_CURLY_BRACE,     /* { */
  CHAR_LEFT_PARENTHESES,     /* ( */
  CHAR_LEFT_SQUARE_BRACKET,  /* [ */
  CHAR_PLUS,                 /* + */
  CHAR_QUESTION_MARK,        /* ? */
  CHAR_RIGHT_CURLY_BRACE,    /* } */
  CHAR_RIGHT_PARENTHESES,    /* ) */
  CHAR_RIGHT_SQUARE_BRACKET  /* ] */
} = __webpack_require__(110);

const isPathSeparator = code => {
  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
};

const depth = token => {
  if (token.isPrefix !== true) {
    token.depth = token.isGlobstar ? Infinity : 1;
  }
};

/**
 * Quickly scans a glob pattern and returns an object with a handful of
 * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),
 * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).
 *
 * ```js
 * const pm = require('picomatch');
 * console.log(pm.scan('foo/bar/*.js'));
 * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }
 * ```
 * @param {String} `str`
 * @param {Object} `options`
 * @return {Object} Returns an object with tokens and regex source string.
 * @api public
 */

const scan = (input, options) => {
  const opts = options || {};

  const length = input.length - 1;
  const scanToEnd = opts.parts === true || opts.scanToEnd === true;
  const slashes = [];
  const tokens = [];
  const parts = [];

  let str = input;
  let index = -1;
  let start = 0;
  let lastIndex = 0;
  let isBrace = false;
  let isBracket = false;
  let isGlob = false;
  let isExtglob = false;
  let isGlobstar = false;
  let braceEscaped = false;
  let backslashes = false;
  let negated = false;
  let finished = false;
  let braces = 0;
  let prev;
  let code;
  let token = { value: '', depth: 0, isGlob: false };

  const eos = () => index >= length;
  const peek = () => str.charCodeAt(index + 1);
  const advance = () => {
    prev = code;
    return str.charCodeAt(++index);
  };

  while (index < length) {
    code = advance();
    let next;

    if (code === CHAR_BACKWARD_SLASH) {
      backslashes = token.backslashes = true;
      code = advance();

      if (code === CHAR_LEFT_CURLY_BRACE) {
        braceEscaped = true;
      }
      continue;
    }

    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
      braces++;

      while (eos() !== true && (code = advance())) {
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          continue;
        }

        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (braceEscaped !== true && code === CHAR_COMMA) {
          isBrace = token.isBrace = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }

          break;
        }

        if (code === CHAR_RIGHT_CURLY_BRACE) {
          braces--;

          if (braces === 0) {
            braceEscaped = false;
            isBrace = token.isBrace = true;
            finished = true;
            break;
          }
        }
      }

      if (scanToEnd === true) {
        continue;
      }

      break;
    }

    if (code === CHAR_FORWARD_SLASH) {
      slashes.push(index);
      tokens.push(token);
      token = { value: '', depth: 0, isGlob: false };

      if (finished === true) continue;
      if (prev === CHAR_DOT && index === (start + 1)) {
        start += 2;
        continue;
      }

      lastIndex = index + 1;
      continue;
    }

    if (opts.noext !== true) {
      const isExtglobChar = code === CHAR_PLUS
        || code === CHAR_AT
        || code === CHAR_ASTERISK
        || code === CHAR_QUESTION_MARK
        || code === CHAR_EXCLAMATION_MARK;

      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
        isGlob = token.isGlob = true;
        isExtglob = token.isExtglob = true;
        finished = true;

        if (scanToEnd === true) {
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              code = advance();
              continue;
            }

            if (code === CHAR_RIGHT_PARENTHESES) {
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          continue;
        }
        break;
      }
    }

    if (code === CHAR_ASTERISK) {
      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }
      break;
    }

    if (code === CHAR_QUESTION_MARK) {
      isGlob = token.isGlob = true;
      finished = true;

      if (scanToEnd === true) {
        continue;
      }
      break;
    }

    if (code === CHAR_LEFT_SQUARE_BRACKET) {
      while (eos() !== true && (next = advance())) {
        if (next === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          advance();
          continue;
        }

        if (next === CHAR_RIGHT_SQUARE_BRACKET) {
          isBracket = token.isBracket = true;
          isGlob = token.isGlob = true;
          finished = true;

          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
    }

    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
      negated = token.negated = true;
      start++;
      continue;
    }

    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
      isGlob = token.isGlob = true;

      if (scanToEnd === true) {
        while (eos() !== true && (code = advance())) {
          if (code === CHAR_LEFT_PARENTHESES) {
            backslashes = token.backslashes = true;
            code = advance();
            continue;
          }

          if (code === CHAR_RIGHT_PARENTHESES) {
            finished = true;
            break;
          }
        }
        continue;
      }
      break;
    }

    if (isGlob === true) {
      finished = true;

      if (scanToEnd === true) {
        continue;
      }

      break;
    }
  }

  if (opts.noext === true) {
    isExtglob = false;
    isGlob = false;
  }

  let base = str;
  let prefix = '';
  let glob = '';

  if (start > 0) {
    prefix = str.slice(0, start);
    str = str.slice(start);
    lastIndex -= start;
  }

  if (base && isGlob === true && lastIndex > 0) {
    base = str.slice(0, lastIndex);
    glob = str.slice(lastIndex);
  } else if (isGlob === true) {
    base = '';
    glob = str;
  } else {
    base = str;
  }

  if (base && base !== '' && base !== '/' && base !== str) {
    if (isPathSeparator(base.charCodeAt(base.length - 1))) {
      base = base.slice(0, -1);
    }
  }

  if (opts.unescape === true) {
    if (glob) glob = utils.removeBackslashes(glob);

    if (base && backslashes === true) {
      base = utils.removeBackslashes(base);
    }
  }

  const state = {
    prefix,
    input,
    start,
    base,
    glob,
    isBrace,
    isBracket,
    isGlob,
    isExtglob,
    isGlobstar,
    negated
  };

  if (opts.tokens === true) {
    state.maxDepth = 0;
    if (!isPathSeparator(code)) {
      tokens.push(token);
    }
    state.tokens = tokens;
  }

  if (opts.parts === true || opts.tokens === true) {
    let prevIndex;

    for (let idx = 0; idx < slashes.length; idx++) {
      const n = prevIndex ? prevIndex + 1 : start;
      const i = slashes[idx];
      const value = input.slice(n, i);
      if (opts.tokens) {
        if (idx === 0 && start !== 0) {
          tokens[idx].isPrefix = true;
          tokens[idx].value = prefix;
        } else {
          tokens[idx].value = value;
        }
        depth(tokens[idx]);
        state.maxDepth += tokens[idx].depth;
      }
      if (idx !== 0 || value !== '') {
        parts.push(value);
      }
      prevIndex = i;
    }

    if (prevIndex && prevIndex + 1 < input.length) {
      const value = input.slice(prevIndex + 1);
      parts.push(value);

      if (opts.tokens) {
        tokens[tokens.length - 1].value = value;
        depth(tokens[tokens.length - 1]);
        state.maxDepth += tokens[tokens.length - 1].depth;
      }
    }

    state.slashes = slashes;
    state.parts = parts;
  }

  return state;
};

module.exports = scan;


/***/ }),
/* 109 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(23);
const win32 = process.platform === 'win32';
const {
  REGEX_BACKSLASH,
  REGEX_REMOVE_BACKSLASH,
  REGEX_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_GLOBAL
} = __webpack_require__(110);

exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);
exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);
exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);
exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\$1');
exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');

exports.removeBackslashes = str => {
  return str.replace(REGEX_REMOVE_BACKSLASH, match => {
    return match === '\\' ? '' : match;
  });
};

exports.supportsLookbehinds = () => {
  const segs = process.version.slice(1).split('.').map(Number);
  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {
    return true;
  }
  return false;
};

exports.isWindows = options => {
  if (options && typeof options.windows === 'boolean') {
    return options.windows;
  }
  return win32 === true || path.sep === '\\';
};

exports.escapeLast = (input, char, lastIdx) => {
  const idx = input.lastIndexOf(char, lastIdx);
  if (idx === -1) return input;
  if (input[idx - 1] === '\\') return exports.escapeLast(input, char, idx - 1);
  return `${input.slice(0, idx)}\\${input.slice(idx)}`;
};

exports.removePrefix = (input, state = {}) => {
  let output = input;
  if (output.startsWith('./')) {
    output = output.slice(2);
    state.prefix = './';
  }
  return output;
};

exports.wrapOutput = (input, state = {}, options = {}) => {
  const prepend = options.contains ? '' : '^';
  const append = options.contains ? '' : '$';

  let output = `${prepend}(?:${input})${append}`;
  if (state.negated === true) {
    output = `(?:^(?!${output}).*$)`;
  }
  return output;
};


/***/ }),
/* 110 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(23);
const WIN_SLASH = '\\\\/';
const WIN_NO_SLASH = `[^${WIN_SLASH}]`;

/**
 * Posix glob regex
 */

const DOT_LITERAL = '\\.';
const PLUS_LITERAL = '\\+';
const QMARK_LITERAL = '\\?';
const SLASH_LITERAL = '\\/';
const ONE_CHAR = '(?=.)';
const QMARK = '[^/]';
const END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
const START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
const DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
const NO_DOT = `(?!${DOT_LITERAL})`;
const NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
const NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
const NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
const QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
const STAR = `${QMARK}*?`;

const POSIX_CHARS = {
  DOT_LITERAL,
  PLUS_LITERAL,
  QMARK_LITERAL,
  SLASH_LITERAL,
  ONE_CHAR,
  QMARK,
  END_ANCHOR,
  DOTS_SLASH,
  NO_DOT,
  NO_DOTS,
  NO_DOT_SLASH,
  NO_DOTS_SLASH,
  QMARK_NO_DOT,
  STAR,
  START_ANCHOR
};

/**
 * Windows glob regex
 */

const WINDOWS_CHARS = {
  ...POSIX_CHARS,

  SLASH_LITERAL: `[${WIN_SLASH}]`,
  QMARK: WIN_NO_SLASH,
  STAR: `${WIN_NO_SLASH}*?`,
  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
  NO_DOT: `(?!${DOT_LITERAL})`,
  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
};

/**
 * POSIX Bracket Regex
 */

const POSIX_REGEX_SOURCE = {
  alnum: 'a-zA-Z0-9',
  alpha: 'a-zA-Z',
  ascii: '\\x00-\\x7F',
  blank: ' \\t',
  cntrl: '\\x00-\\x1F\\x7F',
  digit: '0-9',
  graph: '\\x21-\\x7E',
  lower: 'a-z',
  print: '\\x20-\\x7E ',
  punct: '\\-!"#$%&\'()\\*+,./:;<=>?@[\\]^_`{|}~',
  space: ' \\t\\r\\n\\v\\f',
  upper: 'A-Z',
  word: 'A-Za-z0-9_',
  xdigit: 'A-Fa-f0-9'
};

module.exports = {
  MAX_LENGTH: 1024 * 64,
  POSIX_REGEX_SOURCE,

  // regular expressions
  REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
  REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
  REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
  REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,

  // Replace globs with equivalent patterns to reduce parsing time.
  REPLACEMENTS: {
    '***': '*',
    '**/**': '**',
    '**/**/**': '**'
  },

  // Digits
  CHAR_0: 48, /* 0 */
  CHAR_9: 57, /* 9 */

  // Alphabet chars.
  CHAR_UPPERCASE_A: 65, /* A */
  CHAR_LOWERCASE_A: 97, /* a */
  CHAR_UPPERCASE_Z: 90, /* Z */
  CHAR_LOWERCASE_Z: 122, /* z */

  CHAR_LEFT_PARENTHESES: 40, /* ( */
  CHAR_RIGHT_PARENTHESES: 41, /* ) */

  CHAR_ASTERISK: 42, /* * */

  // Non-alphabetic chars.
  CHAR_AMPERSAND: 38, /* & */
  CHAR_AT: 64, /* @ */
  CHAR_BACKWARD_SLASH: 92, /* \ */
  CHAR_CARRIAGE_RETURN: 13, /* \r */
  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */
  CHAR_COLON: 58, /* : */
  CHAR_COMMA: 44, /* , */
  CHAR_DOT: 46, /* . */
  CHAR_DOUBLE_QUOTE: 34, /* " */
  CHAR_EQUAL: 61, /* = */
  CHAR_EXCLAMATION_MARK: 33, /* ! */
  CHAR_FORM_FEED: 12, /* \f */
  CHAR_FORWARD_SLASH: 47, /* / */
  CHAR_GRAVE_ACCENT: 96, /* ` */
  CHAR_HASH: 35, /* # */
  CHAR_HYPHEN_MINUS: 45, /* - */
  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */
  CHAR_LEFT_CURLY_BRACE: 123, /* { */
  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */
  CHAR_LINE_FEED: 10, /* \n */
  CHAR_NO_BREAK_SPACE: 160, /* \u00A0 */
  CHAR_PERCENT: 37, /* % */
  CHAR_PLUS: 43, /* + */
  CHAR_QUESTION_MARK: 63, /* ? */
  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */
  CHAR_RIGHT_CURLY_BRACE: 125, /* } */
  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */
  CHAR_SEMICOLON: 59, /* ; */
  CHAR_SINGLE_QUOTE: 39, /* ' */
  CHAR_SPACE: 32, /*   */
  CHAR_TAB: 9, /* \t */
  CHAR_UNDERSCORE: 95, /* _ */
  CHAR_VERTICAL_LINE: 124, /* | */
  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \uFEFF */

  SEP: path.sep,

  /**
   * Create EXTGLOB_CHARS
   */

  extglobChars(chars) {
    return {
      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },
      '?': { type: 'qmark', open: '(?:', close: ')?' },
      '+': { type: 'plus', open: '(?:', close: ')+' },
      '*': { type: 'star', open: '(?:', close: ')*' },
      '@': { type: 'at', open: '(?:', close: ')' }
    };
  },

  /**
   * Create GLOB_CHARS
   */

  globChars(win32) {
    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
  }
};


/***/ }),
/* 111 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const constants = __webpack_require__(110);
const utils = __webpack_require__(109);

/**
 * Constants
 */

const {
  MAX_LENGTH,
  POSIX_REGEX_SOURCE,
  REGEX_NON_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_BACKREF,
  REPLACEMENTS
} = constants;

/**
 * Helpers
 */

const expandRange = (args, options) => {
  if (typeof options.expandRange === 'function') {
    return options.expandRange(...args, options);
  }

  args.sort();
  const value = `[${args.join('-')}]`;

  try {
    /* eslint-disable-next-line no-new */
    new RegExp(value);
  } catch (ex) {
    return args.map(v => utils.escapeRegex(v)).join('..');
  }

  return value;
};

/**
 * Create the message for a syntax error
 */

const syntaxError = (type, char) => {
  return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
};

/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */

const parse = (input, options) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  input = REPLACEMENTS[input] || input;

  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;

  let len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  const bos = { type: 'bos', value: '', output: opts.prepend || '' };
  const tokens = [bos];

  const capture = opts.capture ? '' : '?:';
  const win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const PLATFORM_CHARS = constants.globChars(win32);
  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);

  const {
    DOT_LITERAL,
    PLUS_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  } = PLATFORM_CHARS;

  const globstar = (opts) => {
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const nodot = opts.dot ? '' : NO_DOT;
  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
  let star = opts.bash === true ? globstar(opts) : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  // minimatch options support
  if (typeof opts.noext === 'boolean') {
    opts.noextglob = opts.noext;
  }

  const state = {
    input,
    index: -1,
    start: 0,
    dot: opts.dot === true,
    consumed: '',
    output: '',
    prefix: '',
    backtrack: false,
    negated: false,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: false,
    tokens
  };

  input = utils.removePrefix(input, state);
  len = input.length;

  const extglobs = [];
  const braces = [];
  const stack = [];
  let prev = bos;
  let value;

  /**
   * Tokenizing helpers
   */

  const eos = () => state.index === len - 1;
  const peek = state.peek = (n = 1) => input[state.index + n];
  const advance = state.advance = () => input[++state.index];
  const remaining = () => input.slice(state.index + 1);
  const consume = (value = '', num = 0) => {
    state.consumed += value;
    state.index += num;
  };
  const append = token => {
    state.output += token.output != null ? token.output : token.value;
    consume(token.value);
  };

  const negate = () => {
    let count = 1;

    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
      advance();
      state.start++;
      count++;
    }

    if (count % 2 === 0) {
      return false;
    }

    state.negated = true;
    state.start++;
    return true;
  };

  const increment = type => {
    state[type]++;
    stack.push(type);
  };

  const decrement = type => {
    state[type]--;
    stack.pop();
  };

  /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */

  const push = tok => {
    if (prev.type === 'globstar') {
      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));

      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = 'star';
        prev.value = '*';
        prev.output = star;
        state.output += prev.output;
      }
    }

    if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {
      extglobs[extglobs.length - 1].inner += tok.value;
    }

    if (tok.value || tok.output) append(tok);
    if (prev && prev.type === 'text' && tok.type === 'text') {
      prev.value += tok.value;
      prev.output = (prev.output || '') + tok.value;
      return;
    }

    tok.prev = prev;
    tokens.push(tok);
    prev = tok;
  };

  const extglobOpen = (type, value) => {
    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };

    token.prev = prev;
    token.parens = state.parens;
    token.output = state.output;
    const output = (opts.capture ? '(' : '') + token.open;

    increment('parens');
    push({ type, value, output: state.output ? '' : ONE_CHAR });
    push({ type: 'paren', extglob: true, value: advance(), output });
    extglobs.push(token);
  };

  const extglobClose = token => {
    let output = token.close + (opts.capture ? ')' : '');

    if (token.type === 'negate') {
      let extglobStar = star;

      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
        extglobStar = globstar(opts);
      }

      if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
        output = token.close = `)$))${extglobStar}`;
      }

      if (token.prev.type === 'bos' && eos()) {
        state.negatedExtglob = true;
      }
    }

    push({ type: 'paren', extglob: true, value, output });
    decrement('parens');
  };

  /**
   * Fast paths
   */

  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
    let backslashes = false;

    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
      if (first === '\\') {
        backslashes = true;
        return m;
      }

      if (first === '?') {
        if (esc) {
          return esc + first + (rest ? QMARK.repeat(rest.length) : '');
        }
        if (index === 0) {
          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
        }
        return QMARK.repeat(chars.length);
      }

      if (first === '.') {
        return DOT_LITERAL.repeat(chars.length);
      }

      if (first === '*') {
        if (esc) {
          return esc + first + (rest ? star : '');
        }
        return star;
      }
      return esc ? m : `\\${m}`;
    });

    if (backslashes === true) {
      if (opts.unescape === true) {
        output = output.replace(/\\/g, '');
      } else {
        output = output.replace(/\\+/g, m => {
          return m.length % 2 === 0 ? '\\\\' : (m ? '\\' : '');
        });
      }
    }

    if (output === input && opts.contains === true) {
      state.output = input;
      return state;
    }

    state.output = utils.wrapOutput(output, state, options);
    return state;
  }

  /**
   * Tokenize input until we reach end-of-string
   */

  while (!eos()) {
    value = advance();

    if (value === '\u0000') {
      continue;
    }

    /**
     * Escaped characters
     */

    if (value === '\\') {
      const next = peek();

      if (next === '/' && opts.bash !== true) {
        continue;
      }

      if (next === '.' || next === ';') {
        continue;
      }

      if (!next) {
        value += '\\';
        push({ type: 'text', value });
        continue;
      }

      // collapse slashes to reduce potential for exploits
      const match = /^\\+/.exec(remaining());
      let slashes = 0;

      if (match && match[0].length > 2) {
        slashes = match[0].length;
        state.index += slashes;
        if (slashes % 2 !== 0) {
          value += '\\';
        }
      }

      if (opts.unescape === true) {
        value = advance() || '';
      } else {
        value += advance() || '';
      }

      if (state.brackets === 0) {
        push({ type: 'text', value });
        continue;
      }
    }

    /**
     * If we're inside a regex character class, continue
     * until we reach the closing bracket.
     */

    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
      if (opts.posix !== false && value === ':') {
        const inner = prev.value.slice(1);
        if (inner.includes('[')) {
          prev.posix = true;

          if (inner.includes(':')) {
            const idx = prev.value.lastIndexOf('[');
            const pre = prev.value.slice(0, idx);
            const rest = prev.value.slice(idx + 2);
            const posix = POSIX_REGEX_SOURCE[rest];
            if (posix) {
              prev.value = pre + posix;
              state.backtrack = true;
              advance();

              if (!bos.output && tokens.indexOf(prev) === 1) {
                bos.output = ONE_CHAR;
              }
              continue;
            }
          }
        }
      }

      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {
        value = `\\${value}`;
      }

      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
        value = `\\${value}`;
      }

      if (opts.posix === true && value === '!' && prev.value === '[') {
        value = '^';
      }

      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * If we're inside a quoted string, continue
     * until we reach the closing double quote.
     */

    if (state.quotes === 1 && value !== '"') {
      value = utils.escapeRegex(value);
      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * Double quotes
     */

    if (value === '"') {
      state.quotes = state.quotes === 1 ? 0 : 1;
      if (opts.keepQuotes === true) {
        push({ type: 'text', value });
      }
      continue;
    }

    /**
     * Parentheses
     */

    if (value === '(') {
      increment('parens');
      push({ type: 'paren', value });
      continue;
    }

    if (value === ')') {
      if (state.parens === 0 && opts.strictBrackets === true) {
        throw new SyntaxError(syntaxError('opening', '('));
      }

      const extglob = extglobs[extglobs.length - 1];
      if (extglob && state.parens === extglob.parens + 1) {
        extglobClose(extglobs.pop());
        continue;
      }

      push({ type: 'paren', value, output: state.parens ? ')' : '\\)' });
      decrement('parens');
      continue;
    }

    /**
     * Square brackets
     */

    if (value === '[') {
      if (opts.nobracket === true || !remaining().includes(']')) {
        if (opts.nobracket !== true && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('closing', ']'));
        }

        value = `\\${value}`;
      } else {
        increment('brackets');
      }

      push({ type: 'bracket', value });
      continue;
    }

    if (value === ']') {
      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {
        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      if (state.brackets === 0) {
        if (opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('opening', '['));
        }

        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      decrement('brackets');

      const prevValue = prev.value.slice(1);
      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {
        value = `/${value}`;
      }

      prev.value += value;
      append({ value });

      // when literal brackets are explicitly disabled
      // assume we should match with a regex character class
      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
        continue;
      }

      const escaped = utils.escapeRegex(prev.value);
      state.output = state.output.slice(0, -prev.value.length);

      // when literal brackets are explicitly enabled
      // assume we should escape the brackets to match literal characters
      if (opts.literalBrackets === true) {
        state.output += escaped;
        prev.value = escaped;
        continue;
      }

      // when the user specifies nothing, try to match both
      prev.value = `(${capture}${escaped}|${prev.value})`;
      state.output += prev.value;
      continue;
    }

    /**
     * Braces
     */

    if (value === '{' && opts.nobrace !== true) {
      increment('braces');

      const open = {
        type: 'brace',
        value,
        output: '(',
        outputIndex: state.output.length,
        tokensIndex: state.tokens.length
      };

      braces.push(open);
      push(open);
      continue;
    }

    if (value === '}') {
      const brace = braces[braces.length - 1];

      if (opts.nobrace === true || !brace) {
        push({ type: 'text', value, output: value });
        continue;
      }

      let output = ')';

      if (brace.dots === true) {
        const arr = tokens.slice();
        const range = [];

        for (let i = arr.length - 1; i >= 0; i--) {
          tokens.pop();
          if (arr[i].type === 'brace') {
            break;
          }
          if (arr[i].type !== 'dots') {
            range.unshift(arr[i].value);
          }
        }

        output = expandRange(range, opts);
        state.backtrack = true;
      }

      if (brace.comma !== true && brace.dots !== true) {
        const out = state.output.slice(0, brace.outputIndex);
        const toks = state.tokens.slice(brace.tokensIndex);
        brace.value = brace.output = '\\{';
        value = output = '\\}';
        state.output = out;
        for (const t of toks) {
          state.output += (t.output || t.value);
        }
      }

      push({ type: 'brace', value, output });
      decrement('braces');
      braces.pop();
      continue;
    }

    /**
     * Pipes
     */

    if (value === '|') {
      if (extglobs.length > 0) {
        extglobs[extglobs.length - 1].conditions++;
      }
      push({ type: 'text', value });
      continue;
    }

    /**
     * Commas
     */

    if (value === ',') {
      let output = value;

      const brace = braces[braces.length - 1];
      if (brace && stack[stack.length - 1] === 'braces') {
        brace.comma = true;
        output = '|';
      }

      push({ type: 'comma', value, output });
      continue;
    }

    /**
     * Slashes
     */

    if (value === '/') {
      // if the beginning of the glob is "./", advance the start
      // to the current index, and don't add the "./" characters
      // to the state. This greatly simplifies lookbehinds when
      // checking for BOS characters like "!" and "." (not "./")
      if (prev.type === 'dot' && state.index === state.start + 1) {
        state.start = state.index + 1;
        state.consumed = '';
        state.output = '';
        tokens.pop();
        prev = bos; // reset "prev" to the first token
        continue;
      }

      push({ type: 'slash', value, output: SLASH_LITERAL });
      continue;
    }

    /**
     * Dots
     */

    if (value === '.') {
      if (state.braces > 0 && prev.type === 'dot') {
        if (prev.value === '.') prev.output = DOT_LITERAL;
        const brace = braces[braces.length - 1];
        prev.type = 'dots';
        prev.output += value;
        prev.value += value;
        brace.dots = true;
        continue;
      }

      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {
        push({ type: 'text', value, output: DOT_LITERAL });
        continue;
      }

      push({ type: 'dot', value, output: DOT_LITERAL });
      continue;
    }

    /**
     * Question marks
     */

    if (value === '?') {
      const isGroup = prev && prev.value === '(';
      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('qmark', value);
        continue;
      }

      if (prev && prev.type === 'paren') {
        const next = peek();
        let output = value;

        if (next === '<' && !utils.supportsLookbehinds()) {
          throw new Error('Node.js v10 or higher is required for regex lookbehinds');
        }

        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\w+>)/.test(remaining()))) {
          output = `\\${value}`;
        }

        push({ type: 'text', value, output });
        continue;
      }

      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {
        push({ type: 'qmark', value, output: QMARK_NO_DOT });
        continue;
      }

      push({ type: 'qmark', value, output: QMARK });
      continue;
    }

    /**
     * Exclamation
     */

    if (value === '!') {
      if (opts.noextglob !== true && peek() === '(') {
        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {
          extglobOpen('negate', value);
          continue;
        }
      }

      if (opts.nonegate !== true && state.index === 0) {
        negate();
        continue;
      }
    }

    /**
     * Plus
     */

    if (value === '+') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        extglobOpen('plus', value);
        continue;
      }

      if ((prev && prev.value === '(') || opts.regex === false) {
        push({ type: 'plus', value, output: PLUS_LITERAL });
        continue;
      }

      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {
        push({ type: 'plus', value });
        continue;
      }

      push({ type: 'plus', value: PLUS_LITERAL });
      continue;
    }

    /**
     * Plain text
     */

    if (value === '@') {
      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {
        push({ type: 'at', extglob: true, value, output: '' });
        continue;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Plain text
     */

    if (value !== '*') {
      if (value === '$' || value === '^') {
        value = `\\${value}`;
      }

      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
      if (match) {
        value += match[0];
        state.index += match[0].length;
      }

      push({ type: 'text', value });
      continue;
    }

    /**
     * Stars
     */

    if (prev && (prev.type === 'globstar' || prev.star === true)) {
      prev.type = 'star';
      prev.star = true;
      prev.value += value;
      prev.output = star;
      state.backtrack = true;
      state.globstar = true;
      consume(value);
      continue;
    }

    let rest = remaining();
    if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
      extglobOpen('star', value);
      continue;
    }

    if (prev.type === 'star') {
      if (opts.noglobstar === true) {
        consume(value);
        continue;
      }

      const prior = prev.prev;
      const before = prior.prev;
      const isStart = prior.type === 'slash' || prior.type === 'bos';
      const afterStar = before && (before.type === 'star' || before.type === 'globstar');

      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');
      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      // strip consecutive `/**/`
      while (rest.slice(0, 3) === '/**') {
        const after = input[state.index + 4];
        if (after && after !== '/') {
          break;
        }
        rest = rest.slice(3);
        consume('/**', 3);
      }

      if (prior.type === 'bos' && eos()) {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = globstar(opts);
        state.output = prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
        prev.value += value;
        state.globstar = true;
        state.output += prior.output + prev.output;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
        const end = rest[1] !== void 0 ? '|$' : '';

        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
        prev.value += value;

        state.output += prior.output + prev.output;
        state.globstar = true;

        consume(value + advance());

        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      if (prior.type === 'bos' && rest[0] === '/') {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
        state.output = prev.output;
        state.globstar = true;
        consume(value + advance());
        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      // remove single star from output
      state.output = state.output.slice(0, -prev.output.length);

      // reset previous token to globstar
      prev.type = 'globstar';
      prev.output = globstar(opts);
      prev.value += value;

      // reset output with globstar
      state.output += prev.output;
      state.globstar = true;
      consume(value);
      continue;
    }

    const token = { type: 'star', value, output: star };

    if (opts.bash === true) {
      token.output = '.*?';
      if (prev.type === 'bos' || prev.type === 'slash') {
        token.output = nodot + token.output;
      }
      push(token);
      continue;
    }

    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
      token.output = value;
      push(token);
      continue;
    }

    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
      if (prev.type === 'dot') {
        state.output += NO_DOT_SLASH;
        prev.output += NO_DOT_SLASH;

      } else if (opts.dot === true) {
        state.output += NO_DOTS_SLASH;
        prev.output += NO_DOTS_SLASH;

      } else {
        state.output += nodot;
        prev.output += nodot;
      }

      if (peek() !== '*') {
        state.output += ONE_CHAR;
        prev.output += ONE_CHAR;
      }
    }

    push(token);
  }

  while (state.brackets > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
    state.output = utils.escapeLast(state.output, '[');
    decrement('brackets');
  }

  while (state.parens > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
    state.output = utils.escapeLast(state.output, '(');
    decrement('parens');
  }

  while (state.braces > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));
    state.output = utils.escapeLast(state.output, '{');
    decrement('braces');
  }

  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {
    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });
  }

  // rebuild the output if we had to backtrack at any point
  if (state.backtrack === true) {
    state.output = '';

    for (const token of state.tokens) {
      state.output += token.output != null ? token.output : token.value;

      if (token.suffix) {
        state.output += token.suffix;
      }
    }
  }

  return state;
};

/**
 * Fast paths for creating regular expressions for common glob patterns.
 * This can significantly speed up processing and has very little downside
 * impact when none of the fast paths match.
 */

parse.fastpaths = (input, options) => {
  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
  const len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  input = REPLACEMENTS[input] || input;
  const win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const {
    DOT_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOTS_SLASH,
    STAR,
    START_ANCHOR
  } = constants.globChars(win32);

  const nodot = opts.dot ? NO_DOTS : NO_DOT;
  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
  const capture = opts.capture ? '' : '?:';
  const state = { negated: false, prefix: '' };
  let star = opts.bash === true ? '.*?' : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  const globstar = (opts) => {
    if (opts.noglobstar === true) return star;
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const create = str => {
    switch (str) {
      case '*':
        return `${nodot}${ONE_CHAR}${star}`;

      case '.*':
        return `${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*.*':
        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '*/*':
        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;

      case '**':
        return nodot + globstar(opts);

      case '**/*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;

      case '**/*.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;

      case '**/.*':
        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;

      default: {
        const match = /^(.*?)\.(\w+)$/.exec(str);
        if (!match) return;

        const source = create(match[1]);
        if (!source) return;

        return source + DOT_LITERAL + match[2];
      }
    }
  };

  const output = utils.removePrefix(input, state);
  let source = create(output);

  if (source && opts.strictSlashes !== true) {
    source += `${SLASH_LITERAL}?`;
  }

  return source;
};

module.exports = parse;


/***/ }),
/* 112 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.merge = void 0;
const merge2 = __webpack_require__(113);
function merge(streams) {
    const mergedStream = merge2(streams);
    streams.forEach((stream) => {
        stream.once('error', (error) => mergedStream.emit('error', error));
    });
    mergedStream.once('close', () => propagateCloseEventToSources(streams));
    mergedStream.once('end', () => propagateCloseEventToSources(streams));
    return mergedStream;
}
exports.merge = merge;
function propagateCloseEventToSources(streams) {
    streams.forEach((stream) => stream.emit('close'));
}


/***/ }),
/* 113 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

/*
 * merge2
 * https://github.com/teambition/merge2
 *
 * Copyright (c) 2014-2016 Teambition
 * Licensed under the MIT license.
 */
const Stream = __webpack_require__(114)
const PassThrough = Stream.PassThrough
const slice = Array.prototype.slice

module.exports = merge2

function merge2 () {
  const streamsQueue = []
  let merging = false
  const args = slice.call(arguments)
  let options = args[args.length - 1]

  if (options && !Array.isArray(options) && options.pipe == null) args.pop()
  else options = {}

  const doEnd = options.end !== false
  if (options.objectMode == null) options.objectMode = true
  if (options.highWaterMark == null) options.highWaterMark = 64 * 1024
  const mergedStream = PassThrough(options)

  function addStream () {
    for (let i = 0, len = arguments.length; i < len; i++) {
      streamsQueue.push(pauseStreams(arguments[i], options))
    }
    mergeStream()
    return this
  }

  function mergeStream () {
    if (merging) return
    merging = true

    let streams = streamsQueue.shift()
    if (!streams) {
      process.nextTick(endStream)
      return
    }
    if (!Array.isArray(streams)) streams = [streams]

    let pipesCount = streams.length + 1

    function next () {
      if (--pipesCount > 0) return
      merging = false
      mergeStream()
    }

    function pipe (stream) {
      function onend () {
        stream.removeListener('merge2UnpipeEnd', onend)
        stream.removeListener('end', onend)
        next()
      }
      // skip ended stream
      if (stream._readableState.endEmitted) return next()

      stream.on('merge2UnpipeEnd', onend)
      stream.on('end', onend)
      stream.pipe(mergedStream, { end: false })
      // compatible for old stream
      stream.resume()
    }

    for (let i = 0; i < streams.length; i++) pipe(streams[i])

    next()
  }

  function endStream () {
    merging = false
    // emit 'queueDrain' when all streams merged.
    mergedStream.emit('queueDrain')
    return doEnd && mergedStream.end()
  }

  mergedStream.setMaxListeners(0)
  mergedStream.add = addStream
  mergedStream.on('unpipe', function (stream) {
    stream.emit('merge2UnpipeEnd')
  })

  if (args.length) addStream.apply(null, args)
  return mergedStream
}

// check and pause streams for pipe.
function pauseStreams (streams, options) {
  if (!Array.isArray(streams)) {
    // Backwards-compat with old-style streams
    if (!streams._readableState && streams.pipe) streams = streams.pipe(PassThrough(options))
    if (!streams._readableState || !streams.pause || !streams.pipe) {
      throw new Error('Only readable stream can be merged.')
    }
    streams.pause()
  } else {
    for (let i = 0, len = streams.length; i < len; i++) streams[i] = pauseStreams(streams[i], options)
  }
  return streams
}


/***/ }),
/* 114 */
/***/ ((module) => {

"use strict";
module.exports = require("stream");;

/***/ }),
/* 115 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isEmpty = exports.isString = void 0;
function isString(input) {
    return typeof input === 'string';
}
exports.isString = isString;
function isEmpty(input) {
    return input === '';
}
exports.isEmpty = isEmpty;


/***/ }),
/* 116 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const stream_1 = __webpack_require__(117);
const provider_1 = __webpack_require__(144);
class ProviderAsync extends provider_1.default {
    constructor() {
        super(...arguments);
        this._reader = new stream_1.default(this._settings);
    }
    read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = [];
        return new Promise((resolve, reject) => {
            const stream = this.api(root, task, options);
            stream.once('error', reject);
            stream.on('data', (entry) => entries.push(options.transform(entry)));
            stream.once('end', () => resolve(entries));
        });
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
exports.default = ProviderAsync;


/***/ }),
/* 117 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const stream_1 = __webpack_require__(114);
const fsStat = __webpack_require__(118);
const fsWalk = __webpack_require__(123);
const reader_1 = __webpack_require__(143);
class ReaderStream extends reader_1.default {
    constructor() {
        super(...arguments);
        this._walkStream = fsWalk.walkStream;
        this._stat = fsStat.stat;
    }
    dynamic(root, options) {
        return this._walkStream(root, options);
    }
    static(patterns, options) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream = new stream_1.PassThrough({ objectMode: true });
        stream._write = (index, _enc, done) => {
            return this._getEntry(filepaths[index], patterns[index], options)
                .then((entry) => {
                if (entry !== null && options.entryFilter(entry)) {
                    stream.push(entry);
                }
                if (index === filepaths.length - 1) {
                    stream.end();
                }
                done();
            })
                .catch(done);
        };
        for (let i = 0; i < filepaths.length; i++) {
            stream.write(i);
        }
        return stream;
    }
    _getEntry(filepath, pattern, options) {
        return this._getStat(filepath)
            .then((stats) => this._makeEntry(stats, pattern))
            .catch((error) => {
            if (options.errorFilter(error)) {
                return null;
            }
            throw error;
        });
    }
    _getStat(filepath) {
        return new Promise((resolve, reject) => {
            this._stat(filepath, this._fsStatSettings, (error, stats) => {
                return error === null ? resolve(stats) : reject(error);
            });
        });
    }
}
exports.default = ReaderStream;


/***/ }),
/* 118 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const async = __webpack_require__(119);
const sync = __webpack_require__(120);
const settings_1 = __webpack_require__(121);
exports.Settings = settings_1.default;
function stat(path, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        return async.read(path, getSettings(), optionsOrSettingsOrCallback);
    }
    async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
}
exports.stat = stat;
function statSync(path, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    return sync.read(path, settings);
}
exports.statSync = statSync;
function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
}


/***/ }),
/* 119 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function read(path, settings, callback) {
    settings.fs.lstat(path, (lstatError, lstat) => {
        if (lstatError !== null) {
            return callFailureCallback(callback, lstatError);
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
            return callSuccessCallback(callback, lstat);
        }
        settings.fs.stat(path, (statError, stat) => {
            if (statError !== null) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    return callFailureCallback(callback, statError);
                }
                return callSuccessCallback(callback, lstat);
            }
            if (settings.markSymbolicLink) {
                stat.isSymbolicLink = () => true;
            }
            callSuccessCallback(callback, stat);
        });
    });
}
exports.read = read;
function callFailureCallback(callback, error) {
    callback(error);
}
function callSuccessCallback(callback, result) {
    callback(null, result);
}


/***/ }),
/* 120 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function read(path, settings) {
    const lstat = settings.fs.lstatSync(path);
    if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat;
    }
    try {
        const stat = settings.fs.statSync(path);
        if (settings.markSymbolicLink) {
            stat.isSymbolicLink = () => true;
        }
        return stat;
    }
    catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
            return lstat;
        }
        throw error;
    }
}
exports.read = read;


/***/ }),
/* 121 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fs = __webpack_require__(122);
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
    }
    _getValue(option, value) {
        return option === undefined ? value : option;
    }
}
exports.default = Settings;


/***/ }),
/* 122 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fs = __webpack_require__(60);
exports.FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    stat: fs.stat,
    lstatSync: fs.lstatSync,
    statSync: fs.statSync
};
function createFileSystemAdapter(fsMethods) {
    if (fsMethods === undefined) {
        return exports.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
}
exports.createFileSystemAdapter = createFileSystemAdapter;


/***/ }),
/* 123 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const async_1 = __webpack_require__(124);
const stream_1 = __webpack_require__(139);
const sync_1 = __webpack_require__(140);
const settings_1 = __webpack_require__(142);
exports.Settings = settings_1.default;
function walk(directory, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        return new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
    }
    new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
}
exports.walk = walk;
function walkSync(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new sync_1.default(directory, settings);
    return provider.read();
}
exports.walkSync = walkSync;
function walkStream(directory, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    const provider = new stream_1.default(directory, settings);
    return provider.read();
}
exports.walkStream = walkStream;
function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
}


/***/ }),
/* 124 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const async_1 = __webpack_require__(125);
class AsyncProvider {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._storage = new Set();
    }
    read(callback) {
        this._reader.onError((error) => {
            callFailureCallback(callback, error);
        });
        this._reader.onEntry((entry) => {
            this._storage.add(entry);
        });
        this._reader.onEnd(() => {
            callSuccessCallback(callback, [...this._storage]);
        });
        this._reader.read();
    }
}
exports.default = AsyncProvider;
function callFailureCallback(callback, error) {
    callback(error);
}
function callSuccessCallback(callback, entries) {
    callback(null, entries);
}


/***/ }),
/* 125 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const events_1 = __webpack_require__(70);
const fsScandir = __webpack_require__(126);
const fastq = __webpack_require__(135);
const common = __webpack_require__(137);
const reader_1 = __webpack_require__(138);
class AsyncReader extends reader_1.default {
    constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
            if (!this._isFatalError) {
                this._emitter.emit('end');
            }
        };
    }
    read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
            this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
    }
    destroy() {
        if (this._isDestroyed) {
            throw new Error('The reader is already destroyed');
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
    }
    onEntry(callback) {
        this._emitter.on('entry', callback);
    }
    onError(callback) {
        this._emitter.once('error', callback);
    }
    onEnd(callback) {
        this._emitter.once('end', callback);
    }
    _pushToQueue(directory, base) {
        const queueItem = { directory, base };
        this._queue.push(queueItem, (error) => {
            if (error !== null) {
                this._handleError(error);
            }
        });
    }
    _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
            if (error !== null) {
                return done(error, undefined);
            }
            for (const entry of entries) {
                this._handleEntry(entry, item.base);
            }
            done(null, undefined);
        });
    }
    _handleError(error) {
        if (!common.isFatalError(this._settings, error)) {
            return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit('error', error);
    }
    _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
            return;
        }
        const fullpath = entry.path;
        if (base !== undefined) {
            entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
            this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
            this._pushToQueue(fullpath, entry.path);
        }
    }
    _emitEntry(entry) {
        this._emitter.emit('entry', entry);
    }
}
exports.default = AsyncReader;


/***/ }),
/* 126 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const async = __webpack_require__(127);
const sync = __webpack_require__(132);
const settings_1 = __webpack_require__(133);
exports.Settings = settings_1.default;
function scandir(path, optionsOrSettingsOrCallback, callback) {
    if (typeof optionsOrSettingsOrCallback === 'function') {
        return async.read(path, getSettings(), optionsOrSettingsOrCallback);
    }
    async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
}
exports.scandir = scandir;
function scandirSync(path, optionsOrSettings) {
    const settings = getSettings(optionsOrSettings);
    return sync.read(path, settings);
}
exports.scandirSync = scandirSync;
function getSettings(settingsOrOptions = {}) {
    if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
    }
    return new settings_1.default(settingsOrOptions);
}


/***/ }),
/* 127 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fsStat = __webpack_require__(118);
const rpl = __webpack_require__(128);
const constants_1 = __webpack_require__(129);
const utils = __webpack_require__(130);
function read(directory, settings, callback) {
    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings, callback);
    }
    return readdir(directory, settings, callback);
}
exports.read = read;
function readdirWithFileTypes(directory, settings, callback) {
    settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
        if (readdirError !== null) {
            return callFailureCallback(callback, readdirError);
        }
        const entries = dirents.map((dirent) => ({
            dirent,
            name: dirent.name,
            path: `${directory}${settings.pathSegmentSeparator}${dirent.name}`
        }));
        if (!settings.followSymbolicLinks) {
            return callSuccessCallback(callback, entries);
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
            if (rplError !== null) {
                return callFailureCallback(callback, rplError);
            }
            callSuccessCallback(callback, rplEntries);
        });
    });
}
exports.readdirWithFileTypes = readdirWithFileTypes;
function makeRplTaskEntry(entry, settings) {
    return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
            return done(null, entry);
        }
        settings.fs.stat(entry.path, (statError, stats) => {
            if (statError !== null) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    return done(statError);
                }
                return done(null, entry);
            }
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
            return done(null, entry);
        });
    };
}
function readdir(directory, settings, callback) {
    settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
            return callFailureCallback(callback, readdirError);
        }
        const filepaths = names.map((name) => `${directory}${settings.pathSegmentSeparator}${name}`);
        const tasks = filepaths.map((filepath) => {
            return (done) => fsStat.stat(filepath, settings.fsStatSettings, done);
        });
        rpl(tasks, (rplError, results) => {
            if (rplError !== null) {
                return callFailureCallback(callback, rplError);
            }
            const entries = [];
            names.forEach((name, index) => {
                const stats = results[index];
                const entry = {
                    name,
                    path: filepaths[index],
                    dirent: utils.fs.createDirentFromStats(name, stats)
                };
                if (settings.stats) {
                    entry.stats = stats;
                }
                entries.push(entry);
            });
            callSuccessCallback(callback, entries);
        });
    });
}
exports.readdir = readdir;
function callFailureCallback(callback, error) {
    callback(error);
}
function callSuccessCallback(callback, result) {
    callback(null, result);
}


/***/ }),
/* 128 */
/***/ ((module) => {

module.exports = runParallel

function runParallel (tasks, cb) {
  var results, pending, keys
  var isSync = true

  if (Array.isArray(tasks)) {
    results = []
    pending = tasks.length
  } else {
    keys = Object.keys(tasks)
    results = {}
    pending = keys.length
  }

  function done (err) {
    function end () {
      if (cb) cb(err, results)
      cb = null
    }
    if (isSync) process.nextTick(end)
    else end()
  }

  function each (i, err, result) {
    results[i] = result
    if (--pending === 0 || err) {
      done(err)
    }
  }

  if (!pending) {
    // empty
    done(null)
  } else if (keys) {
    // object
    keys.forEach(function (key) {
      tasks[key](function (err, result) { each(key, err, result) })
    })
  } else {
    // array
    tasks.forEach(function (task, i) {
      task(function (err, result) { each(i, err, result) })
    })
  }

  isSync = false
}


/***/ }),
/* 129 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const NODE_PROCESS_VERSION_PARTS = process.versions.node.split('.');
const MAJOR_VERSION = parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
const MINOR_VERSION = parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
const SUPPORTED_MAJOR_VERSION = 10;
const SUPPORTED_MINOR_VERSION = 10;
const IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
const IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
/**
 * IS `true` for Node.js 10.10 and greater.
 */
exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;


/***/ }),
/* 130 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fs = __webpack_require__(131);
exports.fs = fs;


/***/ }),
/* 131 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
class DirentFromStats {
    constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
    }
}
function createDirentFromStats(name, stats) {
    return new DirentFromStats(name, stats);
}
exports.createDirentFromStats = createDirentFromStats;


/***/ }),
/* 132 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fsStat = __webpack_require__(118);
const constants_1 = __webpack_require__(129);
const utils = __webpack_require__(130);
function read(directory, settings) {
    if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
    }
    return readdir(directory, settings);
}
exports.read = read;
function readdirWithFileTypes(directory, settings) {
    const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
    return dirents.map((dirent) => {
        const entry = {
            dirent,
            name: dirent.name,
            path: `${directory}${settings.pathSegmentSeparator}${dirent.name}`
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
            try {
                const stats = settings.fs.statSync(entry.path);
                entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
            }
            catch (error) {
                if (settings.throwErrorOnBrokenSymbolicLink) {
                    throw error;
                }
            }
        }
        return entry;
    });
}
exports.readdirWithFileTypes = readdirWithFileTypes;
function readdir(directory, settings) {
    const names = settings.fs.readdirSync(directory);
    return names.map((name) => {
        const entryPath = `${directory}${settings.pathSegmentSeparator}${name}`;
        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
        const entry = {
            name,
            path: entryPath,
            dirent: utils.fs.createDirentFromStats(name, stats)
        };
        if (settings.stats) {
            entry.stats = stats;
        }
        return entry;
    });
}
exports.readdir = readdir;


/***/ }),
/* 133 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __webpack_require__(23);
const fsStat = __webpack_require__(118);
const fs = __webpack_require__(134);
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat.Settings({
            followSymbolicLink: this.followSymbolicLinks,
            fs: this.fs,
            throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
    }
    _getValue(option, value) {
        return option === undefined ? value : option;
    }
}
exports.default = Settings;


/***/ }),
/* 134 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fs = __webpack_require__(60);
exports.FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    stat: fs.stat,
    lstatSync: fs.lstatSync,
    statSync: fs.statSync,
    readdir: fs.readdir,
    readdirSync: fs.readdirSync
};
function createFileSystemAdapter(fsMethods) {
    if (fsMethods === undefined) {
        return exports.FILE_SYSTEM_ADAPTER;
    }
    return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);
}
exports.createFileSystemAdapter = createFileSystemAdapter;


/***/ }),
/* 135 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var reusify = __webpack_require__(136)

function fastqueue (context, worker, concurrency) {
  if (typeof context === 'function') {
    concurrency = worker
    worker = context
    context = null
  }

  var cache = reusify(Task)
  var queueHead = null
  var queueTail = null
  var _running = 0

  var self = {
    push: push,
    drain: noop,
    saturated: noop,
    pause: pause,
    paused: false,
    concurrency: concurrency,
    running: running,
    resume: resume,
    idle: idle,
    length: length,
    unshift: unshift,
    empty: noop,
    kill: kill,
    killAndDrain: killAndDrain
  }

  return self

  function running () {
    return _running
  }

  function pause () {
    self.paused = true
  }

  function length () {
    var current = queueHead
    var counter = 0

    while (current) {
      current = current.next
      counter++
    }

    return counter
  }

  function resume () {
    if (!self.paused) return
    self.paused = false
    for (var i = 0; i < self.concurrency; i++) {
      _running++
      release()
    }
  }

  function idle () {
    return _running === 0 && self.length() === 0
  }

  function push (value, done) {
    var current = cache.get()

    current.context = context
    current.release = release
    current.value = value
    current.callback = done || noop

    if (_running === self.concurrency || self.paused) {
      if (queueTail) {
        queueTail.next = current
        queueTail = current
      } else {
        queueHead = current
        queueTail = current
        self.saturated()
      }
    } else {
      _running++
      worker.call(context, current.value, current.worked)
    }
  }

  function unshift (value, done) {
    var current = cache.get()

    current.context = context
    current.release = release
    current.value = value
    current.callback = done || noop

    if (_running === self.concurrency || self.paused) {
      if (queueHead) {
        current.next = queueHead
        queueHead = current
      } else {
        queueHead = current
        queueTail = current
        self.saturated()
      }
    } else {
      _running++
      worker.call(context, current.value, current.worked)
    }
  }

  function release (holder) {
    if (holder) {
      cache.release(holder)
    }
    var next = queueHead
    if (next) {
      if (!self.paused) {
        if (queueTail === queueHead) {
          queueTail = null
        }
        queueHead = next.next
        next.next = null
        worker.call(context, next.value, next.worked)
        if (queueTail === null) {
          self.empty()
        }
      } else {
        _running--
      }
    } else if (--_running === 0) {
      self.drain()
    }
  }

  function kill () {
    queueHead = null
    queueTail = null
    self.drain = noop
  }

  function killAndDrain () {
    queueHead = null
    queueTail = null
    self.drain()
    self.drain = noop
  }
}

function noop () {}

function Task () {
  this.value = null
  this.callback = noop
  this.next = null
  this.release = noop
  this.context = null

  var self = this

  this.worked = function worked (err, result) {
    var callback = self.callback
    self.value = null
    self.callback = noop
    callback.call(self.context, err, result)
    self.release(self)
  }
}

module.exports = fastqueue


/***/ }),
/* 136 */
/***/ ((module) => {

"use strict";


function reusify (Constructor) {
  var head = new Constructor()
  var tail = head

  function get () {
    var current = head

    if (current.next) {
      head = current.next
    } else {
      head = new Constructor()
      tail = head
    }

    current.next = null

    return current
  }

  function release (obj) {
    tail.next = obj
    tail = obj
  }

  return {
    get: get,
    release: release
  }
}

module.exports = reusify


/***/ }),
/* 137 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function isFatalError(settings, error) {
    if (settings.errorFilter === null) {
        return true;
    }
    return !settings.errorFilter(error);
}
exports.isFatalError = isFatalError;
function isAppliedFilter(filter, value) {
    return filter === null || filter(value);
}
exports.isAppliedFilter = isAppliedFilter;
function replacePathSegmentSeparator(filepath, separator) {
    return filepath.split(/[\\/]/).join(separator);
}
exports.replacePathSegmentSeparator = replacePathSegmentSeparator;
function joinPathSegments(a, b, separator) {
    if (a === '') {
        return b;
    }
    return a + separator + b;
}
exports.joinPathSegments = joinPathSegments;


/***/ }),
/* 138 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const common = __webpack_require__(137);
class Reader {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
    }
}
exports.default = Reader;


/***/ }),
/* 139 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const stream_1 = __webpack_require__(114);
const async_1 = __webpack_require__(125);
class StreamProvider {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._stream = new stream_1.Readable({
            objectMode: true,
            read: () => { },
            destroy: this._reader.destroy.bind(this._reader)
        });
    }
    read() {
        this._reader.onError((error) => {
            this._stream.emit('error', error);
        });
        this._reader.onEntry((entry) => {
            this._stream.push(entry);
        });
        this._reader.onEnd(() => {
            this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
    }
}
exports.default = StreamProvider;


/***/ }),
/* 140 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const sync_1 = __webpack_require__(141);
class SyncProvider {
    constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1.default(this._root, this._settings);
    }
    read() {
        return this._reader.read();
    }
}
exports.default = SyncProvider;


/***/ }),
/* 141 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fsScandir = __webpack_require__(126);
const common = __webpack_require__(137);
const reader_1 = __webpack_require__(138);
class SyncReader extends reader_1.default {
    constructor() {
        super(...arguments);
        this._scandir = fsScandir.scandirSync;
        this._storage = new Set();
        this._queue = new Set();
    }
    read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return [...this._storage];
    }
    _pushToQueue(directory, base) {
        this._queue.add({ directory, base });
    }
    _handleQueue() {
        for (const item of this._queue.values()) {
            this._handleDirectory(item.directory, item.base);
        }
    }
    _handleDirectory(directory, base) {
        try {
            const entries = this._scandir(directory, this._settings.fsScandirSettings);
            for (const entry of entries) {
                this._handleEntry(entry, base);
            }
        }
        catch (error) {
            this._handleError(error);
        }
    }
    _handleError(error) {
        if (!common.isFatalError(this._settings, error)) {
            return;
        }
        throw error;
    }
    _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== undefined) {
            entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
            this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
            this._pushToQueue(fullpath, entry.path);
        }
    }
    _pushToStorage(entry) {
        this._storage.add(entry);
    }
}
exports.default = SyncReader;


/***/ }),
/* 142 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __webpack_require__(23);
const fsScandir = __webpack_require__(126);
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, undefined);
        this.concurrency = this._getValue(this._options.concurrency, Infinity);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
        this.fsScandirSettings = new fsScandir.Settings({
            followSymbolicLinks: this._options.followSymbolicLinks,
            fs: this._options.fs,
            pathSegmentSeparator: this._options.pathSegmentSeparator,
            stats: this._options.stats,
            throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
    }
    _getValue(option, value) {
        return option === undefined ? value : option;
    }
}
exports.default = Settings;


/***/ }),
/* 143 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __webpack_require__(23);
const fsStat = __webpack_require__(118);
const utils = __webpack_require__(80);
class Reader {
    constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat.Settings({
            followSymbolicLink: this._settings.followSymbolicLinks,
            fs: this._settings.fs,
            throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
    }
    _getFullEntryPath(filepath) {
        return path.resolve(this._settings.cwd, filepath);
    }
    _makeEntry(stats, pattern) {
        const entry = {
            name: pattern,
            path: pattern,
            dirent: utils.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
            entry.stats = stats;
        }
        return entry;
    }
    _isFatalError(error) {
        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
    }
}
exports.default = Reader;


/***/ }),
/* 144 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const path = __webpack_require__(23);
const deep_1 = __webpack_require__(145);
const entry_1 = __webpack_require__(148);
const error_1 = __webpack_require__(149);
const entry_2 = __webpack_require__(150);
class Provider {
    constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
    }
    _getRootDirectory(task) {
        return path.resolve(this._settings.cwd, task.base);
    }
    _getReaderOptions(task) {
        const basePath = task.base === '.' ? '' : task.base;
        return {
            basePath,
            pathSegmentSeparator: '/',
            concurrency: this._settings.concurrency,
            deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
            entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
            errorFilter: this.errorFilter.getFilter(),
            followSymbolicLinks: this._settings.followSymbolicLinks,
            fs: this._settings.fs,
            stats: this._settings.stats,
            throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
            transform: this.entryTransformer.getTransformer()
        };
    }
    _getMicromatchOptions() {
        return {
            dot: this._settings.dot,
            matchBase: this._settings.baseNameMatch,
            nobrace: !this._settings.braceExpansion,
            nocase: !this._settings.caseSensitiveMatch,
            noext: !this._settings.extglob,
            noglobstar: !this._settings.globstar,
            posix: true,
            strictSlashes: false
        };
    }
}
exports.default = Provider;


/***/ }),
/* 145 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __webpack_require__(80);
const partial_1 = __webpack_require__(146);
class DeepFilter {
    constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
    }
    getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
    }
    _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
    }
    _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
    }
    _filter(basePath, entry, matcher, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry.path)) {
            return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
            return false;
        }
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
            return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
    }
    _isSkippedByDeep(basePath, entryPath) {
        /**
         * Avoid unnecessary depth calculations when it doesn't matter.
         */
        if (this._settings.deep === Infinity) {
            return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
    }
    _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split('/').length;
        if (basePath === '') {
            return entryPathDepth;
        }
        const basePathDepth = basePath.split('/').length;
        return entryPathDepth - basePathDepth;
    }
    _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
    }
    _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
    }
    _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils.pattern.matchAny(entryPath, patternsRe);
    }
}
exports.default = DeepFilter;


/***/ }),
/* 146 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const matcher_1 = __webpack_require__(147);
class PartialMatcher extends matcher_1.default {
    match(filepath) {
        const parts = filepath.split('/');
        const levels = parts.length;
        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern of patterns) {
            const section = pattern.sections[0];
            /**
             * In this case, the pattern has a globstar and we must read all directories unconditionally,
             * but only if the level has reached the end of the first group.
             *
             * fixtures/{a,b}/**
             *  ^ true/false  ^ always true
            */
            if (!pattern.complete && levels > section.length) {
                return true;
            }
            const match = parts.every((part, index) => {
                const segment = pattern.segments[index];
                if (segment.dynamic && segment.patternRe.test(part)) {
                    return true;
                }
                if (!segment.dynamic && segment.pattern === part) {
                    return true;
                }
                return false;
            });
            if (match) {
                return true;
            }
        }
        return false;
    }
}
exports.default = PartialMatcher;


/***/ }),
/* 147 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __webpack_require__(80);
class Matcher {
    constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
    }
    _fillStorage() {
        /**
         * The original pattern may include `{,*,**,a/*}`, which will lead to problems with matching (unresolved level).
         * So, before expand patterns with brace expansion into separated patterns.
         */
        const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);
        for (const pattern of patterns) {
            const segments = this._getPatternSegments(pattern);
            const sections = this._splitSegmentsIntoSections(segments);
            this._storage.push({
                complete: sections.length <= 1,
                pattern,
                segments,
                sections
            });
        }
    }
    _getPatternSegments(pattern) {
        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts.map((part) => {
            const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
            if (!dynamic) {
                return {
                    dynamic: false,
                    pattern: part
                };
            }
            return {
                dynamic: true,
                pattern: part,
                patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
            };
        });
    }
    _splitSegmentsIntoSections(segments) {
        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
    }
}
exports.default = Matcher;


/***/ }),
/* 148 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __webpack_require__(80);
class EntryFilter {
    constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = new Map();
    }
    getFilter(positive, negative) {
        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);
        return (entry) => this._filter(entry, positiveRe, negativeRe);
    }
    _filter(entry, positiveRe, negativeRe) {
        if (this._settings.unique && this._isDuplicateEntry(entry)) {
            return false;
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
            return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {
            return false;
        }
        const filepath = this._settings.baseNameMatch ? entry.name : entry.path;
        const isMatched = this._isMatchToPatterns(filepath, positiveRe) && !this._isMatchToPatterns(entry.path, negativeRe);
        if (this._settings.unique && isMatched) {
            this._createIndexRecord(entry);
        }
        return isMatched;
    }
    _isDuplicateEntry(entry) {
        return this.index.has(entry.path);
    }
    _createIndexRecord(entry) {
        this.index.set(entry.path, undefined);
    }
    _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
    }
    _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
    }
    _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
            return false;
        }
        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils.pattern.matchAny(fullpath, patternsRe);
    }
    _isMatchToPatterns(entryPath, patternsRe) {
        const filepath = utils.path.removeLeadingDotSegment(entryPath);
        return utils.pattern.matchAny(filepath, patternsRe);
    }
}
exports.default = EntryFilter;


/***/ }),
/* 149 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __webpack_require__(80);
class ErrorFilter {
    constructor(_settings) {
        this._settings = _settings;
    }
    getFilter() {
        return (error) => this._isNonFatalError(error);
    }
    _isNonFatalError(error) {
        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
    }
}
exports.default = ErrorFilter;


/***/ }),
/* 150 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const utils = __webpack_require__(80);
class EntryTransformer {
    constructor(_settings) {
        this._settings = _settings;
    }
    getTransformer() {
        return (entry) => this._transform(entry);
    }
    _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
            filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
            filepath = utils.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
            filepath += '/';
        }
        if (!this._settings.objectMode) {
            return filepath;
        }
        return Object.assign(Object.assign({}, entry), { path: filepath });
    }
}
exports.default = EntryTransformer;


/***/ }),
/* 151 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const stream_1 = __webpack_require__(114);
const stream_2 = __webpack_require__(117);
const provider_1 = __webpack_require__(144);
class ProviderStream extends provider_1.default {
    constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
    }
    read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const source = this.api(root, task, options);
        const destination = new stream_1.Readable({ objectMode: true, read: () => { } });
        source
            .once('error', (error) => destination.emit('error', error))
            .on('data', (entry) => destination.emit('data', options.transform(entry)))
            .once('end', () => destination.emit('end'));
        destination
            .once('close', () => source.destroy());
        return destination;
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
exports.default = ProviderStream;


/***/ }),
/* 152 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const sync_1 = __webpack_require__(153);
const provider_1 = __webpack_require__(144);
class ProviderSync extends provider_1.default {
    constructor() {
        super(...arguments);
        this._reader = new sync_1.default(this._settings);
    }
    read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = this.api(root, task, options);
        return entries.map(options.transform);
    }
    api(root, task, options) {
        if (task.dynamic) {
            return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
    }
}
exports.default = ProviderSync;


/***/ }),
/* 153 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const fsStat = __webpack_require__(118);
const fsWalk = __webpack_require__(123);
const reader_1 = __webpack_require__(143);
class ReaderSync extends reader_1.default {
    constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
    }
    dynamic(root, options) {
        return this._walkSync(root, options);
    }
    static(patterns, options) {
        const entries = [];
        for (const pattern of patterns) {
            const filepath = this._getFullEntryPath(pattern);
            const entry = this._getEntry(filepath, pattern, options);
            if (entry === null || !options.entryFilter(entry)) {
                continue;
            }
            entries.push(entry);
        }
        return entries;
    }
    _getEntry(filepath, pattern, options) {
        try {
            const stats = this._getStat(filepath);
            return this._makeEntry(stats, pattern);
        }
        catch (error) {
            if (options.errorFilter(error)) {
                return null;
            }
            throw error;
        }
    }
    _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
    }
}
exports.default = ReaderSync;


/***/ }),
/* 154 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
const fs = __webpack_require__(60);
const os = __webpack_require__(24);
const CPU_COUNT = os.cpus().length;
exports.DEFAULT_FILE_SYSTEM_ADAPTER = {
    lstat: fs.lstat,
    lstatSync: fs.lstatSync,
    stat: fs.stat,
    statSync: fs.statSync,
    readdir: fs.readdir,
    readdirSync: fs.readdirSync
};
class Settings {
    constructor(_options = {}) {
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
            this.onlyFiles = false;
        }
        if (this.stats) {
            this.objectMode = true;
        }
    }
    _getValue(option, value) {
        return option === undefined ? value : option;
    }
    _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
    }
}
exports.default = Settings;


/***/ }),
/* 155 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var connection_1 = __webpack_require__(156);
function default_1(name) {
    return {
        log: function (message) {
            connection_1.connection.console.log(name + ": " + message);
        },
        info: function (message) {
            connection_1.connection.console.info(name + ": " + message);
        },
        warn: function (message) {
            connection_1.connection.console.warn(name + ": " + message);
        },
        error: function (message) {
            connection_1.connection.console.error(name + ": " + message);
        },
        showErrorMessage: function (message) {
            connection_1.connection.window.showErrorMessage(message);
        }
    };
}
exports.default = default_1;


/***/ }),
/* 156 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.connection = void 0;
var node_1 = __webpack_require__(157);
// create connection by command argv
exports.connection = node_1.createConnection();


/***/ }),
/* 157 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(2);

/***/ }),
/* 158 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"completionItems":{"commands":[{"label":"range","kind":24,"detail":"{range}","documentation":"go to last line in {range}","sortText":"00004","insertText":"range","insertTextFormat":1},{"label":"!","kind":24,"detail":"!","documentation":"filter lines or execute an external command","sortText":"00004","insertText":"!","insertTextFormat":1},{"label":"!!","kind":24,"detail":"!!","documentation":"repeat last \\":!\\" command","sortText":"00004","insertText":"!!","insertTextFormat":1},{"label":"#","kind":24,"detail":"#","documentation":"same as \\":number\\"","sortText":"00004","insertText":"#","insertTextFormat":1},{"label":"&","kind":24,"detail":"&","documentation":"repeat last \\":substitute\\"","sortText":"00004","insertText":"&","insertTextFormat":1},{"label":"star","kind":24,"detail":"*","documentation":"execute contents of a register","sortText":"00004","insertText":"star","insertTextFormat":1},{"label":"<","kind":24,"detail":"<","documentation":"shift lines one \'shiftwidth\' left","sortText":"00004","insertText":"<","insertTextFormat":1},{"label":"=","kind":24,"detail":"=","documentation":"print the cursor line number","sortText":"00004","insertText":"=","insertTextFormat":1},{"label":">","kind":24,"detail":">","documentation":"shift lines one \'shiftwidth\' right","sortText":"00004","insertText":">","insertTextFormat":1},{"label":"@","kind":24,"detail":"@","documentation":"execute contents of a register","sortText":"00004","insertText":"@","insertTextFormat":1},{"label":"@@","kind":24,"detail":"@@","documentation":"repeat the previous \\":@\\"","sortText":"00004","insertText":"@@","insertTextFormat":1},{"label":"Next","kind":24,"detail":"N[ext]","documentation":"go to previous file in the argument list","sortText":"00004","insertText":"Next","insertTextFormat":1},{"label":"append","kind":24,"detail":"a[ppend]","documentation":"append text","sortText":"00004","insertText":"append","insertTextFormat":1},{"label":"abbreviate","kind":24,"detail":"ab[breviate]","documentation":"enter abbreviation","sortText":"00004","insertText":"abbreviate","insertTextFormat":1},{"label":"abclear","kind":24,"detail":"abc[lear]","documentation":"remove all abbreviations","sortText":"00004","insertText":"abclear","insertTextFormat":1},{"label":"aboveleft","kind":24,"detail":"abo[veleft]","documentation":"make split window appear left or above","sortText":"00004","insertText":"aboveleft","insertTextFormat":1},{"label":"all","kind":24,"detail":"al[l]","documentation":"open a window for each file in the argument list","sortText":"00004","insertText":"all","insertTextFormat":1},{"label":"amenu","kind":24,"detail":"am[enu]","documentation":"enter new menu item for all modes","sortText":"00004","insertText":"amenu","insertTextFormat":1},{"label":"anoremenu","kind":24,"detail":"an[oremenu]","documentation":"enter a new menu for all modes that will not be remapped","sortText":"00004","insertText":"anoremenu","insertTextFormat":1},{"label":"args","kind":24,"detail":"ar[gs]","documentation":"print the argument list","sortText":"00004","insertText":"args","insertTextFormat":1},{"label":"argadd","kind":24,"detail":"arga[dd]","documentation":"add items to the argument list","sortText":"00004","insertText":"argadd","insertTextFormat":1},{"label":"argdelete","kind":24,"detail":"argd[elete]","documentation":"delete items from the argument list","sortText":"00004","insertText":"argdelete","insertTextFormat":1},{"label":"argedit","kind":24,"detail":"arge[dit]","documentation":"add item to the argument list and edit it","sortText":"00004","insertText":"argedit","insertTextFormat":1},{"label":"argdo","kind":24,"detail":"argdo","documentation":"do a command on all items in the argument list","sortText":"00004","insertText":"argdo","insertTextFormat":1},{"label":"argglobal","kind":24,"detail":"argg[lobal]","documentation":"define the global argument list","sortText":"00004","insertText":"argglobal","insertTextFormat":1},{"label":"arglocal","kind":24,"detail":"argl[ocal]","documentation":"define a local argument list","sortText":"00004","insertText":"arglocal","insertTextFormat":1},{"label":"argument","kind":24,"detail":"argu[ment]","documentation":"go to specific file in the argument list","sortText":"00004","insertText":"argument","insertTextFormat":1},{"label":"ascii","kind":24,"detail":"as[cii]","documentation":"print ascii value of character under the cursor","sortText":"00004","insertText":"ascii","insertTextFormat":1},{"label":"autocmd","kind":24,"detail":"au[tocmd]","documentation":"enter or show autocommands","sortText":"00004","insertText":"autocmd","insertTextFormat":1},{"label":"augroup","kind":24,"detail":"aug[roup]","documentation":"select the autocommand group to use","sortText":"00004","insertText":"augroup","insertTextFormat":1},{"label":"aunmenu","kind":24,"detail":"aun[menu]","documentation":"remove menu for all modes","sortText":"00004","insertText":"aunmenu","insertTextFormat":1},{"label":"buffer","kind":24,"detail":"b[uffer]","documentation":"go to specific buffer in the buffer list","sortText":"00004","insertText":"buffer","insertTextFormat":1},{"label":"bNext","kind":24,"detail":"bN[ext]","documentation":"go to previous buffer in the buffer list","sortText":"00004","insertText":"bNext","insertTextFormat":1},{"label":"ball","kind":24,"detail":"ba[ll]","documentation":"open a window for each buffer in the buffer list","sortText":"00004","insertText":"ball","insertTextFormat":1},{"label":"badd","kind":24,"detail":"bad[d]","documentation":"add buffer to the buffer list","sortText":"00004","insertText":"badd","insertTextFormat":1},{"label":"bdelete","kind":24,"detail":"bd[elete]","documentation":"remove a buffer from the buffer list","sortText":"00004","insertText":"bdelete","insertTextFormat":1},{"label":"behave","kind":24,"detail":"be[have]","documentation":"set mouse and selection behavior","sortText":"00004","insertText":"behave","insertTextFormat":1},{"label":"belowright","kind":24,"detail":"bel[owright]","documentation":"make split window appear right or below","sortText":"00004","insertText":"belowright","insertTextFormat":1},{"label":"bfirst","kind":24,"detail":"bf[irst]","documentation":"go to first buffer in the buffer list","sortText":"00004","insertText":"bfirst","insertTextFormat":1},{"label":"blast","kind":24,"detail":"bl[ast]","documentation":"go to last buffer in the buffer list","sortText":"00004","insertText":"blast","insertTextFormat":1},{"label":"bmodified","kind":24,"detail":"bm[odified]","documentation":"go to next buffer in the buffer list that has been modified","sortText":"00004","insertText":"bmodified","insertTextFormat":1},{"label":"bnext","kind":24,"detail":"bn[ext]","documentation":"go to next buffer in the buffer list","sortText":"00004","insertText":"bnext","insertTextFormat":1},{"label":"botright","kind":24,"detail":"bo[tright]","documentation":"make split window appear at bottom or far right","sortText":"00004","insertText":"botright","insertTextFormat":1},{"label":"bprevious","kind":24,"detail":"bp[revious]","documentation":"go to previous buffer in the buffer list","sortText":"00004","insertText":"bprevious","insertTextFormat":1},{"label":"brewind","kind":24,"detail":"br[ewind]","documentation":"go to first buffer in the buffer list","sortText":"00004","insertText":"brewind","insertTextFormat":1},{"label":"break","kind":24,"detail":"brea[k]","documentation":"break out of while loop","sortText":"00004","insertText":"break","insertTextFormat":1},{"label":"breakadd","kind":24,"detail":"breaka[dd]","documentation":"add a debugger breakpoint","sortText":"00004","insertText":"breakadd","insertTextFormat":1},{"label":"breakdel","kind":24,"detail":"breakd[el]","documentation":"delete a debugger breakpoint","sortText":"00004","insertText":"breakdel","insertTextFormat":1},{"label":"breaklist","kind":24,"detail":"breakl[ist]","documentation":"list debugger breakpoints","sortText":"00004","insertText":"breaklist","insertTextFormat":1},{"label":"browse","kind":24,"detail":"bro[wse]","documentation":"use file selection dialog","sortText":"00004","insertText":"browse","insertTextFormat":1},{"label":"bufdo","kind":24,"detail":"bufdo","documentation":"execute command in each listed buffer","sortText":"00004","insertText":"bufdo","insertTextFormat":1},{"label":"buffers","kind":24,"detail":"buffers","documentation":"list all files in the buffer list","sortText":"00004","insertText":"buffers","insertTextFormat":1},{"label":"bunload","kind":24,"detail":"bun[load]","documentation":"unload a specific buffer","sortText":"00004","insertText":"bunload","insertTextFormat":1},{"label":"bwipeout","kind":24,"detail":"bw[ipeout]","documentation":"really delete a buffer","sortText":"00004","insertText":"bwipeout","insertTextFormat":1},{"label":"change","kind":24,"detail":"c[hange]","documentation":"replace a line or series of lines","sortText":"00004","insertText":"change","insertTextFormat":1},{"label":"cNext","kind":24,"detail":"cN[ext]","documentation":"go to previous error","sortText":"00004","insertText":"cNext","insertTextFormat":1},{"label":"cNfile","kind":24,"detail":"cNf[ile]","documentation":"go to last error in previous file","sortText":"00004","insertText":"cNfile","insertTextFormat":1},{"label":"cabbrev","kind":24,"detail":"ca[bbrev]","documentation":"like \\":abbreviate\\" but for Command-line mode","sortText":"00004","insertText":"cabbrev","insertTextFormat":1},{"label":"cabclear","kind":24,"detail":"cabc[lear]","documentation":"clear all abbreviations for Command-line mode","sortText":"00004","insertText":"cabclear","insertTextFormat":1},{"label":"cabove","kind":24,"detail":"cabo[ve]","documentation":"go to error above current line","sortText":"00004","insertText":"cabove","insertTextFormat":1},{"label":"caddbuffer","kind":24,"detail":"cad[dbuffer]","documentation":"add errors from buffer","sortText":"00004","insertText":"caddbuffer","insertTextFormat":1},{"label":"caddexpr","kind":24,"detail":"cadde[xpr]","documentation":"add errors from expr","sortText":"00004","insertText":"caddexpr","insertTextFormat":1},{"label":"caddfile","kind":24,"detail":"caddf[ile]","documentation":"add error message to current quickfix list","sortText":"00004","insertText":"caddfile","insertTextFormat":1},{"label":"call","kind":24,"detail":"cal[l]","documentation":"call a function","sortText":"00004","insertText":"call","insertTextFormat":1},{"label":"catch","kind":24,"detail":"cat[ch]","documentation":"part of a :try command","sortText":"00004","insertText":"catch","insertTextFormat":1},{"label":"cbelow","kind":24,"detail":"cbe[low]","documentation":"go to error below current line","sortText":"00004","insertText":"cbelow","insertTextFormat":1},{"label":"cbottom","kind":24,"detail":"cbo[ttom]","documentation":"scroll to the bottom of the quickfix window","sortText":"00004","insertText":"cbottom","insertTextFormat":1},{"label":"cbuffer","kind":24,"detail":"cb[uffer]","documentation":"parse error messages and jump to first error","sortText":"00004","insertText":"cbuffer","insertTextFormat":1},{"label":"cc","kind":24,"detail":"cc","documentation":"go to specific error","sortText":"00004","insertText":"cc","insertTextFormat":1},{"label":"cclose","kind":24,"detail":"ccl[ose]","documentation":"close quickfix window","sortText":"00004","insertText":"cclose","insertTextFormat":1},{"label":"cd","kind":24,"detail":"cd","documentation":"change directory","sortText":"00004","insertText":"cd","insertTextFormat":1},{"label":"cdo","kind":24,"detail":"cdo","documentation":"execute command in each valid error list entry","sortText":"00004","insertText":"cdo","insertTextFormat":1},{"label":"cfdo","kind":24,"detail":"cfd[o]","documentation":"execute command in each file in error list","sortText":"00004","insertText":"cfdo","insertTextFormat":1},{"label":"center","kind":24,"detail":"ce[nter]","documentation":"format lines at the center","sortText":"00004","insertText":"center","insertTextFormat":1},{"label":"cexpr","kind":24,"detail":"cex[pr]","documentation":"read errors from expr and jump to first","sortText":"00004","insertText":"cexpr","insertTextFormat":1},{"label":"cfile","kind":24,"detail":"cf[ile]","documentation":"read file with error messages and jump to first","sortText":"00004","insertText":"cfile","insertTextFormat":1},{"label":"cfirst","kind":24,"detail":"cfir[st]","documentation":"go to the specified error, default first one","sortText":"00004","insertText":"cfirst","insertTextFormat":1},{"label":"cgetbuffer","kind":24,"detail":"cgetb[uffer]","documentation":"get errors from buffer","sortText":"00004","insertText":"cgetbuffer","insertTextFormat":1},{"label":"cgetexpr","kind":24,"detail":"cgete[xpr]","documentation":"get errors from expr","sortText":"00004","insertText":"cgetexpr","insertTextFormat":1},{"label":"cgetfile","kind":24,"detail":"cg[etfile]","documentation":"read file with error messages","sortText":"00004","insertText":"cgetfile","insertTextFormat":1},{"label":"changes","kind":24,"detail":"changes","documentation":"print the change list","sortText":"00004","insertText":"changes","insertTextFormat":1},{"label":"chdir","kind":24,"detail":"chd[ir]","documentation":"change directory","sortText":"00004","insertText":"chdir","insertTextFormat":1},{"label":"checkpath","kind":24,"detail":"che[ckpath]","documentation":"list included files","sortText":"00004","insertText":"checkpath","insertTextFormat":1},{"label":"checktime","kind":24,"detail":"checkt[ime]","documentation":"check timestamp of loaded buffers","sortText":"00004","insertText":"checktime","insertTextFormat":1},{"label":"chistory","kind":24,"detail":"chi[story]","documentation":"list the error lists","sortText":"00004","insertText":"chistory","insertTextFormat":1},{"label":"clast","kind":24,"detail":"cla[st]","documentation":"go to the specified error, default last one","sortText":"00004","insertText":"clast","insertTextFormat":1},{"label":"clearjumps","kind":24,"detail":"cle[arjumps]","documentation":"clear the jump list","sortText":"00004","insertText":"clearjumps","insertTextFormat":1},{"label":"clist","kind":24,"detail":"cl[ist]","documentation":"list all errors","sortText":"00004","insertText":"clist","insertTextFormat":1},{"label":"close","kind":24,"detail":"clo[se]","documentation":"close current window","sortText":"00004","insertText":"close","insertTextFormat":1},{"label":"cmap","kind":24,"detail":"cm[ap]","documentation":"like \\":map\\" but for Command-line mode","sortText":"00004","insertText":"cmap","insertTextFormat":1},{"label":"cmapclear","kind":24,"detail":"cmapc[lear]","documentation":"clear all mappings for Command-line mode","sortText":"00004","insertText":"cmapclear","insertTextFormat":1},{"label":"cmenu","kind":24,"detail":"cme[nu]","documentation":"add menu for Command-line mode","sortText":"00004","insertText":"cmenu","insertTextFormat":1},{"label":"cnext","kind":24,"detail":"cn[ext]","documentation":"go to next error","sortText":"00004","insertText":"cnext","insertTextFormat":1},{"label":"cnewer","kind":24,"detail":"cnew[er]","documentation":"go to newer error list","sortText":"00004","insertText":"cnewer","insertTextFormat":1},{"label":"cnfile","kind":24,"detail":"cnf[ile]","documentation":"go to first error in next file","sortText":"00004","insertText":"cnfile","insertTextFormat":1},{"label":"cnoremap","kind":24,"detail":"cno[remap]","documentation":"like \\":noremap\\" but for Command-line mode","sortText":"00004","insertText":"cnoremap","insertTextFormat":1},{"label":"cnoreabbrev","kind":24,"detail":"cnorea[bbrev]","documentation":"like \\":noreabbrev\\" but for Command-line mode","sortText":"00004","insertText":"cnoreabbrev","insertTextFormat":1},{"label":"cnoremenu","kind":24,"detail":"cnoreme[nu]","documentation":"like \\":noremenu\\" but for Command-line mode","sortText":"00004","insertText":"cnoremenu","insertTextFormat":1},{"label":"copy","kind":24,"detail":"co[py]","documentation":"copy lines","sortText":"00004","insertText":"copy","insertTextFormat":1},{"label":"colder","kind":24,"detail":"col[der]","documentation":"go to older error list","sortText":"00004","insertText":"colder","insertTextFormat":1},{"label":"colorscheme","kind":24,"detail":"colo[rscheme]","documentation":"load a specific color scheme","sortText":"00004","insertText":"colorscheme","insertTextFormat":1},{"label":"command","kind":24,"detail":"com[mand]","documentation":"create user-defined command","sortText":"00004","insertText":"command","insertTextFormat":1},{"label":"comclear","kind":24,"detail":"comc[lear]","documentation":"clear all user-defined commands","sortText":"00004","insertText":"comclear","insertTextFormat":1},{"label":"compiler","kind":24,"detail":"comp[iler]","documentation":"do settings for a specific compiler","sortText":"00004","insertText":"compiler","insertTextFormat":1},{"label":"continue","kind":24,"detail":"con[tinue]","documentation":"go back to :while","sortText":"00004","insertText":"continue","insertTextFormat":1},{"label":"confirm","kind":24,"detail":"conf[irm]","documentation":"prompt user when confirmation required","sortText":"00004","insertText":"confirm","insertTextFormat":1},{"label":"const","kind":24,"detail":"cons[t]","documentation":"create a variable as a constant","sortText":"00004","insertText":"const","insertTextFormat":1},{"label":"copen","kind":24,"detail":"cope[n]","documentation":"open quickfix window","sortText":"00004","insertText":"copen","insertTextFormat":1},{"label":"cprevious","kind":24,"detail":"cp[revious]","documentation":"go to previous error","sortText":"00004","insertText":"cprevious","insertTextFormat":1},{"label":"cpfile","kind":24,"detail":"cpf[ile]","documentation":"go to last error in previous file","sortText":"00004","insertText":"cpfile","insertTextFormat":1},{"label":"cquit","kind":24,"detail":"cq[uit]","documentation":"quit Vim with an error code","sortText":"00004","insertText":"cquit","insertTextFormat":1},{"label":"crewind","kind":24,"detail":"cr[ewind]","documentation":"go to the specified error, default first one","sortText":"00004","insertText":"crewind","insertTextFormat":1},{"label":"cscope","kind":24,"detail":"cs[cope]","documentation":"execute cscope command","sortText":"00004","insertText":"cscope","insertTextFormat":1},{"label":"cstag","kind":24,"detail":"cst[ag]","documentation":"use cscope to jump to a tag","sortText":"00004","insertText":"cstag","insertTextFormat":1},{"label":"cunmap","kind":24,"detail":"cu[nmap]","documentation":"like \\":unmap\\" but for Command-line mode","sortText":"00004","insertText":"cunmap","insertTextFormat":1},{"label":"cunabbrev","kind":24,"detail":"cuna[bbrev]","documentation":"like \\":unabbrev\\" but for Command-line mode","sortText":"00004","insertText":"cunabbrev","insertTextFormat":1},{"label":"cunmenu","kind":24,"detail":"cunme[nu]","documentation":"remove menu for Command-line mode","sortText":"00004","insertText":"cunmenu","insertTextFormat":1},{"label":"cwindow","kind":24,"detail":"cw[indow]","documentation":"open or close quickfix window","sortText":"00004","insertText":"cwindow","insertTextFormat":1},{"label":"delete","kind":24,"detail":"d[elete]","documentation":"delete lines","sortText":"00004","insertText":"delete","insertTextFormat":1},{"label":"delmarks","kind":24,"detail":"delm[arks]","documentation":"delete marks","sortText":"00004","insertText":"delmarks","insertTextFormat":1},{"label":"debug","kind":24,"detail":"deb[ug]","documentation":"run a command in debugging mode","sortText":"00004","insertText":"debug","insertTextFormat":1},{"label":"debuggreedy","kind":24,"detail":"debugg[reedy]","documentation":"read debug mode commands from normal input","sortText":"00004","insertText":"debuggreedy","insertTextFormat":1},{"label":"delcommand","kind":24,"detail":"delc[ommand]","documentation":"delete user-defined command","sortText":"00004","insertText":"delcommand","insertTextFormat":1},{"label":"delfunction","kind":24,"detail":"delf[unction]","documentation":"delete a user function","sortText":"00004","insertText":"delfunction","insertTextFormat":1},{"label":"diffupdate","kind":24,"detail":"dif[fupdate]","documentation":"update \'diff\' buffers","sortText":"00004","insertText":"diffupdate","insertTextFormat":1},{"label":"diffget","kind":24,"detail":"diffg[et]","documentation":"remove differences in current buffer","sortText":"00004","insertText":"diffget","insertTextFormat":1},{"label":"diffoff","kind":24,"detail":"diffo[ff]","documentation":"switch off diff mode","sortText":"00004","insertText":"diffoff","insertTextFormat":1},{"label":"diffpatch","kind":24,"detail":"diffp[atch]","documentation":"apply a patch and show differences","sortText":"00004","insertText":"diffpatch","insertTextFormat":1},{"label":"diffput","kind":24,"detail":"diffpu[t]","documentation":"remove differences in other buffer","sortText":"00004","insertText":"diffput","insertTextFormat":1},{"label":"diffsplit","kind":24,"detail":"diffs[plit]","documentation":"show differences with another file","sortText":"00004","insertText":"diffsplit","insertTextFormat":1},{"label":"diffthis","kind":24,"detail":"diffthis","documentation":"make current window a diff window","sortText":"00004","insertText":"diffthis","insertTextFormat":1},{"label":"digraphs","kind":24,"detail":"dig[raphs]","documentation":"show or enter digraphs","sortText":"00004","insertText":"digraphs","insertTextFormat":1},{"label":"display","kind":24,"detail":"di[splay]","documentation":"display registers","sortText":"00004","insertText":"display","insertTextFormat":1},{"label":"djump","kind":24,"detail":"dj[ump]","documentation":"jump to #define","sortText":"00004","insertText":"djump","insertTextFormat":1},{"label":"dl","kind":24,"detail":"dl","documentation":"short for |:delete| with the \'l\' flag","sortText":"00004","insertText":"dl","insertTextFormat":1},{"label":"del","kind":24,"detail":"del[ete]l","documentation":"short for |:delete| with the \'l\' flag","sortText":"00004","insertText":"del","insertTextFormat":1},{"label":"dlist","kind":24,"detail":"dli[st]","documentation":"list #defines","sortText":"00004","insertText":"dlist","insertTextFormat":1},{"label":"doautocmd","kind":24,"detail":"do[autocmd]","documentation":"apply autocommands to current buffer","sortText":"00004","insertText":"doautocmd","insertTextFormat":1},{"label":"doautoall","kind":24,"detail":"doautoa[ll]","documentation":"apply autocommands for all loaded buffers","sortText":"00004","insertText":"doautoall","insertTextFormat":1},{"label":"dp","kind":24,"detail":"d[elete]p","documentation":"short for |:delete| with the \'p\' flag","sortText":"00004","insertText":"dp","insertTextFormat":1},{"label":"drop","kind":24,"detail":"dr[op]","documentation":"jump to window editing file or edit file in current window","sortText":"00004","insertText":"drop","insertTextFormat":1},{"label":"dsearch","kind":24,"detail":"ds[earch]","documentation":"list one #define","sortText":"00004","insertText":"dsearch","insertTextFormat":1},{"label":"dsplit","kind":24,"detail":"dsp[lit]","documentation":"split window and jump to #define","sortText":"00004","insertText":"dsplit","insertTextFormat":1},{"label":"edit","kind":24,"detail":"e[dit]","documentation":"edit a file","sortText":"00004","insertText":"edit","insertTextFormat":1},{"label":"earlier","kind":24,"detail":"ea[rlier]","documentation":"go to older change, undo","sortText":"00004","insertText":"earlier","insertTextFormat":1},{"label":"echo","kind":24,"detail":"ec[ho]","documentation":"echoes the result of expressions","sortText":"00004","insertText":"echo","insertTextFormat":1},{"label":"echoerr","kind":24,"detail":"echoe[rr]","documentation":"like :echo, show like an error and use history","sortText":"00004","insertText":"echoerr","insertTextFormat":1},{"label":"echohl","kind":24,"detail":"echoh[l]","documentation":"set highlighting for echo commands","sortText":"00004","insertText":"echohl","insertTextFormat":1},{"label":"echomsg","kind":24,"detail":"echom[sg]","documentation":"same as :echo, put message in history","sortText":"00004","insertText":"echomsg","insertTextFormat":1},{"label":"echon","kind":24,"detail":"echon","documentation":"same as :echo, but without <EOL>","sortText":"00004","insertText":"echon","insertTextFormat":1},{"label":"else","kind":24,"detail":"el[se]","documentation":"part of an :if command","sortText":"00004","insertText":"else","insertTextFormat":1},{"label":"elseif","kind":24,"detail":"elsei[f]","documentation":"part of an :if command","sortText":"00004","insertText":"elseif","insertTextFormat":1},{"label":"emenu","kind":24,"detail":"em[enu]","documentation":"execute a menu by name","sortText":"00004","insertText":"emenu","insertTextFormat":1},{"label":"endif","kind":24,"detail":"en[dif]","documentation":"end previous :if","sortText":"00004","insertText":"endif","insertTextFormat":1},{"label":"endfor","kind":24,"detail":"endfo[r]","documentation":"end previous :for","sortText":"00004","insertText":"endfor","insertTextFormat":1},{"label":"endfunction","kind":24,"detail":"endf[unction]","documentation":"end of a user function","sortText":"00004","insertText":"endfunction","insertTextFormat":1},{"label":"endtry","kind":24,"detail":"endt[ry]","documentation":"end previous :try","sortText":"00004","insertText":"endtry","insertTextFormat":1},{"label":"endwhile","kind":24,"detail":"endw[hile]","documentation":"end previous :while","sortText":"00004","insertText":"endwhile","insertTextFormat":1},{"label":"enew","kind":24,"detail":"ene[w]","documentation":"edit a new, unnamed buffer","sortText":"00004","insertText":"enew","insertTextFormat":1},{"label":"ex","kind":24,"detail":"ex","documentation":"same as \\":edit\\"","sortText":"00004","insertText":"ex","insertTextFormat":1},{"label":"execute","kind":24,"detail":"exe[cute]","documentation":"execute result of expressions","sortText":"00004","insertText":"execute","insertTextFormat":1},{"label":"exit","kind":24,"detail":"exi[t]","documentation":"same as \\":xit\\"","sortText":"00004","insertText":"exit","insertTextFormat":1},{"label":"exusage","kind":24,"detail":"exu[sage]","documentation":"overview of Ex commands","sortText":"00004","insertText":"exusage","insertTextFormat":1},{"label":"file","kind":24,"detail":"f[ile]","documentation":"show or set the current file name","sortText":"00004","insertText":"file","insertTextFormat":1},{"label":"files","kind":24,"detail":"files","documentation":"list all files in the buffer list","sortText":"00004","insertText":"files","insertTextFormat":1},{"label":"filetype","kind":24,"detail":"filet[ype]","documentation":"switch file type detection on/off","sortText":"00004","insertText":"filetype","insertTextFormat":1},{"label":"filter","kind":24,"detail":"filt[er]","documentation":"filter output of following command","sortText":"00004","insertText":"filter","insertTextFormat":1},{"label":"find","kind":24,"detail":"fin[d]","documentation":"find file in \'path\' and edit it","sortText":"00004","insertText":"find","insertTextFormat":1},{"label":"finally","kind":24,"detail":"fina[lly]","documentation":"part of a :try command","sortText":"00004","insertText":"finally","insertTextFormat":1},{"label":"finish","kind":24,"detail":"fini[sh]","documentation":"quit sourcing a Vim script","sortText":"00004","insertText":"finish","insertTextFormat":1},{"label":"first","kind":24,"detail":"fir[st]","documentation":"go to the first file in the argument list","sortText":"00004","insertText":"first","insertTextFormat":1},{"label":"fold","kind":24,"detail":"fo[ld]","documentation":"create a fold","sortText":"00004","insertText":"fold","insertTextFormat":1},{"label":"foldclose","kind":24,"detail":"foldc[lose]","documentation":"close folds","sortText":"00004","insertText":"foldclose","insertTextFormat":1},{"label":"folddoopen","kind":24,"detail":"foldd[oopen]","documentation":"execute command on lines not in a closed fold","sortText":"00004","insertText":"folddoopen","insertTextFormat":1},{"label":"folddoclosed","kind":24,"detail":"folddoc[losed]","documentation":"execute command on lines in a closed fold","sortText":"00004","insertText":"folddoclosed","insertTextFormat":1},{"label":"foldopen","kind":24,"detail":"foldo[pen]","documentation":"open folds","sortText":"00004","insertText":"foldopen","insertTextFormat":1},{"label":"for","kind":24,"detail":"for","documentation":"for loop","sortText":"00004","insertText":"for","insertTextFormat":1},{"label":"function","kind":24,"detail":"fu[nction]","documentation":"define a user function","sortText":"00004","insertText":"function","insertTextFormat":1},{"label":"global","kind":24,"detail":"g[lobal]","documentation":"execute commands for matching lines","sortText":"00004","insertText":"global","insertTextFormat":1},{"label":"goto","kind":24,"detail":"go[to]","documentation":"go to byte in the buffer","sortText":"00004","insertText":"goto","insertTextFormat":1},{"label":"grep","kind":24,"detail":"gr[ep]","documentation":"run \'grepprg\' and jump to first match","sortText":"00004","insertText":"grep","insertTextFormat":1},{"label":"grepadd","kind":24,"detail":"grepa[dd]","documentation":"like :grep, but append to current list","sortText":"00004","insertText":"grepadd","insertTextFormat":1},{"label":"gui","kind":24,"detail":"gu[i]","documentation":"start the GUI","sortText":"00004","insertText":"gui","insertTextFormat":1},{"label":"gvim","kind":24,"detail":"gv[im]","documentation":"start the GUI","sortText":"00004","insertText":"gvim","insertTextFormat":1},{"label":"hardcopy","kind":24,"detail":"ha[rdcopy]","documentation":"send text to the printer","sortText":"00004","insertText":"hardcopy","insertTextFormat":1},{"label":"help","kind":24,"detail":"h[elp]","documentation":"open a help window","sortText":"00004","insertText":"help","insertTextFormat":1},{"label":"helpclose","kind":24,"detail":"helpc[lose]","documentation":"close one help window","sortText":"00004","insertText":"helpclose","insertTextFormat":1},{"label":"helpgrep","kind":24,"detail":"helpg[rep]","documentation":"like \\":grep\\" but searches help files","sortText":"00004","insertText":"helpgrep","insertTextFormat":1},{"label":"helptags","kind":24,"detail":"helpt[ags]","documentation":"generate help tags for a directory","sortText":"00004","insertText":"helptags","insertTextFormat":1},{"label":"highlight","kind":24,"detail":"hi[ghlight]","documentation":"specify highlighting methods","sortText":"00004","insertText":"highlight","insertTextFormat":1},{"label":"hide","kind":24,"detail":"hid[e]","documentation":"hide current buffer for a command","sortText":"00004","insertText":"hide","insertTextFormat":1},{"label":"history","kind":24,"detail":"his[tory]","documentation":"print a history list","sortText":"00004","insertText":"history","insertTextFormat":1},{"label":"insert","kind":24,"detail":"i[nsert]","documentation":"insert text","sortText":"00004","insertText":"insert","insertTextFormat":1},{"label":"iabbrev","kind":24,"detail":"ia[bbrev]","documentation":"like \\":abbrev\\" but for Insert mode","sortText":"00004","insertText":"iabbrev","insertTextFormat":1},{"label":"iabclear","kind":24,"detail":"iabc[lear]","documentation":"like \\":abclear\\" but for Insert mode","sortText":"00004","insertText":"iabclear","insertTextFormat":1},{"label":"if","kind":24,"detail":"if","documentation":"execute commands when condition met","sortText":"00004","insertText":"if","insertTextFormat":1},{"label":"ijump","kind":24,"detail":"ij[ump]","documentation":"jump to definition of identifier","sortText":"00004","insertText":"ijump","insertTextFormat":1},{"label":"ilist","kind":24,"detail":"il[ist]","documentation":"list lines where identifier matches","sortText":"00004","insertText":"ilist","insertTextFormat":1},{"label":"imap","kind":24,"detail":"im[ap]","documentation":"like \\":map\\" but for Insert mode","sortText":"00004","insertText":"imap","insertTextFormat":1},{"label":"imapclear","kind":24,"detail":"imapc[lear]","documentation":"like \\":mapclear\\" but for Insert mode","sortText":"00004","insertText":"imapclear","insertTextFormat":1},{"label":"imenu","kind":24,"detail":"ime[nu]","documentation":"add menu for Insert mode","sortText":"00004","insertText":"imenu","insertTextFormat":1},{"label":"inoremap","kind":24,"detail":"ino[remap]","documentation":"like \\":noremap\\" but for Insert mode","sortText":"00004","insertText":"inoremap","insertTextFormat":1},{"label":"inoreabbrev","kind":24,"detail":"inorea[bbrev]","documentation":"like \\":noreabbrev\\" but for Insert mode","sortText":"00004","insertText":"inoreabbrev","insertTextFormat":1},{"label":"inoremenu","kind":24,"detail":"inoreme[nu]","documentation":"like \\":noremenu\\" but for Insert mode","sortText":"00004","insertText":"inoremenu","insertTextFormat":1},{"label":"intro","kind":24,"detail":"int[ro]","documentation":"print the introductory message","sortText":"00004","insertText":"intro","insertTextFormat":1},{"label":"isearch","kind":24,"detail":"is[earch]","documentation":"list one line where identifier matches","sortText":"00004","insertText":"isearch","insertTextFormat":1},{"label":"isplit","kind":24,"detail":"isp[lit]","documentation":"split window and jump to definition of identifier","sortText":"00004","insertText":"isplit","insertTextFormat":1},{"label":"iunmap","kind":24,"detail":"iu[nmap]","documentation":"like \\":unmap\\" but for Insert mode","sortText":"00004","insertText":"iunmap","insertTextFormat":1},{"label":"iunabbrev","kind":24,"detail":"iuna[bbrev]","documentation":"like \\":unabbrev\\" but for Insert mode","sortText":"00004","insertText":"iunabbrev","insertTextFormat":1},{"label":"iunmenu","kind":24,"detail":"iunme[nu]","documentation":"remove menu for Insert mode","sortText":"00004","insertText":"iunmenu","insertTextFormat":1},{"label":"join","kind":24,"detail":"j[oin]","documentation":"join lines","sortText":"00004","insertText":"join","insertTextFormat":1},{"label":"jumps","kind":24,"detail":"ju[mps]","documentation":"print the jump list","sortText":"00004","insertText":"jumps","insertTextFormat":1},{"label":"k","kind":24,"detail":"k","documentation":"set a mark","sortText":"00004","insertText":"k","insertTextFormat":1},{"label":"keepalt","kind":24,"detail":"keepa[lt]","documentation":"following command keeps the alternate file","sortText":"00004","insertText":"keepalt","insertTextFormat":1},{"label":"keepmarks","kind":24,"detail":"kee[pmarks]","documentation":"following command keeps marks where they are","sortText":"00004","insertText":"keepmarks","insertTextFormat":1},{"label":"keepjumps","kind":24,"detail":"keepj[umps]","documentation":"following command keeps jumplist and marks","sortText":"00004","insertText":"keepjumps","insertTextFormat":1},{"label":"keeppatterns","kind":24,"detail":"keepp[atterns]","documentation":"following command keeps search pattern history","sortText":"00004","insertText":"keeppatterns","insertTextFormat":1},{"label":"lNext","kind":24,"detail":"lN[ext]","documentation":"go to previous entry in location list","sortText":"00004","insertText":"lNext","insertTextFormat":1},{"label":"lNfile","kind":24,"detail":"lNf[ile]","documentation":"go to last entry in previous file","sortText":"00004","insertText":"lNfile","insertTextFormat":1},{"label":"list","kind":24,"detail":"l[ist]","documentation":"print lines","sortText":"00004","insertText":"list","insertTextFormat":1},{"label":"labove","kind":24,"detail":"lab[ove]","documentation":"go to location above current line","sortText":"00004","insertText":"labove","insertTextFormat":1},{"label":"laddexpr","kind":24,"detail":"lad[dexpr]","documentation":"add locations from expr","sortText":"00004","insertText":"laddexpr","insertTextFormat":1},{"label":"laddbuffer","kind":24,"detail":"laddb[uffer]","documentation":"add locations from buffer","sortText":"00004","insertText":"laddbuffer","insertTextFormat":1},{"label":"laddfile","kind":24,"detail":"laddf[ile]","documentation":"add locations to current location list","sortText":"00004","insertText":"laddfile","insertTextFormat":1},{"label":"last","kind":24,"detail":"la[st]","documentation":"go to the last file in the argument list","sortText":"00004","insertText":"last","insertTextFormat":1},{"label":"language","kind":24,"detail":"lan[guage]","documentation":"set the language (locale)","sortText":"00004","insertText":"language","insertTextFormat":1},{"label":"later","kind":24,"detail":"lat[er]","documentation":"go to newer change, redo","sortText":"00004","insertText":"later","insertTextFormat":1},{"label":"lbelow","kind":24,"detail":"lbe[low]","documentation":"go to location below current line","sortText":"00004","insertText":"lbelow","insertTextFormat":1},{"label":"lbottom","kind":24,"detail":"lbo[ttom]","documentation":"scroll to the bottom of the location window","sortText":"00004","insertText":"lbottom","insertTextFormat":1},{"label":"lbuffer","kind":24,"detail":"lb[uffer]","documentation":"parse locations and jump to first location","sortText":"00004","insertText":"lbuffer","insertTextFormat":1},{"label":"lcd","kind":24,"detail":"lc[d]","documentation":"change directory locally","sortText":"00004","insertText":"lcd","insertTextFormat":1},{"label":"lchdir","kind":24,"detail":"lch[dir]","documentation":"change directory locally","sortText":"00004","insertText":"lchdir","insertTextFormat":1},{"label":"lclose","kind":24,"detail":"lcl[ose]","documentation":"close location window","sortText":"00004","insertText":"lclose","insertTextFormat":1},{"label":"lcscope","kind":24,"detail":"lcs[cope]","documentation":"like \\":cscope\\" but uses location list","sortText":"00004","insertText":"lcscope","insertTextFormat":1},{"label":"ldo","kind":24,"detail":"ld[o]","documentation":"execute command in valid location list entries","sortText":"00004","insertText":"ldo","insertTextFormat":1},{"label":"lfdo","kind":24,"detail":"lfd[o]","documentation":"execute command in each file in location list","sortText":"00004","insertText":"lfdo","insertTextFormat":1},{"label":"left","kind":24,"detail":"le[ft]","documentation":"left align lines","sortText":"00004","insertText":"left","insertTextFormat":1},{"label":"leftabove","kind":24,"detail":"lefta[bove]","documentation":"make split window appear left or above","sortText":"00004","insertText":"leftabove","insertTextFormat":1},{"label":"let","kind":24,"detail":"let","documentation":"assign a value to a variable or option","sortText":"00004","insertText":"let","insertTextFormat":1},{"label":"lexpr","kind":24,"detail":"lex[pr]","documentation":"read locations from expr and jump to first","sortText":"00004","insertText":"lexpr","insertTextFormat":1},{"label":"lfile","kind":24,"detail":"lf[ile]","documentation":"read file with locations and jump to first","sortText":"00004","insertText":"lfile","insertTextFormat":1},{"label":"lfirst","kind":24,"detail":"lfir[st]","documentation":"go to the specified location, default first one","sortText":"00004","insertText":"lfirst","insertTextFormat":1},{"label":"lgetbuffer","kind":24,"detail":"lgetb[uffer]","documentation":"get locations from buffer","sortText":"00004","insertText":"lgetbuffer","insertTextFormat":1},{"label":"lgetexpr","kind":24,"detail":"lgete[xpr]","documentation":"get locations from expr","sortText":"00004","insertText":"lgetexpr","insertTextFormat":1},{"label":"lgetfile","kind":24,"detail":"lg[etfile]","documentation":"read file with locations","sortText":"00004","insertText":"lgetfile","insertTextFormat":1},{"label":"lgrep","kind":24,"detail":"lgr[ep]","documentation":"run \'grepprg\' and jump to first match","sortText":"00004","insertText":"lgrep","insertTextFormat":1},{"label":"lgrepadd","kind":24,"detail":"lgrepa[dd]","documentation":"like :grep, but append to current list","sortText":"00004","insertText":"lgrepadd","insertTextFormat":1},{"label":"lhelpgrep","kind":24,"detail":"lh[elpgrep]","documentation":"like \\":helpgrep\\" but uses location list","sortText":"00004","insertText":"lhelpgrep","insertTextFormat":1},{"label":"lhistory","kind":24,"detail":"lhi[story]","documentation":"list the location lists","sortText":"00004","insertText":"lhistory","insertTextFormat":1},{"label":"ll","kind":24,"detail":"ll","documentation":"go to specific location","sortText":"00004","insertText":"ll","insertTextFormat":1},{"label":"llast","kind":24,"detail":"lla[st]","documentation":"go to the specified location, default last one","sortText":"00004","insertText":"llast","insertTextFormat":1},{"label":"llist","kind":24,"detail":"lli[st]","documentation":"list all locations","sortText":"00004","insertText":"llist","insertTextFormat":1},{"label":"lmake","kind":24,"detail":"lmak[e]","documentation":"execute external command \'makeprg\' and parse error messages","sortText":"00004","insertText":"lmake","insertTextFormat":1},{"label":"lmap","kind":24,"detail":"lm[ap]","documentation":"like \\":map!\\" but includes Lang-Arg mode","sortText":"00004","insertText":"lmap","insertTextFormat":1},{"label":"lmapclear","kind":24,"detail":"lmapc[lear]","documentation":"like \\":mapclear!\\" but includes Lang-Arg mode","sortText":"00004","insertText":"lmapclear","insertTextFormat":1},{"label":"lnext","kind":24,"detail":"lne[xt]","documentation":"go to next location","sortText":"00004","insertText":"lnext","insertTextFormat":1},{"label":"lnewer","kind":24,"detail":"lnew[er]","documentation":"go to newer location list","sortText":"00004","insertText":"lnewer","insertTextFormat":1},{"label":"lnfile","kind":24,"detail":"lnf[ile]","documentation":"go to first location in next file","sortText":"00004","insertText":"lnfile","insertTextFormat":1},{"label":"lnoremap","kind":24,"detail":"ln[oremap]","documentation":"like \\":noremap!\\" but includes Lang-Arg mode","sortText":"00004","insertText":"lnoremap","insertTextFormat":1},{"label":"loadkeymap","kind":24,"detail":"loadk[eymap]","documentation":"load the following keymaps until EOF","sortText":"00004","insertText":"loadkeymap","insertTextFormat":1},{"label":"loadview","kind":24,"detail":"lo[adview]","documentation":"load view for current window from a file","sortText":"00004","insertText":"loadview","insertTextFormat":1},{"label":"lockmarks","kind":24,"detail":"loc[kmarks]","documentation":"following command keeps marks where they are","sortText":"00004","insertText":"lockmarks","insertTextFormat":1},{"label":"lockvar","kind":24,"detail":"lockv[ar]","documentation":"lock variables","sortText":"00004","insertText":"lockvar","insertTextFormat":1},{"label":"lolder","kind":24,"detail":"lol[der]","documentation":"go to older location list","sortText":"00004","insertText":"lolder","insertTextFormat":1},{"label":"lopen","kind":24,"detail":"lope[n]","documentation":"open location window","sortText":"00004","insertText":"lopen","insertTextFormat":1},{"label":"lprevious","kind":24,"detail":"lp[revious]","documentation":"go to previous location","sortText":"00004","insertText":"lprevious","insertTextFormat":1},{"label":"lpfile","kind":24,"detail":"lpf[ile]","documentation":"go to last location in previous file","sortText":"00004","insertText":"lpfile","insertTextFormat":1},{"label":"lrewind","kind":24,"detail":"lr[ewind]","documentation":"go to the specified location, default first one","sortText":"00004","insertText":"lrewind","insertTextFormat":1},{"label":"ls","kind":24,"detail":"ls","documentation":"list all buffers","sortText":"00004","insertText":"ls","insertTextFormat":1},{"label":"ltag","kind":24,"detail":"lt[ag]","documentation":"jump to tag and add matching tags to the location list","sortText":"00004","insertText":"ltag","insertTextFormat":1},{"label":"lunmap","kind":24,"detail":"lu[nmap]","documentation":"like \\":unmap!\\" but includes Lang-Arg mode","sortText":"00004","insertText":"lunmap","insertTextFormat":1},{"label":"lua","kind":24,"detail":"lua","documentation":"execute |Lua| command","sortText":"00004","insertText":"lua","insertTextFormat":1},{"label":"luado","kind":24,"detail":"luad[o]","documentation":"execute Lua command for each line","sortText":"00004","insertText":"luado","insertTextFormat":1},{"label":"luafile","kind":24,"detail":"luaf[ile]","documentation":"execute |Lua| script file","sortText":"00004","insertText":"luafile","insertTextFormat":1},{"label":"lvimgrep","kind":24,"detail":"lv[imgrep]","documentation":"search for pattern in files","sortText":"00004","insertText":"lvimgrep","insertTextFormat":1},{"label":"lvimgrepadd","kind":24,"detail":"lvimgrepa[dd]","documentation":"like :vimgrep, but append to current list","sortText":"00004","insertText":"lvimgrepadd","insertTextFormat":1},{"label":"lwindow","kind":24,"detail":"lw[indow]","documentation":"open or close location window","sortText":"00004","insertText":"lwindow","insertTextFormat":1},{"label":"move","kind":24,"detail":"m[ove]","documentation":"move lines","sortText":"00004","insertText":"move","insertTextFormat":1},{"label":"mark","kind":24,"detail":"ma[rk]","documentation":"set a mark","sortText":"00004","insertText":"mark","insertTextFormat":1},{"label":"make","kind":24,"detail":"mak[e]","documentation":"execute external command \'makeprg\' and parse error messages","sortText":"00004","insertText":"make","insertTextFormat":1},{"label":"map","kind":24,"detail":"map","documentation":"show or enter a mapping","sortText":"00004","insertText":"map","insertTextFormat":1},{"label":"mapclear","kind":24,"detail":"mapc[lear]","documentation":"clear all mappings for Normal and Visual mode","sortText":"00004","insertText":"mapclear","insertTextFormat":1},{"label":"marks","kind":24,"detail":"marks","documentation":"list all marks","sortText":"00004","insertText":"marks","insertTextFormat":1},{"label":"match","kind":24,"detail":"mat[ch]","documentation":"define a match to highlight","sortText":"00004","insertText":"match","insertTextFormat":1},{"label":"menu","kind":24,"detail":"me[nu]","documentation":"enter a new menu item","sortText":"00004","insertText":"menu","insertTextFormat":1},{"label":"menutranslate","kind":24,"detail":"menut[ranslate]","documentation":"add a menu translation item","sortText":"00004","insertText":"menutranslate","insertTextFormat":1},{"label":"messages","kind":24,"detail":"mes[sages]","documentation":"view previously displayed messages","sortText":"00004","insertText":"messages","insertTextFormat":1},{"label":"mkexrc","kind":24,"detail":"mk[exrc]","documentation":"write current mappings and settings to a file","sortText":"00004","insertText":"mkexrc","insertTextFormat":1},{"label":"mksession","kind":24,"detail":"mks[ession]","documentation":"write session info to a file","sortText":"00004","insertText":"mksession","insertTextFormat":1},{"label":"mkspell","kind":24,"detail":"mksp[ell]","documentation":"produce .spl spell file","sortText":"00004","insertText":"mkspell","insertTextFormat":1},{"label":"mkvimrc","kind":24,"detail":"mkv[imrc]","documentation":"write current mappings and settings to a file","sortText":"00004","insertText":"mkvimrc","insertTextFormat":1},{"label":"mkview","kind":24,"detail":"mkvie[w]","documentation":"write view of current window to a file","sortText":"00004","insertText":"mkview","insertTextFormat":1},{"label":"mode","kind":24,"detail":"mod[e]","documentation":"show or change the screen mode","sortText":"00004","insertText":"mode","insertTextFormat":1},{"label":"next","kind":24,"detail":"n[ext]","documentation":"go to next file in the argument list","sortText":"00004","insertText":"next","insertTextFormat":1},{"label":"new","kind":24,"detail":"new","documentation":"create a new empty window","sortText":"00004","insertText":"new","insertTextFormat":1},{"label":"nmap","kind":24,"detail":"nm[ap]","documentation":"like \\":map\\" but for Normal mode","sortText":"00004","insertText":"nmap","insertTextFormat":1},{"label":"nmapclear","kind":24,"detail":"nmapc[lear]","documentation":"clear all mappings for Normal mode","sortText":"00004","insertText":"nmapclear","insertTextFormat":1},{"label":"nmenu","kind":24,"detail":"nme[nu]","documentation":"add menu for Normal mode","sortText":"00004","insertText":"nmenu","insertTextFormat":1},{"label":"nnoremap","kind":24,"detail":"nn[oremap]","documentation":"like \\":noremap\\" but for Normal mode","sortText":"00004","insertText":"nnoremap","insertTextFormat":1},{"label":"nnoremenu","kind":24,"detail":"nnoreme[nu]","documentation":"like \\":noremenu\\" but for Normal mode","sortText":"00004","insertText":"nnoremenu","insertTextFormat":1},{"label":"noautocmd","kind":24,"detail":"noa[utocmd]","documentation":"following commands don\'t trigger autocommands","sortText":"00004","insertText":"noautocmd","insertTextFormat":1},{"label":"noremap","kind":24,"detail":"no[remap]","documentation":"enter a mapping that will not be remapped","sortText":"00004","insertText":"noremap","insertTextFormat":1},{"label":"nohlsearch","kind":24,"detail":"noh[lsearch]","documentation":"suspend \'hlsearch\' highlighting","sortText":"00004","insertText":"nohlsearch","insertTextFormat":1},{"label":"noreabbrev","kind":24,"detail":"norea[bbrev]","documentation":"enter an abbreviation that will not be remapped","sortText":"00004","insertText":"noreabbrev","insertTextFormat":1},{"label":"noremenu","kind":24,"detail":"noreme[nu]","documentation":"enter a menu that will not be remapped","sortText":"00004","insertText":"noremenu","insertTextFormat":1},{"label":"normal","kind":24,"detail":"norm[al]","documentation":"execute Normal mode commands","sortText":"00004","insertText":"normal","insertTextFormat":1},{"label":"noswapfile","kind":24,"detail":"nos[wapfile]","documentation":"following commands don\'t create a swap file","sortText":"00004","insertText":"noswapfile","insertTextFormat":1},{"label":"number","kind":24,"detail":"nu[mber]","documentation":"print lines with line number","sortText":"00004","insertText":"number","insertTextFormat":1},{"label":"nunmap","kind":24,"detail":"nun[map]","documentation":"like \\":unmap\\" but for Normal mode","sortText":"00004","insertText":"nunmap","insertTextFormat":1},{"label":"nunmenu","kind":24,"detail":"nunme[nu]","documentation":"remove menu for Normal mode","sortText":"00004","insertText":"nunmenu","insertTextFormat":1},{"label":"oldfiles","kind":24,"detail":"ol[dfiles]","documentation":"list files that have marks in the |shada| file","sortText":"00004","insertText":"oldfiles","insertTextFormat":1},{"label":"omap","kind":24,"detail":"om[ap]","documentation":"like \\":map\\" but for Operator-pending mode","sortText":"00004","insertText":"omap","insertTextFormat":1},{"label":"omapclear","kind":24,"detail":"omapc[lear]","documentation":"remove all mappings for Operator-pending mode","sortText":"00004","insertText":"omapclear","insertTextFormat":1},{"label":"omenu","kind":24,"detail":"ome[nu]","documentation":"add menu for Operator-pending mode","sortText":"00004","insertText":"omenu","insertTextFormat":1},{"label":"only","kind":24,"detail":"on[ly]","documentation":"close all windows except the current one","sortText":"00004","insertText":"only","insertTextFormat":1},{"label":"onoremap","kind":24,"detail":"ono[remap]","documentation":"like \\":noremap\\" but for Operator-pending mode","sortText":"00004","insertText":"onoremap","insertTextFormat":1},{"label":"onoremenu","kind":24,"detail":"onoreme[nu]","documentation":"like \\":noremenu\\" but for Operator-pending mode","sortText":"00004","insertText":"onoremenu","insertTextFormat":1},{"label":"options","kind":24,"detail":"opt[ions]","documentation":"open the options-window","sortText":"00004","insertText":"options","insertTextFormat":1},{"label":"ounmap","kind":24,"detail":"ou[nmap]","documentation":"like \\":unmap\\" but for Operator-pending mode","sortText":"00004","insertText":"ounmap","insertTextFormat":1},{"label":"ounmenu","kind":24,"detail":"ounme[nu]","documentation":"remove menu for Operator-pending mode","sortText":"00004","insertText":"ounmenu","insertTextFormat":1},{"label":"ownsyntax","kind":24,"detail":"ow[nsyntax]","documentation":"set new local syntax highlight for this window","sortText":"00004","insertText":"ownsyntax","insertTextFormat":1},{"label":"packadd","kind":24,"detail":"pa[ckadd]","documentation":"add a plugin from \'packpath\'","sortText":"00004","insertText":"packadd","insertTextFormat":1},{"label":"packloadall","kind":24,"detail":"packl[oadall]","documentation":"load all packages under \'packpath\'","sortText":"00004","insertText":"packloadall","insertTextFormat":1},{"label":"pclose","kind":24,"detail":"pc[lose]","documentation":"close preview window","sortText":"00004","insertText":"pclose","insertTextFormat":1},{"label":"pedit","kind":24,"detail":"ped[it]","documentation":"edit file in the preview window","sortText":"00004","insertText":"pedit","insertTextFormat":1},{"label":"print","kind":24,"detail":"p[rint]","documentation":"print lines","sortText":"00004","insertText":"print","insertTextFormat":1},{"label":"profdel","kind":24,"detail":"profd[el]","documentation":"stop profiling a function or script","sortText":"00004","insertText":"profdel","insertTextFormat":1},{"label":"profile","kind":24,"detail":"prof[ile]","documentation":"profiling functions and scripts","sortText":"00004","insertText":"profile","insertTextFormat":1},{"label":"promptfind","kind":24,"detail":"pro[mptfind]","documentation":"open GUI dialog for searching","sortText":"00004","insertText":"promptfind","insertTextFormat":1},{"label":"promptrepl","kind":24,"detail":"promptr[epl]","documentation":"open GUI dialog for search/replace","sortText":"00004","insertText":"promptrepl","insertTextFormat":1},{"label":"pop","kind":24,"detail":"po[p]","documentation":"jump to older entry in tag stack","sortText":"00004","insertText":"pop","insertTextFormat":1},{"label":"popup","kind":24,"detail":"popu[p]","documentation":"popup a menu by name","sortText":"00004","insertText":"popup","insertTextFormat":1},{"label":"ppop","kind":24,"detail":"pp[op]","documentation":"\\":pop\\" in preview window","sortText":"00004","insertText":"ppop","insertTextFormat":1},{"label":"preserve","kind":24,"detail":"pre[serve]","documentation":"write all text to swap file","sortText":"00004","insertText":"preserve","insertTextFormat":1},{"label":"previous","kind":24,"detail":"prev[ious]","documentation":"go to previous file in argument list","sortText":"00004","insertText":"previous","insertTextFormat":1},{"label":"psearch","kind":24,"detail":"ps[earch]","documentation":"like \\":ijump\\" but shows match in preview window","sortText":"00004","insertText":"psearch","insertTextFormat":1},{"label":"ptag","kind":24,"detail":"pt[ag]","documentation":"show tag in preview window","sortText":"00004","insertText":"ptag","insertTextFormat":1},{"label":"ptNext","kind":24,"detail":"ptN[ext]","documentation":"|:tNext| in preview window","sortText":"00004","insertText":"ptNext","insertTextFormat":1},{"label":"ptfirst","kind":24,"detail":"ptf[irst]","documentation":"|:trewind| in preview window","sortText":"00004","insertText":"ptfirst","insertTextFormat":1},{"label":"ptjump","kind":24,"detail":"ptj[ump]","documentation":"|:tjump| and show tag in preview window","sortText":"00004","insertText":"ptjump","insertTextFormat":1},{"label":"ptlast","kind":24,"detail":"ptl[ast]","documentation":"|:tlast| in preview window","sortText":"00004","insertText":"ptlast","insertTextFormat":1},{"label":"ptnext","kind":24,"detail":"ptn[ext]","documentation":"|:tnext| in preview window","sortText":"00004","insertText":"ptnext","insertTextFormat":1},{"label":"ptprevious","kind":24,"detail":"ptp[revious]","documentation":"|:tprevious| in preview window","sortText":"00004","insertText":"ptprevious","insertTextFormat":1},{"label":"ptrewind","kind":24,"detail":"ptr[ewind]","documentation":"|:trewind| in preview window","sortText":"00004","insertText":"ptrewind","insertTextFormat":1},{"label":"ptselect","kind":24,"detail":"pts[elect]","documentation":"|:tselect| and show tag in preview window","sortText":"00004","insertText":"ptselect","insertTextFormat":1},{"label":"put","kind":24,"detail":"pu[t]","documentation":"insert contents of register in the text","sortText":"00004","insertText":"put","insertTextFormat":1},{"label":"pwd","kind":24,"detail":"pw[d]","documentation":"print current directory","sortText":"00004","insertText":"pwd","insertTextFormat":1},{"label":"py3","kind":24,"detail":"py3","documentation":"execute Python 3 command","sortText":"00004","insertText":"py3","insertTextFormat":1},{"label":"python3","kind":24,"detail":"python3","documentation":"same as :py3","sortText":"00004","insertText":"python3","insertTextFormat":1},{"label":"py3do","kind":24,"detail":"py3d[o]","documentation":"execute Python 3 command for each line","sortText":"00004","insertText":"py3do","insertTextFormat":1},{"label":"py3file","kind":24,"detail":"py3f[ile]","documentation":"execute Python 3 script file","sortText":"00004","insertText":"py3file","insertTextFormat":1},{"label":"python","kind":24,"detail":"py[thon]","documentation":"execute Python command","sortText":"00004","insertText":"python","insertTextFormat":1},{"label":"pydo","kind":24,"detail":"pyd[o]","documentation":"execute Python command for each line","sortText":"00004","insertText":"pydo","insertTextFormat":1},{"label":"pyfile","kind":24,"detail":"pyf[ile]","documentation":"execute Python script file","sortText":"00004","insertText":"pyfile","insertTextFormat":1},{"label":"pyx","kind":24,"detail":"pyx","documentation":"execute |python_x| command","sortText":"00004","insertText":"pyx","insertTextFormat":1},{"label":"pythonx","kind":24,"detail":"pythonx","documentation":"same as :pyx","sortText":"00004","insertText":"pythonx","insertTextFormat":1},{"label":"pyxdo","kind":24,"detail":"pyxd[o]","documentation":"execute |python_x| command for each line","sortText":"00004","insertText":"pyxdo","insertTextFormat":1},{"label":"pyxfile","kind":24,"detail":"pyxf[ile]","documentation":"execute |python_x| script file","sortText":"00004","insertText":"pyxfile","insertTextFormat":1},{"label":"quit","kind":24,"detail":"q[uit]","documentation":"quit current window (when one window quit Vim)","sortText":"00004","insertText":"quit","insertTextFormat":1},{"label":"quitall","kind":24,"detail":"quita[ll]","documentation":"quit Vim","sortText":"00004","insertText":"quitall","insertTextFormat":1},{"label":"qall","kind":24,"detail":"qa[ll]","documentation":"quit Vim","sortText":"00004","insertText":"qall","insertTextFormat":1},{"label":"read","kind":24,"detail":"r[ead]","documentation":"read file into the text","sortText":"00004","insertText":"read","insertTextFormat":1},{"label":"recover","kind":24,"detail":"rec[over]","documentation":"recover a file from a swap file","sortText":"00004","insertText":"recover","insertTextFormat":1},{"label":"redo","kind":24,"detail":"red[o]","documentation":"redo one undone change","sortText":"00004","insertText":"redo","insertTextFormat":1},{"label":"redir","kind":24,"detail":"redi[r]","documentation":"redirect messages to a file or register","sortText":"00004","insertText":"redir","insertTextFormat":1},{"label":"redraw","kind":24,"detail":"redr[aw]","documentation":"force a redraw of the display","sortText":"00004","insertText":"redraw","insertTextFormat":1},{"label":"redrawstatus","kind":24,"detail":"redraws[tatus]","documentation":"force a redraw of the status line(s)","sortText":"00004","insertText":"redrawstatus","insertTextFormat":1},{"label":"redrawtabline","kind":24,"detail":"redrawt[abline]","documentation":"force a redraw of the tabline","sortText":"00004","insertText":"redrawtabline","insertTextFormat":1},{"label":"registers","kind":24,"detail":"reg[isters]","documentation":"display the contents of registers","sortText":"00004","insertText":"registers","insertTextFormat":1},{"label":"resize","kind":24,"detail":"res[ize]","documentation":"change current window height","sortText":"00004","insertText":"resize","insertTextFormat":1},{"label":"retab","kind":24,"detail":"ret[ab]","documentation":"change tab size","sortText":"00004","insertText":"retab","insertTextFormat":1},{"label":"return","kind":24,"detail":"retu[rn]","documentation":"return from a user function","sortText":"00004","insertText":"return","insertTextFormat":1},{"label":"rewind","kind":24,"detail":"rew[ind]","documentation":"go to the first file in the argument list","sortText":"00004","insertText":"rewind","insertTextFormat":1},{"label":"right","kind":24,"detail":"ri[ght]","documentation":"right align text","sortText":"00004","insertText":"right","insertTextFormat":1},{"label":"rightbelow","kind":24,"detail":"rightb[elow]","documentation":"make split window appear right or below","sortText":"00004","insertText":"rightbelow","insertTextFormat":1},{"label":"rshada","kind":24,"detail":"rsh[ada]","documentation":"read from |shada| file","sortText":"00004","insertText":"rshada","insertTextFormat":1},{"label":"ruby","kind":24,"detail":"rub[y]","documentation":"execute Ruby command","sortText":"00004","insertText":"ruby","insertTextFormat":1},{"label":"rubydo","kind":24,"detail":"rubyd[o]","documentation":"execute Ruby command for each line","sortText":"00004","insertText":"rubydo","insertTextFormat":1},{"label":"rubyfile","kind":24,"detail":"rubyf[ile]","documentation":"execute Ruby script file","sortText":"00004","insertText":"rubyfile","insertTextFormat":1},{"label":"rundo","kind":24,"detail":"rund[o]","documentation":"read undo information from a file","sortText":"00004","insertText":"rundo","insertTextFormat":1},{"label":"runtime","kind":24,"detail":"ru[ntime]","documentation":"source vim scripts in \'runtimepath\'","sortText":"00004","insertText":"runtime","insertTextFormat":1},{"label":"substitute","kind":24,"detail":"s[ubstitute]","documentation":"find and replace text","sortText":"00004","insertText":"substitute","insertTextFormat":1},{"label":"sNext","kind":24,"detail":"sN[ext]","documentation":"split window and go to previous file in argument list","sortText":"00004","insertText":"sNext","insertTextFormat":1},{"label":"sandbox","kind":24,"detail":"san[dbox]","documentation":"execute a command in the sandbox","sortText":"00004","insertText":"sandbox","insertTextFormat":1},{"label":"sargument","kind":24,"detail":"sa[rgument]","documentation":"split window and go to specific file in argument list","sortText":"00004","insertText":"sargument","insertTextFormat":1},{"label":"sall","kind":24,"detail":"sal[l]","documentation":"open a window for each file in argument list","sortText":"00004","insertText":"sall","insertTextFormat":1},{"label":"saveas","kind":24,"detail":"sav[eas]","documentation":"save file under another name.","sortText":"00004","insertText":"saveas","insertTextFormat":1},{"label":"sbuffer","kind":24,"detail":"sb[uffer]","documentation":"split window and go to specific file in the buffer list","sortText":"00004","insertText":"sbuffer","insertTextFormat":1},{"label":"sbNext","kind":24,"detail":"sbN[ext]","documentation":"split window and go to previous file in the buffer list","sortText":"00004","insertText":"sbNext","insertTextFormat":1},{"label":"sball","kind":24,"detail":"sba[ll]","documentation":"open a window for each file in the buffer list","sortText":"00004","insertText":"sball","insertTextFormat":1},{"label":"sbfirst","kind":24,"detail":"sbf[irst]","documentation":"split window and go to first file in the buffer list","sortText":"00004","insertText":"sbfirst","insertTextFormat":1},{"label":"sblast","kind":24,"detail":"sbl[ast]","documentation":"split window and go to last file in buffer list","sortText":"00004","insertText":"sblast","insertTextFormat":1},{"label":"sbmodified","kind":24,"detail":"sbm[odified]","documentation":"split window and go to modified file in the buffer list","sortText":"00004","insertText":"sbmodified","insertTextFormat":1},{"label":"sbnext","kind":24,"detail":"sbn[ext]","documentation":"split window and go to next file in the buffer list","sortText":"00004","insertText":"sbnext","insertTextFormat":1},{"label":"sbprevious","kind":24,"detail":"sbp[revious]","documentation":"split window and go to previous file in the buffer list","sortText":"00004","insertText":"sbprevious","insertTextFormat":1},{"label":"sbrewind","kind":24,"detail":"sbr[ewind]","documentation":"split window and go to first file in the buffer list","sortText":"00004","insertText":"sbrewind","insertTextFormat":1},{"label":"scriptnames","kind":24,"detail":"scr[iptnames]","documentation":"list names of all sourced Vim scripts","sortText":"00004","insertText":"scriptnames","insertTextFormat":1},{"label":"scriptencoding","kind":24,"detail":"scripte[ncoding]","documentation":"encoding used in sourced Vim script","sortText":"00004","insertText":"scriptencoding","insertTextFormat":1},{"label":"scriptversion","kind":24,"detail":"scriptv[ersion]","documentation":"version of Vim script used","sortText":"00004","insertText":"scriptversion","insertTextFormat":1},{"label":"scscope","kind":24,"detail":"scs[cope]","documentation":"split window and execute cscope command","sortText":"00004","insertText":"scscope","insertTextFormat":1},{"label":"set","kind":24,"detail":"se[t]","documentation":"show or set options","sortText":"00004","insertText":"set","insertTextFormat":1},{"label":"setfiletype","kind":24,"detail":"setf[iletype]","documentation":"set \'filetype\', unless it was set already","sortText":"00004","insertText":"setfiletype","insertTextFormat":1},{"label":"setglobal","kind":24,"detail":"setg[lobal]","documentation":"show global values of options","sortText":"00004","insertText":"setglobal","insertTextFormat":1},{"label":"setlocal","kind":24,"detail":"setl[ocal]","documentation":"show or set options locally","sortText":"00004","insertText":"setlocal","insertTextFormat":1},{"label":"sfind","kind":24,"detail":"sf[ind]","documentation":"split current window and edit file in \'path\'","sortText":"00004","insertText":"sfind","insertTextFormat":1},{"label":"sfirst","kind":24,"detail":"sfir[st]","documentation":"split window and go to first file in the argument list","sortText":"00004","insertText":"sfirst","insertTextFormat":1},{"label":"sign","kind":24,"detail":"sig[n]","documentation":"manipulate signs","sortText":"00004","insertText":"sign","insertTextFormat":1},{"label":"silent","kind":24,"detail":"sil[ent]","documentation":"run a command silently","sortText":"00004","insertText":"silent","insertTextFormat":1},{"label":"sleep","kind":24,"detail":"sl[eep]","documentation":"do nothing for a few seconds","sortText":"00004","insertText":"sleep","insertTextFormat":1},{"label":"slast","kind":24,"detail":"sla[st]","documentation":"split window and go to last file in the argument list","sortText":"00004","insertText":"slast","insertTextFormat":1},{"label":"smagic","kind":24,"detail":"sm[agic]","documentation":":substitute with \'magic\'","sortText":"00004","insertText":"smagic","insertTextFormat":1},{"label":"smap","kind":24,"detail":"smap","documentation":"like \\":map\\" but for Select mode","sortText":"00004","insertText":"smap","insertTextFormat":1},{"label":"smapclear","kind":24,"detail":"smapc[lear]","documentation":"remove all mappings for Select mode","sortText":"00004","insertText":"smapclear","insertTextFormat":1},{"label":"smenu","kind":24,"detail":"sme[nu]","documentation":"add menu for Select mode","sortText":"00004","insertText":"smenu","insertTextFormat":1},{"label":"snext","kind":24,"detail":"sn[ext]","documentation":"split window and go to next file in the argument list","sortText":"00004","insertText":"snext","insertTextFormat":1},{"label":"snomagic","kind":24,"detail":"sno[magic]","documentation":":substitute with \'nomagic\'","sortText":"00004","insertText":"snomagic","insertTextFormat":1},{"label":"snoremap","kind":24,"detail":"snor[emap]","documentation":"like \\":noremap\\" but for Select mode","sortText":"00004","insertText":"snoremap","insertTextFormat":1},{"label":"snoremenu","kind":24,"detail":"snoreme[nu]","documentation":"like \\":noremenu\\" but for Select mode","sortText":"00004","insertText":"snoremenu","insertTextFormat":1},{"label":"sort","kind":24,"detail":"sor[t]","documentation":"sort lines","sortText":"00004","insertText":"sort","insertTextFormat":1},{"label":"source","kind":24,"detail":"so[urce]","documentation":"read Vim or Ex commands from a file","sortText":"00004","insertText":"source","insertTextFormat":1},{"label":"spelldump","kind":24,"detail":"spelld[ump]","documentation":"split window and fill with all correct words","sortText":"00004","insertText":"spelldump","insertTextFormat":1},{"label":"spellgood","kind":24,"detail":"spe[llgood]","documentation":"add good word for spelling","sortText":"00004","insertText":"spellgood","insertTextFormat":1},{"label":"spellinfo","kind":24,"detail":"spelli[nfo]","documentation":"show info about loaded spell files","sortText":"00004","insertText":"spellinfo","insertTextFormat":1},{"label":"spellrare","kind":24,"detail":"spellra[re]","documentation":"add rare word for spelling","sortText":"00004","insertText":"spellrare","insertTextFormat":1},{"label":"spellrepall","kind":24,"detail":"spellr[epall]","documentation":"replace all bad words like last |z=|","sortText":"00004","insertText":"spellrepall","insertTextFormat":1},{"label":"spellundo","kind":24,"detail":"spellu[ndo]","documentation":"remove good or bad word","sortText":"00004","insertText":"spellundo","insertTextFormat":1},{"label":"spellwrong","kind":24,"detail":"spellw[rong]","documentation":"add spelling mistake","sortText":"00004","insertText":"spellwrong","insertTextFormat":1},{"label":"split","kind":24,"detail":"sp[lit]","documentation":"split current window","sortText":"00004","insertText":"split","insertTextFormat":1},{"label":"sprevious","kind":24,"detail":"spr[evious]","documentation":"split window and go to previous file in the argument list","sortText":"00004","insertText":"sprevious","insertTextFormat":1},{"label":"srewind","kind":24,"detail":"sre[wind]","documentation":"split window and go to first file in the argument list","sortText":"00004","insertText":"srewind","insertTextFormat":1},{"label":"stop","kind":24,"detail":"st[op]","documentation":"suspend the editor or escape to a shell","sortText":"00004","insertText":"stop","insertTextFormat":1},{"label":"stag","kind":24,"detail":"sta[g]","documentation":"split window and jump to a tag","sortText":"00004","insertText":"stag","insertTextFormat":1},{"label":"startinsert","kind":24,"detail":"star[tinsert]","documentation":"start Insert mode","sortText":"00004","insertText":"startinsert","insertTextFormat":1},{"label":"startgreplace","kind":24,"detail":"startg[replace]","documentation":"start Virtual Replace mode","sortText":"00004","insertText":"startgreplace","insertTextFormat":1},{"label":"startreplace","kind":24,"detail":"startr[eplace]","documentation":"start Replace mode","sortText":"00004","insertText":"startreplace","insertTextFormat":1},{"label":"stopinsert","kind":24,"detail":"stopi[nsert]","documentation":"stop Insert mode","sortText":"00004","insertText":"stopinsert","insertTextFormat":1},{"label":"stjump","kind":24,"detail":"stj[ump]","documentation":"do \\":tjump\\" and split window","sortText":"00004","insertText":"stjump","insertTextFormat":1},{"label":"stselect","kind":24,"detail":"sts[elect]","documentation":"do \\":tselect\\" and split window","sortText":"00004","insertText":"stselect","insertTextFormat":1},{"label":"sunhide","kind":24,"detail":"sun[hide]","documentation":"same as \\":unhide\\"","sortText":"00004","insertText":"sunhide","insertTextFormat":1},{"label":"sunmap","kind":24,"detail":"sunm[ap]","documentation":"like \\":unmap\\" but for Select mode","sortText":"00004","insertText":"sunmap","insertTextFormat":1},{"label":"sunmenu","kind":24,"detail":"sunme[nu]","documentation":"remove menu for Select mode","sortText":"00004","insertText":"sunmenu","insertTextFormat":1},{"label":"suspend","kind":24,"detail":"sus[pend]","documentation":"same as \\":stop\\"","sortText":"00004","insertText":"suspend","insertTextFormat":1},{"label":"sview","kind":24,"detail":"sv[iew]","documentation":"split window and edit file read-only","sortText":"00004","insertText":"sview","insertTextFormat":1},{"label":"swapname","kind":24,"detail":"sw[apname]","documentation":"show the name of the current swap file","sortText":"00004","insertText":"swapname","insertTextFormat":1},{"label":"syntax","kind":24,"detail":"sy[ntax]","documentation":"syntax highlighting","sortText":"00004","insertText":"syntax","insertTextFormat":1},{"label":"syntime","kind":24,"detail":"synti[me]","documentation":"measure syntax highlighting speed","sortText":"00004","insertText":"syntime","insertTextFormat":1},{"label":"syncbind","kind":24,"detail":"sync[bind]","documentation":"sync scroll binding","sortText":"00004","insertText":"syncbind","insertTextFormat":1},{"label":"t","kind":24,"detail":"t","documentation":"same as \\":copy\\"","sortText":"00004","insertText":"t","insertTextFormat":1},{"label":"tNext","kind":24,"detail":"tN[ext]","documentation":"jump to previous matching tag","sortText":"00004","insertText":"tNext","insertTextFormat":1},{"label":"tabNext","kind":24,"detail":"tabN[ext]","documentation":"go to previous tab page","sortText":"00004","insertText":"tabNext","insertTextFormat":1},{"label":"tabclose","kind":24,"detail":"tabc[lose]","documentation":"close current tab page","sortText":"00004","insertText":"tabclose","insertTextFormat":1},{"label":"tabdo","kind":24,"detail":"tabdo","documentation":"execute command in each tab page","sortText":"00004","insertText":"tabdo","insertTextFormat":1},{"label":"tabedit","kind":24,"detail":"tabe[dit]","documentation":"edit a file in a new tab page","sortText":"00004","insertText":"tabedit","insertTextFormat":1},{"label":"tabfind","kind":24,"detail":"tabf[ind]","documentation":"find file in \'path\', edit it in a new tab page","sortText":"00004","insertText":"tabfind","insertTextFormat":1},{"label":"tabfirst","kind":24,"detail":"tabfir[st]","documentation":"go to first tab page","sortText":"00004","insertText":"tabfirst","insertTextFormat":1},{"label":"tablast","kind":24,"detail":"tabl[ast]","documentation":"go to last tab page","sortText":"00004","insertText":"tablast","insertTextFormat":1},{"label":"tabmove","kind":24,"detail":"tabm[ove]","documentation":"move tab page to other position","sortText":"00004","insertText":"tabmove","insertTextFormat":1},{"label":"tabnew","kind":24,"detail":"tabnew","documentation":"edit a file in a new tab page","sortText":"00004","insertText":"tabnew","insertTextFormat":1},{"label":"tabnext","kind":24,"detail":"tabn[ext]","documentation":"go to next tab page","sortText":"00004","insertText":"tabnext","insertTextFormat":1},{"label":"tabonly","kind":24,"detail":"tabo[nly]","documentation":"close all tab pages except the current one","sortText":"00004","insertText":"tabonly","insertTextFormat":1},{"label":"tabprevious","kind":24,"detail":"tabp[revious]","documentation":"go to previous tab page","sortText":"00004","insertText":"tabprevious","insertTextFormat":1},{"label":"tabrewind","kind":24,"detail":"tabr[ewind]","documentation":"go to first tab page","sortText":"00004","insertText":"tabrewind","insertTextFormat":1},{"label":"tabs","kind":24,"detail":"tabs","documentation":"list the tab pages and what they contain","sortText":"00004","insertText":"tabs","insertTextFormat":1},{"label":"tab","kind":24,"detail":"tab","documentation":"create new tab when opening new window","sortText":"00004","insertText":"tab","insertTextFormat":1},{"label":"tag","kind":24,"detail":"ta[g]","documentation":"jump to tag","sortText":"00004","insertText":"tag","insertTextFormat":1},{"label":"tags","kind":24,"detail":"tags","documentation":"show the contents of the tag stack","sortText":"00004","insertText":"tags","insertTextFormat":1},{"label":"tcd","kind":24,"detail":"tcd","documentation":"change directory for tab page","sortText":"00004","insertText":"tcd","insertTextFormat":1},{"label":"tchdir","kind":24,"detail":"tch[dir]","documentation":"change directory for tab page","sortText":"00004","insertText":"tchdir","insertTextFormat":1},{"label":"terminal","kind":24,"detail":"te[rminal]","documentation":"open a terminal buffer","sortText":"00004","insertText":"terminal","insertTextFormat":1},{"label":"tfirst","kind":24,"detail":"tf[irst]","documentation":"jump to first matching tag","sortText":"00004","insertText":"tfirst","insertTextFormat":1},{"label":"throw","kind":24,"detail":"th[row]","documentation":"throw an exception","sortText":"00004","insertText":"throw","insertTextFormat":1},{"label":"tjump","kind":24,"detail":"tj[ump]","documentation":"like \\":tselect\\", but jump directly when there is only one match","sortText":"00004","insertText":"tjump","insertTextFormat":1},{"label":"tlast","kind":24,"detail":"tl[ast]","documentation":"jump to last matching tag","sortText":"00004","insertText":"tlast","insertTextFormat":1},{"label":"tmapclear","kind":24,"detail":"tmapc[lear]","documentation":"remove all mappings for Terminal-Job mode","sortText":"00004","insertText":"tmapclear","insertTextFormat":1},{"label":"tmap","kind":24,"detail":"tma[p]","documentation":"like \\":map\\" but for Terminal-Job mode","sortText":"00004","insertText":"tmap","insertTextFormat":1},{"label":"tmenu","kind":24,"detail":"tm[enu]","documentation":"define menu tooltip","sortText":"00004","insertText":"tmenu","insertTextFormat":1},{"label":"tnext","kind":24,"detail":"tn[ext]","documentation":"jump to next matching tag","sortText":"00004","insertText":"tnext","insertTextFormat":1},{"label":"tnoremap","kind":24,"detail":"tno[remap]","documentation":"like \\":noremap\\" but for Terminal-Job mode","sortText":"00004","insertText":"tnoremap","insertTextFormat":1},{"label":"topleft","kind":24,"detail":"to[pleft]","documentation":"make split window appear at top or far left","sortText":"00004","insertText":"topleft","insertTextFormat":1},{"label":"tprevious","kind":24,"detail":"tp[revious]","documentation":"jump to previous matching tag","sortText":"00004","insertText":"tprevious","insertTextFormat":1},{"label":"trewind","kind":24,"detail":"tr[ewind]","documentation":"jump to first matching tag","sortText":"00004","insertText":"trewind","insertTextFormat":1},{"label":"try","kind":24,"detail":"try","documentation":"execute commands, abort on error or exception","sortText":"00004","insertText":"try","insertTextFormat":1},{"label":"tselect","kind":24,"detail":"ts[elect]","documentation":"list matching tags and select one","sortText":"00004","insertText":"tselect","insertTextFormat":1},{"label":"tunmap","kind":24,"detail":"tunma[p]","documentation":"like \\":unmap\\" but for Terminal-Job mode","sortText":"00004","insertText":"tunmap","insertTextFormat":1},{"label":"tunmenu","kind":24,"detail":"tu[nmenu]","documentation":"remove menu tooltip","sortText":"00004","insertText":"tunmenu","insertTextFormat":1},{"label":"undo","kind":24,"detail":"u[ndo]","documentation":"undo last change(s)","sortText":"00004","insertText":"undo","insertTextFormat":1},{"label":"undojoin","kind":24,"detail":"undoj[oin]","documentation":"join next change with previous undo block","sortText":"00004","insertText":"undojoin","insertTextFormat":1},{"label":"undolist","kind":24,"detail":"undol[ist]","documentation":"list leafs of the undo tree","sortText":"00004","insertText":"undolist","insertTextFormat":1},{"label":"unabbreviate","kind":24,"detail":"una[bbreviate]","documentation":"remove abbreviation","sortText":"00004","insertText":"unabbreviate","insertTextFormat":1},{"label":"unhide","kind":24,"detail":"unh[ide]","documentation":"open a window for each loaded file in the buffer list","sortText":"00004","insertText":"unhide","insertTextFormat":1},{"label":"unlet","kind":24,"detail":"unl[et]","documentation":"delete variable","sortText":"00004","insertText":"unlet","insertTextFormat":1},{"label":"unlockvar","kind":24,"detail":"unlo[ckvar]","documentation":"unlock variables","sortText":"00004","insertText":"unlockvar","insertTextFormat":1},{"label":"unmap","kind":24,"detail":"unm[ap]","documentation":"remove mapping","sortText":"00004","insertText":"unmap","insertTextFormat":1},{"label":"unmenu","kind":24,"detail":"unme[nu]","documentation":"remove menu","sortText":"00004","insertText":"unmenu","insertTextFormat":1},{"label":"unsilent","kind":24,"detail":"uns[ilent]","documentation":"run a command not silently","sortText":"00004","insertText":"unsilent","insertTextFormat":1},{"label":"update","kind":24,"detail":"up[date]","documentation":"write buffer if modified","sortText":"00004","insertText":"update","insertTextFormat":1},{"label":"vglobal","kind":24,"detail":"v[global]","documentation":"execute commands for not matching lines","sortText":"00004","insertText":"vglobal","insertTextFormat":1},{"label":"version","kind":24,"detail":"ve[rsion]","documentation":"print version number and other info","sortText":"00004","insertText":"version","insertTextFormat":1},{"label":"verbose","kind":24,"detail":"verb[ose]","documentation":"execute command with \'verbose\' set","sortText":"00004","insertText":"verbose","insertTextFormat":1},{"label":"vertical","kind":24,"detail":"vert[ical]","documentation":"make following command split vertically","sortText":"00004","insertText":"vertical","insertTextFormat":1},{"label":"vimgrep","kind":24,"detail":"vim[grep]","documentation":"search for pattern in files","sortText":"00004","insertText":"vimgrep","insertTextFormat":1},{"label":"vimgrepadd","kind":24,"detail":"vimgrepa[dd]","documentation":"like :vimgrep, but append to current list","sortText":"00004","insertText":"vimgrepadd","insertTextFormat":1},{"label":"visual","kind":24,"detail":"vi[sual]","documentation":"same as \\":edit\\", but turns off \\"Ex\\" mode","sortText":"00004","insertText":"visual","insertTextFormat":1},{"label":"viusage","kind":24,"detail":"viu[sage]","documentation":"overview of Normal mode commands","sortText":"00004","insertText":"viusage","insertTextFormat":1},{"label":"view","kind":24,"detail":"vie[w]","documentation":"edit a file read-only","sortText":"00004","insertText":"view","insertTextFormat":1},{"label":"vmap","kind":24,"detail":"vm[ap]","documentation":"like \\":map\\" but for Visual+Select mode","sortText":"00004","insertText":"vmap","insertTextFormat":1},{"label":"vmapclear","kind":24,"detail":"vmapc[lear]","documentation":"remove all mappings for Visual+Select mode","sortText":"00004","insertText":"vmapclear","insertTextFormat":1},{"label":"vmenu","kind":24,"detail":"vme[nu]","documentation":"add menu for Visual+Select mode","sortText":"00004","insertText":"vmenu","insertTextFormat":1},{"label":"vnew","kind":24,"detail":"vne[w]","documentation":"create a new empty window, vertically split","sortText":"00004","insertText":"vnew","insertTextFormat":1},{"label":"vnoremap","kind":24,"detail":"vn[oremap]","documentation":"like \\":noremap\\" but for Visual+Select mode","sortText":"00004","insertText":"vnoremap","insertTextFormat":1},{"label":"vnoremenu","kind":24,"detail":"vnoreme[nu]","documentation":"like \\":noremenu\\" but for Visual+Select mode","sortText":"00004","insertText":"vnoremenu","insertTextFormat":1},{"label":"vsplit","kind":24,"detail":"vs[plit]","documentation":"split current window vertically","sortText":"00004","insertText":"vsplit","insertTextFormat":1},{"label":"vunmap","kind":24,"detail":"vu[nmap]","documentation":"like \\":unmap\\" but for Visual+Select mode","sortText":"00004","insertText":"vunmap","insertTextFormat":1},{"label":"vunmenu","kind":24,"detail":"vunme[nu]","documentation":"remove menu for Visual+Select mode","sortText":"00004","insertText":"vunmenu","insertTextFormat":1},{"label":"windo","kind":24,"detail":"windo","documentation":"execute command in each window","sortText":"00004","insertText":"windo","insertTextFormat":1},{"label":"write","kind":24,"detail":"w[rite]","documentation":"write to a file","sortText":"00004","insertText":"write","insertTextFormat":1},{"label":"wNext","kind":24,"detail":"wN[ext]","documentation":"write to a file and go to previous file in argument list","sortText":"00004","insertText":"wNext","insertTextFormat":1},{"label":"wall","kind":24,"detail":"wa[ll]","documentation":"write all (changed) buffers","sortText":"00004","insertText":"wall","insertTextFormat":1},{"label":"while","kind":24,"detail":"wh[ile]","documentation":"execute loop for as long as condition met","sortText":"00004","insertText":"while","insertTextFormat":1},{"label":"winsize","kind":24,"detail":"wi[nsize]","documentation":"get or set window size (obsolete)","sortText":"00004","insertText":"winsize","insertTextFormat":1},{"label":"wincmd","kind":24,"detail":"winc[md]","documentation":"execute a Window (CTRL-W) command","sortText":"00004","insertText":"wincmd","insertTextFormat":1},{"label":"winpos","kind":24,"detail":"winp[os]","documentation":"get or set window position","sortText":"00004","insertText":"winpos","insertTextFormat":1},{"label":"wnext","kind":24,"detail":"wn[ext]","documentation":"write to a file and go to next file in argument list","sortText":"00004","insertText":"wnext","insertTextFormat":1},{"label":"wprevious","kind":24,"detail":"wp[revious]","documentation":"write to a file and go to previous file in argument list","sortText":"00004","insertText":"wprevious","insertTextFormat":1},{"label":"wq","kind":24,"detail":"wq","documentation":"write to a file and quit window or Vim","sortText":"00004","insertText":"wq","insertTextFormat":1},{"label":"wqall","kind":24,"detail":"wqa[ll]","documentation":"write all changed buffers and quit Vim","sortText":"00004","insertText":"wqall","insertTextFormat":1},{"label":"wshada","kind":24,"detail":"wsh[ada]","documentation":"write to ShaDa file","sortText":"00004","insertText":"wshada","insertTextFormat":1},{"label":"wundo","kind":24,"detail":"wu[ndo]","documentation":"write undo information to a file","sortText":"00004","insertText":"wundo","insertTextFormat":1},{"label":"xit","kind":24,"detail":"x[it]","documentation":"write if buffer changed and quit window or Vim","sortText":"00004","insertText":"xit","insertTextFormat":1},{"label":"xall","kind":24,"detail":"xa[ll]","documentation":"same as \\":wqall\\"","sortText":"00004","insertText":"xall","insertTextFormat":1},{"label":"xmapclear","kind":24,"detail":"xmapc[lear]","documentation":"remove all mappings for Visual mode","sortText":"00004","insertText":"xmapclear","insertTextFormat":1},{"label":"xmap","kind":24,"detail":"xm[ap]","documentation":"like \\":map\\" but for Visual mode","sortText":"00004","insertText":"xmap","insertTextFormat":1},{"label":"xmenu","kind":24,"detail":"xme[nu]","documentation":"add menu for Visual mode","sortText":"00004","insertText":"xmenu","insertTextFormat":1},{"label":"xnoremap","kind":24,"detail":"xn[oremap]","documentation":"like \\":noremap\\" but for Visual mode","sortText":"00004","insertText":"xnoremap","insertTextFormat":1},{"label":"xnoremenu","kind":24,"detail":"xnoreme[nu]","documentation":"like \\":noremenu\\" but for Visual mode","sortText":"00004","insertText":"xnoremenu","insertTextFormat":1},{"label":"xunmap","kind":24,"detail":"xu[nmap]","documentation":"like \\":unmap\\" but for Visual mode","sortText":"00004","insertText":"xunmap","insertTextFormat":1},{"label":"xunmenu","kind":24,"detail":"xunme[nu]","documentation":"remove menu for Visual mode","sortText":"00004","insertText":"xunmenu","insertTextFormat":1},{"label":"yank","kind":24,"detail":"y[ank]","documentation":"yank lines into a register","sortText":"00004","insertText":"yank","insertTextFormat":1},{"label":"z","kind":24,"detail":"z","documentation":"print some lines","sortText":"00004","insertText":"z","insertTextFormat":1},{"label":"~","kind":24,"detail":"~","documentation":"repeat last \\":substitute\\"","sortText":"00004","insertText":"~","insertTextFormat":1},{"label":"Print","kind":24,"detail":"P[rint]","documentation":"print lines","sortText":"00004","insertText":"Print","insertTextFormat":1},{"label":"X","kind":24,"detail":"X","documentation":"ask for encryption key","sortText":"00004","insertText":"X","insertTextFormat":1},{"label":"cafter","kind":24,"detail":"caf[ter]","documentation":"go to error after current cursor","sortText":"00004","insertText":"cafter","insertTextFormat":1},{"label":"cbefore","kind":24,"detail":"cbef[ore]","documentation":"go to error before current cursor","sortText":"00004","insertText":"cbefore","insertTextFormat":1},{"label":"fixdel","kind":24,"detail":"fix[del]","documentation":"set key code of <Del>","sortText":"00004","insertText":"fixdel","insertTextFormat":1},{"label":"helpfind","kind":24,"detail":"helpf[ind]","documentation":"dialog to open a help window","sortText":"00004","insertText":"helpfind","insertTextFormat":1},{"label":"lafter","kind":24,"detail":"laf[ter]","documentation":"go to location after current cursor","sortText":"00004","insertText":"lafter","insertTextFormat":1},{"label":"lbefore","kind":24,"detail":"lbef[ore]","documentation":"go to location before current cursor","sortText":"00004","insertText":"lbefore","insertTextFormat":1},{"label":"mzscheme","kind":24,"detail":"mz[scheme]","documentation":"execute MzScheme command","sortText":"00004","insertText":"mzscheme","insertTextFormat":1},{"label":"mzfile","kind":24,"detail":"mzf[ile]","documentation":"execute MzScheme script file","sortText":"00004","insertText":"mzfile","insertTextFormat":1},{"label":"nbclose","kind":24,"detail":"nbc[lose]","documentation":"close the current Netbeans session","sortText":"00004","insertText":"nbclose","insertTextFormat":1},{"label":"nbkey","kind":24,"detail":"nb[key]","documentation":"pass a key to Netbeans","sortText":"00004","insertText":"nbkey","insertTextFormat":1},{"label":"nbstart","kind":24,"detail":"nbs[art]","documentation":"start a new Netbeans session","sortText":"00004","insertText":"nbstart","insertTextFormat":1},{"label":"open","kind":24,"detail":"o[pen]","documentation":"start open mode (not implemented)","sortText":"00004","insertText":"open","insertTextFormat":1},{"label":"perl","kind":24,"detail":"pe[rl]","documentation":"execute Perl command","sortText":"00004","insertText":"perl","insertTextFormat":1},{"label":"perldo","kind":24,"detail":"perld[o]","documentation":"execute Perl command for each line","sortText":"00004","insertText":"perldo","insertTextFormat":1},{"label":"rviminfo","kind":24,"detail":"rv[iminfo]","documentation":"read from viminfo file","sortText":"00004","insertText":"rviminfo","insertTextFormat":1},{"label":"shell","kind":24,"detail":"sh[ell]","documentation":"escape to a shell","sortText":"00004","insertText":"shell","insertTextFormat":1},{"label":"simalt","kind":24,"detail":"sim[alt]","documentation":"Win32 GUI: simulate Windows ALT key","sortText":"00004","insertText":"simalt","insertTextFormat":1},{"label":"smile","kind":24,"detail":"smi[le]","documentation":"make the user happy","sortText":"00004","insertText":"smile","insertTextFormat":1},{"label":"tcl","kind":24,"detail":"tc[l]","documentation":"execute Tcl command","sortText":"00004","insertText":"tcl","insertTextFormat":1},{"label":"tcldo","kind":24,"detail":"tcld[o]","documentation":"execute Tcl command for each line","sortText":"00004","insertText":"tcldo","insertTextFormat":1},{"label":"tclfile","kind":24,"detail":"tclf[ile]","documentation":"execute Tcl script file","sortText":"00004","insertText":"tclfile","insertTextFormat":1},{"label":"tearoff","kind":24,"detail":"te[aroff]","documentation":"tear-off a menu","sortText":"00004","insertText":"tearoff","insertTextFormat":1},{"label":"tlmenu","kind":24,"detail":"tlm[enu]","documentation":"add menu for Terminal-Job mode","sortText":"00004","insertText":"tlmenu","insertTextFormat":1},{"label":"tlnoremenu","kind":24,"detail":"tln[oremenu]","documentation":"like \\":noremenu\\" but for Terminal-Job mode","sortText":"00004","insertText":"tlnoremenu","insertTextFormat":1},{"label":"tlunmenu","kind":24,"detail":"tlu[nmenu]","documentation":"remove menu for Terminal-Job mode","sortText":"00004","insertText":"tlunmenu","insertTextFormat":1},{"label":"wviminfo","kind":24,"detail":"wv[iminfo]","documentation":"write to viminfo file","sortText":"00004","insertText":"wviminfo","insertTextFormat":1},{"label":"xrestore","kind":24,"detail":"xr[estore]","documentation":"restores the X server connection","sortText":"00004","insertText":"xrestore","insertTextFormat":1}],"functions":[{"label":"abs","kind":3,"detail":"Float","sortText":"00004","insertText":"abs(${1:expr})${0}","insertTextFormat":2},{"label":"acos","kind":3,"detail":"Float","sortText":"00004","insertText":"acos(${1:expr})${0}","insertTextFormat":2},{"label":"add","kind":3,"detail":"List","sortText":"00004","insertText":"add(${1:list}, ${2:item})${0}","insertTextFormat":2},{"label":"and","kind":3,"detail":"Number","sortText":"00004","insertText":"and(${1:expr}, ${2:expr})${0}","insertTextFormat":2},{"label":"api_info","kind":3,"detail":"Dict","sortText":"00004","insertText":"api_info(${0})","insertTextFormat":2},{"label":"append","kind":3,"detail":"Number","sortText":"00004","insertText":"append(${1:lnum}, ${2:string})${0}","insertTextFormat":2},{"label":"append","kind":3,"detail":"Number","sortText":"00004","insertText":"append(${1:lnum}, ${2:list})${0}","insertTextFormat":2},{"label":"argc","kind":3,"detail":"Number","sortText":"00004","insertText":"argc(${1})${0}","insertTextFormat":2},{"label":"argidx","kind":3,"detail":"Number","sortText":"00004","insertText":"argidx(${0})","insertTextFormat":2},{"label":"arglistid","kind":3,"detail":"Number","sortText":"00004","insertText":"arglistid(${1})${0}","insertTextFormat":2},{"label":"argv","kind":3,"detail":"String","sortText":"00004","insertText":"argv(${1:nr})${0}","insertTextFormat":2},{"label":"argv","kind":3,"detail":"List","sortText":"00004","insertText":"argv(${1})${0}","insertTextFormat":2},{"label":"assert_beeps","kind":3,"detail":"Number","sortText":"00004","insertText":"assert_beeps(${1:cmd})${0}","insertTextFormat":2},{"label":"assert_equal","kind":3,"detail":"Number","sortText":"00004","insertText":"assert_equal(${1:exp}, ${2:act})${0}","insertTextFormat":2},{"label":"assert_equalfile","kind":3,"detail":"Number","sortText":"00004","insertText":"assert_equalfile(${1:fname}-${2:one}, ${3:fname}-${4:two})${0}","insertTextFormat":2},{"label":"assert_exception","kind":3,"detail":"Number","sortText":"00004","insertText":"assert_exception(${1:error})${0}","insertTextFormat":2},{"label":"assert_fails","kind":3,"detail":"Number","sortText":"00004","insertText":"assert_fails(${1:cmd})${0}","insertTextFormat":2},{"label":"assert_false","kind":3,"detail":"Number","sortText":"00004","insertText":"assert_false(${1:actual})${0}","insertTextFormat":2},{"label":"assert_inrange","kind":3,"detail":"Number","sortText":"00004","insertText":"assert_inrange(${1:lower}, ${2:upper}, ${3:actual})${0}","insertTextFormat":2},{"label":"assert_match","kind":3,"detail":"Number","sortText":"00004","insertText":"assert_match(${1:pat}, ${2:text})${0}","insertTextFormat":2},{"label":"assert_notequal","kind":3,"detail":"Number","sortText":"00004","insertText":"assert_notequal(${1:exp}, ${2:act})${0}","insertTextFormat":2},{"label":"assert_notmatch","kind":3,"detail":"Number","sortText":"00004","insertText":"assert_notmatch(${1:pat}, ${2:text})${0}","insertTextFormat":2},{"label":"assert_report","kind":3,"detail":"Number","sortText":"00004","insertText":"assert_report(${1:msg})${0}","insertTextFormat":2},{"label":"assert_true","kind":3,"detail":"Number","sortText":"00004","insertText":"assert_true(${1:actual})${0}","insertTextFormat":2},{"label":"asin","kind":3,"detail":"Float","sortText":"00004","insertText":"asin(${1:expr})${0}","insertTextFormat":2},{"label":"atan","kind":3,"detail":"Float","sortText":"00004","insertText":"atan(${1:expr})${0}","insertTextFormat":2},{"label":"atan2","kind":3,"detail":"Float","sortText":"00004","insertText":"atan2(${1:expr}, ${2:expr})${0}","insertTextFormat":2},{"label":"browse","kind":3,"detail":"String","sortText":"00004","insertText":"browse(${1:save}, ${2:title}, ${3:initdir}, ${4:default})${0}","insertTextFormat":2},{"label":"browsedir","kind":3,"detail":"String","sortText":"00004","insertText":"browsedir(${1:title}, ${2:initdir})${0}","insertTextFormat":2},{"label":"bufadd","kind":3,"detail":"Number","sortText":"00004","insertText":"bufadd(${1:name})${0}","insertTextFormat":2},{"label":"bufexists","kind":3,"detail":"Number","sortText":"00004","insertText":"bufexists(${1:expr})${0}","insertTextFormat":2},{"label":"buflisted","kind":3,"detail":"Number","sortText":"00004","insertText":"buflisted(${1:expr})${0}","insertTextFormat":2},{"label":"bufload","kind":3,"detail":"Number","sortText":"00004","insertText":"bufload(${1:expr})${0}","insertTextFormat":2},{"label":"bufloaded","kind":3,"detail":"Number","sortText":"00004","insertText":"bufloaded(${1:expr})${0}","insertTextFormat":2},{"label":"bufname","kind":3,"detail":"String","sortText":"00004","insertText":"bufname(${1})${0}","insertTextFormat":2},{"label":"bufnr","kind":3,"detail":"Number","sortText":"00004","insertText":"bufnr(${1})${0}","insertTextFormat":2},{"label":"bufwinid","kind":3,"detail":"Number","sortText":"00004","insertText":"bufwinid(${1:expr})${0}","insertTextFormat":2},{"label":"bufwinnr","kind":3,"detail":"Number","sortText":"00004","insertText":"bufwinnr(${1:expr})${0}","insertTextFormat":2},{"label":"byte2line","kind":3,"detail":"Number","sortText":"00004","insertText":"byte2line(${1:byte})${0}","insertTextFormat":2},{"label":"byteidx","kind":3,"detail":"Number","sortText":"00004","insertText":"byteidx(${1:expr}, ${2:nr})${0}","insertTextFormat":2},{"label":"byteidxcomp","kind":3,"detail":"Number","sortText":"00004","insertText":"byteidxcomp(${1:expr}, ${2:nr})${0}","insertTextFormat":2},{"label":"call","kind":3,"detail":"any","sortText":"00004","insertText":"call(${1:func}, ${2:arglist})${0}","insertTextFormat":2},{"label":"ceil","kind":3,"detail":"Float","sortText":"00004","insertText":"ceil(${1:expr})${0}","insertTextFormat":2},{"label":"changenr","kind":3,"detail":"Number","sortText":"00004","insertText":"changenr(${0})","insertTextFormat":2},{"label":"chanclose","kind":3,"detail":"Number","sortText":"00004","insertText":"chanclose(${1:id})${0}","insertTextFormat":2},{"label":"chansend","kind":3,"detail":"Number","sortText":"00004","insertText":"chansend(${1:id}, ${2:data})${0}","insertTextFormat":2},{"label":"char2nr","kind":3,"detail":"Number","sortText":"00004","insertText":"char2nr(${1:expr})${0}","insertTextFormat":2},{"label":"cindent","kind":3,"detail":"Number","sortText":"00004","insertText":"cindent(${1:lnum})${0}","insertTextFormat":2},{"label":"clearmatches","kind":3,"detail":"none","sortText":"00004","insertText":"clearmatches(${0})","insertTextFormat":2},{"label":"col","kind":3,"detail":"Number","sortText":"00004","insertText":"col(${1:expr})${0}","insertTextFormat":2},{"label":"complete","kind":3,"detail":"none","sortText":"00004","insertText":"complete(${1:startcol}, ${2:matches})${0}","insertTextFormat":2},{"label":"complete_add","kind":3,"detail":"Number","sortText":"00004","insertText":"complete_add(${1:expr})${0}","insertTextFormat":2},{"label":"complete_check","kind":3,"detail":"Number","sortText":"00004","insertText":"complete_check(${0})","insertTextFormat":2},{"label":"complete_info","kind":3,"detail":"Dict","sortText":"00004","insertText":"complete_info(${1})${0}","insertTextFormat":2},{"label":"confirm","kind":3,"detail":"Number","sortText":"00004","insertText":"confirm(${1:msg})${0}","insertTextFormat":2},{"label":"copy","kind":3,"detail":"any","sortText":"00004","insertText":"copy(${1:expr})${0}","insertTextFormat":2},{"label":"cos","kind":3,"detail":"Float","sortText":"00004","insertText":"cos(${1:expr})${0}","insertTextFormat":2},{"label":"cosh","kind":3,"detail":"Float","sortText":"00004","insertText":"cosh(${1:expr})${0}","insertTextFormat":2},{"label":"count","kind":3,"detail":"Number","sortText":"00004","insertText":"count(${1:list}, ${2:expr})${0}","insertTextFormat":2},{"label":"cscope_connection","kind":3,"detail":"Number","sortText":"00004","insertText":"cscope_connection(${1})${0}","insertTextFormat":2},{"label":"ctxget","kind":3,"detail":"Dict","sortText":"00004","insertText":"ctxget(${1})${0}","insertTextFormat":2},{"label":"ctxpop","kind":3,"detail":"none","sortText":"00004","insertText":"ctxpop(${0})","insertTextFormat":2},{"label":"ctxpush","kind":3,"detail":"none","sortText":"00004","insertText":"ctxpush(${1})${0}","insertTextFormat":2},{"label":"ctxset","kind":3,"detail":"none","sortText":"00004","insertText":"ctxset(${1:context})${0}","insertTextFormat":2},{"label":"ctxsize","kind":3,"detail":"Number","sortText":"00004","insertText":"ctxsize(${0})","insertTextFormat":2},{"label":"cursor","kind":3,"detail":"Number","sortText":"00004","insertText":"cursor(${1:lnum}, ${2:col})${0}","insertTextFormat":2},{"label":"cursor","kind":3,"detail":"Number","sortText":"00004","insertText":"cursor(${1:list})${0}","insertTextFormat":2},{"label":"debugbreak","kind":3,"detail":"Number","sortText":"00004","insertText":"debugbreak(${1:pid})${0}","insertTextFormat":2},{"label":"deepcopy","kind":3,"detail":"any","sortText":"00004","insertText":"deepcopy(${1:expr})${0}","insertTextFormat":2},{"label":"delete","kind":3,"detail":"Number","sortText":"00004","insertText":"delete(${1:fname})${0}","insertTextFormat":2},{"label":"deletebufline","kind":3,"detail":"Number","sortText":"00004","insertText":"deletebufline(${1:expr}, ${2:first})${0}","insertTextFormat":2},{"label":"dictwatcheradd","kind":3,"detail":"Start","sortText":"00004","insertText":"dictwatcheradd(${1:dict}, ${2:pattern}, ${3:callback})${0}","insertTextFormat":2},{"label":"dictwatcherdel","kind":3,"detail":"Stop","sortText":"00004","insertText":"dictwatcherdel(${1:dict}, ${2:pattern}, ${3:callback})${0}","insertTextFormat":2},{"label":"did_filetype","kind":3,"detail":"Number","sortText":"00004","insertText":"did_filetype(${0})","insertTextFormat":2},{"label":"diff_filler","kind":3,"detail":"Number","sortText":"00004","insertText":"diff_filler(${1:lnum})${0}","insertTextFormat":2},{"label":"diff_hlID","kind":3,"detail":"Number","sortText":"00004","insertText":"diff_hlID(${1:lnum}, ${2:col})${0}","insertTextFormat":2},{"label":"empty","kind":3,"detail":"Number","sortText":"00004","insertText":"empty(${1:expr})${0}","insertTextFormat":2},{"label":"environ","kind":3,"detail":"Dict","sortText":"00004","insertText":"environ(${0})","insertTextFormat":2},{"label":"escape","kind":3,"detail":"String","sortText":"00004","insertText":"escape(${1:string}, ${2:chars})${0}","insertTextFormat":2},{"label":"eval","kind":3,"detail":"any","sortText":"00004","insertText":"eval(${1:string})${0}","insertTextFormat":2},{"label":"eventhandler","kind":3,"detail":"Number","sortText":"00004","insertText":"eventhandler(${0})","insertTextFormat":2},{"label":"executable","kind":3,"detail":"Number","sortText":"00004","insertText":"executable(${1:expr})${0}","insertTextFormat":2},{"label":"execute","kind":3,"detail":"String","sortText":"00004","insertText":"execute(${1:command})${0}","insertTextFormat":2},{"label":"exepath","kind":3,"detail":"String","sortText":"00004","insertText":"exepath(${1:expr})${0}","insertTextFormat":2},{"label":"exists","kind":3,"detail":"Number","sortText":"00004","insertText":"exists(${1:expr})${0}","insertTextFormat":2},{"label":"extend","kind":3,"detail":"List/Dict","sortText":"00004","insertText":"extend(${1:expr1}, ${2:expr2})${0}","insertTextFormat":2},{"label":"exp","kind":3,"detail":"Float","sortText":"00004","insertText":"exp(${1:expr})${0}","insertTextFormat":2},{"label":"expand","kind":3,"detail":"any","sortText":"00004","insertText":"expand(${1:expr})${0}","insertTextFormat":2},{"label":"expandcmd","kind":3,"detail":"String","sortText":"00004","insertText":"expandcmd(${1:expr})${0}","insertTextFormat":2},{"label":"feedkeys","kind":3,"detail":"Number","sortText":"00004","insertText":"feedkeys(${1:string})${0}","insertTextFormat":2},{"label":"filereadable","kind":3,"detail":"Number","sortText":"00004","insertText":"filereadable(${1:file})${0}","insertTextFormat":2},{"label":"filewritable","kind":3,"detail":"Number","sortText":"00004","insertText":"filewritable(${1:file})${0}","insertTextFormat":2},{"label":"filter","kind":3,"detail":"List/Dict","sortText":"00004","insertText":"filter(${1:expr1}, ${2:expr2})${0}","insertTextFormat":2},{"label":"finddir","kind":3,"detail":"String","sortText":"00004","insertText":"finddir(${1:name})${0}","insertTextFormat":2},{"label":"findfile","kind":3,"detail":"String","sortText":"00004","insertText":"findfile(${1:name})${0}","insertTextFormat":2},{"label":"float2nr","kind":3,"detail":"Number","sortText":"00004","insertText":"float2nr(${1:expr})${0}","insertTextFormat":2},{"label":"floor","kind":3,"detail":"Float","sortText":"00004","insertText":"floor(${1:expr})${0}","insertTextFormat":2},{"label":"fmod","kind":3,"detail":"Float","sortText":"00004","insertText":"fmod(${1:expr1}, ${2:expr2})${0}","insertTextFormat":2},{"label":"fnameescape","kind":3,"detail":"String","sortText":"00004","insertText":"fnameescape(${1:fname})${0}","insertTextFormat":2},{"label":"fnamemodify","kind":3,"detail":"String","sortText":"00004","insertText":"fnamemodify(${1:fname}, ${2:mods})${0}","insertTextFormat":2},{"label":"foldclosed","kind":3,"detail":"Number","sortText":"00004","insertText":"foldclosed(${1:lnum})${0}","insertTextFormat":2},{"label":"foldclosedend","kind":3,"detail":"Number","sortText":"00004","insertText":"foldclosedend(${1:lnum})${0}","insertTextFormat":2},{"label":"foldlevel","kind":3,"detail":"Number","sortText":"00004","insertText":"foldlevel(${1:lnum})${0}","insertTextFormat":2},{"label":"foldtext","kind":3,"detail":"String","sortText":"00004","insertText":"foldtext(${0})","insertTextFormat":2},{"label":"foldtextresult","kind":3,"detail":"String","sortText":"00004","insertText":"foldtextresult(${1:lnum})${0}","insertTextFormat":2},{"label":"foreground","kind":3,"detail":"Number","sortText":"00004","insertText":"foreground(${0})","insertTextFormat":2},{"label":"funcref","kind":3,"detail":"Funcref","sortText":"00004","insertText":"funcref(${1:name})${0}","insertTextFormat":2},{"label":"function","kind":3,"detail":"Funcref","sortText":"00004","insertText":"function(${1:name})${0}","insertTextFormat":2},{"label":"garbagecollect","kind":3,"detail":"none","sortText":"00004","insertText":"garbagecollect(${1})${0}","insertTextFormat":2},{"label":"get","kind":3,"detail":"any","sortText":"00004","insertText":"get(${1:list}, ${2:idx})${0}","insertTextFormat":2},{"label":"get","kind":3,"detail":"any","sortText":"00004","insertText":"get(${1:dict}, ${2:key})${0}","insertTextFormat":2},{"label":"get","kind":3,"detail":"any","sortText":"00004","insertText":"get(${1:func}, ${2:what})${0}","insertTextFormat":2},{"label":"getbufinfo","kind":3,"detail":"List","sortText":"00004","insertText":"getbufinfo(${1})${0}","insertTextFormat":2},{"label":"getbufline","kind":3,"detail":"List","sortText":"00004","insertText":"getbufline(${1:expr}, ${2:lnum})${0}","insertTextFormat":2},{"label":"getbufvar","kind":3,"detail":"any","sortText":"00004","insertText":"getbufvar(${1:expr}, ${2:varname})${0}","insertTextFormat":2},{"label":"getchangelist","kind":3,"detail":"List","sortText":"00004","insertText":"getchangelist(${1:expr})${0}","insertTextFormat":2},{"label":"getchar","kind":3,"detail":"Number","sortText":"00004","insertText":"getchar(${1})${0}","insertTextFormat":2},{"label":"getcharmod","kind":3,"detail":"Number","sortText":"00004","insertText":"getcharmod(${0})","insertTextFormat":2},{"label":"getcharsearch","kind":3,"detail":"Dict","sortText":"00004","insertText":"getcharsearch(${0})","insertTextFormat":2},{"label":"getcmdline","kind":3,"detail":"String","sortText":"00004","insertText":"getcmdline(${0})","insertTextFormat":2},{"label":"getcmdpos","kind":3,"detail":"Number","sortText":"00004","insertText":"getcmdpos(${0})","insertTextFormat":2},{"label":"getcmdtype","kind":3,"detail":"String","sortText":"00004","insertText":"getcmdtype(${0})","insertTextFormat":2},{"label":"getcmdwintype","kind":3,"detail":"String","sortText":"00004","insertText":"getcmdwintype(${0})","insertTextFormat":2},{"label":"getcompletion","kind":3,"detail":"List","sortText":"00004","insertText":"getcompletion(${1:pat}, ${2:type})${0}","insertTextFormat":2},{"label":"getcurpos","kind":3,"detail":"List","sortText":"00004","insertText":"getcurpos(${0})","insertTextFormat":2},{"label":"getcwd","kind":3,"detail":"String","sortText":"00004","insertText":"getcwd(${1})${0}","insertTextFormat":2},{"label":"getenv","kind":3,"detail":"String","sortText":"00004","insertText":"getenv(${1:name})${0}","insertTextFormat":2},{"label":"getfontname","kind":3,"detail":"String","sortText":"00004","insertText":"getfontname(${1})${0}","insertTextFormat":2},{"label":"getfperm","kind":3,"detail":"String","sortText":"00004","insertText":"getfperm(${1:fname})${0}","insertTextFormat":2},{"label":"getfsize","kind":3,"detail":"Number","sortText":"00004","insertText":"getfsize(${1:fname})${0}","insertTextFormat":2},{"label":"getftime","kind":3,"detail":"Number","sortText":"00004","insertText":"getftime(${1:fname})${0}","insertTextFormat":2},{"label":"getftype","kind":3,"detail":"String","sortText":"00004","insertText":"getftype(${1:fname})${0}","insertTextFormat":2},{"label":"getjumplist","kind":3,"detail":"List","sortText":"00004","insertText":"getjumplist(${1})${0}","insertTextFormat":2},{"label":"getline","kind":3,"detail":"String","sortText":"00004","insertText":"getline(${1:lnum})${0}","insertTextFormat":2},{"label":"getline","kind":3,"detail":"List","sortText":"00004","insertText":"getline(${1:lnum}, ${2:end})${0}","insertTextFormat":2},{"label":"getloclist","kind":3,"detail":"List","sortText":"00004","insertText":"getloclist(${1:nr})${0}","insertTextFormat":2},{"label":"getmatches","kind":3,"detail":"List","sortText":"00004","insertText":"getmatches(${0})","insertTextFormat":2},{"label":"getpid","kind":3,"detail":"Number","sortText":"00004","insertText":"getpid(${0})","insertTextFormat":2},{"label":"getpos","kind":3,"detail":"List","sortText":"00004","insertText":"getpos(${1:expr})${0}","insertTextFormat":2},{"label":"getqflist","kind":3,"detail":"List","sortText":"00004","insertText":"getqflist(${1})${0}","insertTextFormat":2},{"label":"getreg","kind":3,"detail":"String","sortText":"00004","insertText":"getreg(${1})${0}","insertTextFormat":2},{"label":"getregtype","kind":3,"detail":"String","sortText":"00004","insertText":"getregtype(${1})${0}","insertTextFormat":2},{"label":"gettabinfo","kind":3,"detail":"List","sortText":"00004","insertText":"gettabinfo(${1})${0}","insertTextFormat":2},{"label":"gettabvar","kind":3,"detail":"any","sortText":"00004","insertText":"gettabvar(${1:nr}, ${2:varname})${0}","insertTextFormat":2},{"label":"gettabwinvar","kind":3,"detail":"any","sortText":"00004","insertText":"gettabwinvar(${1:tabnr}, ${2:winnr}, ${3:name})${0}","insertTextFormat":2},{"label":"gettagstack","kind":3,"detail":"Dict","sortText":"00004","insertText":"gettagstack(${1})${0}","insertTextFormat":2},{"label":"getwininfo","kind":3,"detail":"List","sortText":"00004","insertText":"getwininfo(${1})${0}","insertTextFormat":2},{"label":"getwinpos","kind":3,"detail":"List","sortText":"00004","insertText":"getwinpos(${1})${0}","insertTextFormat":2},{"label":"getwinposx","kind":3,"detail":"Number","sortText":"00004","insertText":"getwinposx(${0})","insertTextFormat":2},{"label":"getwinposy","kind":3,"detail":"Number","sortText":"00004","insertText":"getwinposy(${0})","insertTextFormat":2},{"label":"getwinvar","kind":3,"detail":"any","sortText":"00004","insertText":"getwinvar(${1:nr}, ${2:varname})${0}","insertTextFormat":2},{"label":"glob","kind":3,"detail":"any","sortText":"00004","insertText":"glob(${1:expr})${0}","insertTextFormat":2},{"label":"glob2regpat","kind":3,"detail":"String","sortText":"00004","insertText":"glob2regpat(${1:expr})${0}","insertTextFormat":2},{"label":"globpath","kind":3,"detail":"String","sortText":"00004","insertText":"globpath(${1:path}, ${2:expr})${0}","insertTextFormat":2},{"label":"has","kind":3,"detail":"Number","sortText":"00004","insertText":"has(${1:feature})${0}","insertTextFormat":2},{"label":"has_key","kind":3,"detail":"Number","sortText":"00004","insertText":"has_key(${1:dict}, ${2:key})${0}","insertTextFormat":2},{"label":"haslocaldir","kind":3,"detail":"Number","sortText":"00004","insertText":"haslocaldir(${1})${0}","insertTextFormat":2},{"label":"hasmapto","kind":3,"detail":"Number","sortText":"00004","insertText":"hasmapto(${1:what})${0}","insertTextFormat":2},{"label":"histadd","kind":3,"detail":"String","sortText":"00004","insertText":"histadd(${1:history}, ${2:item})${0}","insertTextFormat":2},{"label":"histdel","kind":3,"detail":"String","sortText":"00004","insertText":"histdel(${1:history})${0}","insertTextFormat":2},{"label":"histget","kind":3,"detail":"String","sortText":"00004","insertText":"histget(${1:history})${0}","insertTextFormat":2},{"label":"histnr","kind":3,"detail":"Number","sortText":"00004","insertText":"histnr(${1:history})${0}","insertTextFormat":2},{"label":"hlexists","kind":3,"detail":"Number","sortText":"00004","insertText":"hlexists(${1:name})${0}","insertTextFormat":2},{"label":"hlID","kind":3,"detail":"Number","sortText":"00004","insertText":"hlID(${1:name})${0}","insertTextFormat":2},{"label":"hostname","kind":3,"detail":"String","sortText":"00004","insertText":"hostname(${0})","insertTextFormat":2},{"label":"iconv","kind":3,"detail":"String","sortText":"00004","insertText":"iconv(${1:expr}, ${2:from}, ${3:to})${0}","insertTextFormat":2},{"label":"indent","kind":3,"detail":"Number","sortText":"00004","insertText":"indent(${1:lnum})${0}","insertTextFormat":2},{"label":"index","kind":3,"detail":"Number","sortText":"00004","insertText":"index(${1:list}, ${2:expr})${0}","insertTextFormat":2},{"label":"input","kind":3,"detail":"String","sortText":"00004","insertText":"input(${1:prompt})${0}","insertTextFormat":2},{"label":"inputlist","kind":3,"detail":"Number","sortText":"00004","insertText":"inputlist(${1:textlist})${0}","insertTextFormat":2},{"label":"inputrestore","kind":3,"detail":"Number","sortText":"00004","insertText":"inputrestore(${0})","insertTextFormat":2},{"label":"inputsave","kind":3,"detail":"Number","sortText":"00004","insertText":"inputsave(${0})","insertTextFormat":2},{"label":"inputsecret","kind":3,"detail":"String","sortText":"00004","insertText":"inputsecret(${1:prompt})${0}","insertTextFormat":2},{"label":"insert","kind":3,"detail":"List","sortText":"00004","insertText":"insert(${1:list}, ${2:item})${0}","insertTextFormat":2},{"label":"invert","kind":3,"detail":"Number","sortText":"00004","insertText":"invert(${1:expr})${0}","insertTextFormat":2},{"label":"isdirectory","kind":3,"detail":"Number","sortText":"00004","insertText":"isdirectory(${1:directory})${0}","insertTextFormat":2},{"label":"isinf","kind":3,"detail":"Number","sortText":"00004","insertText":"isinf(${1:expr})${0}","insertTextFormat":2},{"label":"islocked","kind":3,"detail":"Number","sortText":"00004","insertText":"islocked(${1:expr})${0}","insertTextFormat":2},{"label":"isnan","kind":3,"detail":"Number","sortText":"00004","insertText":"isnan(${1:expr})${0}","insertTextFormat":2},{"label":"id","kind":3,"detail":"String","sortText":"00004","insertText":"id(${1:expr})${0}","insertTextFormat":2},{"label":"items","kind":3,"detail":"List","sortText":"00004","insertText":"items(${1:dict})${0}","insertTextFormat":2},{"label":"jobpid","kind":3,"detail":"Number","sortText":"00004","insertText":"jobpid(${1:id})${0}","insertTextFormat":2},{"label":"jobresize","kind":3,"detail":"Number","sortText":"00004","insertText":"jobresize(${1:id}, ${2:width}, ${3:height})${0}","insertTextFormat":2},{"label":"jobstart","kind":3,"detail":"Number","sortText":"00004","insertText":"jobstart(${1:cmd})${0}","insertTextFormat":2},{"label":"jobstop","kind":3,"detail":"Number","sortText":"00004","insertText":"jobstop(${1:id})${0}","insertTextFormat":2},{"label":"jobwait","kind":3,"detail":"Number","sortText":"00004","insertText":"jobwait(${1:ids})${0}","insertTextFormat":2},{"label":"join","kind":3,"detail":"String","sortText":"00004","insertText":"join(${1:list})${0}","insertTextFormat":2},{"label":"json_decode","kind":3,"detail":"any","sortText":"00004","insertText":"json_decode(${1:expr})${0}","insertTextFormat":2},{"label":"json_encode","kind":3,"detail":"String","sortText":"00004","insertText":"json_encode(${1:expr})${0}","insertTextFormat":2},{"label":"keys","kind":3,"detail":"List","sortText":"00004","insertText":"keys(${1:dict})${0}","insertTextFormat":2},{"label":"len","kind":3,"detail":"Number","sortText":"00004","insertText":"len(${1:expr})${0}","insertTextFormat":2},{"label":"libcall","kind":3,"detail":"String","sortText":"00004","insertText":"libcall(${1:lib}, ${2:func}, ${3:arg})${0}","insertTextFormat":2},{"label":"libcallnr","kind":3,"detail":"Number","sortText":"00004","insertText":"libcallnr(${1:lib}, ${2:func}, ${3:arg})${0}","insertTextFormat":2},{"label":"line","kind":3,"detail":"Number","sortText":"00004","insertText":"line(${1:expr})${0}","insertTextFormat":2},{"label":"line2byte","kind":3,"detail":"Number","sortText":"00004","insertText":"line2byte(${1:lnum})${0}","insertTextFormat":2},{"label":"lispindent","kind":3,"detail":"Number","sortText":"00004","insertText":"lispindent(${1:lnum})${0}","insertTextFormat":2},{"label":"list2str","kind":3,"detail":"String","sortText":"00004","insertText":"list2str(${1:list})${0}","insertTextFormat":2},{"label":"localtime","kind":3,"detail":"Number","sortText":"00004","insertText":"localtime(${0})","insertTextFormat":2},{"label":"log","kind":3,"detail":"Float","sortText":"00004","insertText":"log(${1:expr})${0}","insertTextFormat":2},{"label":"log10","kind":3,"detail":"Float","sortText":"00004","insertText":"log10(${1:expr})${0}","insertTextFormat":2},{"label":"luaeval","kind":3,"detail":"any","sortText":"00004","insertText":"luaeval(${1:expr})${0}","insertTextFormat":2},{"label":"map","kind":3,"detail":"List/Dict","sortText":"00004","insertText":"map(${1:expr1}, ${2:expr2})${0}","insertTextFormat":2},{"label":"maparg","kind":3,"detail":"String","sortText":"00004","insertText":"maparg(${1:name})${0}","insertTextFormat":2},{"label":"mapcheck","kind":3,"detail":"String","sortText":"00004","insertText":"mapcheck(${1:name})${0}","insertTextFormat":2},{"label":"match","kind":3,"detail":"Number","sortText":"00004","insertText":"match(${1:expr}, ${2:pat})${0}","insertTextFormat":2},{"label":"matchadd","kind":3,"detail":"Number","sortText":"00004","insertText":"matchadd(${1:group}, ${2:pattern})${0}","insertTextFormat":2},{"label":"matchaddpos","kind":3,"detail":"Number","sortText":"00004","insertText":"matchaddpos(${1:group}, ${2:list})${0}","insertTextFormat":2},{"label":"matcharg","kind":3,"detail":"List","sortText":"00004","insertText":"matcharg(${1:nr})${0}","insertTextFormat":2},{"label":"matchdelete","kind":3,"detail":"Number","sortText":"00004","insertText":"matchdelete(${1:id})${0}","insertTextFormat":2},{"label":"matchend","kind":3,"detail":"Number","sortText":"00004","insertText":"matchend(${1:expr}, ${2:pat})${0}","insertTextFormat":2},{"label":"matchlist","kind":3,"detail":"List","sortText":"00004","insertText":"matchlist(${1:expr}, ${2:pat})${0}","insertTextFormat":2},{"label":"matchstr","kind":3,"detail":"String","sortText":"00004","insertText":"matchstr(${1:expr}, ${2:pat})${0}","insertTextFormat":2},{"label":"matchstrpos","kind":3,"detail":"List","sortText":"00004","insertText":"matchstrpos(${1:expr}, ${2:pat})${0}","insertTextFormat":2},{"label":"max","kind":3,"detail":"Number","sortText":"00004","insertText":"max(${1:expr})${0}","insertTextFormat":2},{"label":"min","kind":3,"detail":"Number","sortText":"00004","insertText":"min(${1:expr})${0}","insertTextFormat":2},{"label":"mkdir","kind":3,"detail":"Number","sortText":"00004","insertText":"mkdir(${1:name})${0}","insertTextFormat":2},{"label":"mode","kind":3,"detail":"String","sortText":"00004","insertText":"mode(${1})${0}","insertTextFormat":2},{"label":"msgpackdump","kind":3,"detail":"List","sortText":"00004","insertText":"msgpackdump(${1:list})${0}","insertTextFormat":2},{"label":"msgpackparse","kind":3,"detail":"List","sortText":"00004","insertText":"msgpackparse(${1:list})${0}","insertTextFormat":2},{"label":"nextnonblank","kind":3,"detail":"Number","sortText":"00004","insertText":"nextnonblank(${1:lnum})${0}","insertTextFormat":2},{"label":"nr2char","kind":3,"detail":"String","sortText":"00004","insertText":"nr2char(${1:expr})${0}","insertTextFormat":2},{"label":"or","kind":3,"detail":"Number","sortText":"00004","insertText":"or(${1:expr}, ${2:expr})${0}","insertTextFormat":2},{"label":"pathshorten","kind":3,"detail":"String","sortText":"00004","insertText":"pathshorten(${1:expr})${0}","insertTextFormat":2},{"label":"pow","kind":3,"detail":"Float","sortText":"00004","insertText":"pow(${1:x}, ${2:y})${0}","insertTextFormat":2},{"label":"prevnonblank","kind":3,"detail":"Number","sortText":"00004","insertText":"prevnonblank(${1:lnum})${0}","insertTextFormat":2},{"label":"printf","kind":3,"detail":"String","sortText":"00004","insertText":"printf(${1:fmt}, ${2:expr1}...)${0}","insertTextFormat":2},{"label":"prompt_addtext","kind":3,"detail":"none","sortText":"00004","insertText":"prompt_addtext(${1:buf}, ${2:expr})${0}","insertTextFormat":2},{"label":"prompt_setcallback","kind":3,"detail":"none","sortText":"00004","insertText":"prompt_setcallback(${1:buf}, ${2:expr})${0}","insertTextFormat":2},{"label":"prompt_setinterrupt","kind":3,"detail":"none","sortText":"00004","insertText":"prompt_setinterrupt(${1:buf}, ${2:text})${0}","insertTextFormat":2},{"label":"prompt_setprompt","kind":3,"detail":"none","sortText":"00004","insertText":"prompt_setprompt(${1:buf}, ${2:text})${0}","insertTextFormat":2},{"label":"pum_getpos","kind":3,"detail":"Dict","sortText":"00004","insertText":"pum_getpos(${0})","insertTextFormat":2},{"label":"pumvisible","kind":3,"detail":"Number","sortText":"00004","insertText":"pumvisible(${0})","insertTextFormat":2},{"label":"pyeval","kind":3,"detail":"any","sortText":"00004","insertText":"pyeval(${1:expr})${0}","insertTextFormat":2},{"label":"py3eval","kind":3,"detail":"any","sortText":"00004","insertText":"py3eval(${1:expr})${0}","insertTextFormat":2},{"label":"pyxeval","kind":3,"detail":"any","sortText":"00004","insertText":"pyxeval(${1:expr})${0}","insertTextFormat":2},{"label":"range","kind":3,"detail":"List","sortText":"00004","insertText":"range(${1:expr})${0}","insertTextFormat":2},{"label":"readdir","kind":3,"detail":"List","sortText":"00004","insertText":"readdir(${1:dir})${0}","insertTextFormat":2},{"label":"readfile","kind":3,"detail":"List","sortText":"00004","insertText":"readfile(${1:fname})${0}","insertTextFormat":2},{"label":"reg_executing","kind":3,"detail":"String","sortText":"00004","insertText":"reg_executing(${0})","insertTextFormat":2},{"label":"reg_recording","kind":3,"detail":"String","sortText":"00004","insertText":"reg_recording(${0})","insertTextFormat":2},{"label":"reltime","kind":3,"detail":"List","sortText":"00004","insertText":"reltime(${1})${0}","insertTextFormat":2},{"label":"reltimefloat","kind":3,"detail":"Float","sortText":"00004","insertText":"reltimefloat(${1:time})${0}","insertTextFormat":2},{"label":"reltimestr","kind":3,"detail":"String","sortText":"00004","insertText":"reltimestr(${1:time})${0}","insertTextFormat":2},{"label":"remote_expr","kind":3,"detail":"String","sortText":"00004","insertText":"remote_expr(${1:server}, ${2:string})${0}","insertTextFormat":2},{"label":"remote_foreground","kind":3,"detail":"Number","sortText":"00004","insertText":"remote_foreground(${1:server})${0}","insertTextFormat":2},{"label":"remote_peek","kind":3,"detail":"Number","sortText":"00004","insertText":"remote_peek(${1:serverid})${0}","insertTextFormat":2},{"label":"remote_read","kind":3,"detail":"String","sortText":"00004","insertText":"remote_read(${1:serverid})${0}","insertTextFormat":2},{"label":"remote_send","kind":3,"detail":"String","sortText":"00004","insertText":"remote_send(${1:server}, ${2:string})${0}","insertTextFormat":2},{"label":"remote_startserver","kind":3,"detail":"none","sortText":"00004","insertText":"remote_startserver(${1:name})${0}","insertTextFormat":2},{"label":"remove","kind":3,"detail":"any","sortText":"00004","insertText":"remove(${1:list}, ${2:idx})${0}","insertTextFormat":2},{"label":"remove","kind":3,"detail":"any","sortText":"00004","insertText":"remove(${1:dict}, ${2:key})${0}","insertTextFormat":2},{"label":"rename","kind":3,"detail":"Number","sortText":"00004","insertText":"rename(${1:from}, ${2:to})${0}","insertTextFormat":2},{"label":"repeat","kind":3,"detail":"String","sortText":"00004","insertText":"repeat(${1:expr}, ${2:count})${0}","insertTextFormat":2},{"label":"resolve","kind":3,"detail":"String","sortText":"00004","insertText":"resolve(${1:filename})${0}","insertTextFormat":2},{"label":"reverse","kind":3,"detail":"List","sortText":"00004","insertText":"reverse(${1:list})${0}","insertTextFormat":2},{"label":"round","kind":3,"detail":"Float","sortText":"00004","insertText":"round(${1:expr})${0}","insertTextFormat":2},{"label":"rpcnotify","kind":3,"detail":"Sends","sortText":"00004","insertText":"rpcnotify(${1:channel}, ${2:event})${0}","insertTextFormat":2},{"label":"rpcrequest","kind":3,"detail":"Sends","sortText":"00004","insertText":"rpcrequest(${1:channel}, ${2:method})${0}","insertTextFormat":2},{"label":"screenattr","kind":3,"detail":"Number","sortText":"00004","insertText":"screenattr(${1:row}, ${2:col})${0}","insertTextFormat":2},{"label":"screenchar","kind":3,"detail":"Number","sortText":"00004","insertText":"screenchar(${1:row}, ${2:col})${0}","insertTextFormat":2},{"label":"screencol","kind":3,"detail":"Number","sortText":"00004","insertText":"screencol(${0})","insertTextFormat":2},{"label":"screenpos","kind":3,"detail":"Dict","sortText":"00004","insertText":"screenpos(${1:winid}, ${2:lnum}, ${3:col})${0}","insertTextFormat":2},{"label":"screenrow","kind":3,"detail":"Number","sortText":"00004","insertText":"screenrow(${0})","insertTextFormat":2},{"label":"search","kind":3,"detail":"Number","sortText":"00004","insertText":"search(${1:pattern})${0}","insertTextFormat":2},{"label":"searchdecl","kind":3,"detail":"Number","sortText":"00004","insertText":"searchdecl(${1:name})${0}","insertTextFormat":2},{"label":"searchpair","kind":3,"detail":"Number","sortText":"00004","insertText":"searchpair(${1:start}, ${2:middle}, ${3:end})${0}","insertTextFormat":2},{"label":"searchpairpos","kind":3,"detail":"List","sortText":"00004","insertText":"searchpairpos(${1:start}, ${2:middle}, ${3:end})${0}","insertTextFormat":2},{"label":"searchpos","kind":3,"detail":"List","sortText":"00004","insertText":"searchpos(${1:pattern})${0}","insertTextFormat":2},{"label":"server2client","kind":3,"detail":"Number","sortText":"00004","insertText":"server2client(${1:clientid}, ${2:string})${0}","insertTextFormat":2},{"label":"serverlist","kind":3,"detail":"String","sortText":"00004","insertText":"serverlist(${0})","insertTextFormat":2},{"label":"setbufline","kind":3,"detail":"Number","sortText":"00004","insertText":"setbufline(${1:expr}, ${2:lnum}, ${3:line})${0}","insertTextFormat":2},{"label":"setbufvar","kind":3,"detail":"set","sortText":"00004","insertText":"setbufvar(${1:expr}, ${2:varname}, ${3:val})${0}","insertTextFormat":2},{"label":"setcharsearch","kind":3,"detail":"Dict","sortText":"00004","insertText":"setcharsearch(${1:dict})${0}","insertTextFormat":2},{"label":"setcmdpos","kind":3,"detail":"Number","sortText":"00004","insertText":"setcmdpos(${1:pos})${0}","insertTextFormat":2},{"label":"setenv","kind":3,"detail":"none","sortText":"00004","insertText":"setenv(${1:name}, ${2:val})${0}","insertTextFormat":2},{"label":"setline","kind":3,"detail":"Number","sortText":"00004","insertText":"setline(${1:lnum}, ${2:line})${0}","insertTextFormat":2},{"label":"setloclist","kind":3,"detail":"Number","sortText":"00004","insertText":"setloclist(${1:nr}, ${2:list})${0}","insertTextFormat":2},{"label":"setmatches","kind":3,"detail":"Number","sortText":"00004","insertText":"setmatches(${1:list})${0}","insertTextFormat":2},{"label":"setpos","kind":3,"detail":"Number","sortText":"00004","insertText":"setpos(${1:expr}, ${2:list})${0}","insertTextFormat":2},{"label":"setreg","kind":3,"detail":"Number","sortText":"00004","insertText":"setreg(${1:n}, ${2:v})${0}","insertTextFormat":2},{"label":"settabvar","kind":3,"detail":"set","sortText":"00004","insertText":"settabvar(${1:nr}, ${2:varname}, ${3:val})${0}","insertTextFormat":2},{"label":"settabwinvar","kind":3,"detail":"set","sortText":"00004","insertText":"settabwinvar(${1:tabnr}, ${2:winnr}, ${3:varname}, ${4:val})${0}","insertTextFormat":2},{"label":"settagstack","kind":3,"detail":"Number","sortText":"00004","insertText":"settagstack(${1:nr}, ${2:dict})${0}","insertTextFormat":2},{"label":"setwinvar","kind":3,"detail":"set","sortText":"00004","insertText":"setwinvar(${1:nr}, ${2:varname}, ${3:val})${0}","insertTextFormat":2},{"label":"sha256","kind":3,"detail":"String","sortText":"00004","insertText":"sha256(${1:string})${0}","insertTextFormat":2},{"label":"shellescape","kind":3,"detail":"String","sortText":"00004","insertText":"shellescape(${1:string})${0}","insertTextFormat":2},{"label":"shiftwidth","kind":3,"detail":"Number","sortText":"00004","insertText":"shiftwidth(${0})","insertTextFormat":2},{"label":"sign_define","kind":3,"detail":"Number","sortText":"00004","insertText":"sign_define(${1:name})${0}","insertTextFormat":2},{"label":"sign_getdefined","kind":3,"detail":"List","sortText":"00004","insertText":"sign_getdefined(${1})${0}","insertTextFormat":2},{"label":"sign_getplaced","kind":3,"detail":"List","sortText":"00004","insertText":"sign_getplaced(${1})${0}","insertTextFormat":2},{"label":"sign_jump","kind":3,"detail":"Number","sortText":"00004","insertText":"sign_jump(${1:id}, ${2:group}, ${3:expr})${0}","insertTextFormat":2},{"label":"sign_place","kind":3,"detail":"Number","sortText":"00004","insertText":"sign_place(${1:id}, ${2:group}, ${3:name}, ${4:expr})${0}","insertTextFormat":2},{"label":"sign_undefine","kind":3,"detail":"Number","sortText":"00004","insertText":"sign_undefine(${1})${0}","insertTextFormat":2},{"label":"sign_unplace","kind":3,"detail":"Number","sortText":"00004","insertText":"sign_unplace(${1:group})${0}","insertTextFormat":2},{"label":"simplify","kind":3,"detail":"String","sortText":"00004","insertText":"simplify(${1:filename})${0}","insertTextFormat":2},{"label":"sin","kind":3,"detail":"Float","sortText":"00004","insertText":"sin(${1:expr})${0}","insertTextFormat":2},{"label":"sinh","kind":3,"detail":"Float","sortText":"00004","insertText":"sinh(${1:expr})${0}","insertTextFormat":2},{"label":"sockconnect","kind":3,"detail":"Number","sortText":"00004","insertText":"sockconnect(${1:mode}, ${2:address})${0}","insertTextFormat":2},{"label":"sort","kind":3,"detail":"List","sortText":"00004","insertText":"sort(${1:list})${0}","insertTextFormat":2},{"label":"soundfold","kind":3,"detail":"String","sortText":"00004","insertText":"soundfold(${1:word})${0}","insertTextFormat":2},{"label":"spellbadword","kind":3,"detail":"String","sortText":"00004","insertText":"spellbadword(${0})","insertTextFormat":2},{"label":"spellsuggest","kind":3,"detail":"List","sortText":"00004","insertText":"spellsuggest(${1:word})${0}","insertTextFormat":2},{"label":"split","kind":3,"detail":"List","sortText":"00004","insertText":"split(${1:expr})${0}","insertTextFormat":2},{"label":"sqrt","kind":3,"detail":"Float","sortText":"00004","insertText":"sqrt(${1:expr})${0}","insertTextFormat":2},{"label":"stdioopen","kind":3,"detail":"Number","sortText":"00004","insertText":"stdioopen(${1:dict})${0}","insertTextFormat":2},{"label":"stdpath","kind":3,"detail":"String/List","sortText":"00004","insertText":"stdpath(${1:what})${0}","insertTextFormat":2},{"label":"str2float","kind":3,"detail":"Float","sortText":"00004","insertText":"str2float(${1:expr})${0}","insertTextFormat":2},{"label":"str2list","kind":3,"detail":"List","sortText":"00004","insertText":"str2list(${1:expr})${0}","insertTextFormat":2},{"label":"str2nr","kind":3,"detail":"Number","sortText":"00004","insertText":"str2nr(${1:expr})${0}","insertTextFormat":2},{"label":"strchars","kind":3,"detail":"Number","sortText":"00004","insertText":"strchars(${1:expr})${0}","insertTextFormat":2},{"label":"strcharpart","kind":3,"detail":"String","sortText":"00004","insertText":"strcharpart(${1:str}, ${2:start})${0}","insertTextFormat":2},{"label":"strdisplaywidth","kind":3,"detail":"Number","sortText":"00004","insertText":"strdisplaywidth(${1:expr})${0}","insertTextFormat":2},{"label":"strftime","kind":3,"detail":"String","sortText":"00004","insertText":"strftime(${1:format})${0}","insertTextFormat":2},{"label":"strgetchar","kind":3,"detail":"Number","sortText":"00004","insertText":"strgetchar(${1:str}, ${2:index})${0}","insertTextFormat":2},{"label":"stridx","kind":3,"detail":"Number","sortText":"00004","insertText":"stridx(${1:haystack}, ${2:needle})${0}","insertTextFormat":2},{"label":"string","kind":3,"detail":"String","sortText":"00004","insertText":"string(${1:expr})${0}","insertTextFormat":2},{"label":"strlen","kind":3,"detail":"Number","sortText":"00004","insertText":"strlen(${1:expr})${0}","insertTextFormat":2},{"label":"strpart","kind":3,"detail":"String","sortText":"00004","insertText":"strpart(${1:str}, ${2:start})${0}","insertTextFormat":2},{"label":"strridx","kind":3,"detail":"Number","sortText":"00004","insertText":"strridx(${1:haystack}, ${2:needle})${0}","insertTextFormat":2},{"label":"strtrans","kind":3,"detail":"String","sortText":"00004","insertText":"strtrans(${1:expr})${0}","insertTextFormat":2},{"label":"strwidth","kind":3,"detail":"Number","sortText":"00004","insertText":"strwidth(${1:expr})${0}","insertTextFormat":2},{"label":"submatch","kind":3,"detail":"String","sortText":"00004","insertText":"submatch(${1:nr})${0}","insertTextFormat":2},{"label":"substitute","kind":3,"detail":"String","sortText":"00004","insertText":"substitute(${1:expr}, ${2:pat}, ${3:sub}, ${4:flags})${0}","insertTextFormat":2},{"label":"swapinfo","kind":3,"detail":"Dict","sortText":"00004","insertText":"swapinfo(${1:fname})${0}","insertTextFormat":2},{"label":"swapname","kind":3,"detail":"String","sortText":"00004","insertText":"swapname(${1:expr})${0}","insertTextFormat":2},{"label":"synID","kind":3,"detail":"Number","sortText":"00004","insertText":"synID(${1:lnum}, ${2:col}, ${3:trans})${0}","insertTextFormat":2},{"label":"synIDattr","kind":3,"detail":"String","sortText":"00004","insertText":"synIDattr(${1:synID}, ${2:what})${0}","insertTextFormat":2},{"label":"synIDtrans","kind":3,"detail":"Number","sortText":"00004","insertText":"synIDtrans(${1:synID})${0}","insertTextFormat":2},{"label":"synconcealed","kind":3,"detail":"List","sortText":"00004","insertText":"synconcealed(${1:lnum}, ${2:col})${0}","insertTextFormat":2},{"label":"synstack","kind":3,"detail":"List","sortText":"00004","insertText":"synstack(${1:lnum}, ${2:col})${0}","insertTextFormat":2},{"label":"system","kind":3,"detail":"String","sortText":"00004","insertText":"system(${1:cmd})${0}","insertTextFormat":2},{"label":"systemlist","kind":3,"detail":"List","sortText":"00004","insertText":"systemlist(${1:cmd})${0}","insertTextFormat":2},{"label":"tabpagebuflist","kind":3,"detail":"List","sortText":"00004","insertText":"tabpagebuflist(${1})${0}","insertTextFormat":2},{"label":"tabpagenr","kind":3,"detail":"Number","sortText":"00004","insertText":"tabpagenr(${1})${0}","insertTextFormat":2},{"label":"tabpagewinnr","kind":3,"detail":"Number","sortText":"00004","insertText":"tabpagewinnr(${1:tabarg})${0}","insertTextFormat":2},{"label":"taglist","kind":3,"detail":"List","sortText":"00004","insertText":"taglist(${1:expr})${0}","insertTextFormat":2},{"label":"tagfiles","kind":3,"detail":"List","sortText":"00004","insertText":"tagfiles(${0})","insertTextFormat":2},{"label":"tan","kind":3,"detail":"Float","sortText":"00004","insertText":"tan(${1:expr})${0}","insertTextFormat":2},{"label":"tanh","kind":3,"detail":"Float","sortText":"00004","insertText":"tanh(${1:expr})${0}","insertTextFormat":2},{"label":"tempname","kind":3,"detail":"String","sortText":"00004","insertText":"tempname(${0})","insertTextFormat":2},{"label":"test_garbagecollect_now","kind":3,"detail":"none","sortText":"00004","insertText":"test_garbagecollect_now(${0})","insertTextFormat":2},{"label":"timer_info","kind":3,"detail":"List","sortText":"00004","insertText":"timer_info(${1})${0}","insertTextFormat":2},{"label":"timer_pause","kind":3,"detail":"none","sortText":"00004","insertText":"timer_pause(${1:id}, ${2:pause})${0}","insertTextFormat":2},{"label":"timer_start","kind":3,"detail":"Number","sortText":"00004","insertText":"timer_start(${1:time}, ${2:callback})${0}","insertTextFormat":2},{"label":"timer_stop","kind":3,"detail":"none","sortText":"00004","insertText":"timer_stop(${1:timer})${0}","insertTextFormat":2},{"label":"timer_stopall","kind":3,"detail":"none","sortText":"00004","insertText":"timer_stopall(${0})","insertTextFormat":2},{"label":"tolower","kind":3,"detail":"String","sortText":"00004","insertText":"tolower(${1:expr})${0}","insertTextFormat":2},{"label":"toupper","kind":3,"detail":"String","sortText":"00004","insertText":"toupper(${1:expr})${0}","insertTextFormat":2},{"label":"tr","kind":3,"detail":"String","sortText":"00004","insertText":"tr(${1:src}, ${2:fromstr}, ${3:tostr})${0}","insertTextFormat":2},{"label":"trim","kind":3,"detail":"String","sortText":"00004","insertText":"trim(${1:text})${0}","insertTextFormat":2},{"label":"trunc","kind":3,"detail":"Float","sortText":"00004","insertText":"trunc(${1:expr})${0}","insertTextFormat":2},{"label":"type","kind":3,"detail":"Number","sortText":"00004","insertText":"type(${1:name})${0}","insertTextFormat":2},{"label":"undofile","kind":3,"detail":"String","sortText":"00004","insertText":"undofile(${1:name})${0}","insertTextFormat":2},{"label":"undotree","kind":3,"detail":"List","sortText":"00004","insertText":"undotree(${0})","insertTextFormat":2},{"label":"uniq","kind":3,"detail":"List","sortText":"00004","insertText":"uniq(${1:list})${0}","insertTextFormat":2},{"label":"values","kind":3,"detail":"List","sortText":"00004","insertText":"values(${1:dict})${0}","insertTextFormat":2},{"label":"virtcol","kind":3,"detail":"Number","sortText":"00004","insertText":"virtcol(${1:expr})${0}","insertTextFormat":2},{"label":"visualmode","kind":3,"detail":"String","sortText":"00004","insertText":"visualmode(${1})${0}","insertTextFormat":2},{"label":"wait","kind":3,"detail":"Number","sortText":"00004","insertText":"wait(${1:timeout}, ${2:condition})${0}","insertTextFormat":2},{"label":"wildmenumode","kind":3,"detail":"Number","sortText":"00004","insertText":"wildmenumode(${0})","insertTextFormat":2},{"label":"win_findbuf","kind":3,"detail":"List","sortText":"00004","insertText":"win_findbuf(${1:bufnr})${0}","insertTextFormat":2},{"label":"win_getid","kind":3,"detail":"Number","sortText":"00004","insertText":"win_getid(${1})${0}","insertTextFormat":2},{"label":"win_gotoid","kind":3,"detail":"Number","sortText":"00004","insertText":"win_gotoid(${1:expr})${0}","insertTextFormat":2},{"label":"win_id2tabwin","kind":3,"detail":"List","sortText":"00004","insertText":"win_id2tabwin(${1:expr})${0}","insertTextFormat":2},{"label":"win_id2win","kind":3,"detail":"Number","sortText":"00004","insertText":"win_id2win(${1:expr})${0}","insertTextFormat":2},{"label":"win_screenpos","kind":3,"detail":"List","sortText":"00004","insertText":"win_screenpos(${1:nr})${0}","insertTextFormat":2},{"label":"winbufnr","kind":3,"detail":"Number","sortText":"00004","insertText":"winbufnr(${1:nr})${0}","insertTextFormat":2},{"label":"wincol","kind":3,"detail":"Number","sortText":"00004","insertText":"wincol(${0})","insertTextFormat":2},{"label":"winheight","kind":3,"detail":"Number","sortText":"00004","insertText":"winheight(${1:nr})${0}","insertTextFormat":2},{"label":"winlayout","kind":3,"detail":"List","sortText":"00004","insertText":"winlayout(${1})${0}","insertTextFormat":2},{"label":"winline","kind":3,"detail":"Number","sortText":"00004","insertText":"winline(${0})","insertTextFormat":2},{"label":"winnr","kind":3,"detail":"Number","sortText":"00004","insertText":"winnr(${1})${0}","insertTextFormat":2},{"label":"winrestcmd","kind":3,"detail":"String","sortText":"00004","insertText":"winrestcmd(${0})","insertTextFormat":2},{"label":"winrestview","kind":3,"detail":"none","sortText":"00004","insertText":"winrestview(${1:dict})${0}","insertTextFormat":2},{"label":"winsaveview","kind":3,"detail":"Dict","sortText":"00004","insertText":"winsaveview(${0})","insertTextFormat":2},{"label":"winwidth","kind":3,"detail":"Number","sortText":"00004","insertText":"winwidth(${1:nr})${0}","insertTextFormat":2},{"label":"wordcount","kind":3,"detail":"Dict","sortText":"00004","insertText":"wordcount(${0})","insertTextFormat":2},{"label":"writefile","kind":3,"detail":"Number","sortText":"00004","insertText":"writefile(${1:list}, ${2:fname})${0}","insertTextFormat":2},{"label":"xor","kind":3,"detail":"Number","sortText":"00004","insertText":"xor(${1:expr}, ${2:expr})${0}","insertTextFormat":2},{"label":"nvim__id","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim__id(${1:obj})${0}","insertTextFormat":2},{"label":"nvim__id_array","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim__id_array(${1:arr})${0}","insertTextFormat":2},{"label":"nvim__id_dictionary","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim__id_dictionary(${1:dct})${0}","insertTextFormat":2},{"label":"nvim__id_float","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim__id_float(${1:flt})${0}","insertTextFormat":2},{"label":"nvim__inspect_cell","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim__inspect_cell(${1:grid}, ${2:row}, ${3:col})${0}","insertTextFormat":2},{"label":"nvim__put_attr","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim__put_attr(${1:id}, ${2:c0}, ${3:c1})${0}","insertTextFormat":2},{"label":"nvim__stats","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim__stats(${0})","insertTextFormat":2},{"label":"nvim_call_atomic","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_call_atomic(${1:calls})${0}","insertTextFormat":2},{"label":"nvim_call_dict_function","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_call_dict_function(${1:dict}, ${2:fn}, ${3:args})${0}","insertTextFormat":2},{"label":"nvim_call_function","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_call_function(${1:fn}, ${2:args})${0}","insertTextFormat":2},{"label":"nvim_command","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_command(${1:command})${0}","insertTextFormat":2},{"label":"nvim_create_buf","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_create_buf(${1:listed}, ${2:scratch})${0}","insertTextFormat":2},{"label":"nvim_create_namespace","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_create_namespace(${1:name})${0}","insertTextFormat":2},{"label":"nvim_del_current_line","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_del_current_line(${0})","insertTextFormat":2},{"label":"nvim_del_keymap","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_del_keymap(${1:mode}, ${2:lhs})${0}","insertTextFormat":2},{"label":"nvim_del_var","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_del_var(${1:name})${0}","insertTextFormat":2},{"label":"nvim_err_write","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_err_write(${1:str})${0}","insertTextFormat":2},{"label":"nvim_err_writeln","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_err_writeln(${1:str})${0}","insertTextFormat":2},{"label":"nvim_eval","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_eval(${1:expr})${0}","insertTextFormat":2},{"label":"nvim_exec","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_exec(${1:src}, ${2:output})${0}","insertTextFormat":2},{"label":"nvim_exec_lua","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_exec_lua(${1:code}, ${2:args})${0}","insertTextFormat":2},{"label":"nvim_feedkeys","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_feedkeys(${1:keys}, ${2:mode}, ${3:escape_csi})${0}","insertTextFormat":2},{"label":"nvim_get_api_info","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_get_api_info(${0})","insertTextFormat":2},{"label":"nvim_get_chan_info","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_get_chan_info(${1:chan})${0}","insertTextFormat":2},{"label":"nvim_get_color_by_name","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_get_color_by_name(${1:name})${0}","insertTextFormat":2},{"label":"nvim_get_color_map","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_get_color_map(${0})","insertTextFormat":2},{"label":"nvim_get_commands","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_get_commands(${1:opts})${0}","insertTextFormat":2},{"label":"nvim_get_context","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_get_context(${1:opts})${0}","insertTextFormat":2},{"label":"nvim_get_current_buf","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_get_current_buf(${0})","insertTextFormat":2},{"label":"nvim_get_current_line","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_get_current_line(${0})","insertTextFormat":2},{"label":"nvim_get_current_tabpage","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_get_current_tabpage(${0})","insertTextFormat":2},{"label":"nvim_get_current_win","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_get_current_win(${0})","insertTextFormat":2},{"label":"nvim_get_hl_by_id","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_get_hl_by_id(${1:hl_id}, ${2:rgb})${0}","insertTextFormat":2},{"label":"nvim_get_hl_by_name","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_get_hl_by_name(${1:name}, ${2:rgb})${0}","insertTextFormat":2},{"label":"nvim_get_hl_id_by_name","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_get_hl_id_by_name(${1:name})${0}","insertTextFormat":2},{"label":"nvim_get_keymap","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_get_keymap(${1:mode})${0}","insertTextFormat":2},{"label":"nvim_get_mode","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_get_mode(${0})","insertTextFormat":2},{"label":"nvim_get_namespaces","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_get_namespaces(${0})","insertTextFormat":2},{"label":"nvim_get_option","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_get_option(${1:name})${0}","insertTextFormat":2},{"label":"nvim_get_proc","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_get_proc(${1:pid})${0}","insertTextFormat":2},{"label":"nvim_get_proc_children","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_get_proc_children(${1:pid})${0}","insertTextFormat":2},{"label":"nvim_get_var","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_get_var(${1:name})${0}","insertTextFormat":2},{"label":"nvim_get_vvar","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_get_vvar(${1:name})${0}","insertTextFormat":2},{"label":"nvim_input","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_input(${1:keys})${0}","insertTextFormat":2},{"label":"nvim_input_mouse","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_input_mouse(${1:button}, ${2:action}, ${3:modifier}, ${4:grid}, ${5:row}, ${6:col})${0}","insertTextFormat":2},{"label":"nvim_list_bufs","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_list_bufs(${0})","insertTextFormat":2},{"label":"nvim_list_chans","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_list_chans(${0})","insertTextFormat":2},{"label":"nvim_list_runtime_paths","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_list_runtime_paths(${0})","insertTextFormat":2},{"label":"nvim_list_tabpages","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_list_tabpages(${0})","insertTextFormat":2},{"label":"nvim_list_uis","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_list_uis(${0})","insertTextFormat":2},{"label":"nvim_list_wins","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_list_wins(${0})","insertTextFormat":2},{"label":"nvim_load_context","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_load_context(${1:dict})${0}","insertTextFormat":2},{"label":"nvim_open_win","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_open_win(${1:buffer}, ${2:enter}, ${3:config})${0}","insertTextFormat":2},{"label":"nvim_out_write","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_out_write(${1:str})${0}","insertTextFormat":2},{"label":"nvim_parse_expression","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_parse_expression(${1:expr}, ${2:flags}, ${3:highlight})${0}","insertTextFormat":2},{"label":"nvim_paste","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_paste(${1:data}, ${2:crlf}, ${3:phase})${0}","insertTextFormat":2},{"label":"nvim_put","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_put(${1:lines}, ${2:type}, ${3:after}, ${4:follow})${0}","insertTextFormat":2},{"label":"nvim_replace_termcodes","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_replace_termcodes(${1:str}, ${2:from_part}, ${3:do_lt}, ${4:special})${0}","insertTextFormat":2},{"label":"nvim_select_popupmenu_item","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_select_popupmenu_item(${1:item}, ${2:insert}, ${3:finish}, ${4:opts})${0}","insertTextFormat":2},{"label":"nvim_set_client_info","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_set_client_info(${1:name}, ${2:version}, ${3:type}, ${4:methods}, ${5:attributes})${0}","insertTextFormat":2},{"label":"nvim_set_current_buf","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_set_current_buf(${1:buffer})${0}","insertTextFormat":2},{"label":"nvim_set_current_dir","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_set_current_dir(${1:dir})${0}","insertTextFormat":2},{"label":"nvim_set_current_line","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_set_current_line(${1:line})${0}","insertTextFormat":2},{"label":"nvim_set_current_tabpage","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_set_current_tabpage(${1:tabpage})${0}","insertTextFormat":2},{"label":"nvim_set_current_win","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_set_current_win(${1:window})${0}","insertTextFormat":2},{"label":"nvim_set_keymap","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_set_keymap(${1:mode}, ${2:lhs}, ${3:rhs}, ${4:opts})${0}","insertTextFormat":2},{"label":"nvim_set_option","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_set_option(${1:name}, ${2:value})${0}","insertTextFormat":2},{"label":"nvim_set_var","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_set_var(${1:name}, ${2:value})${0}","insertTextFormat":2},{"label":"nvim_set_vvar","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_set_vvar(${1:name}, ${2:value})${0}","insertTextFormat":2},{"label":"nvim_strwidth","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_strwidth(${1:text})${0}","insertTextFormat":2},{"label":"nvim_subscribe","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_subscribe(${1:event})${0}","insertTextFormat":2},{"label":"nvim_unsubscribe","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_unsubscribe(${1:event})${0}","insertTextFormat":2},{"label":"nvim__buf_redraw_range","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim__buf_redraw_range(${1:buffer}, ${2:first}, ${3:last})${0}","insertTextFormat":2},{"label":"nvim__buf_set_luahl","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim__buf_set_luahl(${1:buffer}, ${2:opts})${0}","insertTextFormat":2},{"label":"nvim__buf_stats","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim__buf_stats(${1:buffer})${0}","insertTextFormat":2},{"label":"nvim_buf_add_highlight","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_add_highlight(${1:buffer}, ${2:ns_id}, ${3:hl_group}, ${4:line}, ${5:col_start}, ${6:col_end})${0}","insertTextFormat":2},{"label":"nvim_buf_attach","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_attach(${1:buffer}, ${2:send_buffer}, ${3:opts})${0}","insertTextFormat":2},{"label":"nvim_buf_clear_namespace","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_clear_namespace(${1:buffer}, ${2:ns_id}, ${3:line_start}, ${4:line_end})${0}","insertTextFormat":2},{"label":"nvim_buf_del_extmark","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_del_extmark(${1:buffer}, ${2:ns_id}, ${3:id})${0}","insertTextFormat":2},{"label":"nvim_buf_del_keymap","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_del_keymap(${1:buffer}, ${2:mode}, ${3:lhs})${0}","insertTextFormat":2},{"label":"nvim_buf_del_var","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_del_var(${1:buffer}, ${2:name})${0}","insertTextFormat":2},{"label":"nvim_buf_detach","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_detach(${1:buffer})${0}","insertTextFormat":2},{"label":"nvim_buf_get_changedtick","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_get_changedtick(${1:buffer})${0}","insertTextFormat":2},{"label":"nvim_buf_get_commands","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_get_commands(${1:buffer}, ${2:opts})${0}","insertTextFormat":2},{"label":"nvim_buf_get_extmark_by_id","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_get_extmark_by_id(${1:buffer}, ${2:ns_id}, ${3:id})${0}","insertTextFormat":2},{"label":"nvim_buf_get_extmarks","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_get_extmarks(${1:buffer}, ${2:ns_id}, ${3:start}, ${4:end}, ${5:opts})${0}","insertTextFormat":2},{"label":"nvim_buf_get_keymap","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_get_keymap(${1:buffer}, ${2:mode})${0}","insertTextFormat":2},{"label":"nvim_buf_get_lines","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_get_lines(${1:buffer}, ${2:start}, ${3:end}, ${4:strict_indexing})${0}","insertTextFormat":2},{"label":"nvim_buf_get_mark","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_get_mark(${1:buffer}, ${2:name})${0}","insertTextFormat":2},{"label":"nvim_buf_get_name","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_get_name(${1:buffer})${0}","insertTextFormat":2},{"label":"nvim_buf_get_offset","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_get_offset(${1:buffer}, ${2:index})${0}","insertTextFormat":2},{"label":"nvim_buf_get_option","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_get_option(${1:buffer}, ${2:name})${0}","insertTextFormat":2},{"label":"nvim_buf_get_var","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_get_var(${1:buffer}, ${2:name})${0}","insertTextFormat":2},{"label":"nvim_buf_get_virtual_text","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_get_virtual_text(${1:buffer}, ${2:lnum})${0}","insertTextFormat":2},{"label":"nvim_buf_is_loaded","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_is_loaded(${1:buffer})${0}","insertTextFormat":2},{"label":"nvim_buf_is_valid","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_is_valid(${1:buffer})${0}","insertTextFormat":2},{"label":"nvim_buf_line_count","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_line_count(${1:buffer})${0}","insertTextFormat":2},{"label":"nvim_buf_set_extmark","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_set_extmark(${1:buffer}, ${2:ns_id}, ${3:id}, ${4:line}, ${5:col}, ${6:opts})${0}","insertTextFormat":2},{"label":"nvim_buf_set_keymap","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_set_keymap(${1:buffer}, ${2:mode}, ${3:lhs}, ${4:rhs}, ${5:opts})${0}","insertTextFormat":2},{"label":"nvim_buf_set_lines","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_set_lines(${1:buffer}, ${2:start}, ${3:end}, ${4:strict_indexing}, ${5:replacement})${0}","insertTextFormat":2},{"label":"nvim_buf_set_name","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_set_name(${1:buffer}, ${2:name})${0}","insertTextFormat":2},{"label":"nvim_buf_set_option","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_set_option(${1:buffer}, ${2:name}, ${3:value})${0}","insertTextFormat":2},{"label":"nvim_buf_set_var","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_set_var(${1:buffer}, ${2:name}, ${3:value})${0}","insertTextFormat":2},{"label":"nvim_buf_set_virtual_text","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_buf_set_virtual_text(${1:buffer}, ${2:ns_id}, ${3:line}, ${4:chunks}, ${5:opts})${0}","insertTextFormat":2},{"label":"nvim_win_close","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_win_close(${1:window}, ${2:force})${0}","insertTextFormat":2},{"label":"nvim_win_del_var","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_win_del_var(${1:window}, ${2:name})${0}","insertTextFormat":2},{"label":"nvim_win_get_buf","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_win_get_buf(${1:window})${0}","insertTextFormat":2},{"label":"nvim_win_get_config","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_win_get_config(${1:window})${0}","insertTextFormat":2},{"label":"nvim_win_get_cursor","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_win_get_cursor(${1:window})${0}","insertTextFormat":2},{"label":"nvim_win_get_height","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_win_get_height(${1:window})${0}","insertTextFormat":2},{"label":"nvim_win_get_number","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_win_get_number(${1:window})${0}","insertTextFormat":2},{"label":"nvim_win_get_option","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_win_get_option(${1:window}, ${2:name})${0}","insertTextFormat":2},{"label":"nvim_win_get_position","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_win_get_position(${1:window})${0}","insertTextFormat":2},{"label":"nvim_win_get_tabpage","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_win_get_tabpage(${1:window})${0}","insertTextFormat":2},{"label":"nvim_win_get_var","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_win_get_var(${1:window}, ${2:name})${0}","insertTextFormat":2},{"label":"nvim_win_get_width","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_win_get_width(${1:window})${0}","insertTextFormat":2},{"label":"nvim_win_is_valid","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_win_is_valid(${1:window})${0}","insertTextFormat":2},{"label":"nvim_win_set_buf","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_win_set_buf(${1:window}, ${2:buffer})${0}","insertTextFormat":2},{"label":"nvim_win_set_config","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_win_set_config(${1:window}, ${2:config})${0}","insertTextFormat":2},{"label":"nvim_win_set_cursor","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_win_set_cursor(${1:window}, ${2:pos})${0}","insertTextFormat":2},{"label":"nvim_win_set_height","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_win_set_height(${1:window}, ${2:height})${0}","insertTextFormat":2},{"label":"nvim_win_set_option","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_win_set_option(${1:window}, ${2:name}, ${3:value})${0}","insertTextFormat":2},{"label":"nvim_win_set_var","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_win_set_var(${1:window}, ${2:name}, ${3:value})${0}","insertTextFormat":2},{"label":"nvim_win_set_width","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_win_set_width(${1:window}, ${2:width})${0}","insertTextFormat":2},{"label":"nvim_tabpage_del_var","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_tabpage_del_var(${1:tabpage}, ${2:name})${0}","insertTextFormat":2},{"label":"nvim_tabpage_get_number","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_tabpage_get_number(${1:tabpage})${0}","insertTextFormat":2},{"label":"nvim_tabpage_get_var","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_tabpage_get_var(${1:tabpage}, ${2:name})${0}","insertTextFormat":2},{"label":"nvim_tabpage_get_win","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_tabpage_get_win(${1:tabpage})${0}","insertTextFormat":2},{"label":"nvim_tabpage_is_valid","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_tabpage_is_valid(${1:tabpage})${0}","insertTextFormat":2},{"label":"nvim_tabpage_list_wins","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_tabpage_list_wins(${1:tabpage})${0}","insertTextFormat":2},{"label":"nvim_tabpage_set_var","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_tabpage_set_var(${1:tabpage}, ${2:name}, ${3:value})${0}","insertTextFormat":2},{"label":"nvim_ui_attach","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_ui_attach(${1:width}, ${2:height}, ${3:options})${0}","insertTextFormat":2},{"label":"nvim_ui_detach","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_ui_detach(${0})","insertTextFormat":2},{"label":"nvim_ui_pum_set_height","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_ui_pum_set_height(${1:height})${0}","insertTextFormat":2},{"label":"nvim_ui_set_option","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_ui_set_option(${1:name}, ${2:value})${0}","insertTextFormat":2},{"label":"nvim_ui_try_resize","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_ui_try_resize(${1:width}, ${2:height})${0}","insertTextFormat":2},{"label":"nvim_ui_try_resize_grid","kind":3,"detail":"","documentation":"","sortText":"00004","insertText":"nvim_ui_try_resize_grid(${1:grid}, ${2:width}, ${3:height})${0}","insertTextFormat":2},{"label":"balloon_gettext","kind":3,"detail":"String","sortText":"00004","insertText":"balloon_gettext(${0})","insertTextFormat":2},{"label":"balloon_show","kind":3,"detail":"none","sortText":"00004","insertText":"balloon_show(${1:expr})${0}","insertTextFormat":2},{"label":"balloon_split","kind":3,"detail":"List","sortText":"00004","insertText":"balloon_split(${1:msg})${0}","insertTextFormat":2},{"label":"ch_canread","kind":3,"detail":"Number","sortText":"00004","insertText":"ch_canread(${1:handle})${0}","insertTextFormat":2},{"label":"ch_close","kind":3,"detail":"none","sortText":"00004","insertText":"ch_close(${1:handle})${0}","insertTextFormat":2},{"label":"ch_close_in","kind":3,"detail":"none","sortText":"00004","insertText":"ch_close_in(${1:handle})${0}","insertTextFormat":2},{"label":"ch_evalexpr","kind":3,"detail":"any","sortText":"00004","insertText":"ch_evalexpr(${1:handle}, ${2:expr})${0}","insertTextFormat":2},{"label":"ch_evalraw","kind":3,"detail":"any","sortText":"00004","insertText":"ch_evalraw(${1:handle}, ${2:string})${0}","insertTextFormat":2},{"label":"ch_getbufnr","kind":3,"detail":"Number","sortText":"00004","insertText":"ch_getbufnr(${1:handle}, ${2:what})${0}","insertTextFormat":2},{"label":"ch_getjob","kind":3,"detail":"Job","sortText":"00004","insertText":"ch_getjob(${1:channel})${0}","insertTextFormat":2},{"label":"ch_info","kind":3,"detail":"String","sortText":"00004","insertText":"ch_info(${1:handle})${0}","insertTextFormat":2},{"label":"ch_log","kind":3,"detail":"none","sortText":"00004","insertText":"ch_log(${1:msg})${0}","insertTextFormat":2},{"label":"ch_logfile","kind":3,"detail":"none","sortText":"00004","insertText":"ch_logfile(${1:fname})${0}","insertTextFormat":2},{"label":"ch_open","kind":3,"detail":"Channel","sortText":"00004","insertText":"ch_open(${1:address})${0}","insertTextFormat":2},{"label":"ch_read","kind":3,"detail":"String","sortText":"00004","insertText":"ch_read(${1:handle})${0}","insertTextFormat":2},{"label":"ch_readblob","kind":3,"detail":"Blob","sortText":"00004","insertText":"ch_readblob(${1:handle})${0}","insertTextFormat":2},{"label":"ch_readraw","kind":3,"detail":"String","sortText":"00004","insertText":"ch_readraw(${1:handle})${0}","insertTextFormat":2},{"label":"ch_sendexpr","kind":3,"detail":"any","sortText":"00004","insertText":"ch_sendexpr(${1:handle}, ${2:expr})${0}","insertTextFormat":2},{"label":"ch_sendraw","kind":3,"detail":"any","sortText":"00004","insertText":"ch_sendraw(${1:handle}, ${2:expr})${0}","insertTextFormat":2},{"label":"ch_setoptions","kind":3,"detail":"none","sortText":"00004","insertText":"ch_setoptions(${1:handle}, ${2:options})${0}","insertTextFormat":2},{"label":"ch_status","kind":3,"detail":"String","sortText":"00004","insertText":"ch_status(${1:handle})${0}","insertTextFormat":2},{"label":"chdir","kind":3,"detail":"String","sortText":"00004","insertText":"chdir(${1:dir})${0}","insertTextFormat":2},{"label":"getimstatus","kind":3,"detail":"Number","sortText":"00004","insertText":"getimstatus(${0})","insertTextFormat":2},{"label":"getmousepos","kind":3,"detail":"Dict","sortText":"00004","insertText":"getmousepos(${0})","insertTextFormat":2},{"label":"inputdialog","kind":3,"detail":"String","sortText":"00004","insertText":"inputdialog(${1:prompt})${0}","insertTextFormat":2},{"label":"interrupt","kind":3,"detail":"none","sortText":"00004","insertText":"interrupt(${0})","insertTextFormat":2},{"label":"job_getchannel","kind":3,"detail":"Channel","sortText":"00004","insertText":"job_getchannel(${1:job})${0}","insertTextFormat":2},{"label":"job_info","kind":3,"detail":"Dict","sortText":"00004","insertText":"job_info(${1})${0}","insertTextFormat":2},{"label":"job_setoptions","kind":3,"detail":"none","sortText":"00004","insertText":"job_setoptions(${1:job}, ${2:options})${0}","insertTextFormat":2},{"label":"job_start","kind":3,"detail":"Job","sortText":"00004","insertText":"job_start(${1:command})${0}","insertTextFormat":2},{"label":"job_status","kind":3,"detail":"String","sortText":"00004","insertText":"job_status(${1:job})${0}","insertTextFormat":2},{"label":"job_stop","kind":3,"detail":"Number","sortText":"00004","insertText":"job_stop(${1:job})${0}","insertTextFormat":2},{"label":"js_decode","kind":3,"detail":"any","sortText":"00004","insertText":"js_decode(${1:string})${0}","insertTextFormat":2},{"label":"js_encode","kind":3,"detail":"String","sortText":"00004","insertText":"js_encode(${1:expr})${0}","insertTextFormat":2},{"label":"listener_add","kind":3,"detail":"Number","sortText":"00004","insertText":"listener_add(${1:callback})${0}","insertTextFormat":2},{"label":"listener_flush","kind":3,"detail":"none","sortText":"00004","insertText":"listener_flush(${1})${0}","insertTextFormat":2},{"label":"listener_remove","kind":3,"detail":"none","sortText":"00004","insertText":"listener_remove(${1:id})${0}","insertTextFormat":2},{"label":"mzeval","kind":3,"detail":"any","sortText":"00004","insertText":"mzeval(${1:expr})${0}","insertTextFormat":2},{"label":"perleval","kind":3,"detail":"any","sortText":"00004","insertText":"perleval(${1:expr})${0}","insertTextFormat":2},{"label":"popup_atcursor","kind":3,"detail":"Number","sortText":"00004","insertText":"popup_atcursor(${1:what}, ${2:options})${0}","insertTextFormat":2},{"label":"popup_beval","kind":3,"detail":"Number","sortText":"00004","insertText":"popup_beval(${1:what}, ${2:options})${0}","insertTextFormat":2},{"label":"popup_clear","kind":3,"detail":"none","sortText":"00004","insertText":"popup_clear(${0})","insertTextFormat":2},{"label":"popup_close","kind":3,"detail":"none","sortText":"00004","insertText":"popup_close(${1:id})${0}","insertTextFormat":2},{"label":"popup_create","kind":3,"detail":"Number","sortText":"00004","insertText":"popup_create(${1:what}, ${2:options})${0}","insertTextFormat":2},{"label":"popup_dialog","kind":3,"detail":"Number","sortText":"00004","insertText":"popup_dialog(${1:what}, ${2:options})${0}","insertTextFormat":2},{"label":"popup_filter_menu","kind":3,"detail":"Number","sortText":"00004","insertText":"popup_filter_menu(${1:id}, ${2:key})${0}","insertTextFormat":2},{"label":"popup_filter_yesno","kind":3,"detail":"Number","sortText":"00004","insertText":"popup_filter_yesno(${1:id}, ${2:key})${0}","insertTextFormat":2},{"label":"popup_findinfo","kind":3,"detail":"Number","sortText":"00004","insertText":"popup_findinfo(${0})","insertTextFormat":2},{"label":"popup_findpreview","kind":3,"detail":"Number","sortText":"00004","insertText":"popup_findpreview(${0})","insertTextFormat":2},{"label":"popup_getoptions","kind":3,"detail":"Dict","sortText":"00004","insertText":"popup_getoptions(${1:id})${0}","insertTextFormat":2},{"label":"popup_getpos","kind":3,"detail":"Dict","sortText":"00004","insertText":"popup_getpos(${1:id})${0}","insertTextFormat":2},{"label":"popup_hide","kind":3,"detail":"none","sortText":"00004","insertText":"popup_hide(${1:id})${0}","insertTextFormat":2},{"label":"popup_menu","kind":3,"detail":"Number","sortText":"00004","insertText":"popup_menu(${1:what}, ${2:options})${0}","insertTextFormat":2},{"label":"popup_move","kind":3,"detail":"none","sortText":"00004","insertText":"popup_move(${1:id}, ${2:options})${0}","insertTextFormat":2},{"label":"popup_notification","kind":3,"detail":"Number","sortText":"00004","insertText":"popup_notification(${1:what}, ${2:options})${0}","insertTextFormat":2},{"label":"popup_show","kind":3,"detail":"none","sortText":"00004","insertText":"popup_show(${1:id})${0}","insertTextFormat":2},{"label":"popup_setoptions","kind":3,"detail":"none","sortText":"00004","insertText":"popup_setoptions(${1:id}, ${2:options})${0}","insertTextFormat":2},{"label":"popup_settext","kind":3,"detail":"none","sortText":"00004","insertText":"popup_settext(${1:id}, ${2:text})${0}","insertTextFormat":2},{"label":"prop_add","kind":3,"detail":"none","sortText":"00004","insertText":"prop_add(${1:lnum}, ${2:col}, ${3:props})${0}","insertTextFormat":2},{"label":"prop_clear","kind":3,"detail":"none","sortText":"00004","insertText":"prop_clear(${1:lnum})${0}","insertTextFormat":2},{"label":"prop_find","kind":3,"detail":"Dict","sortText":"00004","insertText":"prop_find(${1:props})${0}","insertTextFormat":2},{"label":"prop_list","kind":3,"detail":"List","sortText":"00004","insertText":"prop_list(${1:lnum})${0}","insertTextFormat":2},{"label":"prop_remove","kind":3,"detail":"Number","sortText":"00004","insertText":"prop_remove(${1:props})${0}","insertTextFormat":2},{"label":"prop_type_add","kind":3,"detail":"none","sortText":"00004","insertText":"prop_type_add(${1:name}, ${2:props})${0}","insertTextFormat":2},{"label":"prop_type_change","kind":3,"detail":"none","sortText":"00004","insertText":"prop_type_change(${1:name}, ${2:props})${0}","insertTextFormat":2},{"label":"prop_type_delete","kind":3,"detail":"none","sortText":"00004","insertText":"prop_type_delete(${1:name})${0}","insertTextFormat":2},{"label":"prop_type_get","kind":3,"detail":"Dict","sortText":"00004","insertText":"prop_type_get(${1})${0}","insertTextFormat":2},{"label":"prop_type_list","kind":3,"detail":"List","sortText":"00004","insertText":"prop_type_list(${1})${0}","insertTextFormat":2},{"label":"rand","kind":3,"detail":"Number","sortText":"00004","insertText":"rand(${1})${0}","insertTextFormat":2},{"label":"rubyeval","kind":3,"detail":"any","sortText":"00004","insertText":"rubyeval(${1:expr})${0}","insertTextFormat":2},{"label":"screenchars","kind":3,"detail":"List","sortText":"00004","insertText":"screenchars(${1:row}, ${2:col})${0}","insertTextFormat":2},{"label":"screenstring","kind":3,"detail":"String","sortText":"00004","insertText":"screenstring(${1:row}, ${2:col})${0}","insertTextFormat":2},{"label":"searchpair","kind":3,"detail":"Number","sortText":"00004","insertText":"searchpair(${1:start}, ${2:middle}, ${3:end})${0}","insertTextFormat":2},{"label":"searchpairpos","kind":3,"detail":"List","sortText":"00004","insertText":"searchpairpos(${1:start}, ${2:middle}, ${3:end})${0}","insertTextFormat":2},{"label":"sign_placelist","kind":3,"detail":"List","sortText":"00004","insertText":"sign_placelist(${1:list})${0}","insertTextFormat":2},{"label":"sign_unplacelist","kind":3,"detail":"List","sortText":"00004","insertText":"sign_unplacelist(${1:list})${0}","insertTextFormat":2},{"label":"sound_clear","kind":3,"detail":"none","sortText":"00004","insertText":"sound_clear(${0})","insertTextFormat":2},{"label":"sound_playevent","kind":3,"detail":"Number","sortText":"00004","insertText":"sound_playevent(${1:name})${0}","insertTextFormat":2},{"label":"sound_playfile","kind":3,"detail":"Number","sortText":"00004","insertText":"sound_playfile(${1:path})${0}","insertTextFormat":2},{"label":"sound_stop","kind":3,"detail":"none","sortText":"00004","insertText":"sound_stop(${1:id})${0}","insertTextFormat":2},{"label":"srand","kind":3,"detail":"List","sortText":"00004","insertText":"srand(${1})${0}","insertTextFormat":2},{"label":"state","kind":3,"detail":"String","sortText":"00004","insertText":"state(${1})${0}","insertTextFormat":2},{"label":"strptime","kind":3,"detail":"Number","sortText":"00004","insertText":"strptime(${1:format}, ${2:timestring})${0}","insertTextFormat":2},{"label":"term_dumpdiff","kind":3,"detail":"Number","sortText":"00004","insertText":"term_dumpdiff(${1:filename}, ${2:filename})${0}","insertTextFormat":2},{"label":"term_dumpload","kind":3,"detail":"Number","sortText":"00004","insertText":"term_dumpload(${1:filename})${0}","insertTextFormat":2},{"label":"term_dumpwrite","kind":3,"detail":"none","sortText":"00004","insertText":"term_dumpwrite(${1:buf}, ${2:filename})${0}","insertTextFormat":2},{"label":"term_getaltscreen","kind":3,"detail":"Number","sortText":"00004","insertText":"term_getaltscreen(${1:buf})${0}","insertTextFormat":2},{"label":"term_getansicolors","kind":3,"detail":"List","sortText":"00004","insertText":"term_getansicolors(${1:buf})${0}","insertTextFormat":2},{"label":"term_getattr","kind":3,"detail":"Number","sortText":"00004","insertText":"term_getattr(${1:attr}, ${2:what})${0}","insertTextFormat":2},{"label":"term_getcursor","kind":3,"detail":"List","sortText":"00004","insertText":"term_getcursor(${1:buf})${0}","insertTextFormat":2},{"label":"term_getjob","kind":3,"detail":"Job","sortText":"00004","insertText":"term_getjob(${1:buf})${0}","insertTextFormat":2},{"label":"term_getline","kind":3,"detail":"String","sortText":"00004","insertText":"term_getline(${1:buf}, ${2:row})${0}","insertTextFormat":2},{"label":"term_getscrolled","kind":3,"detail":"Number","sortText":"00004","insertText":"term_getscrolled(${1:buf})${0}","insertTextFormat":2},{"label":"term_getsize","kind":3,"detail":"List","sortText":"00004","insertText":"term_getsize(${1:buf})${0}","insertTextFormat":2},{"label":"term_getstatus","kind":3,"detail":"String","sortText":"00004","insertText":"term_getstatus(${1:buf})${0}","insertTextFormat":2},{"label":"term_gettitle","kind":3,"detail":"String","sortText":"00004","insertText":"term_gettitle(${1:buf})${0}","insertTextFormat":2},{"label":"term_gettty","kind":3,"detail":"String","sortText":"00004","insertText":"term_gettty(${1:buf},)${0}","insertTextFormat":2},{"label":"term_list","kind":3,"detail":"List","sortText":"00004","insertText":"term_list(${0})","insertTextFormat":2},{"label":"term_scrape","kind":3,"detail":"List","sortText":"00004","insertText":"term_scrape(${1:buf}, ${2:row})${0}","insertTextFormat":2},{"label":"term_sendkeys","kind":3,"detail":"none","sortText":"00004","insertText":"term_sendkeys(${1:buf}, ${2:keys})${0}","insertTextFormat":2},{"label":"term_setapi","kind":3,"detail":"none","sortText":"00004","insertText":"term_setapi(${1:buf}, ${2:expr})${0}","insertTextFormat":2},{"label":"term_setansicolors","kind":3,"detail":"none","sortText":"00004","insertText":"term_setansicolors(${1:buf}, ${2:colors})${0}","insertTextFormat":2},{"label":"term_setkill","kind":3,"detail":"none","sortText":"00004","insertText":"term_setkill(${1:buf}, ${2:how})${0}","insertTextFormat":2},{"label":"term_setrestore","kind":3,"detail":"none","sortText":"00004","insertText":"term_setrestore(${1:buf}, ${2:command})${0}","insertTextFormat":2},{"label":"term_setsize","kind":3,"detail":"none","sortText":"00004","insertText":"term_setsize(${1:buf}, ${2:rows}, ${3:cols})${0}","insertTextFormat":2},{"label":"term_start","kind":3,"detail":"Number","sortText":"00004","insertText":"term_start(${1:cmd})${0}","insertTextFormat":2},{"label":"term_wait","kind":3,"detail":"Number","sortText":"00004","insertText":"term_wait(${1:buf})${0}","insertTextFormat":2},{"label":"test_alloc_fail","kind":3,"detail":"none","sortText":"00004","insertText":"test_alloc_fail(${1:id}, ${2:countdown}, ${3:repeat})${0}","insertTextFormat":2},{"label":"test_autochdir","kind":3,"detail":"none","sortText":"00004","insertText":"test_autochdir(${0})","insertTextFormat":2},{"label":"test_feedinput","kind":3,"detail":"none","sortText":"00004","insertText":"test_feedinput(${1:string})${0}","insertTextFormat":2},{"label":"test_garbagecollect_soon","kind":3,"detail":"none","sortText":"00004","insertText":"test_garbagecollect_soon(${0})","insertTextFormat":2},{"label":"test_getvalue","kind":3,"detail":"any","sortText":"00004","insertText":"test_getvalue(${1:string})${0}","insertTextFormat":2},{"label":"test_ignore_error","kind":3,"detail":"none","sortText":"00004","insertText":"test_ignore_error(${1:expr})${0}","insertTextFormat":2},{"label":"test_null_blob","kind":3,"detail":"Blob","sortText":"00004","insertText":"test_null_blob(${0})","insertTextFormat":2},{"label":"test_null_channel","kind":3,"detail":"Channel","sortText":"00004","insertText":"test_null_channel(${0})","insertTextFormat":2},{"label":"test_null_dict","kind":3,"detail":"Dict","sortText":"00004","insertText":"test_null_dict(${0})","insertTextFormat":2},{"label":"test_null_job","kind":3,"detail":"Job","sortText":"00004","insertText":"test_null_job(${0})","insertTextFormat":2},{"label":"test_null_list","kind":3,"detail":"List","sortText":"00004","insertText":"test_null_list(${0})","insertTextFormat":2},{"label":"test_null_partial","kind":3,"detail":"Funcref","sortText":"00004","insertText":"test_null_partial(${0})","insertTextFormat":2},{"label":"test_null_string","kind":3,"detail":"String","sortText":"00004","insertText":"test_null_string(${0})","insertTextFormat":2},{"label":"test_option_not_set","kind":3,"detail":"none","sortText":"00004","insertText":"test_option_not_set(${1:name})${0}","insertTextFormat":2},{"label":"test_override","kind":3,"detail":"none","sortText":"00004","insertText":"test_override(${1:expr}, ${2:val})${0}","insertTextFormat":2},{"label":"test_refcount","kind":3,"detail":"Number","sortText":"00004","insertText":"test_refcount(${1:expr})${0}","insertTextFormat":2},{"label":"test_scrollbar","kind":3,"detail":"none","sortText":"00004","insertText":"test_scrollbar(${1:which}, ${2:value}, ${3:dragging})${0}","insertTextFormat":2},{"label":"test_setmouse","kind":3,"detail":"none","sortText":"00004","insertText":"test_setmouse(${1:row}, ${2:col})${0}","insertTextFormat":2},{"label":"test_settime","kind":3,"detail":"none","sortText":"00004","insertText":"test_settime(${1:expr})${0}","insertTextFormat":2},{"label":"win_execute","kind":3,"detail":"String","sortText":"00004","insertText":"win_execute(${1:id}, ${2:command})${0}","insertTextFormat":2},{"label":"win_splitmove","kind":3,"detail":"Number","sortText":"00004","insertText":"win_splitmove(${1:nr}, ${2:target})${0}","insertTextFormat":2}],"variables":[{"label":"v:beval_col","kind":6,"sortText":"00004","insertText":"beval_col","insertTextFormat":1},{"label":"v:beval_bufnr","kind":6,"sortText":"00004","insertText":"beval_bufnr","insertTextFormat":1},{"label":"v:beval_lnum","kind":6,"sortText":"00004","insertText":"beval_lnum","insertTextFormat":1},{"label":"v:beval_text","kind":6,"sortText":"00004","insertText":"beval_text","insertTextFormat":1},{"label":"v:beval_winnr","kind":6,"sortText":"00004","insertText":"beval_winnr","insertTextFormat":1},{"label":"v:beval_winid","kind":6,"sortText":"00004","insertText":"beval_winid","insertTextFormat":1},{"label":"v:char","kind":6,"sortText":"00004","insertText":"char","insertTextFormat":1},{"label":"v:cmdarg","kind":6,"sortText":"00004","insertText":"cmdarg","insertTextFormat":1},{"label":"v:cmdbang","kind":6,"sortText":"00004","insertText":"cmdbang","insertTextFormat":1},{"label":"v:count","kind":6,"sortText":"00004","insertText":"count","insertTextFormat":1},{"label":"v:count1","kind":6,"sortText":"00004","insertText":"count1","insertTextFormat":1},{"label":"v:ctype","kind":6,"sortText":"00004","insertText":"ctype","insertTextFormat":1},{"label":"v:dying","kind":6,"sortText":"00004","insertText":"dying","insertTextFormat":1},{"label":"v:exiting","kind":6,"sortText":"00004","insertText":"exiting","insertTextFormat":1},{"label":"v:echospace","kind":6,"sortText":"00004","insertText":"echospace","insertTextFormat":1},{"label":"v:errmsg","kind":6,"sortText":"00004","insertText":"errmsg","insertTextFormat":1},{"label":"v:errors","kind":6,"sortText":"00004","insertText":"errors","insertTextFormat":1},{"label":"v:event","kind":6,"sortText":"00004","insertText":"event","insertTextFormat":1},{"label":"v:exception","kind":6,"sortText":"00004","insertText":"exception","insertTextFormat":1},{"label":"v:false","kind":6,"sortText":"00004","insertText":"false","insertTextFormat":1},{"label":"v:fcs_reason","kind":6,"sortText":"00004","insertText":"fcs_reason","insertTextFormat":1},{"label":"v:fcs_choice","kind":6,"sortText":"00004","insertText":"fcs_choice","insertTextFormat":1},{"label":"v:fname_in","kind":6,"sortText":"00004","insertText":"fname_in","insertTextFormat":1},{"label":"v:fname_out","kind":6,"sortText":"00004","insertText":"fname_out","insertTextFormat":1},{"label":"v:fname_new","kind":6,"sortText":"00004","insertText":"fname_new","insertTextFormat":1},{"label":"v:fname_diff","kind":6,"sortText":"00004","insertText":"fname_diff","insertTextFormat":1},{"label":"v:folddashes","kind":6,"sortText":"00004","insertText":"folddashes","insertTextFormat":1},{"label":"v:foldlevel","kind":6,"sortText":"00004","insertText":"foldlevel","insertTextFormat":1},{"label":"v:foldend","kind":6,"sortText":"00004","insertText":"foldend","insertTextFormat":1},{"label":"v:foldstart","kind":6,"sortText":"00004","insertText":"foldstart","insertTextFormat":1},{"label":"v:hlsearch","kind":6,"sortText":"00004","insertText":"hlsearch","insertTextFormat":1},{"label":"v:insertmode","kind":6,"sortText":"00004","insertText":"insertmode","insertTextFormat":1},{"label":"v:key","kind":6,"sortText":"00004","insertText":"key","insertTextFormat":1},{"label":"v:lang","kind":6,"sortText":"00004","insertText":"lang","insertTextFormat":1},{"label":"v:lc_time","kind":6,"sortText":"00004","insertText":"lc_time","insertTextFormat":1},{"label":"v:lnum","kind":6,"sortText":"00004","insertText":"lnum","insertTextFormat":1},{"label":"v:lua","kind":6,"sortText":"00004","insertText":"lua","insertTextFormat":1},{"label":"v:mouse_win","kind":6,"sortText":"00004","insertText":"mouse_win","insertTextFormat":1},{"label":"v:mouse_winid","kind":6,"sortText":"00004","insertText":"mouse_winid","insertTextFormat":1},{"label":"v:mouse_lnum","kind":6,"sortText":"00004","insertText":"mouse_lnum","insertTextFormat":1},{"label":"v:mouse_col","kind":6,"sortText":"00004","insertText":"mouse_col","insertTextFormat":1},{"label":"v:msgpack_types","kind":6,"sortText":"00004","insertText":"msgpack_types","insertTextFormat":1},{"label":"v:null","kind":6,"sortText":"00004","insertText":"null","insertTextFormat":1},{"label":"v:oldfiles","kind":6,"sortText":"00004","insertText":"oldfiles","insertTextFormat":1},{"label":"v:option_new","kind":6,"sortText":"00004","insertText":"option_new","insertTextFormat":1},{"label":"v:option_old","kind":6,"sortText":"00004","insertText":"option_old","insertTextFormat":1},{"label":"v:option_type","kind":6,"sortText":"00004","insertText":"option_type","insertTextFormat":1},{"label":"v:operator","kind":6,"sortText":"00004","insertText":"operator","insertTextFormat":1},{"label":"v:prevcount","kind":6,"sortText":"00004","insertText":"prevcount","insertTextFormat":1},{"label":"v:profiling","kind":6,"sortText":"00004","insertText":"profiling","insertTextFormat":1},{"label":"v:progname","kind":6,"sortText":"00004","insertText":"progname","insertTextFormat":1},{"label":"v:progpath","kind":6,"sortText":"00004","insertText":"progpath","insertTextFormat":1},{"label":"v:register","kind":6,"sortText":"00004","insertText":"register","insertTextFormat":1},{"label":"v:scrollstart","kind":6,"sortText":"00004","insertText":"scrollstart","insertTextFormat":1},{"label":"v:servername","kind":6,"sortText":"00004","insertText":"servername","insertTextFormat":1},{"label":"v:searchforward","kind":6,"sortText":"00004","insertText":"searchforward","insertTextFormat":1},{"label":"v:shell_error","kind":6,"sortText":"00004","insertText":"shell_error","insertTextFormat":1},{"label":"v:statusmsg","kind":6,"sortText":"00004","insertText":"statusmsg","insertTextFormat":1},{"label":"v:stderr","kind":6,"sortText":"00004","insertText":"stderr","insertTextFormat":1},{"label":"v:swapname","kind":6,"sortText":"00004","insertText":"swapname","insertTextFormat":1},{"label":"v:swapchoice","kind":6,"sortText":"00004","insertText":"swapchoice","insertTextFormat":1},{"label":"v:swapcommand","kind":6,"sortText":"00004","insertText":"swapcommand","insertTextFormat":1},{"label":"v:t_bool","kind":6,"sortText":"00004","insertText":"t_bool","insertTextFormat":1},{"label":"v:t_dict","kind":6,"sortText":"00004","insertText":"t_dict","insertTextFormat":1},{"label":"v:t_float","kind":6,"sortText":"00004","insertText":"t_float","insertTextFormat":1},{"label":"v:t_func","kind":6,"sortText":"00004","insertText":"t_func","insertTextFormat":1},{"label":"v:t_list","kind":6,"sortText":"00004","insertText":"t_list","insertTextFormat":1},{"label":"v:t_number","kind":6,"sortText":"00004","insertText":"t_number","insertTextFormat":1},{"label":"v:t_string","kind":6,"sortText":"00004","insertText":"t_string","insertTextFormat":1},{"label":"v:termresponse","kind":6,"sortText":"00004","insertText":"termresponse","insertTextFormat":1},{"label":"v:testing","kind":6,"sortText":"00004","insertText":"testing","insertTextFormat":1},{"label":"v:this_session","kind":6,"sortText":"00004","insertText":"this_session","insertTextFormat":1},{"label":"v:throwpoint","kind":6,"sortText":"00004","insertText":"throwpoint","insertTextFormat":1},{"label":"v:true","kind":6,"sortText":"00004","insertText":"true","insertTextFormat":1},{"label":"v:val","kind":6,"sortText":"00004","insertText":"val","insertTextFormat":1},{"label":"v:version","kind":6,"sortText":"00004","insertText":"version","insertTextFormat":1},{"label":"v:vim_did_enter","kind":6,"sortText":"00004","insertText":"vim_did_enter","insertTextFormat":1},{"label":"v:warningmsg","kind":6,"sortText":"00004","insertText":"warningmsg","insertTextFormat":1},{"label":"v:windowid","kind":6,"sortText":"00004","insertText":"windowid","insertTextFormat":1},{"label":"v:argv","kind":6,"sortText":"00004","insertText":"argv","insertTextFormat":1},{"label":"v:none","kind":6,"sortText":"00004","insertText":"none","insertTextFormat":1},{"label":"v:t_channel","kind":6,"sortText":"00004","insertText":"t_channel","insertTextFormat":1},{"label":"v:t_job","kind":6,"sortText":"00004","insertText":"t_job","insertTextFormat":1},{"label":"v:t_none","kind":6,"sortText":"00004","insertText":"t_none","insertTextFormat":1},{"label":"v:t_blob","kind":6,"sortText":"00004","insertText":"t_blob","insertTextFormat":1},{"label":"v:termblinkresp","kind":6,"sortText":"00004","insertText":"termblinkresp","insertTextFormat":1},{"label":"v:termstyleresp","kind":6,"sortText":"00004","insertText":"termstyleresp","insertTextFormat":1},{"label":"v:termrbgresp","kind":6,"sortText":"00004","insertText":"termrbgresp","insertTextFormat":1},{"label":"v:termrfgresp","kind":6,"sortText":"00004","insertText":"termrfgresp","insertTextFormat":1},{"label":"v:termu7resp","kind":6,"sortText":"00004","insertText":"termu7resp","insertTextFormat":1},{"label":"v:versionlong","kind":6,"sortText":"00004","insertText":"versionlong","insertTextFormat":1}],"options":[{"label":"aleph","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"aleph","insertTextFormat":1},{"label":"allowrevins","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"allowrevins","insertTextFormat":1},{"label":"ambiwidth","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"ambiwidth","insertTextFormat":1},{"label":"autochdir","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"autochdir","insertTextFormat":1},{"label":"arabic","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"arabic","insertTextFormat":1},{"label":"arabicshape","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"arabicshape","insertTextFormat":1},{"label":"autoindent","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"autoindent","insertTextFormat":1},{"label":"autowrite","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"autowrite","insertTextFormat":1},{"label":"autowriteall","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"autowriteall","insertTextFormat":1},{"label":"background","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"background","insertTextFormat":1},{"label":"backspace","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"backspace","insertTextFormat":1},{"label":"backup","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"backup","insertTextFormat":1},{"label":"backupcopy","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"backupcopy","insertTextFormat":1},{"label":"backupdir","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"backupdir","insertTextFormat":1},{"label":"backupext","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"backupext","insertTextFormat":1},{"label":"backupskip","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"backupskip","insertTextFormat":1},{"label":"balloondelay","kind":10,"detail":"Removed.","documentation":"","sortText":"00004","insertText":"balloondelay","insertTextFormat":1},{"label":"ballooneval","kind":10,"detail":"Removed.","documentation":"","sortText":"00004","insertText":"ballooneval","insertTextFormat":1},{"label":"balloonexpr","kind":10,"detail":"Removed.","documentation":"","sortText":"00004","insertText":"balloonexpr","insertTextFormat":1},{"label":"belloff","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"belloff","insertTextFormat":1},{"label":"binary","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"binary","insertTextFormat":1},{"label":"bomb","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"bomb","insertTextFormat":1},{"label":"breakat","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"breakat","insertTextFormat":1},{"label":"breakindent","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"breakindent","insertTextFormat":1},{"label":"breakindentopt","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"breakindentopt","insertTextFormat":1},{"label":"browsedir","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"browsedir","insertTextFormat":1},{"label":"bufhidden","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"bufhidden","insertTextFormat":1},{"label":"buflisted","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"buflisted","insertTextFormat":1},{"label":"buftype","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"buftype","insertTextFormat":1},{"label":"casemap","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"casemap","insertTextFormat":1},{"label":"cdpath","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"cdpath","insertTextFormat":1},{"label":"cedit","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"cedit","insertTextFormat":1},{"label":"channel","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"channel","insertTextFormat":1},{"label":"charconvert","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"charconvert","insertTextFormat":1},{"label":"cindent","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"cindent","insertTextFormat":1},{"label":"cinkeys","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"cinkeys","insertTextFormat":1},{"label":"cinoptions","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"cinoptions","insertTextFormat":1},{"label":"cinwords","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"cinwords","insertTextFormat":1},{"label":"clipboard","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"clipboard","insertTextFormat":1},{"label":"cmdheight","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"cmdheight","insertTextFormat":1},{"label":"cmdwinheight","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"cmdwinheight","insertTextFormat":1},{"label":"colorcolumn","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"colorcolumn","insertTextFormat":1},{"label":"columns","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"columns","insertTextFormat":1},{"label":"comments","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"comments","insertTextFormat":1},{"label":"commentstring","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"commentstring","insertTextFormat":1},{"label":"complete","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"complete","insertTextFormat":1},{"label":"completefunc","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"completefunc","insertTextFormat":1},{"label":"completeopt","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"completeopt","insertTextFormat":1},{"label":"concealcursor","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"concealcursor","insertTextFormat":1},{"label":"conceallevel","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"conceallevel","insertTextFormat":1},{"label":"confirm","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"confirm","insertTextFormat":1},{"label":"copyindent","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"copyindent","insertTextFormat":1},{"label":"cpoptions","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"cpoptions","insertTextFormat":1},{"label":"cscopepathcomp","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"cscopepathcomp","insertTextFormat":1},{"label":"cscopeprg","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"cscopeprg","insertTextFormat":1},{"label":"cscopequickfix","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"cscopequickfix","insertTextFormat":1},{"label":"cscoperelative","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"cscoperelative","insertTextFormat":1},{"label":"cscopetag","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"cscopetag","insertTextFormat":1},{"label":"cscopetagorder","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"cscopetagorder","insertTextFormat":1},{"label":"cursorbind","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"cursorbind","insertTextFormat":1},{"label":"cursorcolumn","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"cursorcolumn","insertTextFormat":1},{"label":"cursorline","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"cursorline","insertTextFormat":1},{"label":"debug","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"debug","insertTextFormat":1},{"label":"define","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"define","insertTextFormat":1},{"label":"delcombine","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"delcombine","insertTextFormat":1},{"label":"dictionary","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"dictionary","insertTextFormat":1},{"label":"diff","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"diff","insertTextFormat":1},{"label":"diffexpr","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"diffexpr","insertTextFormat":1},{"label":"diffopt","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"diffopt","insertTextFormat":1},{"label":"digraph","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"digraph","insertTextFormat":1},{"label":"directory","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"directory","insertTextFormat":1},{"label":"display","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"display","insertTextFormat":1},{"label":"eadirection","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"eadirection","insertTextFormat":1},{"label":"emoji","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"emoji","insertTextFormat":1},{"label":"endofline","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"endofline","insertTextFormat":1},{"label":"equalalways","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"equalalways","insertTextFormat":1},{"label":"equalprg","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"equalprg","insertTextFormat":1},{"label":"errorbells","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"errorbells","insertTextFormat":1},{"label":"errorfile","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"errorfile","insertTextFormat":1},{"label":"errorformat","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"errorformat","insertTextFormat":1},{"label":"expandtab","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"expandtab","insertTextFormat":1},{"label":"fileencoding","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"fileencoding","insertTextFormat":1},{"label":"fileencodings","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"fileencodings","insertTextFormat":1},{"label":"fileformat","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"fileformat","insertTextFormat":1},{"label":"fileformats","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"fileformats","insertTextFormat":1},{"label":"fileignorecase","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"fileignorecase","insertTextFormat":1},{"label":"filetype","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"filetype","insertTextFormat":1},{"label":"fillchars","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"fillchars","insertTextFormat":1},{"label":"fixendofline","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"fixendofline","insertTextFormat":1},{"label":"foldclose","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"foldclose","insertTextFormat":1},{"label":"foldcolumn","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"foldcolumn","insertTextFormat":1},{"label":"foldenable","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"foldenable","insertTextFormat":1},{"label":"foldexpr","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"foldexpr","insertTextFormat":1},{"label":"foldignore","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"foldignore","insertTextFormat":1},{"label":"foldlevel","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"foldlevel","insertTextFormat":1},{"label":"foldlevelstart","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"foldlevelstart","insertTextFormat":1},{"label":"foldmarker","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"foldmarker","insertTextFormat":1},{"label":"foldmethod","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"foldmethod","insertTextFormat":1},{"label":"foldminlines","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"foldminlines","insertTextFormat":1},{"label":"foldnestmax","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"foldnestmax","insertTextFormat":1},{"label":"foldopen","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"foldopen","insertTextFormat":1},{"label":"foldtext","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"foldtext","insertTextFormat":1},{"label":"formatexpr","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"formatexpr","insertTextFormat":1},{"label":"formatlistpat","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"formatlistpat","insertTextFormat":1},{"label":"formatoptions","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"formatoptions","insertTextFormat":1},{"label":"formatprg","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"formatprg","insertTextFormat":1},{"label":"fsync","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"fsync","insertTextFormat":1},{"label":"gdefault","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"gdefault","insertTextFormat":1},{"label":"grepformat","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"grepformat","insertTextFormat":1},{"label":"grepprg","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"grepprg","insertTextFormat":1},{"label":"guicursor","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"guicursor","insertTextFormat":1},{"label":"guifont","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"guifont","insertTextFormat":1},{"label":"guifontwide","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"guifontwide","insertTextFormat":1},{"label":"guioptions","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"guioptions","insertTextFormat":1},{"label":"guitablabel","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"guitablabel","insertTextFormat":1},{"label":"guitabtooltip","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"guitabtooltip","insertTextFormat":1},{"label":"helpfile","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"helpfile","insertTextFormat":1},{"label":"helpheight","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"helpheight","insertTextFormat":1},{"label":"helplang","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"helplang","insertTextFormat":1},{"label":"hidden","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"hidden","insertTextFormat":1},{"label":"history","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"history","insertTextFormat":1},{"label":"hkmap","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"hkmap","insertTextFormat":1},{"label":"hkmapp","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"hkmapp","insertTextFormat":1},{"label":"hlsearch","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"hlsearch","insertTextFormat":1},{"label":"icon","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"icon","insertTextFormat":1},{"label":"iconstring","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"iconstring","insertTextFormat":1},{"label":"ignorecase","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"ignorecase","insertTextFormat":1},{"label":"imcmdline","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"imcmdline","insertTextFormat":1},{"label":"imdisable","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"imdisable","insertTextFormat":1},{"label":"iminsert","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"iminsert","insertTextFormat":1},{"label":"imsearch","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"imsearch","insertTextFormat":1},{"label":"inccommand","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"inccommand","insertTextFormat":1},{"label":"include","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"include","insertTextFormat":1},{"label":"includeexpr","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"includeexpr","insertTextFormat":1},{"label":"incsearch","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"incsearch","insertTextFormat":1},{"label":"indentexpr","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"indentexpr","insertTextFormat":1},{"label":"indentkeys","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"indentkeys","insertTextFormat":1},{"label":"infercase","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"infercase","insertTextFormat":1},{"label":"insertmode","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"insertmode","insertTextFormat":1},{"label":"isfname","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"isfname","insertTextFormat":1},{"label":"isident","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"isident","insertTextFormat":1},{"label":"iskeyword","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"iskeyword","insertTextFormat":1},{"label":"isprint","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"isprint","insertTextFormat":1},{"label":"jumpoptions","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"jumpoptions","insertTextFormat":1},{"label":"joinspaces","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"joinspaces","insertTextFormat":1},{"label":"keymap","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"keymap","insertTextFormat":1},{"label":"keymodel","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"keymodel","insertTextFormat":1},{"label":"keywordprg","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"keywordprg","insertTextFormat":1},{"label":"langmap","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"langmap","insertTextFormat":1},{"label":"langmenu","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"langmenu","insertTextFormat":1},{"label":"langremap","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"langremap","insertTextFormat":1},{"label":"laststatus","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"laststatus","insertTextFormat":1},{"label":"lazyredraw","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"lazyredraw","insertTextFormat":1},{"label":"linebreak","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"linebreak","insertTextFormat":1},{"label":"lines","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"lines","insertTextFormat":1},{"label":"linespace","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"linespace","insertTextFormat":1},{"label":"lisp","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"lisp","insertTextFormat":1},{"label":"lispwords","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"lispwords","insertTextFormat":1},{"label":"list","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"list","insertTextFormat":1},{"label":"listchars","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"listchars","insertTextFormat":1},{"label":"loadplugins","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"loadplugins","insertTextFormat":1},{"label":"magic","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"magic","insertTextFormat":1},{"label":"makeef","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"makeef","insertTextFormat":1},{"label":"makeencoding","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"makeencoding","insertTextFormat":1},{"label":"makeprg","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"makeprg","insertTextFormat":1},{"label":"matchpairs","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"matchpairs","insertTextFormat":1},{"label":"matchtime","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"matchtime","insertTextFormat":1},{"label":"maxcombine","kind":10,"detail":"Removed.","documentation":"","sortText":"00004","insertText":"maxcombine","insertTextFormat":1},{"label":"maxfuncdepth","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"maxfuncdepth","insertTextFormat":1},{"label":"maxmapdepth","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"maxmapdepth","insertTextFormat":1},{"label":"maxmempattern","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"maxmempattern","insertTextFormat":1},{"label":"menuitems","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"menuitems","insertTextFormat":1},{"label":"mkspellmem","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"mkspellmem","insertTextFormat":1},{"label":"modeline","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"modeline","insertTextFormat":1},{"label":"modelineexpr","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"modelineexpr","insertTextFormat":1},{"label":"modelines","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"modelines","insertTextFormat":1},{"label":"modifiable","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"modifiable","insertTextFormat":1},{"label":"modified","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"modified","insertTextFormat":1},{"label":"more","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"more","insertTextFormat":1},{"label":"mouse","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"mouse","insertTextFormat":1},{"label":"mousefocus","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"mousefocus","insertTextFormat":1},{"label":"mousehide","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"mousehide","insertTextFormat":1},{"label":"mousemodel","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"mousemodel","insertTextFormat":1},{"label":"mouseshape","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"mouseshape","insertTextFormat":1},{"label":"mousetime","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"mousetime","insertTextFormat":1},{"label":"nrformats","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"nrformats","insertTextFormat":1},{"label":"number","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"number","insertTextFormat":1},{"label":"numberwidth","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"numberwidth","insertTextFormat":1},{"label":"omnifunc","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"omnifunc","insertTextFormat":1},{"label":"opendevice","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"opendevice","insertTextFormat":1},{"label":"operatorfunc","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"operatorfunc","insertTextFormat":1},{"label":"packpath","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"packpath","insertTextFormat":1},{"label":"paragraphs","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"paragraphs","insertTextFormat":1},{"label":"paste","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"paste","insertTextFormat":1},{"label":"pastetoggle","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"pastetoggle","insertTextFormat":1},{"label":"patchexpr","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"patchexpr","insertTextFormat":1},{"label":"patchmode","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"patchmode","insertTextFormat":1},{"label":"path","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"path","insertTextFormat":1},{"label":"preserveindent","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"preserveindent","insertTextFormat":1},{"label":"previewheight","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"previewheight","insertTextFormat":1},{"label":"previewwindow","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"previewwindow","insertTextFormat":1},{"label":"printdevice","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"printdevice","insertTextFormat":1},{"label":"printencoding","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"printencoding","insertTextFormat":1},{"label":"printexpr","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"printexpr","insertTextFormat":1},{"label":"printfont","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"printfont","insertTextFormat":1},{"label":"printheader","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"printheader","insertTextFormat":1},{"label":"printmbcharset","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"printmbcharset","insertTextFormat":1},{"label":"printmbfont","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"printmbfont","insertTextFormat":1},{"label":"printoptions","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"printoptions","insertTextFormat":1},{"label":"prompt","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"prompt","insertTextFormat":1},{"label":"pumblend","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"pumblend","insertTextFormat":1},{"label":"pumheight","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"pumheight","insertTextFormat":1},{"label":"pumwidth","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"pumwidth","insertTextFormat":1},{"label":"pyxversion","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"pyxversion","insertTextFormat":1},{"label":"quoteescape","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"quoteescape","insertTextFormat":1},{"label":"readonly","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"readonly","insertTextFormat":1},{"label":"redrawdebug","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"redrawdebug","insertTextFormat":1},{"label":"redrawtime","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"redrawtime","insertTextFormat":1},{"label":"regexpengine","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"regexpengine","insertTextFormat":1},{"label":"relativenumber","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"relativenumber","insertTextFormat":1},{"label":"remap","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"remap","insertTextFormat":1},{"label":"report","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"report","insertTextFormat":1},{"label":"revins","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"revins","insertTextFormat":1},{"label":"rightleft","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"rightleft","insertTextFormat":1},{"label":"rightleftcmd","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"rightleftcmd","insertTextFormat":1},{"label":"ruler","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"ruler","insertTextFormat":1},{"label":"rulerformat","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"rulerformat","insertTextFormat":1},{"label":"runtimepath","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"runtimepath","insertTextFormat":1},{"label":"scroll","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"scroll","insertTextFormat":1},{"label":"scrollback","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"scrollback","insertTextFormat":1},{"label":"scrollbind","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"scrollbind","insertTextFormat":1},{"label":"scrolljump","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"scrolljump","insertTextFormat":1},{"label":"scrolloff","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"scrolloff","insertTextFormat":1},{"label":"scrollopt","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"scrollopt","insertTextFormat":1},{"label":"sections","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"sections","insertTextFormat":1},{"label":"secure","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"secure","insertTextFormat":1},{"label":"selection","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"selection","insertTextFormat":1},{"label":"selectmode","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"selectmode","insertTextFormat":1},{"label":"sessionoptions","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"sessionoptions","insertTextFormat":1},{"label":"shada","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"shada","insertTextFormat":1},{"label":"shadafile","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"shadafile","insertTextFormat":1},{"label":"shell","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"shell","insertTextFormat":1},{"label":"shellcmdflag","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"shellcmdflag","insertTextFormat":1},{"label":"shellpipe","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"shellpipe","insertTextFormat":1},{"label":"shellquote","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"shellquote","insertTextFormat":1},{"label":"shellredir","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"shellredir","insertTextFormat":1},{"label":"shelltemp","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"shelltemp","insertTextFormat":1},{"label":"shellxescape","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"shellxescape","insertTextFormat":1},{"label":"shellxquote","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"shellxquote","insertTextFormat":1},{"label":"shiftround","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"shiftround","insertTextFormat":1},{"label":"shiftwidth","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"shiftwidth","insertTextFormat":1},{"label":"shortmess","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"shortmess","insertTextFormat":1},{"label":"showbreak","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"showbreak","insertTextFormat":1},{"label":"showcmd","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"showcmd","insertTextFormat":1},{"label":"showfulltag","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"showfulltag","insertTextFormat":1},{"label":"showmatch","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"showmatch","insertTextFormat":1},{"label":"showmode","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"showmode","insertTextFormat":1},{"label":"showtabline","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"showtabline","insertTextFormat":1},{"label":"sidescroll","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"sidescroll","insertTextFormat":1},{"label":"sidescrolloff","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"sidescrolloff","insertTextFormat":1},{"label":"signcolumn","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"signcolumn","insertTextFormat":1},{"label":"smartcase","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"smartcase","insertTextFormat":1},{"label":"smartindent","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"smartindent","insertTextFormat":1},{"label":"smarttab","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"smarttab","insertTextFormat":1},{"label":"softtabstop","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"softtabstop","insertTextFormat":1},{"label":"spell","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"spell","insertTextFormat":1},{"label":"spellcapcheck","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"spellcapcheck","insertTextFormat":1},{"label":"spellfile","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"spellfile","insertTextFormat":1},{"label":"spelllang","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"spelllang","insertTextFormat":1},{"label":"spellsuggest","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"spellsuggest","insertTextFormat":1},{"label":"splitbelow","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"splitbelow","insertTextFormat":1},{"label":"splitright","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"splitright","insertTextFormat":1},{"label":"startofline","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"startofline","insertTextFormat":1},{"label":"statusline","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"statusline","insertTextFormat":1},{"label":"suffixes","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"suffixes","insertTextFormat":1},{"label":"swapfile","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"swapfile","insertTextFormat":1},{"label":"switchbuf","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"switchbuf","insertTextFormat":1},{"label":"synmaxcol","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"synmaxcol","insertTextFormat":1},{"label":"syntax","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"syntax","insertTextFormat":1},{"label":"tabline","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"tabline","insertTextFormat":1},{"label":"tabpagemax","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"tabpagemax","insertTextFormat":1},{"label":"tabstop","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"tabstop","insertTextFormat":1},{"label":"tagbsearch","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"tagbsearch","insertTextFormat":1},{"label":"tagcase","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"tagcase","insertTextFormat":1},{"label":"tagfunc","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"tagfunc","insertTextFormat":1},{"label":"taglength","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"taglength","insertTextFormat":1},{"label":"tagrelative","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"tagrelative","insertTextFormat":1},{"label":"tags","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"tags","insertTextFormat":1},{"label":"tagstack","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"tagstack","insertTextFormat":1},{"label":"termbidi","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"termbidi","insertTextFormat":1},{"label":"termguicolors","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"termguicolors","insertTextFormat":1},{"label":"terse","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"terse","insertTextFormat":1},{"label":"textwidth","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"textwidth","insertTextFormat":1},{"label":"thesaurus","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"thesaurus","insertTextFormat":1},{"label":"tildeop","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"tildeop","insertTextFormat":1},{"label":"timeout","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"timeout","insertTextFormat":1},{"label":"ttimeout","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"ttimeout","insertTextFormat":1},{"label":"timeoutlen","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"timeoutlen","insertTextFormat":1},{"label":"ttimeoutlen","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"ttimeoutlen","insertTextFormat":1},{"label":"title","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"title","insertTextFormat":1},{"label":"titlelen","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"titlelen","insertTextFormat":1},{"label":"titlestring","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"titlestring","insertTextFormat":1},{"label":"ttyfast","kind":10,"detail":"Removed.","documentation":"","sortText":"00004","insertText":"ttyfast","insertTextFormat":1},{"label":"undodir","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"undodir","insertTextFormat":1},{"label":"undofile","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"undofile","insertTextFormat":1},{"label":"undolevels","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"undolevels","insertTextFormat":1},{"label":"undoreload","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"undoreload","insertTextFormat":1},{"label":"updatecount","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"updatecount","insertTextFormat":1},{"label":"updatetime","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"updatetime","insertTextFormat":1},{"label":"verbose","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"verbose","insertTextFormat":1},{"label":"verbosefile","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"verbosefile","insertTextFormat":1},{"label":"viewdir","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"viewdir","insertTextFormat":1},{"label":"viewoptions","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"viewoptions","insertTextFormat":1},{"label":"virtualedit","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"virtualedit","insertTextFormat":1},{"label":"visualbell","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"visualbell","insertTextFormat":1},{"label":"warn","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"warn","insertTextFormat":1},{"label":"whichwrap","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"whichwrap","insertTextFormat":1},{"label":"wildchar","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"wildchar","insertTextFormat":1},{"label":"wildcharm","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"wildcharm","insertTextFormat":1},{"label":"wildignore","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"wildignore","insertTextFormat":1},{"label":"wildignorecase","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"wildignorecase","insertTextFormat":1},{"label":"wildmenu","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"wildmenu","insertTextFormat":1},{"label":"wildmode","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"wildmode","insertTextFormat":1},{"label":"wildoptions","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"wildoptions","insertTextFormat":1},{"label":"winaltkeys","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"winaltkeys","insertTextFormat":1},{"label":"winblend","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"winblend","insertTextFormat":1},{"label":"window","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"window","insertTextFormat":1},{"label":"winheight","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"winheight","insertTextFormat":1},{"label":"winhighlight","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"winhighlight","insertTextFormat":1},{"label":"winfixheight","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"winfixheight","insertTextFormat":1},{"label":"winfixwidth","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"winfixwidth","insertTextFormat":1},{"label":"winminheight","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"winminheight","insertTextFormat":1},{"label":"winminwidth","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"winminwidth","insertTextFormat":1},{"label":"winwidth","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"winwidth","insertTextFormat":1},{"label":"wrap","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"wrap","insertTextFormat":1},{"label":"wrapmargin","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"wrapmargin","insertTextFormat":1},{"label":"wrapscan","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"wrapscan","insertTextFormat":1},{"label":"write","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"write","insertTextFormat":1},{"label":"writeany","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"writeany","insertTextFormat":1},{"label":"writebackup","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"writebackup","insertTextFormat":1},{"label":"writedelay","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"writedelay","insertTextFormat":1},{"label":"altkeymap","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"altkeymap","insertTextFormat":1},{"label":"antialias","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"antialias","insertTextFormat":1},{"label":"balloonevalterm","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"balloonevalterm","insertTextFormat":1},{"label":"bioskey","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"bioskey","insertTextFormat":1},{"label":"compatible","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"compatible","insertTextFormat":1},{"label":"completeslash","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"completeslash","insertTextFormat":1},{"label":"completepopup","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"completepopup","insertTextFormat":1},{"label":"conskey","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"conskey","insertTextFormat":1},{"label":"cryptmethod","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"cryptmethod","insertTextFormat":1},{"label":"cscopeverbose","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"cscopeverbose","insertTextFormat":1},{"label":"cursorlineopt","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"cursorlineopt","insertTextFormat":1},{"label":"edcompatible","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"edcompatible","insertTextFormat":1},{"label":"encoding","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"encoding","insertTextFormat":1},{"label":"esckeys","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"esckeys","insertTextFormat":1},{"label":"exrc","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"exrc","insertTextFormat":1},{"label":"fkmap","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"fkmap","insertTextFormat":1},{"label":"guiheadroom","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"guiheadroom","insertTextFormat":1},{"label":"guipty","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"guipty","insertTextFormat":1},{"label":"highlight","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"highlight","insertTextFormat":1},{"label":"imactivatefunc","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"imactivatefunc","insertTextFormat":1},{"label":"imactivatekey","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"imactivatekey","insertTextFormat":1},{"label":"imstatusfunc","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"imstatusfunc","insertTextFormat":1},{"label":"imstyle","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"imstyle","insertTextFormat":1},{"label":"key","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"key","insertTextFormat":1},{"label":"langnoremap","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"langnoremap","insertTextFormat":1},{"label":"luadll","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"luadll","insertTextFormat":1},{"label":"macatsui","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"macatsui","insertTextFormat":1},{"label":"maxmem","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"maxmem","insertTextFormat":1},{"label":"maxmemtot","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"maxmemtot","insertTextFormat":1},{"label":"mzschemedll","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"mzschemedll","insertTextFormat":1},{"label":"mzschemegcdll","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"mzschemegcdll","insertTextFormat":1},{"label":"mzquantum","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"mzquantum","insertTextFormat":1},{"label":"osfiletype","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"osfiletype","insertTextFormat":1},{"label":"perldll","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"perldll","insertTextFormat":1},{"label":"previewpopup","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"previewpopup","insertTextFormat":1},{"label":"pythondll","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"pythondll","insertTextFormat":1},{"label":"pythonhome","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"pythonhome","insertTextFormat":1},{"label":"renderoptions","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"renderoptions","insertTextFormat":1},{"label":"restorescreen","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"restorescreen","insertTextFormat":1},{"label":"rubydll","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"rubydll","insertTextFormat":1},{"label":"scrollfocus","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"scrollfocus","insertTextFormat":1},{"label":"shelltype","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"shelltype","insertTextFormat":1},{"label":"shortname","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"shortname","insertTextFormat":1},{"label":"swapsync","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"swapsync","insertTextFormat":1},{"label":"tcldll","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"tcldll","insertTextFormat":1},{"label":"term","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"term","insertTextFormat":1},{"label":"termencoding","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"termencoding","insertTextFormat":1},{"label":"termwinkey","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"termwinkey","insertTextFormat":1},{"label":"termwinscroll","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"termwinscroll","insertTextFormat":1},{"label":"termwinsize","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"termwinsize","insertTextFormat":1},{"label":"termwintype","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"termwintype","insertTextFormat":1},{"label":"textauto","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"textauto","insertTextFormat":1},{"label":"textmode","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"textmode","insertTextFormat":1},{"label":"toolbar","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"toolbar","insertTextFormat":1},{"label":"toolbariconsize","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"toolbariconsize","insertTextFormat":1},{"label":"ttybuiltin","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"ttybuiltin","insertTextFormat":1},{"label":"ttymouse","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"ttymouse","insertTextFormat":1},{"label":"ttyscroll","kind":10,"detail":"number","documentation":"","sortText":"00004","insertText":"ttyscroll","insertTextFormat":1},{"label":"ttytype","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"ttytype","insertTextFormat":1},{"label":"varsofttabstop","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"varsofttabstop","insertTextFormat":1},{"label":"vartabstop","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"vartabstop","insertTextFormat":1},{"label":"viminfo","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"viminfo","insertTextFormat":1},{"label":"viminfofile","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"viminfofile","insertTextFormat":1},{"label":"weirdinvert","kind":10,"detail":"boolean","documentation":"","sortText":"00004","insertText":"weirdinvert","insertTextFormat":1},{"label":"wincolor","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"wincolor","insertTextFormat":1},{"label":"winptydll","kind":10,"detail":"string","documentation":"","sortText":"00004","insertText":"winptydll","insertTextFormat":1}],"features":[{"label":"acl","kind":20,"documentation":"","sortText":"00004","insertText":"acl","insertTextFormat":1},{"label":"bsd","kind":20,"documentation":"","sortText":"00004","insertText":"bsd","insertTextFormat":1},{"label":"iconv","kind":20,"documentation":"","sortText":"00004","insertText":"iconv","insertTextFormat":1},{"label":"+shellslash","kind":20,"documentation":"","sortText":"00004","insertText":"+shellslash","insertTextFormat":1},{"label":"clipboard","kind":20,"documentation":"","sortText":"00004","insertText":"clipboard","insertTextFormat":1},{"label":"mac","kind":20,"documentation":"","sortText":"00004","insertText":"mac","insertTextFormat":1},{"label":"nvim","kind":20,"documentation":"","sortText":"00004","insertText":"nvim","insertTextFormat":1},{"label":"python2","kind":20,"documentation":"","sortText":"00004","insertText":"python2","insertTextFormat":1},{"label":"python3","kind":20,"documentation":"","sortText":"00004","insertText":"python3","insertTextFormat":1},{"label":"pythonx","kind":20,"documentation":"","sortText":"00004","insertText":"pythonx","insertTextFormat":1},{"label":"ttyin","kind":20,"documentation":"","sortText":"00004","insertText":"ttyin","insertTextFormat":1},{"label":"ttyout","kind":20,"documentation":"","sortText":"00004","insertText":"ttyout","insertTextFormat":1},{"label":"unix","kind":20,"documentation":"","sortText":"00004","insertText":"unix","insertTextFormat":1},{"label":"vim_starting","kind":20,"documentation":"","sortText":"00004","insertText":"vim_starting","insertTextFormat":1},{"label":"win32","kind":20,"documentation":"","sortText":"00004","insertText":"win32","insertTextFormat":1},{"label":"win64","kind":20,"documentation":"","sortText":"00004","insertText":"win64","insertTextFormat":1},{"label":"wsl","kind":20,"documentation":"","sortText":"00004","insertText":"wsl","insertTextFormat":1},{"label":"all_builtin_terms","kind":20,"documentation":"","sortText":"00004","insertText":"all_builtin_terms","insertTextFormat":1},{"label":"amiga","kind":20,"documentation":"","sortText":"00004","insertText":"amiga","insertTextFormat":1},{"label":"arabic","kind":20,"documentation":"","sortText":"00004","insertText":"arabic","insertTextFormat":1},{"label":"arp","kind":20,"documentation":"","sortText":"00004","insertText":"arp","insertTextFormat":1},{"label":"autocmd","kind":20,"documentation":"","sortText":"00004","insertText":"autocmd","insertTextFormat":1},{"label":"autochdir","kind":20,"documentation":"","sortText":"00004","insertText":"autochdir","insertTextFormat":1},{"label":"autoservername","kind":20,"documentation":"","sortText":"00004","insertText":"autoservername","insertTextFormat":1},{"label":"balloon_eval","kind":20,"documentation":"","sortText":"00004","insertText":"balloon_eval","insertTextFormat":1},{"label":"balloon_multiline","kind":20,"documentation":"","sortText":"00004","insertText":"balloon_multiline","insertTextFormat":1},{"label":"beos","kind":20,"documentation":"","sortText":"00004","insertText":"beos","insertTextFormat":1},{"label":"browse","kind":20,"documentation":"","sortText":"00004","insertText":"browse","insertTextFormat":1},{"label":"browsefilter","kind":20,"documentation":"","sortText":"00004","insertText":"browsefilter","insertTextFormat":1},{"label":"builtin_terms","kind":20,"documentation":"","sortText":"00004","insertText":"builtin_terms","insertTextFormat":1},{"label":"byte_offset","kind":20,"documentation":"","sortText":"00004","insertText":"byte_offset","insertTextFormat":1},{"label":"cindent","kind":20,"documentation":"","sortText":"00004","insertText":"cindent","insertTextFormat":1},{"label":"clientserver","kind":20,"documentation":"","sortText":"00004","insertText":"clientserver","insertTextFormat":1},{"label":"clipboard_working","kind":20,"documentation":"","sortText":"00004","insertText":"clipboard_working","insertTextFormat":1},{"label":"cmdline_compl","kind":20,"documentation":"","sortText":"00004","insertText":"cmdline_compl","insertTextFormat":1},{"label":"cmdline_hist","kind":20,"documentation":"","sortText":"00004","insertText":"cmdline_hist","insertTextFormat":1},{"label":"cmdline_info","kind":20,"documentation":"","sortText":"00004","insertText":"cmdline_info","insertTextFormat":1},{"label":"comments","kind":20,"documentation":"","sortText":"00004","insertText":"comments","insertTextFormat":1},{"label":"compatible","kind":20,"documentation":"","sortText":"00004","insertText":"compatible","insertTextFormat":1},{"label":"conpty","kind":20,"documentation":"","sortText":"00004","insertText":"conpty","insertTextFormat":1},{"label":"cryptv","kind":20,"documentation":"","sortText":"00004","insertText":"cryptv","insertTextFormat":1},{"label":"cscope","kind":20,"documentation":"","sortText":"00004","insertText":"cscope","insertTextFormat":1},{"label":"cursorbind","kind":20,"documentation":"","sortText":"00004","insertText":"cursorbind","insertTextFormat":1},{"label":"debug","kind":20,"documentation":"","sortText":"00004","insertText":"debug","insertTextFormat":1},{"label":"dialog_con","kind":20,"documentation":"","sortText":"00004","insertText":"dialog_con","insertTextFormat":1},{"label":"dialog_gui","kind":20,"documentation":"","sortText":"00004","insertText":"dialog_gui","insertTextFormat":1},{"label":"diff","kind":20,"documentation":"","sortText":"00004","insertText":"diff","insertTextFormat":1},{"label":"digraphs","kind":20,"documentation":"","sortText":"00004","insertText":"digraphs","insertTextFormat":1},{"label":"directx","kind":20,"documentation":"","sortText":"00004","insertText":"directx","insertTextFormat":1},{"label":"dnd","kind":20,"documentation":"","sortText":"00004","insertText":"dnd","insertTextFormat":1},{"label":"ebcdic","kind":20,"documentation":"","sortText":"00004","insertText":"ebcdic","insertTextFormat":1},{"label":"emacs_tags","kind":20,"documentation":"","sortText":"00004","insertText":"emacs_tags","insertTextFormat":1},{"label":"eval","kind":20,"documentation":"","sortText":"00004","insertText":"eval","insertTextFormat":1},{"label":"true,","kind":20,"documentation":"","sortText":"00004","insertText":"true,","insertTextFormat":1},{"label":"ex_extra","kind":20,"documentation":"","sortText":"00004","insertText":"ex_extra","insertTextFormat":1},{"label":"extra_search","kind":20,"documentation":"","sortText":"00004","insertText":"extra_search","insertTextFormat":1},{"label":"farsi","kind":20,"documentation":"","sortText":"00004","insertText":"farsi","insertTextFormat":1},{"label":"file_in_path","kind":20,"documentation":"","sortText":"00004","insertText":"file_in_path","insertTextFormat":1},{"label":"filterpipe","kind":20,"documentation":"","sortText":"00004","insertText":"filterpipe","insertTextFormat":1},{"label":"read/write/filter","kind":20,"documentation":"","sortText":"00004","insertText":"read/write/filter","insertTextFormat":1},{"label":"find_in_path","kind":20,"documentation":"","sortText":"00004","insertText":"find_in_path","insertTextFormat":1},{"label":"float","kind":20,"documentation":"","sortText":"00004","insertText":"float","insertTextFormat":1},{"label":"fname_case","kind":20,"documentation":"","sortText":"00004","insertText":"fname_case","insertTextFormat":1},{"label":"Windows","kind":20,"documentation":"","sortText":"00004","insertText":"Windows","insertTextFormat":1},{"label":"folding","kind":20,"documentation":"","sortText":"00004","insertText":"folding","insertTextFormat":1},{"label":"footer","kind":20,"documentation":"","sortText":"00004","insertText":"footer","insertTextFormat":1},{"label":"fork","kind":20,"documentation":"","sortText":"00004","insertText":"fork","insertTextFormat":1},{"label":"gettext","kind":20,"documentation":"","sortText":"00004","insertText":"gettext","insertTextFormat":1},{"label":"gui","kind":20,"documentation":"","sortText":"00004","insertText":"gui","insertTextFormat":1},{"label":"gui_athena","kind":20,"documentation":"","sortText":"00004","insertText":"gui_athena","insertTextFormat":1},{"label":"gui_gnome","kind":20,"documentation":"","sortText":"00004","insertText":"gui_gnome","insertTextFormat":1},{"label":"gui_gtk","kind":20,"documentation":"","sortText":"00004","insertText":"gui_gtk","insertTextFormat":1},{"label":"gui_gtk2","kind":20,"documentation":"","sortText":"00004","insertText":"gui_gtk2","insertTextFormat":1},{"label":"gui_gtk3","kind":20,"documentation":"","sortText":"00004","insertText":"gui_gtk3","insertTextFormat":1},{"label":"gui_mac","kind":20,"documentation":"","sortText":"00004","insertText":"gui_mac","insertTextFormat":1},{"label":"gui_motif","kind":20,"documentation":"","sortText":"00004","insertText":"gui_motif","insertTextFormat":1},{"label":"gui_photon","kind":20,"documentation":"","sortText":"00004","insertText":"gui_photon","insertTextFormat":1},{"label":"gui_running","kind":20,"documentation":"","sortText":"00004","insertText":"gui_running","insertTextFormat":1},{"label":"gui_win32","kind":20,"documentation":"","sortText":"00004","insertText":"gui_win32","insertTextFormat":1},{"label":"gui_win32s","kind":20,"documentation":"","sortText":"00004","insertText":"gui_win32s","insertTextFormat":1},{"label":"hangul_input","kind":20,"documentation":"","sortText":"00004","insertText":"hangul_input","insertTextFormat":1},{"label":"hpux","kind":20,"documentation":"","sortText":"00004","insertText":"hpux","insertTextFormat":1},{"label":"insert_expand","kind":20,"documentation":"","sortText":"00004","insertText":"insert_expand","insertTextFormat":1},{"label":"Insert","kind":20,"documentation":"","sortText":"00004","insertText":"Insert","insertTextFormat":1},{"label":"jumplist","kind":20,"documentation":"","sortText":"00004","insertText":"jumplist","insertTextFormat":1},{"label":"keymap","kind":20,"documentation":"","sortText":"00004","insertText":"keymap","insertTextFormat":1},{"label":"lambda","kind":20,"documentation":"","sortText":"00004","insertText":"lambda","insertTextFormat":1},{"label":"langmap","kind":20,"documentation":"","sortText":"00004","insertText":"langmap","insertTextFormat":1},{"label":"libcall","kind":20,"documentation":"","sortText":"00004","insertText":"libcall","insertTextFormat":1},{"label":"linebreak","kind":20,"documentation":"","sortText":"00004","insertText":"linebreak","insertTextFormat":1},{"label":"\'breakindent\'","kind":20,"documentation":"","sortText":"00004","insertText":"\'breakindent\'","insertTextFormat":1},{"label":"linux","kind":20,"documentation":"","sortText":"00004","insertText":"linux","insertTextFormat":1},{"label":"lispindent","kind":20,"documentation":"","sortText":"00004","insertText":"lispindent","insertTextFormat":1},{"label":"listcmds","kind":20,"documentation":"","sortText":"00004","insertText":"listcmds","insertTextFormat":1},{"label":"and","kind":20,"documentation":"","sortText":"00004","insertText":"and","insertTextFormat":1},{"label":"localmap","kind":20,"documentation":"","sortText":"00004","insertText":"localmap","insertTextFormat":1},{"label":"lua","kind":20,"documentation":"","sortText":"00004","insertText":"lua","insertTextFormat":1},{"label":"macunix","kind":20,"documentation":"","sortText":"00004","insertText":"macunix","insertTextFormat":1},{"label":"menu","kind":20,"documentation":"","sortText":"00004","insertText":"menu","insertTextFormat":1},{"label":"mksession","kind":20,"documentation":"","sortText":"00004","insertText":"mksession","insertTextFormat":1},{"label":"modify_fname","kind":20,"documentation":"","sortText":"00004","insertText":"modify_fname","insertTextFormat":1},{"label":"(always","kind":20,"documentation":"","sortText":"00004","insertText":"(always","insertTextFormat":1},{"label":"mouse","kind":20,"documentation":"","sortText":"00004","insertText":"mouse","insertTextFormat":1},{"label":"mouse_dec","kind":20,"documentation":"","sortText":"00004","insertText":"mouse_dec","insertTextFormat":1},{"label":"mouse_gpm","kind":20,"documentation":"","sortText":"00004","insertText":"mouse_gpm","insertTextFormat":1},{"label":"mouse_gpm_enabled","kind":20,"documentation":"","sortText":"00004","insertText":"mouse_gpm_enabled","insertTextFormat":1},{"label":"mouse_netterm","kind":20,"documentation":"","sortText":"00004","insertText":"mouse_netterm","insertTextFormat":1},{"label":"mouse_pterm","kind":20,"documentation":"","sortText":"00004","insertText":"mouse_pterm","insertTextFormat":1},{"label":"mouse_sysmouse","kind":20,"documentation":"","sortText":"00004","insertText":"mouse_sysmouse","insertTextFormat":1},{"label":"mouse_sgr","kind":20,"documentation":"","sortText":"00004","insertText":"mouse_sgr","insertTextFormat":1},{"label":"mouse_urxvt","kind":20,"documentation":"","sortText":"00004","insertText":"mouse_urxvt","insertTextFormat":1},{"label":"mouse_xterm","kind":20,"documentation":"","sortText":"00004","insertText":"mouse_xterm","insertTextFormat":1},{"label":"mouseshape","kind":20,"documentation":"","sortText":"00004","insertText":"mouseshape","insertTextFormat":1},{"label":"multi_byte","kind":20,"documentation":"","sortText":"00004","insertText":"multi_byte","insertTextFormat":1},{"label":"multi_byte_encoding","kind":20,"documentation":"","sortText":"00004","insertText":"multi_byte_encoding","insertTextFormat":1},{"label":"multi_byte_ime","kind":20,"documentation":"","sortText":"00004","insertText":"multi_byte_ime","insertTextFormat":1},{"label":"multi_lang","kind":20,"documentation":"","sortText":"00004","insertText":"multi_lang","insertTextFormat":1},{"label":"mzscheme","kind":20,"documentation":"","sortText":"00004","insertText":"mzscheme","insertTextFormat":1},{"label":"netbeans_enabled","kind":20,"documentation":"","sortText":"00004","insertText":"netbeans_enabled","insertTextFormat":1},{"label":"netbeans_intg","kind":20,"documentation":"","sortText":"00004","insertText":"netbeans_intg","insertTextFormat":1},{"label":"num64","kind":20,"documentation":"","sortText":"00004","insertText":"num64","insertTextFormat":1},{"label":"ole","kind":20,"documentation":"","sortText":"00004","insertText":"ole","insertTextFormat":1},{"label":"osx","kind":20,"documentation":"","sortText":"00004","insertText":"osx","insertTextFormat":1},{"label":"osxdarwin","kind":20,"documentation":"","sortText":"00004","insertText":"osxdarwin","insertTextFormat":1},{"label":"packages","kind":20,"documentation":"","sortText":"00004","insertText":"packages","insertTextFormat":1},{"label":"path_extra","kind":20,"documentation":"","sortText":"00004","insertText":"path_extra","insertTextFormat":1},{"label":"perl","kind":20,"documentation":"","sortText":"00004","insertText":"perl","insertTextFormat":1},{"label":"persistent_undo","kind":20,"documentation":"","sortText":"00004","insertText":"persistent_undo","insertTextFormat":1},{"label":"postscript","kind":20,"documentation":"","sortText":"00004","insertText":"postscript","insertTextFormat":1},{"label":"printer","kind":20,"documentation":"","sortText":"00004","insertText":"printer","insertTextFormat":1},{"label":"profile","kind":20,"documentation":"","sortText":"00004","insertText":"profile","insertTextFormat":1},{"label":"python","kind":20,"documentation":"","sortText":"00004","insertText":"python","insertTextFormat":1},{"label":"python_compiled","kind":20,"documentation":"","sortText":"00004","insertText":"python_compiled","insertTextFormat":1},{"label":"python_dynamic","kind":20,"documentation":"","sortText":"00004","insertText":"python_dynamic","insertTextFormat":1},{"label":"python3_compiled","kind":20,"documentation":"","sortText":"00004","insertText":"python3_compiled","insertTextFormat":1},{"label":"python3_dynamic","kind":20,"documentation":"","sortText":"00004","insertText":"python3_dynamic","insertTextFormat":1},{"label":"qnx","kind":20,"documentation":"","sortText":"00004","insertText":"qnx","insertTextFormat":1},{"label":"quickfix","kind":20,"documentation":"","sortText":"00004","insertText":"quickfix","insertTextFormat":1},{"label":"reltime","kind":20,"documentation":"","sortText":"00004","insertText":"reltime","insertTextFormat":1},{"label":"rightleft","kind":20,"documentation":"","sortText":"00004","insertText":"rightleft","insertTextFormat":1},{"label":"ruby","kind":20,"documentation":"","sortText":"00004","insertText":"ruby","insertTextFormat":1},{"label":"scrollbind","kind":20,"documentation":"","sortText":"00004","insertText":"scrollbind","insertTextFormat":1},{"label":"showcmd","kind":20,"documentation":"","sortText":"00004","insertText":"showcmd","insertTextFormat":1},{"label":"signs","kind":20,"documentation":"","sortText":"00004","insertText":"signs","insertTextFormat":1},{"label":"smartindent","kind":20,"documentation":"","sortText":"00004","insertText":"smartindent","insertTextFormat":1},{"label":"sound","kind":20,"documentation":"","sortText":"00004","insertText":"sound","insertTextFormat":1},{"label":"spell","kind":20,"documentation":"","sortText":"00004","insertText":"spell","insertTextFormat":1},{"label":"startuptime","kind":20,"documentation":"","sortText":"00004","insertText":"startuptime","insertTextFormat":1},{"label":"statusline","kind":20,"documentation":"","sortText":"00004","insertText":"statusline","insertTextFormat":1},{"label":"sun","kind":20,"documentation":"","sortText":"00004","insertText":"sun","insertTextFormat":1},{"label":"sun_workshop","kind":20,"documentation":"","sortText":"00004","insertText":"sun_workshop","insertTextFormat":1},{"label":"syntax","kind":20,"documentation":"","sortText":"00004","insertText":"syntax","insertTextFormat":1},{"label":"syntax_items","kind":20,"documentation":"","sortText":"00004","insertText":"syntax_items","insertTextFormat":1},{"label":"current","kind":20,"documentation":"","sortText":"00004","insertText":"current","insertTextFormat":1},{"label":"system","kind":20,"documentation":"","sortText":"00004","insertText":"system","insertTextFormat":1},{"label":"tag_binary","kind":20,"documentation":"","sortText":"00004","insertText":"tag_binary","insertTextFormat":1},{"label":"tag_old_static","kind":20,"documentation":"","sortText":"00004","insertText":"tag_old_static","insertTextFormat":1},{"label":"tcl","kind":20,"documentation":"","sortText":"00004","insertText":"tcl","insertTextFormat":1},{"label":"termguicolors","kind":20,"documentation":"","sortText":"00004","insertText":"termguicolors","insertTextFormat":1},{"label":"terminal","kind":20,"documentation":"","sortText":"00004","insertText":"terminal","insertTextFormat":1},{"label":"terminfo","kind":20,"documentation":"","sortText":"00004","insertText":"terminfo","insertTextFormat":1},{"label":"termresponse","kind":20,"documentation":"","sortText":"00004","insertText":"termresponse","insertTextFormat":1},{"label":"textobjects","kind":20,"documentation":"","sortText":"00004","insertText":"textobjects","insertTextFormat":1},{"label":"textprop","kind":20,"documentation":"","sortText":"00004","insertText":"textprop","insertTextFormat":1},{"label":"tgetent","kind":20,"documentation":"","sortText":"00004","insertText":"tgetent","insertTextFormat":1},{"label":"or","kind":20,"documentation":"","sortText":"00004","insertText":"or","insertTextFormat":1},{"label":"timers","kind":20,"documentation":"","sortText":"00004","insertText":"timers","insertTextFormat":1},{"label":"title","kind":20,"documentation":"","sortText":"00004","insertText":"title","insertTextFormat":1},{"label":"toolbar","kind":20,"documentation":"","sortText":"00004","insertText":"toolbar","insertTextFormat":1},{"label":"unnamedplus","kind":20,"documentation":"","sortText":"00004","insertText":"unnamedplus","insertTextFormat":1},{"label":"user_commands","kind":20,"documentation":"","sortText":"00004","insertText":"user_commands","insertTextFormat":1},{"label":"vartabs","kind":20,"documentation":"","sortText":"00004","insertText":"vartabs","insertTextFormat":1},{"label":"vcon","kind":20,"documentation":"","sortText":"00004","insertText":"vcon","insertTextFormat":1},{"label":"\'termguicolors\'.","kind":20,"documentation":"","sortText":"00004","insertText":"\'termguicolors\'.","insertTextFormat":1},{"label":"vertsplit","kind":20,"documentation":"","sortText":"00004","insertText":"vertsplit","insertTextFormat":1},{"label":"viminfo","kind":20,"documentation":"","sortText":"00004","insertText":"viminfo","insertTextFormat":1},{"label":"vimscript-1","kind":20,"documentation":"","sortText":"00004","insertText":"vimscript-1","insertTextFormat":1},{"label":"vimscript-2","kind":20,"documentation":"","sortText":"00004","insertText":"vimscript-2","insertTextFormat":1},{"label":"vimscript-3","kind":20,"documentation":"","sortText":"00004","insertText":"vimscript-3","insertTextFormat":1},{"label":"virtualedit","kind":20,"documentation":"","sortText":"00004","insertText":"virtualedit","insertTextFormat":1},{"label":"visual","kind":20,"documentation":"","sortText":"00004","insertText":"visual","insertTextFormat":1},{"label":"visualextra","kind":20,"documentation":"","sortText":"00004","insertText":"visualextra","insertTextFormat":1},{"label":"true)","kind":20,"documentation":"","sortText":"00004","insertText":"true)","insertTextFormat":1},{"label":"vms","kind":20,"documentation":"","sortText":"00004","insertText":"vms","insertTextFormat":1},{"label":"vreplace","kind":20,"documentation":"","sortText":"00004","insertText":"vreplace","insertTextFormat":1},{"label":"vtp","kind":20,"documentation":"","sortText":"00004","insertText":"vtp","insertTextFormat":1},{"label":"out","kind":20,"documentation":"","sortText":"00004","insertText":"out","insertTextFormat":1},{"label":"wildignore","kind":20,"documentation":"","sortText":"00004","insertText":"wildignore","insertTextFormat":1},{"label":"wildmenu","kind":20,"documentation":"","sortText":"00004","insertText":"wildmenu","insertTextFormat":1},{"label":"win16","kind":20,"documentation":"","sortText":"00004","insertText":"win16","insertTextFormat":1},{"label":"64","kind":20,"documentation":"","sortText":"00004","insertText":"64","insertTextFormat":1},{"label":"win32unix","kind":20,"documentation":"","sortText":"00004","insertText":"win32unix","insertTextFormat":1},{"label":"win95","kind":20,"documentation":"","sortText":"00004","insertText":"win95","insertTextFormat":1},{"label":"winaltkeys","kind":20,"documentation":"","sortText":"00004","insertText":"winaltkeys","insertTextFormat":1},{"label":"windows","kind":20,"documentation":"","sortText":"00004","insertText":"windows","insertTextFormat":1},{"label":"writebackup","kind":20,"documentation":"","sortText":"00004","insertText":"writebackup","insertTextFormat":1},{"label":"xfontset","kind":20,"documentation":"","sortText":"00004","insertText":"xfontset","insertTextFormat":1},{"label":"xim","kind":20,"documentation":"","sortText":"00004","insertText":"xim","insertTextFormat":1},{"label":"xpm","kind":20,"documentation":"","sortText":"00004","insertText":"xpm","insertTextFormat":1},{"label":"xpm_w32","kind":20,"documentation":"","sortText":"00004","insertText":"xpm_w32","insertTextFormat":1},{"label":"backward","kind":20,"documentation":"","sortText":"00004","insertText":"backward","insertTextFormat":1},{"label":"xsmp","kind":20,"documentation":"","sortText":"00004","insertText":"xsmp","insertTextFormat":1},{"label":"xsmp_interact","kind":20,"documentation":"","sortText":"00004","insertText":"xsmp_interact","insertTextFormat":1},{"label":"xterm_clipboard","kind":20,"documentation":"","sortText":"00004","insertText":"xterm_clipboard","insertTextFormat":1},{"label":"xterm_save","kind":20,"documentation":"","sortText":"00004","insertText":"xterm_save","insertTextFormat":1},{"label":"xterm","kind":20,"documentation":"","sortText":"00004","insertText":"xterm","insertTextFormat":1},{"label":"x11","kind":20,"documentation":"","sortText":"00004","insertText":"x11","insertTextFormat":1}],"expandKeywords":[{"label":"<cfile>","kind":14,"documentation":"file name under the cursor","sortText":"00004","insertText":"<cfile>","insertTextFormat":1},{"label":"<afile>","kind":14,"documentation":"autocmd file name","sortText":"00004","insertText":"<afile>","insertTextFormat":1},{"label":"<abuf>","kind":14,"documentation":"autocmd buffer number (as a String!)","sortText":"00004","insertText":"<abuf>","insertTextFormat":1},{"label":"<amatch>","kind":14,"documentation":"autocmd matched name","sortText":"00004","insertText":"<amatch>","insertTextFormat":1},{"label":"<sfile>","kind":14,"documentation":"sourced script file or function name","sortText":"00004","insertText":"<sfile>","insertTextFormat":1},{"label":"<slnum>","kind":14,"documentation":"sourced script file line number","sortText":"00004","insertText":"<slnum>","insertTextFormat":1},{"label":"<cword>","kind":14,"documentation":"word under the cursor","sortText":"00004","insertText":"<cword>","insertTextFormat":1},{"label":"<cWORD>","kind":14,"documentation":"WORD under the cursor","sortText":"00004","insertText":"<cWORD>","insertTextFormat":1},{"label":"<client>","kind":14,"documentation":"the {clientid} of the last received message `server2client()`","sortText":"00004","insertText":"<client>","insertTextFormat":1}],"autocmds":[{"label":"BufNewFile","kind":20,"documentation":"starting to edit a file that doesn\'t exist","sortText":"00004","insertText":"BufNewFile","insertTextFormat":1},{"label":"BufReadPre","kind":20,"documentation":"starting to edit a new buffer, before reading the file","sortText":"00004","insertText":"BufReadPre","insertTextFormat":1},{"label":"BufRead","kind":20,"documentation":"starting to edit a new buffer, after reading the file","sortText":"00004","insertText":"BufRead","insertTextFormat":1},{"label":"BufReadPost","kind":20,"documentation":"starting to edit a new buffer, after reading the file","sortText":"00004","insertText":"BufReadPost","insertTextFormat":1},{"label":"BufReadCmd","kind":20,"documentation":"before starting to edit a new buffer |Cmd-event|","sortText":"00004","insertText":"BufReadCmd","insertTextFormat":1},{"label":"FileReadPre","kind":20,"documentation":"before reading a file with a \\":read\\" command","sortText":"00004","insertText":"FileReadPre","insertTextFormat":1},{"label":"FileReadPost","kind":20,"documentation":"after reading a file with a \\":read\\" command","sortText":"00004","insertText":"FileReadPost","insertTextFormat":1},{"label":"FileReadCmd","kind":20,"documentation":"before reading a file with a \\":read\\" command |Cmd-event|","sortText":"00004","insertText":"FileReadCmd","insertTextFormat":1},{"label":"FilterReadPre","kind":20,"documentation":"before reading a file from a filter command","sortText":"00004","insertText":"FilterReadPre","insertTextFormat":1},{"label":"FilterReadPost","kind":20,"documentation":"after reading a file from a filter command","sortText":"00004","insertText":"FilterReadPost","insertTextFormat":1},{"label":"StdinReadPre","kind":20,"documentation":"before reading from stdin into the buffer","sortText":"00004","insertText":"StdinReadPre","insertTextFormat":1},{"label":"StdinReadPost","kind":20,"documentation":"After reading from the stdin into the buffer","sortText":"00004","insertText":"StdinReadPost","insertTextFormat":1},{"label":"BufWrite","kind":20,"documentation":"starting to write the whole buffer to a file","sortText":"00004","insertText":"BufWrite","insertTextFormat":1},{"label":"BufWritePre","kind":20,"documentation":"starting to write the whole buffer to a file","sortText":"00004","insertText":"BufWritePre","insertTextFormat":1},{"label":"BufWritePost","kind":20,"documentation":"after writing the whole buffer to a file","sortText":"00004","insertText":"BufWritePost","insertTextFormat":1},{"label":"BufWriteCmd","kind":20,"documentation":"before writing the whole buffer to a file |Cmd-event|","sortText":"00004","insertText":"BufWriteCmd","insertTextFormat":1},{"label":"FileWritePre","kind":20,"documentation":"starting to write part of a buffer to a file","sortText":"00004","insertText":"FileWritePre","insertTextFormat":1},{"label":"FileWritePost","kind":20,"documentation":"after writing part of a buffer to a file","sortText":"00004","insertText":"FileWritePost","insertTextFormat":1},{"label":"FileWriteCmd","kind":20,"documentation":"before writing part of a buffer to a file |Cmd-event|","sortText":"00004","insertText":"FileWriteCmd","insertTextFormat":1},{"label":"FileAppendPre","kind":20,"documentation":"starting to append to a file","sortText":"00004","insertText":"FileAppendPre","insertTextFormat":1},{"label":"FileAppendPost","kind":20,"documentation":"after appending to a file","sortText":"00004","insertText":"FileAppendPost","insertTextFormat":1},{"label":"FileAppendCmd","kind":20,"documentation":"before appending to a file |Cmd-event|","sortText":"00004","insertText":"FileAppendCmd","insertTextFormat":1},{"label":"FilterWritePre","kind":20,"documentation":"starting to write a file for a filter command or diff","sortText":"00004","insertText":"FilterWritePre","insertTextFormat":1},{"label":"FilterWritePost","kind":20,"documentation":"after writing a file for a filter command or diff","sortText":"00004","insertText":"FilterWritePost","insertTextFormat":1},{"label":"BufAdd","kind":20,"documentation":"just after adding a buffer to the buffer list","sortText":"00004","insertText":"BufAdd","insertTextFormat":1},{"label":"BufDelete","kind":20,"documentation":"before deleting a buffer from the buffer list","sortText":"00004","insertText":"BufDelete","insertTextFormat":1},{"label":"BufWipeout","kind":20,"documentation":"before completely deleting a buffer","sortText":"00004","insertText":"BufWipeout","insertTextFormat":1},{"label":"BufFilePre","kind":20,"documentation":"before changing the name of the current buffer","sortText":"00004","insertText":"BufFilePre","insertTextFormat":1},{"label":"BufFilePost","kind":20,"documentation":"after changing the name of the current buffer","sortText":"00004","insertText":"BufFilePost","insertTextFormat":1},{"label":"BufEnter","kind":20,"documentation":"after entering a buffer","sortText":"00004","insertText":"BufEnter","insertTextFormat":1},{"label":"BufLeave","kind":20,"documentation":"before leaving to another buffer","sortText":"00004","insertText":"BufLeave","insertTextFormat":1},{"label":"BufWinEnter","kind":20,"documentation":"after a buffer is displayed in a window","sortText":"00004","insertText":"BufWinEnter","insertTextFormat":1},{"label":"BufWinLeave","kind":20,"documentation":"before a buffer is removed from a window","sortText":"00004","insertText":"BufWinLeave","insertTextFormat":1},{"label":"BufUnload","kind":20,"documentation":"before unloading a buffer","sortText":"00004","insertText":"BufUnload","insertTextFormat":1},{"label":"BufHidden","kind":20,"documentation":"just after a buffer has become hidden","sortText":"00004","insertText":"BufHidden","insertTextFormat":1},{"label":"BufNew","kind":20,"documentation":"just after creating a new buffer","sortText":"00004","insertText":"BufNew","insertTextFormat":1},{"label":"SwapExists","kind":20,"documentation":"detected an existing swap file","sortText":"00004","insertText":"SwapExists","insertTextFormat":1},{"label":"TermOpen","kind":20,"documentation":"starting a terminal job","sortText":"00004","insertText":"TermOpen","insertTextFormat":1},{"label":"TermEnter","kind":20,"documentation":"entering Terminal-mode","sortText":"00004","insertText":"TermEnter","insertTextFormat":1},{"label":"TermLeave","kind":20,"documentation":"leaving Terminal-mode","sortText":"00004","insertText":"TermLeave","insertTextFormat":1},{"label":"TermClose","kind":20,"documentation":"stopping a terminal job","sortText":"00004","insertText":"TermClose","insertTextFormat":1},{"label":"ChanOpen","kind":20,"documentation":"after a channel opened","sortText":"00004","insertText":"ChanOpen","insertTextFormat":1},{"label":"ChanInfo","kind":20,"documentation":"after a channel has its state changed","sortText":"00004","insertText":"ChanInfo","insertTextFormat":1},{"label":"FileType","kind":20,"documentation":"when the \'filetype\' option has been set","sortText":"00004","insertText":"FileType","insertTextFormat":1},{"label":"Syntax","kind":20,"documentation":"when the \'syntax\' option has been set","sortText":"00004","insertText":"Syntax","insertTextFormat":1},{"label":"OptionSet","kind":20,"documentation":"after setting any option","sortText":"00004","insertText":"OptionSet","insertTextFormat":1},{"label":"VimEnter","kind":20,"documentation":"after doing all the startup stuff","sortText":"00004","insertText":"VimEnter","insertTextFormat":1},{"label":"UIEnter","kind":20,"documentation":"after a UI attaches","sortText":"00004","insertText":"UIEnter","insertTextFormat":1},{"label":"UILeave","kind":20,"documentation":"after a UI detaches","sortText":"00004","insertText":"UILeave","insertTextFormat":1},{"label":"TermResponse","kind":20,"documentation":"after the terminal response to t_RV is received","sortText":"00004","insertText":"TermResponse","insertTextFormat":1},{"label":"QuitPre","kind":20,"documentation":"when using `:quit`, before deciding whether to exit","sortText":"00004","insertText":"QuitPre","insertTextFormat":1},{"label":"ExitPre","kind":20,"documentation":"when using a command that may make Vim exit","sortText":"00004","insertText":"ExitPre","insertTextFormat":1},{"label":"VimLeavePre","kind":20,"documentation":"before exiting Nvim, before writing the shada file","sortText":"00004","insertText":"VimLeavePre","insertTextFormat":1},{"label":"VimLeave","kind":20,"documentation":"before exiting Nvim, after writing the shada file","sortText":"00004","insertText":"VimLeave","insertTextFormat":1},{"label":"VimResume","kind":20,"documentation":"after Nvim is resumed","sortText":"00004","insertText":"VimResume","insertTextFormat":1},{"label":"VimSuspend","kind":20,"documentation":"before Nvim is suspended","sortText":"00004","insertText":"VimSuspend","insertTextFormat":1},{"label":"DiffUpdated","kind":20,"documentation":"after diffs have been updated","sortText":"00004","insertText":"DiffUpdated","insertTextFormat":1},{"label":"DirChanged","kind":20,"documentation":"after the |current-directory| was changed","sortText":"00004","insertText":"DirChanged","insertTextFormat":1},{"label":"FileChangedShell","kind":20,"documentation":"Vim notices that a file changed since editing started","sortText":"00004","insertText":"FileChangedShell","insertTextFormat":1},{"label":"FileChangedShellPost","kind":20,"documentation":"after handling a file changed since editing started","sortText":"00004","insertText":"FileChangedShellPost","insertTextFormat":1},{"label":"FileChangedRO","kind":20,"documentation":"before making the first change to a read-only file","sortText":"00004","insertText":"FileChangedRO","insertTextFormat":1},{"label":"ShellCmdPost","kind":20,"documentation":"after executing a shell command","sortText":"00004","insertText":"ShellCmdPost","insertTextFormat":1},{"label":"ShellFilterPost","kind":20,"documentation":"after filtering with a shell command","sortText":"00004","insertText":"ShellFilterPost","insertTextFormat":1},{"label":"CmdUndefined","kind":20,"documentation":"a user command is used but it isn\'t defined","sortText":"00004","insertText":"CmdUndefined","insertTextFormat":1},{"label":"FuncUndefined","kind":20,"documentation":"a user function is used but it isn\'t defined","sortText":"00004","insertText":"FuncUndefined","insertTextFormat":1},{"label":"SpellFileMissing","kind":20,"documentation":"a spell file is used but it can\'t be found","sortText":"00004","insertText":"SpellFileMissing","insertTextFormat":1},{"label":"SourcePre","kind":20,"documentation":"before sourcing a Vim script","sortText":"00004","insertText":"SourcePre","insertTextFormat":1},{"label":"SourcePost","kind":20,"documentation":"after sourcing a Vim script","sortText":"00004","insertText":"SourcePost","insertTextFormat":1},{"label":"SourceCmd","kind":20,"documentation":"before sourcing a Vim script |Cmd-event|","sortText":"00004","insertText":"SourceCmd","insertTextFormat":1},{"label":"VimResized","kind":20,"documentation":"after the Vim window size changed","sortText":"00004","insertText":"VimResized","insertTextFormat":1},{"label":"FocusGained","kind":20,"documentation":"Nvim got focus","sortText":"00004","insertText":"FocusGained","insertTextFormat":1},{"label":"FocusLost","kind":20,"documentation":"Nvim lost focus","sortText":"00004","insertText":"FocusLost","insertTextFormat":1},{"label":"CursorHold","kind":20,"documentation":"the user doesn\'t press a key for a while","sortText":"00004","insertText":"CursorHold","insertTextFormat":1},{"label":"CursorHoldI","kind":20,"documentation":"the user doesn\'t press a key for a while in Insert mode","sortText":"00004","insertText":"CursorHoldI","insertTextFormat":1},{"label":"CursorMoved","kind":20,"documentation":"the cursor was moved in Normal mode","sortText":"00004","insertText":"CursorMoved","insertTextFormat":1},{"label":"CursorMovedI","kind":20,"documentation":"the cursor was moved in Insert mode","sortText":"00004","insertText":"CursorMovedI","insertTextFormat":1},{"label":"WinClosed","kind":20,"documentation":"after closing a window","sortText":"00004","insertText":"WinClosed","insertTextFormat":1},{"label":"WinNew","kind":20,"documentation":"after creating a new window","sortText":"00004","insertText":"WinNew","insertTextFormat":1},{"label":"WinEnter","kind":20,"documentation":"after entering another window","sortText":"00004","insertText":"WinEnter","insertTextFormat":1},{"label":"WinLeave","kind":20,"documentation":"before leaving a window","sortText":"00004","insertText":"WinLeave","insertTextFormat":1},{"label":"TabEnter","kind":20,"documentation":"after entering another tab page","sortText":"00004","insertText":"TabEnter","insertTextFormat":1},{"label":"TabLeave","kind":20,"documentation":"before leaving a tab page","sortText":"00004","insertText":"TabLeave","insertTextFormat":1},{"label":"TabNew","kind":20,"documentation":"when creating a new tab page","sortText":"00004","insertText":"TabNew","insertTextFormat":1},{"label":"TabNewEntered","kind":20,"documentation":"after entering a new tab page","sortText":"00004","insertText":"TabNewEntered","insertTextFormat":1},{"label":"TabClosed","kind":20,"documentation":"after closing a tab page","sortText":"00004","insertText":"TabClosed","insertTextFormat":1},{"label":"CmdlineChanged","kind":20,"documentation":"after a change was made to the command-line text","sortText":"00004","insertText":"CmdlineChanged","insertTextFormat":1},{"label":"CmdlineEnter","kind":20,"documentation":"after entering cmdline mode","sortText":"00004","insertText":"CmdlineEnter","insertTextFormat":1},{"label":"CmdlineLeave","kind":20,"documentation":"before leaving cmdline mode","sortText":"00004","insertText":"CmdlineLeave","insertTextFormat":1},{"label":"CmdwinEnter","kind":20,"documentation":"after entering the command-line window","sortText":"00004","insertText":"CmdwinEnter","insertTextFormat":1},{"label":"CmdwinLeave","kind":20,"documentation":"before leaving the command-line window","sortText":"00004","insertText":"CmdwinLeave","insertTextFormat":1},{"label":"InsertEnter","kind":20,"documentation":"starting Insert mode","sortText":"00004","insertText":"InsertEnter","insertTextFormat":1},{"label":"InsertChange","kind":20,"documentation":"when typing <Insert> while in Insert or Replace mode","sortText":"00004","insertText":"InsertChange","insertTextFormat":1},{"label":"InsertLeave","kind":20,"documentation":"when leaving Insert mode","sortText":"00004","insertText":"InsertLeave","insertTextFormat":1},{"label":"InsertCharPre","kind":20,"documentation":"when a character was typed in Insert mode, before","sortText":"00004","insertText":"InsertCharPre","insertTextFormat":1},{"label":"TextYankPost","kind":20,"documentation":"when some text is yanked or deleted","sortText":"00004","insertText":"TextYankPost","insertTextFormat":1},{"label":"TextChanged","kind":20,"documentation":"after a change was made to the text in Normal mode","sortText":"00004","insertText":"TextChanged","insertTextFormat":1},{"label":"TextChangedI","kind":20,"documentation":"after a change was made to the text in Insert mode","sortText":"00004","insertText":"TextChangedI","insertTextFormat":1},{"label":"TextChangedP","kind":20,"documentation":"after a change was made to the text in Insert mode","sortText":"00004","insertText":"TextChangedP","insertTextFormat":1},{"label":"ColorSchemePre","kind":20,"documentation":"before loading a color scheme","sortText":"00004","insertText":"ColorSchemePre","insertTextFormat":1},{"label":"ColorScheme","kind":20,"documentation":"after loading a color scheme","sortText":"00004","insertText":"ColorScheme","insertTextFormat":1},{"label":"RemoteReply","kind":20,"documentation":"a reply from a server Vim was received","sortText":"00004","insertText":"RemoteReply","insertTextFormat":1},{"label":"QuickFixCmdPre","kind":20,"documentation":"before a quickfix command is run","sortText":"00004","insertText":"QuickFixCmdPre","insertTextFormat":1},{"label":"QuickFixCmdPost","kind":20,"documentation":"after a quickfix command is run","sortText":"00004","insertText":"QuickFixCmdPost","insertTextFormat":1},{"label":"SessionLoadPost","kind":20,"documentation":"after loading a session file","sortText":"00004","insertText":"SessionLoadPost","insertTextFormat":1},{"label":"MenuPopup","kind":20,"documentation":"just before showing the popup menu","sortText":"00004","insertText":"MenuPopup","insertTextFormat":1},{"label":"CompleteChanged","kind":20,"documentation":"after popup menu changed, not fired on popup menu hide","sortText":"00004","insertText":"CompleteChanged","insertTextFormat":1},{"label":"CompleteDonePre","kind":20,"documentation":"after Insert mode completion is done, before clearing","sortText":"00004","insertText":"CompleteDonePre","insertTextFormat":1},{"label":"CompleteDone","kind":20,"documentation":"after Insert mode completion is done, after clearing","sortText":"00004","insertText":"CompleteDone","insertTextFormat":1},{"label":"User","kind":20,"documentation":"to be used in combination with \\":doautocmd\\"","sortText":"00004","insertText":"User","insertTextFormat":1},{"label":"Signal","kind":20,"documentation":"after Nvim receives a signal","sortText":"00004","insertText":"Signal","insertTextFormat":1},{"label":"BufCreate","kind":20,"documentation":"just after adding a buffer to the buffer list","sortText":"00004","insertText":"BufCreate","insertTextFormat":1},{"label":"EncodingChanged","kind":20,"documentation":"after the \'encoding\' option has been changed","sortText":"00004","insertText":"EncodingChanged","insertTextFormat":1},{"label":"TermChanged","kind":20,"documentation":"after the value of \'term\' has changed","sortText":"00004","insertText":"TermChanged","insertTextFormat":1},{"label":"GUIEnter","kind":20,"documentation":"after starting the GUI successfully","sortText":"00004","insertText":"GUIEnter","insertTextFormat":1},{"label":"GUIFailed","kind":20,"documentation":"after starting the GUI failed","sortText":"00004","insertText":"GUIFailed","insertTextFormat":1},{"label":"TerminalOpen","kind":20,"documentation":"after a terminal buffer was created","sortText":"00004","insertText":"TerminalOpen","insertTextFormat":1},{"label":"TerminalWinOpen","kind":20,"documentation":"after a terminal buffer was created in a new window","sortText":"00004","insertText":"TerminalWinOpen","insertTextFormat":1},{"label":"SafeState","kind":20,"documentation":"nothing pending, going to wait for the user to type a","sortText":"00004","insertText":"SafeState","insertTextFormat":1},{"label":"SafeStateAgain","kind":20,"documentation":"repeated SafeState","sortText":"00004","insertText":"SafeStateAgain","insertTextFormat":1}]},"signatureHelp":{"abs":["{expr}","Float"],"acos":["{expr}","Float"],"add":["{list}, {item}","List"],"and":["{expr}, {expr}","Number"],"append":["{lnum}, {list}","Number"],"appendbufline":["{expr}, {lnum}, {text}","Number"],"argc":["[{winid}]","Number"],"argidx":["","Number"],"arglistid":["[{winnr} [, {tabnr}]]","Number"],"argv":["[-1, {winid}]","List"],"assert_beeps":["{cmd}","Number"],"assert_equal":["{exp}, {act} [, {msg}]","Number"],"assert_equalfile":["{fname-one}, {fname-two}","Number"],"assert_exception":["{error} [, {msg}]","Number"],"assert_fails":["{cmd} [, {error}]","Number"],"assert_false":["{actual} [, {msg}]","Number"],"assert_inrange":["{lower}, {upper}, {actual} [, {msg}]","Number"],"assert_match":["{pat}, {text} [, {msg}]","Number"],"assert_notequal":["{exp}, {act} [, {msg}]","Number"],"assert_notmatch":["{pat}, {text} [, {msg}]","Number"],"assert_report":["{msg}","Number"],"assert_true":["{actual} [, {msg}]","Number"],"asin":["{expr}","Float"],"atan":["{expr}","Float"],"atan2":["{expr}, {expr}","Float"],"balloon_gettext":["","String"],"balloon_show":["{expr}","none"],"balloon_split":["{msg}","List"],"browse":["{save}, {title}, {initdir}, {default}","String"],"browsedir":["{title}, {initdir}","String"],"bufadd":["{name}","Number"],"bufexists":["{expr}","Number"],"buflisted":["{expr}","Number"],"bufload":["{expr}","Number"],"bufloaded":["{expr}","Number"],"bufname":["[{expr}]","String"],"bufnr":["[{expr} [, {create}]]","Number"],"bufwinid":["{expr}","Number"],"bufwinnr":["{expr}","Number"],"byte2line":["{byte}","Number"],"byteidx":["{expr}, {nr}","Number"],"byteidxcomp":["{expr}, {nr}","Number"],"call":["{func}, {arglist} [, {dict}]","any"],"ceil":["{expr}","Float"],"ch_canread":["{handle}","Number"],"ch_close":["{handle}","none"],"ch_close_in":["{handle}","none"],"ch_evalexpr":["{handle}, {expr} [, {options}]","any"],"ch_evalraw":["{handle}, {string} [, {options}]","any"],"ch_getbufnr":["{handle}, {what}","Number"],"ch_getjob":["{channel}","Job"],"ch_info":["{handle}","String"],"ch_log":["{msg} [, {handle}]","none"],"ch_logfile":["{fname} [, {mode}]","none"],"ch_open":["{address} [, {options}]","Channel"],"ch_read":["{handle} [, {options}]","String"],"ch_readblob":["{handle} [, {options}]","Blob"],"ch_readraw":["{handle} [, {options}]","String"],"ch_sendexpr":["{handle}, {expr} [, {options}]","any"],"ch_sendraw":["{handle}, {expr} [, {options}]","any"],"ch_setoptions":["{handle}, {options}","none"],"ch_status":["{handle} [, {options}]","String"],"changenr":["","Number"],"char2nr":["{expr}[, {utf8}]","Number"],"chdir":["{dir}","String"],"cindent":["{lnum}","Number"],"clearmatches":["","none"],"col":["{expr}","Number"],"complete":["{startcol}, {matches}","none"],"complete_add":["{expr}","Number"],"complete_check":["","Number"],"complete_info":["[{what}]","Dict"],"confirm":["{msg} [, {choices} [, {default} [, {type}]]]","Number"],"copy":["{expr}","any"],"cos":["{expr}","Float"],"cosh":["{expr}","Float"],"count":["{list}, {expr} [, {ic} [, {start}]]","Number"],"cscope_connection":["[{num}, {dbpath} [, {prepend}]]","Number"],"cursor":["{list}","Number"],"debugbreak":["{pid}","Number"],"deepcopy":["{expr} [, {noref}]","any"],"delete":["{fname} [, {flags}]","Number"],"deletebufline":["{expr}, {first}[, {last}]","Number"],"did_filetype":["","Number"],"diff_filler":["{lnum}","Number"],"diff_hlID":["{lnum}, {col}","Number"],"empty":["{expr}","Number"],"environ":["","Dict"],"escape":["{string}, {chars}","String"],"eval":["{string}","any"],"eventhandler":["","Number"],"executable":["{expr}","Number"],"execute":["{command}","String"],"exepath":["{expr}","String"],"exists":["{expr}","Number"],"extend":["{expr1}, {expr2} [, {expr3}]","List/Dict"],"exp":["{expr}","Float"],"expand":["{expr} [, {nosuf} [, {list}]]","any"],"expandcmd":["{expr}","String"],"feedkeys":["{string} [, {mode}]","Number"],"filereadable":["{file}","Number"],"filewritable":["{file}","Number"],"filter":["{expr1}, {expr2}","List/Dict"],"finddir":["{name} [, {path} [, {count}]]","String"],"findfile":["{name} [, {path} [, {count}]]","String"],"float2nr":["{expr}","Number"],"floor":["{expr}","Float"],"fmod":["{expr1}, {expr2}","Float"],"fnameescape":["{fname}","String"],"fnamemodify":["{fname}, {mods}","String"],"foldclosed":["{lnum}","Number"],"foldclosedend":["{lnum}","Number"],"foldlevel":["{lnum}","Number"],"foldtext":["","String"],"foldtextresult":["{lnum}","String"],"foreground":["","Number"],"funcref":["{name} [, {arglist}] [, {dict}]","Funcref"],"function":["{name} [, {arglist}] [, {dict}]","Funcref"],"garbagecollect":["[{atexit}]","none"],"get":["{func}, {what}","any"],"getbufinfo":["[{expr}]","List"],"getbufline":["{expr}, {lnum} [, {end}]","List"],"getbufvar":["{expr}, {varname} [, {def}]","any"],"getchangelist":["{expr}","List"],"getchar":["[expr]","Number"],"getcharmod":["","Number"],"getcharsearch":["","Dict"],"getcmdline":["","String"],"getcmdpos":["","Number"],"getcmdtype":["","String"],"getcmdwintype":["","String"],"getcompletion":["{pat}, {type} [, {filtered}]","List"],"getcurpos":["","List"],"getcwd":["[{winnr} [, {tabnr}]]","String"],"getenv":["{name}","String"],"getfontname":["[{name}]","String"],"getfperm":["{fname}","String"],"getfsize":["{fname}","Number"],"getftime":["{fname}","Number"],"getftype":["{fname}","String"],"getimstatus":["","Number"],"getjumplist":["[{winnr} [, {tabnr}]]","List"],"getline":["{lnum}, {end}","List"],"getloclist":["{nr} [, {what}]","List"],"getmatches":["","List"],"getmousepos":["","Dict"],"getpid":["","Number"],"getpos":["{expr}","List"],"getqflist":["[{what}]","List"],"getreg":["[{regname} [, 1 [, {list}]]]","String"],"getregtype":["[{regname}]","String"],"gettabinfo":["[{expr}]","List"],"gettabvar":["{nr}, {varname} [, {def}]","any"],"gettabwinvar":["{tabnr}, {winnr}, {name} [, {def}]","any"],"gettagstack":["[{nr}]","Dict"],"getwininfo":["[{winid}]","List"],"getwinpos":["[{timeout}]","List"],"getwinposx":["","Number"],"getwinposy":["","Number"],"getwinvar":["{nr}, {varname} [, {def}]","any"],"glob":["{expr} [, {nosuf} [, {list} [, {alllinks}]]]","any"],"glob2regpat":["{expr}","String"],"globpath":["{path}, {expr} [, {nosuf} [, {list} [, {alllinks}]]]","String"],"has":["{feature}","Number"],"has_key":["{dict}, {key}","Number"],"haslocaldir":["[{winnr} [, {tabnr}]]","Number"],"hasmapto":["{what} [, {mode} [, {abbr}]]","Number"],"histadd":["{history}, {item}","String"],"histdel":["{history} [, {item}]","String"],"histget":["{history} [, {index}]","String"],"histnr":["{history}","Number"],"hlexists":["{name}","Number"],"hlID":["{name}","Number"],"hostname":["","String"],"iconv":["{expr}, {from}, {to}","String"],"indent":["{lnum}","Number"],"index":["{list}, {expr} [, {start} [, {ic}]]","Number"],"input":["{prompt} [, {text} [, {completion}]]","String"],"inputdialog":["{prompt} [, {text} [, {completion}]]","String"],"inputlist":["{textlist}","Number"],"inputrestore":["","Number"],"inputsave":["","Number"],"inputsecret":["{prompt} [, {text}]","String"],"insert":["{list}, {item} [, {idx}]","List"],"interrupt":["","none"],"invert":["{expr}","Number"],"isdirectory":["{directory}","Number"],"isinf":["{expr}","Number"],"islocked":["{expr}","Number"],"isnan":["{expr}","Number"],"items":["{dict}","List"],"job_getchannel":["{job}","Channel"],"job_info":["[{job}]","Dict"],"job_setoptions":["{job}, {options}","none"],"job_start":["{command} [, {options}]","Job"],"job_status":["{job}","String"],"job_stop":["{job} [, {how}]","Number"],"join":["{list} [, {sep}]","String"],"js_decode":["{string}","any"],"js_encode":["{expr}","String"],"json_decode":["{expr}","any"],"json_encode":["{expr}","String"],"keys":["{dict}","List"],"len":["{expr}","Number"],"libcall":["{lib}, {func}, {arg}","String"],"libcallnr":["{lib}, {func}, {arg}","Number"],"line":["{expr}","Number"],"line2byte":["{lnum}","Number"],"lispindent":["{lnum}","Number"],"list2str":["{list} [, {utf8}]","String"],"listener_add":["{callback} [, {buf}]","Number"],"listener_flush":["[{buf}]","none"],"listener_remove":["{id}","none"],"localtime":["","Number"],"log":["{expr}","Float"],"log10":["{expr}","Float"],"luaeval":["{expr}[, {expr}]","any"],"map":["{expr1}, {expr2}","List/Dict"],"maparg":["{name}[, {mode} [, {abbr} [, {dict}]]]","String"],"mapcheck":["{name}[, {mode} [, {abbr}]]","String"],"match":["{expr}, {pat}[, {start}[, {count}]]","Number"],"matchadd":["{group}, {pattern}[, {priority}[, {id}]]","Number"],"matchaddpos":["{group}, {list}[, {priority}[, {id}]]","Number"],"matcharg":["{nr}","List"],"matchdelete":["{id}","Number"],"matchend":["{expr}, {pat}[, {start}[, {count}]]","Number"],"matchlist":["{expr}, {pat}[, {start}[, {count}]]","List"],"matchstr":["{expr}, {pat}[, {start}[, {count}]]","String"],"matchstrpos":["{expr}, {pat}[, {start}[, {count}]]","List"],"max":["{expr}","Number"],"min":["{expr}","Number"],"mkdir":["{name} [, {path} [, {prot}]]","Number"],"mode":["[expr]","String"],"mzeval":["{expr}","any"],"nextnonblank":["{lnum}","Number"],"nr2char":["{expr}[, {utf8}]","String"],"or":["{expr}, {expr}","Number"],"pathshorten":["{expr}","String"],"perleval":["{expr}","any"],"popup_atcursor":["{what}, {options}","Number"],"popup_beval":["{what}, {options}","Number"],"popup_clear":["","none"],"popup_close":["{id} [, {result}]","none"],"popup_create":["{what}, {options}","Number"],"popup_dialog":["{what}, {options}","Number"],"popup_filter_menu":["{id}, {key}","Number"],"popup_filter_yesno":["{id}, {key}","Number"],"popup_findinfo":["","Number"],"popup_findpreview":["","Number"],"popup_getoptions":["{id}","Dict"],"popup_getpos":["{id}","Dict"],"popup_hide":["{id}","none"],"popup_menu":["{what}, {options}","Number"],"popup_move":["{id}, {options}","none"],"popup_notification":["{what}, {options}","Number"],"popup_show":["{id}","none"],"popup_setoptions":["{id}, {options}","none"],"popup_settext":["{id}, {text}","none"],"pow":["{x}, {y}","Float"],"prevnonblank":["{lnum}","Number"],"printf":["{fmt}, {expr1}...","String"],"prompt_setcallback":["{buf}, {expr}","none"],"prompt_setinterrupt":["{buf}, {text}","none"],"prompt_setprompt":["{buf}, {text}","none"],"prop_add":["{lnum}, {col}, {props}","none"],"prop_clear":["{lnum} [, {lnum-end} [, {props}]]","none"],"prop_find":["{props} [, {direction}]","Dict"],"prop_list":["{lnum} [, {props}","List"],"prop_remove":["{props} [, {lnum} [, {lnum-end}]]","Number"],"prop_type_add":["{name}, {props}","none"],"prop_type_change":["{name}, {props}","none"],"prop_type_delete":["{name} [, {props}]","none"],"prop_type_get":["[{name} [, {props}]","Dict"],"prop_type_list":["[{props}]","List"],"pum_getpos":["","Dict"],"pumvisible":["","Number"],"pyeval":["{expr}","any"],"py3eval":["{expr}","any"],"pyxeval":["{expr}","any"],"rand":["[{expr}]","Number"],"range":["{expr} [, {max} [, {stride}]]","List"],"readdir":["{dir} [, {expr}]","List"],"readfile":["{fname} [, {binary} [, {max}]]","List"],"reg_executing":["","String"],"reg_recording":["","String"],"reltime":["[{start} [, {end}]]","List"],"reltimefloat":["{time}","Float"],"reltimestr":["{time}","String"],"remote_expr":["{server}, {string} [, {idvar} [, {timeout}]]","String"],"remote_foreground":["{server}","Number"],"remote_peek":["{serverid} [, {retvar}]","Number"],"remote_read":["{serverid} [, {timeout}]","String"],"remote_send":["{server}, {string} [, {idvar}]","String"],"remote_startserver":["{name}","none"],"remove":["{dict}, {key}","any"],"rename":["{from}, {to}","Number"],"repeat":["{expr}, {count}","String"],"resolve":["{filename}","String"],"reverse":["{list}","List"],"round":["{expr}","Float"],"rubyeval":["{expr}","any"],"screenattr":["{row}, {col}","Number"],"screenchar":["{row}, {col}","Number"],"screenchars":["{row}, {col}","List"],"screencol":["","Number"],"screenpos":["{winid}, {lnum}, {col}","Dict"],"screenrow":["","Number"],"screenstring":["{row}, {col}","String"],"search":["{pattern} [, {flags} [, {stopline} [, {timeout}]]]","Number"],"searchdecl":["{name} [, {global} [, {thisblock}]]","Number"],"searchpair":["{start}, {middle}, {end} [, {flags} [, {skip} [...]]]","Number"],"searchpairpos":["{start}, {middle}, {end} [, {flags} [, {skip} [...]]]","List"],"searchpos":["{pattern} [, {flags} [, {stopline} [, {timeout}]]]","List"],"server2client":["{clientid}, {string}","Number"],"serverlist":["","String"],"setbufline":[" {expr}, {lnum}, {line}","Number"],"setbufvar":["{expr}, {varname}, {val}","set"],"setcharsearch":["{dict}","Dict"],"setcmdpos":["{pos}","Number"],"setenv":["{name}, {val}","none"],"setfperm":["{fname}, {mode}","Number"],"setline":["{lnum}, {line}","Number"],"setloclist":["{nr}, {list}[, {action}[, {what}]]","Number"],"setmatches":["{list}","Number"],"setpos":["{expr}, {list}","Number"],"setqflist":["{list} [, {action} [, {what}]]","Number"],"setreg":["{n}, {v}[, {opt}]","Number"],"settabvar":["{nr}, {varname}, {val}","set"],"settabwinvar":["{tabnr}, {winnr}, {varname}, {val}","set"],"settagstack":["{nr}, {dict} [, {action}]","Number"],"setwinvar":["{nr}, {varname}, {val}","set"],"sha256":["{string}","String"],"shellescape":["{string} [, {special}]","String"],"shiftwidth":["","Number"],"sign_define":["{name} [, {dict}]","Number"],"sign_getdefined":["[{name}]","List"],"sign_getplaced":["[{expr} [, {dict}]]","List"],"sign_jump":["{id}, {group}, {expr}","Number"],"sign_place":["{id}, {group}, {name}, {expr} [, {dict}]","Number"],"sign_placelist":["{list}","List"],"sign_undefine":["[{name}]","Number"],"sign_unplace":["{group} [, {dict}]","Number"],"sign_unplacelist":["{list}","List"],"simplify":["{filename}","String"],"sin":["{expr}","Float"],"sinh":["{expr}","Float"],"sort":["{list} [, {func} [, {dict}]]","List"],"sound_clear":["","none"],"sound_playevent":["{name} [, {callback}]","Number"],"sound_playfile":["{path} [, {callback}]","Number"],"sound_stop":["{id}","none"],"soundfold":["{word}","String"],"spellbadword":["","String"],"spellsuggest":["{word} [, {max} [, {capital}]]","List"],"split":["{expr} [, {pat} [, {keepempty}]]","List"],"sqrt":["{expr}","Float"],"srand":["[{expr}]","List"],"state":["[{what}]","String"],"str2float":["{expr}","Float"],"str2list":["{expr} [, {utf8}]","List"],"str2nr":["{expr} [, {base}]","Number"],"strchars":["{expr} [, {skipcc}]","Number"],"strcharpart":["{str}, {start} [, {len}]","String"],"strdisplaywidth":["{expr} [, {col}]","Number"],"strftime":["{format} [, {time}]","String"],"strgetchar":["{str}, {index}","Number"],"stridx":["{haystack}, {needle} [, {start}]","Number"],"string":["{expr}","String"],"strlen":["{expr}","Number"],"strpart":["{str}, {start} [, {len}]","String"],"strptime":["{format}, {timestring}","Number"],"strridx":["{haystack}, {needle} [, {start}]","Number"],"strtrans":["{expr}","String"],"strwidth":["{expr}","Number"],"submatch":["{nr} [, {list}]","String"],"substitute":["{expr}, {pat}, {sub}, {flags}","String"],"swapinfo":["{fname}","Dict"],"swapname":["{expr}","String"],"synID":["{lnum}, {col}, {trans}","Number"],"synIDattr":["{synID}, {what} [, {mode}]","String"],"synIDtrans":["{synID}","Number"],"synconcealed":["{lnum}, {col}","List"],"synstack":["{lnum}, {col}","List"],"system":["{cmd} [, {input}]","String"],"systemlist":["{cmd} [, {input}]","List"],"tabpagebuflist":["[{arg}]","List"],"tabpagenr":["[{arg}]","Number"],"tabpagewinnr":["{tabarg}[, {arg}]","Number"],"taglist":["{expr}[, {filename}]","List"],"tagfiles":["","List"],"tan":["{expr}","Float"],"tanh":["{expr}","Float"],"tempname":["","String"],"term_dumpdiff":["{filename}, {filename} [, {options}]","Number"],"term_dumpload":["{filename} [, {options}]","Number"],"term_dumpwrite":["{buf}, {filename} [, {options}]","none"],"term_getaltscreen":["{buf}","Number"],"term_getansicolors":["{buf}","List"],"term_getattr":["{attr}, {what}","Number"],"term_getcursor":["{buf}","List"],"term_getjob":["{buf}","Job"],"term_getline":["{buf}, {row}","String"],"term_getscrolled":["{buf}","Number"],"term_getsize":["{buf}","List"],"term_getstatus":["{buf}","String"],"term_gettitle":["{buf}","String"],"term_gettty":["{buf}, [{input}]","String"],"term_list":["","List"],"term_scrape":["{buf}, {row}","List"],"term_sendkeys":["{buf}, {keys}","none"],"term_setapi":["{buf}, {expr}","none"],"term_setansicolors":["{buf}, {colors}","none"],"term_setkill":["{buf}, {how}","none"],"term_setrestore":["{buf}, {command}","none"],"term_setsize":["{buf}, {rows}, {cols}","none"],"term_start":["{cmd} [, {options}]","Number"],"term_wait":["{buf} [, {time}]","Number"],"test_alloc_fail":["{id}, {countdown}, {repeat}","none"],"test_autochdir":["","none"],"test_feedinput":["{string}","none"],"test_garbagecollect_now":["","none"],"test_garbagecollect_soon":["","none"],"test_getvalue":["{string}","any"],"test_ignore_error":["{expr}","none"],"test_null_blob":["","Blob"],"test_null_channel":["","Channel"],"test_null_dict":["","Dict"],"test_null_job":["","Job"],"test_null_list":["","List"],"test_null_partial":["","Funcref"],"test_null_string":["","String"],"test_option_not_set":["{name}","none"],"test_override":["{expr}, {val}","none"],"test_refcount":["{expr}","Number"],"test_scrollbar":["{which}, {value}, {dragging}","none"],"test_setmouse":["{row}, {col}","none"],"test_settime":["{expr}","none"],"timer_info":["[{id}]","List"],"timer_pause":["{id}, {pause}","none"],"timer_start":["{time}, {callback} [, {options}]","Number"],"timer_stop":["{timer}","none"],"timer_stopall":["","none"],"tolower":["{expr}","String"],"toupper":["{expr}","String"],"tr":["{src}, {fromstr}, {tostr}","String"],"trim":["{text} [, {mask}]","String"],"trunc":["{expr}","Float"],"type":["{name}","Number"],"undofile":["{name}","String"],"undotree":["","List"],"uniq":["{list} [, {func} [, {dict}]]","List"],"values":["{dict}","List"],"virtcol":["{expr}","Number"],"visualmode":["[expr]","String"],"wildmenumode":["","Number"],"win_execute":["{id}, {command} [, {silent}]","String"],"win_findbuf":["{bufnr}","List"],"win_getid":["[{win} [, {tab}]]","Number"],"win_gotoid":["{expr}","Number"],"win_id2tabwin":["{expr}","List"],"win_id2win":["{expr}","Number"],"win_screenpos":["{nr}","List"],"win_splitmove":["{nr}, {target} [, {options}]","Number"],"winbufnr":["{nr}","Number"],"wincol":["","Number"],"winheight":["{nr}","Number"],"winlayout":["[{tabnr}]","List"],"winline":["","Number"],"winnr":["[{expr}]","Number"],"winrestcmd":["","String"],"winrestview":["{dict}","none"],"winsaveview":["","Dict"],"winwidth":["{nr}","Number"],"wordcount":["","Dict"],"writefile":["{list}, {fname} [, {flags}]","Number"],"xor":["{expr}, {expr}","Number"],"api_info":["","Dict"],"chanclose":["{id}[, {stream}]","Number"],"chansend":["{id}, {data}","Number"],"ctxget":["[{index}]","Dict"],"ctxpop":["","none"],"ctxpush":["[{types}]","none"],"ctxset":["{context}[, {index}]","none"],"ctxsize":["","Number"],"dictwatcheradd":["{dict}, {pattern}, {callback}","Start"],"dictwatcherdel":["{dict}, {pattern}, {callback}","Stop"],"id":["{expr}","String"],"jobpid":["{id}","Number"],"jobresize":["{id}, {width}, {height}","Number"],"jobstart":["{cmd}[, {opts}]","Number"],"jobstop":["{id}","Number"],"jobwait":["{ids}[, {timeout}]","Number"],"msgpackdump":["{list}","List"],"msgpackparse":["{list}","List"],"prompt_addtext":["{buf}, {expr}","none"],"rpcnotify":["{channel}, {event}[, {args}...]","Sends"],"rpcrequest":["{channel}, {method}[, {args}...]","Sends"],"sockconnect":["{mode}, {address} [, {opts}]","Number"],"stdioopen":["{dict}","Number"],"stdpath":["{what}","String/List"],"wait":["{timeout}, {condition}[, {interval}]","Number"],"nvim__id":["{obj}",""],"nvim__id_array":["{arr}",""],"nvim__id_dictionary":["{dct}",""],"nvim__id_float":["{flt}",""],"nvim__inspect_cell":["{grid}, {row}, {col}",""],"nvim__put_attr":["{id}, {c0}, {c1}",""],"nvim__stats":["",""],"nvim_call_atomic":["{calls}",""],"nvim_call_dict_function":["{dict}, {fn}, {args}",""],"nvim_call_function":["{fn}, {args}",""],"nvim_command":["{command}",""],"nvim_create_buf":["{listed}, {scratch}",""],"nvim_create_namespace":["{name}",""],"nvim_del_current_line":["",""],"nvim_del_keymap":["{mode}, {lhs}",""],"nvim_del_var":["{name}",""],"nvim_err_write":["{str}",""],"nvim_err_writeln":["{str}",""],"nvim_eval":["{expr}",""],"nvim_exec":["{src}, {output}",""],"nvim_exec_lua":["{code}, {args}",""],"nvim_feedkeys":["{keys}, {mode}, {escape_csi}",""],"nvim_get_api_info":["",""],"nvim_get_chan_info":["{chan}",""],"nvim_get_color_by_name":["{name}",""],"nvim_get_color_map":["",""],"nvim_get_commands":["{opts}",""],"nvim_get_context":["{opts}",""],"nvim_get_current_buf":["",""],"nvim_get_current_line":["",""],"nvim_get_current_tabpage":["",""],"nvim_get_current_win":["",""],"nvim_get_hl_by_id":["{hl_id}, {rgb}",""],"nvim_get_hl_by_name":["{name}, {rgb}",""],"nvim_get_hl_id_by_name":["{name}",""],"nvim_get_keymap":["{mode}",""],"nvim_get_mode":["",""],"nvim_get_namespaces":["",""],"nvim_get_option":["{name}",""],"nvim_get_proc":["{pid}",""],"nvim_get_proc_children":["{pid}",""],"nvim_get_var":["{name}",""],"nvim_get_vvar":["{name}",""],"nvim_input":["{keys}",""],"nvim_input_mouse":["{button}, {action}, {modifier}, {grid}, {row}, {col}",""],"nvim_list_bufs":["",""],"nvim_list_chans":["",""],"nvim_list_runtime_paths":["",""],"nvim_list_tabpages":["",""],"nvim_list_uis":["",""],"nvim_list_wins":["",""],"nvim_load_context":["{dict}",""],"nvim_open_win":["{buffer}, {enter}, {config}",""],"nvim_out_write":["{str}",""],"nvim_parse_expression":["{expr}, {flags}, {highlight}",""],"nvim_paste":["{data}, {crlf}, {phase}",""],"nvim_put":["{lines}, {type}, {after}, {follow}",""],"nvim_replace_termcodes":["{str}, {from_part}, {do_lt}, {special}",""],"nvim_select_popupmenu_item":["{item}, {insert}, {finish}, {opts}",""],"nvim_set_client_info":["{name}, {version}, {type}, {methods}, {attributes}",""],"nvim_set_current_buf":["{buffer}",""],"nvim_set_current_dir":["{dir}",""],"nvim_set_current_line":["{line}",""],"nvim_set_current_tabpage":["{tabpage}",""],"nvim_set_current_win":["{window}",""],"nvim_set_keymap":["{mode}, {lhs}, {rhs}, {opts}",""],"nvim_set_option":["{name}, {value}",""],"nvim_set_var":["{name}, {value}",""],"nvim_set_vvar":["{name}, {value}",""],"nvim_strwidth":["{text}",""],"nvim_subscribe":["{event}",""],"nvim_unsubscribe":["{event}",""],"nvim__buf_redraw_range":["{buffer}, {first}, {last}",""],"nvim__buf_set_luahl":["{buffer}, {opts}",""],"nvim__buf_stats":["{buffer}",""],"nvim_buf_add_highlight":["{buffer}, {ns_id}, {hl_group}, {line}, {col_start}, {col_end}",""],"nvim_buf_attach":["{buffer}, {send_buffer}, {opts}",""],"nvim_buf_clear_namespace":["{buffer}, {ns_id}, {line_start}, {line_end}",""],"nvim_buf_del_extmark":["{buffer}, {ns_id}, {id}",""],"nvim_buf_del_keymap":["{buffer}, {mode}, {lhs}",""],"nvim_buf_del_var":["{buffer}, {name}",""],"nvim_buf_detach":["{buffer}",""],"nvim_buf_get_changedtick":["{buffer}",""],"nvim_buf_get_commands":["{buffer}, {opts}",""],"nvim_buf_get_extmark_by_id":["{buffer}, {ns_id}, {id}",""],"nvim_buf_get_extmarks":["{buffer}, {ns_id}, {start}, {end}, {opts}",""],"nvim_buf_get_keymap":["{buffer}, {mode}",""],"nvim_buf_get_lines":["{buffer}, {start}, {end}, {strict_indexing}",""],"nvim_buf_get_mark":["{buffer}, {name}",""],"nvim_buf_get_name":["{buffer}",""],"nvim_buf_get_offset":["{buffer}, {index}",""],"nvim_buf_get_option":["{buffer}, {name}",""],"nvim_buf_get_var":["{buffer}, {name}",""],"nvim_buf_get_virtual_text":["{buffer}, {lnum}",""],"nvim_buf_is_loaded":["{buffer}",""],"nvim_buf_is_valid":["{buffer}",""],"nvim_buf_line_count":["{buffer}",""],"nvim_buf_set_extmark":["{buffer}, {ns_id}, {id}, {line}, {col}, {opts}",""],"nvim_buf_set_keymap":["{buffer}, {mode}, {lhs}, {rhs}, {opts}",""],"nvim_buf_set_lines":["{buffer}, {start}, {end}, {strict_indexing}, {replacement}",""],"nvim_buf_set_name":["{buffer}, {name}",""],"nvim_buf_set_option":["{buffer}, {name}, {value}",""],"nvim_buf_set_var":["{buffer}, {name}, {value}",""],"nvim_buf_set_virtual_text":["{buffer}, {ns_id}, {line}, {chunks}, {opts}",""],"nvim_win_close":["{window}, {force}",""],"nvim_win_del_var":["{window}, {name}",""],"nvim_win_get_buf":["{window}",""],"nvim_win_get_config":["{window}",""],"nvim_win_get_cursor":["{window}",""],"nvim_win_get_height":["{window}",""],"nvim_win_get_number":["{window}",""],"nvim_win_get_option":["{window}, {name}",""],"nvim_win_get_position":["{window}",""],"nvim_win_get_tabpage":["{window}",""],"nvim_win_get_var":["{window}, {name}",""],"nvim_win_get_width":["{window}",""],"nvim_win_is_valid":["{window}",""],"nvim_win_set_buf":["{window}, {buffer}",""],"nvim_win_set_config":["{window}, {config}",""],"nvim_win_set_cursor":["{window}, {pos}",""],"nvim_win_set_height":["{window}, {height}",""],"nvim_win_set_option":["{window}, {name}, {value}",""],"nvim_win_set_var":["{window}, {name}, {value}",""],"nvim_win_set_width":["{window}, {width}",""],"nvim_tabpage_del_var":["{tabpage}, {name}",""],"nvim_tabpage_get_number":["{tabpage}",""],"nvim_tabpage_get_var":["{tabpage}, {name}",""],"nvim_tabpage_get_win":["{tabpage}",""],"nvim_tabpage_is_valid":["{tabpage}",""],"nvim_tabpage_list_wins":["{tabpage}",""],"nvim_tabpage_set_var":["{tabpage}, {name}, {value}",""],"nvim_ui_attach":["{width}, {height}, {options}",""],"nvim_ui_detach":["",""],"nvim_ui_pum_set_height":["{height}",""],"nvim_ui_set_option":["{name}, {value}",""],"nvim_ui_try_resize":["{width}, {height}",""],"nvim_ui_try_resize_grid":["{grid}, {width}, {height}",""]},"documents":{"commands":{"range":["go to last line in {range}"],"!":["filter lines or execute an external command"],"!!":["repeat last \\":!\\" command"],"#":["same as \\":number\\""],"&":["repeat last \\":substitute\\""],"star":["execute contents of a register"],"<":["shift lines one \'shiftwidth\' left"],"=":["print the cursor line number"],">":["shift lines one \'shiftwidth\' right"],"@":["execute contents of a register"],"@@":["repeat the previous \\":@\\""],"Next":["go to previous file in the argument list"],"append":["append text"],"abbreviate":["enter abbreviation"],"abclear":["remove all abbreviations"],"aboveleft":["make split window appear left or above"],"all":["open a window for each file in the argument","\\t\\t\\t\\tlist"],"amenu":["enter new menu item for all modes"],"anoremenu":["enter a new menu for all modes that will not","\\t\\t\\t\\tbe remapped"],"args":["print the argument list"],"argadd":["add items to the argument list"],"argdelete":["delete items from the argument list"],"argedit":["add item to the argument list and edit it"],"argdo":["do a command on all items in the argument list"],"argglobal":["define the global argument list"],"arglocal":["define a local argument list"],"argument":["go to specific file in the argument list"],"ascii":["print ascii value of character under the cursor"],"autocmd":["enter or show autocommands"],"augroup":["select the autocommand group to use"],"aunmenu":["remove menu for all modes"],"buffer":["go to specific buffer in the buffer list"],"bNext":["go to previous buffer in the buffer list"],"ball":["open a window for each buffer in the buffer list"],"badd":["add buffer to the buffer list"],"bdelete":["remove a buffer from the buffer list"],"behave":["set mouse and selection behavior"],"belowright":["make split window appear right or below"],"bfirst":["go to first buffer in the buffer list"],"blast":["go to last buffer in the buffer list"],"bmodified":["go to next buffer in the buffer list that has","\\t\\t\\t\\tbeen modified"],"bnext":["go to next buffer in the buffer list"],"botright":["make split window appear at bottom or far right"],"bprevious":["go to previous buffer in the buffer list"],"brewind":["go to first buffer in the buffer list"],"break":["break out of while loop"],"breakadd":["add a debugger breakpoint"],"breakdel":["delete a debugger breakpoint"],"breaklist":["list debugger breakpoints"],"browse":["use file selection dialog"],"bufdo":["execute command in each listed buffer"],"buffers":["list all files in the buffer list"],"bunload":["unload a specific buffer"],"bwipeout":["really delete a buffer"],"change":["replace a line or series of lines"],"cNext":["go to previous error"],"cNfile":["go to last error in previous file"],"cabbrev":["like \\":abbreviate\\" but for Command-line mode"],"cabclear":["clear all abbreviations for Command-line mode"],"cabove":["go to error above current line"],"caddbuffer":["add errors from buffer"],"caddexpr":["add errors from expr"],"caddfile":["add error message to current quickfix list"],"call":["call a function"],"catch":["part of a :try command"],"cbelow":["go to error below current line"],"cbottom":["scroll to the bottom of the quickfix window"],"cbuffer":["parse error messages and jump to first error"],"cc":["go to specific error"],"cclose":["close quickfix window"],"cd":["change directory"],"cdo":["execute command in each valid error list entry"],"cfdo":["execute command in each file in error list"],"center":["format lines at the center"],"cexpr":["read errors from expr and jump to first"],"cfile":["read file with error messages and jump to first"],"cfirst":["go to the specified error, default first one"],"cgetbuffer":["get errors from buffer"],"cgetexpr":["get errors from expr"],"cgetfile":["read file with error messages"],"changes":["print the change list"],"chdir":["change directory"],"checkpath":["list included files"],"checktime":["check timestamp of loaded buffers"],"chistory":["list the error lists"],"clast":["go to the specified error, default last one"],"clearjumps":["clear the jump list"],"clist":["list all errors"],"close":["close current window"],"cmap":["like \\":map\\" but for Command-line mode"],"cmapclear":["clear all mappings for Command-line mode"],"cmenu":["add menu for Command-line mode"],"cnext":["go to next error"],"cnewer":["go to newer error list"],"cnfile":["go to first error in next file"],"cnoremap":["like \\":noremap\\" but for Command-line mode"],"cnoreabbrev":["like \\":noreabbrev\\" but for Command-line mode"],"cnoremenu":["like \\":noremenu\\" but for Command-line mode"],"copy":["copy lines"],"colder":["go to older error list"],"colorscheme":["load a specific color scheme"],"command":["create user-defined command"],"comclear":["clear all user-defined commands"],"compiler":["do settings for a specific compiler"],"continue":["go back to :while"],"confirm":["prompt user when confirmation required"],"const":["create a variable as a constant"],"copen":["open quickfix window"],"cprevious":["go to previous error"],"cpfile":["go to last error in previous file"],"cquit":["quit Vim with an error code"],"crewind":["go to the specified error, default first one"],"cscope":["execute cscope command"],"cstag":["use cscope to jump to a tag"],"cunmap":["like \\":unmap\\" but for Command-line mode"],"cunabbrev":["like \\":unabbrev\\" but for Command-line mode"],"cunmenu":["remove menu for Command-line mode"],"cwindow":["open or close quickfix window"],"delete":["delete lines"],"delmarks":["delete marks"],"debug":["run a command in debugging mode"],"debuggreedy":["read debug mode commands from normal input"],"delcommand":["delete user-defined command"],"delfunction":["delete a user function"],"diffupdate":["update \'diff\' buffers"],"diffget":["remove differences in current buffer"],"diffoff":["switch off diff mode"],"diffpatch":["apply a patch and show differences"],"diffput":["remove differences in other buffer"],"diffsplit":["show differences with another file"],"diffthis":["make current window a diff window"],"digraphs":["show or enter digraphs"],"display":["display registers"],"djump":["jump to #define"],"dl":["short for |:delete| with the \'l\' flag"],"del":["short for |:delete| with the \'l\' flag"],"dlist":["list #defines"],"doautocmd":["apply autocommands to current buffer"],"doautoall":["apply autocommands for all loaded buffers"],"dp":["short for |:delete| with the \'p\' flag"],"drop":["jump to window editing file or edit file in","\\t\\t\\t\\tcurrent window"],"dsearch":["list one #define"],"dsplit":["split window and jump to #define"],"edit":["edit a file"],"earlier":["go to older change, undo"],"echo":["echoes the result of expressions"],"echoerr":["like :echo, show like an error and use history"],"echohl":["set highlighting for echo commands"],"echomsg":["same as :echo, put message in history"],"echon":["same as :echo, but without <EOL>"],"else":["part of an :if command"],"elseif":["part of an :if command"],"emenu":["execute a menu by name"],"endif":["end previous :if"],"endfor":["end previous :for"],"endfunction":["end of a user function"],"endtry":["end previous :try"],"endwhile":["end previous :while"],"enew":["edit a new, unnamed buffer"],"ex":["same as \\":edit\\""],"execute":["execute result of expressions"],"exit":["same as \\":xit\\""],"exusage":["overview of Ex commands"],"file":["show or set the current file name"],"files":["list all files in the buffer list"],"filetype":["switch file type detection on/off"],"filter":["filter output of following command"],"find":["find file in \'path\' and edit it"],"finally":["part of a :try command"],"finish":["quit sourcing a Vim script"],"first":["go to the first file in the argument list"],"fold":["create a fold"],"foldclose":["close folds"],"folddoopen":["execute command on lines not in a closed fold"],"folddoclosed":["execute command on lines in a closed fold"],"foldopen":["open folds"],"for":["for loop"],"function":["define a user function"],"global":["execute commands for matching lines"],"goto":["go to byte in the buffer"],"grep":["run \'grepprg\' and jump to first match"],"grepadd":["like :grep, but append to current list"],"gui":["start the GUI"],"gvim":["start the GUI"],"hardcopy":["send text to the printer"],"help":["open a help window"],"helpclose":["close one help window"],"helpgrep":["like \\":grep\\" but searches help files"],"helptags":["generate help tags for a directory"],"highlight":["specify highlighting methods"],"hide":["hide current buffer for a command"],"history":["print a history list"],"insert":["insert text"],"iabbrev":["like \\":abbrev\\" but for Insert mode"],"iabclear":["like \\":abclear\\" but for Insert mode"],"if":["execute commands when condition met"],"ijump":["jump to definition of identifier"],"ilist":["list lines where identifier matches"],"imap":["like \\":map\\" but for Insert mode"],"imapclear":["like \\":mapclear\\" but for Insert mode"],"imenu":["add menu for Insert mode"],"inoremap":["like \\":noremap\\" but for Insert mode"],"inoreabbrev":["like \\":noreabbrev\\" but for Insert mode"],"inoremenu":["like \\":noremenu\\" but for Insert mode"],"intro":["print the introductory message"],"isearch":["list one line where identifier matches"],"isplit":["split window and jump to definition of","\\t\\t\\t\\tidentifier"],"iunmap":["like \\":unmap\\" but for Insert mode"],"iunabbrev":["like \\":unabbrev\\" but for Insert mode"],"iunmenu":["remove menu for Insert mode"],"join":["join lines"],"jumps":["print the jump list"],"k":["set a mark"],"keepalt":["following command keeps the alternate file"],"keepmarks":["following command keeps marks where they are"],"keepjumps":["following command keeps jumplist and marks"],"keeppatterns":["following command keeps search pattern history"],"lNext":["go to previous entry in location list"],"lNfile":["go to last entry in previous file"],"list":["print lines"],"labove":["go to location above current line"],"laddexpr":["add locations from expr"],"laddbuffer":["add locations from buffer"],"laddfile":["add locations to current location list"],"last":["go to the last file in the argument list"],"language":["set the language (locale)"],"later":["go to newer change, redo"],"lbelow":["go to location below current line"],"lbottom":["scroll to the bottom of the location window"],"lbuffer":["parse locations and jump to first location"],"lcd":["change directory locally"],"lchdir":["change directory locally"],"lclose":["close location window"],"lcscope":["like \\":cscope\\" but uses location list"],"ldo":["execute command in valid location list entries"],"lfdo":["execute command in each file in location list"],"left":["left align lines"],"leftabove":["make split window appear left or above"],"let":["assign a value to a variable or option"],"lexpr":["read locations from expr and jump to first"],"lfile":["read file with locations and jump to first"],"lfirst":["go to the specified location, default first one"],"lgetbuffer":["get locations from buffer"],"lgetexpr":["get locations from expr"],"lgetfile":["read file with locations"],"lgrep":["run \'grepprg\' and jump to first match"],"lgrepadd":["like :grep, but append to current list"],"lhelpgrep":["like \\":helpgrep\\" but uses location list"],"lhistory":["list the location lists"],"ll":["go to specific location"],"llast":["go to the specified location, default last one"],"llist":["list all locations"],"lmake":["execute external command \'makeprg\' and parse","\\t\\t\\t\\terror messages"],"lmap":["like \\":map!\\" but includes Lang-Arg mode"],"lmapclear":["like \\":mapclear!\\" but includes Lang-Arg mode"],"lnext":["go to next location"],"lnewer":["go to newer location list"],"lnfile":["go to first location in next file"],"lnoremap":["like \\":noremap!\\" but includes Lang-Arg mode"],"loadkeymap":["load the following keymaps until EOF"],"loadview":["load view for current window from a file"],"lockmarks":["following command keeps marks where they are"],"lockvar":["lock variables"],"lolder":["go to older location list"],"lopen":["open location window"],"lprevious":["go to previous location"],"lpfile":["go to last location in previous file"],"lrewind":["go to the specified location, default first one"],"ls":["list all buffers"],"ltag":["jump to tag and add matching tags to the","\\t\\t\\t\\tlocation list"],"lunmap":["like \\":unmap!\\" but includes Lang-Arg mode"],"lua":["execute |Lua| command"],"luado":["execute Lua command for each line"],"luafile":["execute |Lua| script file"],"lvimgrep":["search for pattern in files"],"lvimgrepadd":["like :vimgrep, but append to current list"],"lwindow":["open or close location window"],"move":["move lines"],"mark":["set a mark"],"make":["execute external command \'makeprg\' and parse","\\t\\t\\t\\terror messages"],"map":["show or enter a mapping"],"mapclear":["clear all mappings for Normal and Visual mode"],"marks":["list all marks"],"match":["define a match to highlight"],"menu":["enter a new menu item"],"menutranslate":["add a menu translation item"],"messages":["view previously displayed messages"],"mkexrc":["write current mappings and settings to a file"],"mksession":["write session info to a file"],"mkspell":["produce .spl spell file"],"mkvimrc":["write current mappings and settings to a file"],"mkview":["write view of current window to a file"],"mode":["show or change the screen mode"],"next":["go to next file in the argument list"],"new":["create a new empty window"],"nmap":["like \\":map\\" but for Normal mode"],"nmapclear":["clear all mappings for Normal mode"],"nmenu":["add menu for Normal mode"],"nnoremap":["like \\":noremap\\" but for Normal mode"],"nnoremenu":["like \\":noremenu\\" but for Normal mode"],"noautocmd":["following commands don\'t trigger autocommands"],"noremap":["enter a mapping that will not be remapped"],"nohlsearch":["suspend \'hlsearch\' highlighting"],"noreabbrev":["enter an abbreviation that will not be","\\t\\t\\t\\tremapped"],"noremenu":["enter a menu that will not be remapped"],"normal":["execute Normal mode commands"],"noswapfile":["following commands don\'t create a swap file"],"number":["print lines with line number"],"nunmap":["like \\":unmap\\" but for Normal mode"],"nunmenu":["remove menu for Normal mode"],"oldfiles":["list files that have marks in the |shada| file"],"omap":["like \\":map\\" but for Operator-pending mode"],"omapclear":["remove all mappings for Operator-pending mode"],"omenu":["add menu for Operator-pending mode"],"only":["close all windows except the current one"],"onoremap":["like \\":noremap\\" but for Operator-pending mode"],"onoremenu":["like \\":noremenu\\" but for Operator-pending mode"],"options":["open the options-window"],"ounmap":["like \\":unmap\\" but for Operator-pending mode"],"ounmenu":["remove menu for Operator-pending mode"],"ownsyntax":["set new local syntax highlight for this window"],"packadd":["add a plugin from \'packpath\'"],"packloadall":["load all packages under \'packpath\'"],"pclose":["close preview window"],"pedit":["edit file in the preview window"],"print":["print lines"],"profdel":["stop profiling a function or script"],"profile":["profiling functions and scripts"],"promptfind":["open GUI dialog for searching"],"promptrepl":["open GUI dialog for search/replace"],"pop":["jump to older entry in tag stack"],"popup":["popup a menu by name"],"ppop":["\\":pop\\" in preview window"],"preserve":["write all text to swap file"],"previous":["go to previous file in argument list"],"psearch":["like \\":ijump\\" but shows match in preview window"],"ptag":["show tag in preview window"],"ptNext":["|:tNext| in preview window"],"ptfirst":["|:trewind| in preview window"],"ptjump":["|:tjump| and show tag in preview window"],"ptlast":["|:tlast| in preview window"],"ptnext":["|:tnext| in preview window"],"ptprevious":["|:tprevious| in preview window"],"ptrewind":["|:trewind| in preview window"],"ptselect":["|:tselect| and show tag in preview window"],"put":["insert contents of register in the text"],"pwd":["print current directory"],"py3":["execute Python 3 command"],"python3":["same as :py3"],"py3do":["execute Python 3 command for each line"],"py3file":["execute Python 3 script file"],"python":["execute Python command"],"pydo":["execute Python command for each line"],"pyfile":["execute Python script file"],"pyx":["execute |python_x| command"],"pythonx":["same as :pyx"],"pyxdo":["execute |python_x| command for each line"],"pyxfile":["execute |python_x| script file"],"quit":["quit current window (when one window quit Vim)"],"quitall":["quit Vim"],"qall":["quit Vim"],"read":["read file into the text"],"recover":["recover a file from a swap file"],"redo":["redo one undone change"],"redir":["redirect messages to a file or register"],"redraw":["force a redraw of the display"],"redrawstatus":["force a redraw of the status line(s)"],"redrawtabline":["force a redraw of the tabline"],"registers":["display the contents of registers"],"resize":["change current window height"],"retab":["change tab size"],"return":["return from a user function"],"rewind":["go to the first file in the argument list"],"right":["right align text"],"rightbelow":["make split window appear right or below"],"rshada":["read from |shada| file"],"ruby":["execute Ruby command"],"rubydo":["execute Ruby command for each line"],"rubyfile":["execute Ruby script file"],"rundo":["read undo information from a file"],"runtime":["source vim scripts in \'runtimepath\'"],"substitute":["find and replace text"],"sNext":["split window and go to previous file in","\\t\\t\\t\\targument list"],"sandbox":["execute a command in the sandbox"],"sargument":["split window and go to specific file in","\\t\\t\\t\\targument list"],"sall":["open a window for each file in argument list"],"saveas":["save file under another name."],"sbuffer":["split window and go to specific file in the","\\t\\t\\t\\tbuffer list"],"sbNext":["split window and go to previous file in the","\\t\\t\\t\\tbuffer list"],"sball":["open a window for each file in the buffer list"],"sbfirst":["split window and go to first file in the","\\t\\t\\t\\tbuffer list"],"sblast":["split window and go to last file in buffer","\\t\\t\\t\\tlist"],"sbmodified":["split window and go to modified file in the","\\t\\t\\t\\tbuffer list"],"sbnext":["split window and go to next file in the buffer","\\t\\t\\t\\tlist"],"sbprevious":["split window and go to previous file in the","\\t\\t\\t\\tbuffer list"],"sbrewind":["split window and go to first file in the","\\t\\t\\t\\tbuffer list"],"scriptnames":["list names of all sourced Vim scripts"],"scriptencoding":["encoding used in sourced Vim script"],"scriptversion":["version of Vim script used"],"scscope":["split window and execute cscope command"],"set":["show or set options"],"setfiletype":["set \'filetype\', unless it was set already"],"setglobal":["show global values of options"],"setlocal":["show or set options locally"],"sfind":["split current window and edit file in \'path\'"],"sfirst":["split window and go to first file in the","\\t\\t\\t\\targument list"],"sign":["manipulate signs"],"silent":["run a command silently"],"sleep":["do nothing for a few seconds"],"slast":["split window and go to last file in the","\\t\\t\\t\\targument list"],"smagic":[":substitute with \'magic\'"],"smap":["like \\":map\\" but for Select mode"],"smapclear":["remove all mappings for Select mode"],"smenu":["add menu for Select mode"],"snext":["split window and go to next file in the","\\t\\t\\t\\targument list"],"snomagic":[":substitute with \'nomagic\'"],"snoremap":["like \\":noremap\\" but for Select mode"],"snoremenu":["like \\":noremenu\\" but for Select mode"],"sort":["sort lines"],"source":["read Vim or Ex commands from a file"],"spelldump":["split window and fill with all correct words"],"spellgood":["add good word for spelling"],"spellinfo":["show info about loaded spell files"],"spellrare":["add rare word for spelling"],"spellrepall":["replace all bad words like last |z=|"],"spellundo":["remove good or bad word"],"spellwrong":["add spelling mistake"],"split":["split current window"],"sprevious":["split window and go to previous file in the","\\t\\t\\t\\targument list"],"srewind":["split window and go to first file in the","\\t\\t\\t\\targument list"],"stop":["suspend the editor or escape to a shell"],"stag":["split window and jump to a tag"],"startinsert":["start Insert mode"],"startgreplace":["start Virtual Replace mode"],"startreplace":["start Replace mode"],"stopinsert":["stop Insert mode"],"stjump":["do \\":tjump\\" and split window"],"stselect":["do \\":tselect\\" and split window"],"sunhide":["same as \\":unhide\\""],"sunmap":["like \\":unmap\\" but for Select mode"],"sunmenu":["remove menu for Select mode"],"suspend":["same as \\":stop\\""],"sview":["split window and edit file read-only"],"swapname":["show the name of the current swap file"],"syntax":["syntax highlighting"],"syntime":["measure syntax highlighting speed"],"syncbind":["sync scroll binding"],"t":["same as \\":copy\\""],"tNext":["jump to previous matching tag"],"tabNext":["go to previous tab page"],"tabclose":["close current tab page"],"tabdo":["execute command in each tab page"],"tabedit":["edit a file in a new tab page"],"tabfind":["find file in \'path\', edit it in a new tab page"],"tabfirst":["go to first tab page"],"tablast":["go to last tab page"],"tabmove":["move tab page to other position"],"tabnew":["edit a file in a new tab page"],"tabnext":["go to next tab page"],"tabonly":["close all tab pages except the current one"],"tabprevious":["go to previous tab page"],"tabrewind":["go to first tab page"],"tabs":["list the tab pages and what they contain"],"tab":["create new tab when opening new window"],"tag":["jump to tag"],"tags":["show the contents of the tag stack"],"tcd":["change directory for tab page"],"tchdir":["change directory for tab page"],"terminal":["open a terminal buffer"],"tfirst":["jump to first matching tag"],"throw":["throw an exception"],"tjump":["like \\":tselect\\", but jump directly when there","\\t\\t\\t\\tis only one match"],"tlast":["jump to last matching tag"],"tmapclear":["remove all mappings for Terminal-Job mode"],"tmap":["like \\":map\\" but for Terminal-Job mode"],"tmenu":["define menu tooltip"],"tnext":["jump to next matching tag"],"tnoremap":["like \\":noremap\\" but for Terminal-Job mode"],"topleft":["make split window appear at top or far left"],"tprevious":["jump to previous matching tag"],"trewind":["jump to first matching tag"],"try":["execute commands, abort on error or exception"],"tselect":["list matching tags and select one"],"tunmap":["like \\":unmap\\" but for Terminal-Job mode"],"tunmenu":["remove menu tooltip"],"undo":["undo last change(s)"],"undojoin":["join next change with previous undo block"],"undolist":["list leafs of the undo tree"],"unabbreviate":["remove abbreviation"],"unhide":["open a window for each loaded file in the","\\t\\t\\t\\tbuffer list"],"unlet":["delete variable"],"unlockvar":["unlock variables"],"unmap":["remove mapping"],"unmenu":["remove menu"],"unsilent":["run a command not silently"],"update":["write buffer if modified"],"vglobal":["execute commands for not matching lines"],"version":["print version number and other info"],"verbose":["execute command with \'verbose\' set"],"vertical":["make following command split vertically"],"vimgrep":["search for pattern in files"],"vimgrepadd":["like :vimgrep, but append to current list"],"visual":["same as \\":edit\\", but turns off \\"Ex\\" mode"],"viusage":["overview of Normal mode commands"],"view":["edit a file read-only"],"vmap":["like \\":map\\" but for Visual+Select mode"],"vmapclear":["remove all mappings for Visual+Select mode"],"vmenu":["add menu for Visual+Select mode"],"vnew":["create a new empty window, vertically split"],"vnoremap":["like \\":noremap\\" but for Visual+Select mode"],"vnoremenu":["like \\":noremenu\\" but for Visual+Select mode"],"vsplit":["split current window vertically"],"vunmap":["like \\":unmap\\" but for Visual+Select mode"],"vunmenu":["remove menu for Visual+Select mode"],"windo":["execute command in each window"],"write":["write to a file"],"wNext":["write to a file and go to previous file in","\\t\\t\\t\\targument list"],"wall":["write all (changed) buffers"],"while":["execute loop for as long as condition met"],"winsize":["get or set window size (obsolete)"],"wincmd":["execute a Window (CTRL-W) command"],"winpos":["get or set window position"],"wnext":["write to a file and go to next file in","\\t\\t\\t\\targument list"],"wprevious":["write to a file and go to previous file in","\\t\\t\\t\\targument list"],"wq":["write to a file and quit window or Vim"],"wqall":["write all changed buffers and quit Vim"],"wshada":["write to ShaDa file"],"wundo":["write undo information to a file"],"xit":["write if buffer changed and quit window or Vim"],"xall":["same as \\":wqall\\""],"xmapclear":["remove all mappings for Visual mode"],"xmap":["like \\":map\\" but for Visual mode"],"xmenu":["add menu for Visual mode"],"xnoremap":["like \\":noremap\\" but for Visual mode"],"xnoremenu":["like \\":noremenu\\" but for Visual mode"],"xunmap":["like \\":unmap\\" but for Visual mode"],"xunmenu":["remove menu for Visual mode"],"yank":["yank lines into a register"],"z":["print some lines"],"~":["repeat last \\":substitute\\""],"Print":["print lines"],"X":["ask for encryption key"],"cafter":["go to error after current cursor"],"cbefore":["go to error before current cursor"],"fixdel":["set key code of <Del>"],"helpfind":["dialog to open a help window"],"lafter":["go to location after current cursor"],"lbefore":["go to location before current cursor"],"mzscheme":["execute MzScheme command"],"mzfile":["execute MzScheme script file"],"nbclose":["close the current Netbeans session"],"nbkey":["pass a key to Netbeans"],"nbstart":["start a new Netbeans session"],"open":["start open mode (not implemented)"],"perl":["execute Perl command"],"perldo":["execute Perl command for each line"],"rviminfo":["read from viminfo file"],"shell":["escape to a shell"],"simalt":["Win32 GUI: simulate Windows ALT key"],"smile":["make the user happy"],"tcl":["execute Tcl command"],"tcldo":["execute Tcl command for each line"],"tclfile":["execute Tcl script file"],"tearoff":["tear-off a menu"],"tlmenu":["add menu for Terminal-Job mode"],"tlnoremenu":["like \\":noremenu\\" but for Terminal-Job mode"],"tlunmenu":["remove menu for Terminal-Job mode"],"wviminfo":["write to viminfo file"],"xrestore":["restores the X server connection"]},"functions":{"abs":["\\t\\tReturn the absolute value of {expr}.  When {expr} evaluates to","\\t\\ta |Float| abs() returns a |Float|.  When {expr} can be","\\t\\tconverted to a |Number| abs() returns a |Number|.  Otherwise","\\t\\tabs() gives an error message and returns -1.","\\t\\tExamples: >","\\t\\t\\techo abs(1.456)","<\\t\\t\\t1.456  >","\\t\\t\\techo abs(-5.456)","<\\t\\t\\t5.456  >","\\t\\t\\techo abs(-4)","<\\t\\t\\t4",""],"acos":["\\t\\tReturn the arc cosine of {expr} measured in radians, as a","\\t\\t|Float| in the range of [0, pi].","\\t\\t{expr} must evaluate to a |Float| or a |Number| in the range","\\t\\t[-1, 1].","\\t\\tExamples: >","\\t\\t\\t:echo acos(0)","<\\t\\t\\t1.570796 >","\\t\\t\\t:echo acos(-0.5)","<\\t\\t\\t2.094395",""],"add":["\\t\\tAppend the item {expr} to |List| {list}.  Returns the","\\t\\tresulting |List|.  Examples: >","\\t\\t\\t:let alist = add([1, 2, 3], item)","\\t\\t\\t:call add(mylist, \\"woodstock\\")","<\\t\\tNote that when {expr} is a |List| it is appended as a single","\\t\\titem.  Use |extend()| to concatenate |Lists|.","\\t\\tUse |insert()| to add an item at another position.",""],"and":["\\t\\tBitwise AND on the two arguments.  The arguments are converted","\\t\\tto a number.  A List, Dict or Float argument causes an error.","\\t\\tExample: >","\\t\\t\\t:let flag = and(bits, 0x80)"],"api_info":["\\t\\tReturns Dictionary of |api-metadata|.","","\\t\\tView it in a nice human-readable format: >","\\t\\t       :lua print(vim.inspect(vim.fn.api_info()))"],"append":["\\t\\tWhen {text} is a |List|: Append each item of the |List| as a","\\t\\ttext line below line {lnum} in the current buffer.","\\t\\tOtherwise append {text} as one text line below line {lnum} in","\\t\\tthe current buffer.","\\t\\t{lnum} can be zero to insert a line before the first one.","\\t\\tReturns 1 for failure ({lnum} out of range or out of memory),","\\t\\t0 for success.  Example: >","\\t\\t\\t:let failed = append(line(\'$\'), \\"# THE END\\")","\\t\\t\\t:let failed = append(0, [\\"Chapter 1\\", \\"the beginning\\"])"],"appendbufline":["\\t\\tLike |append()| but append the text in buffer {expr}.","","\\t\\tFor the use of {expr}, see |bufname()|.","","\\t\\t{lnum} is used like with |append()|.  Note that using |line()|","\\t\\twould use the current buffer, not the one appending to.","\\t\\tUse \\"$\\" to append at the end of the buffer.","","\\t\\tOn success 0 is returned, on failure 1 is returned.","","\\t\\tIf {expr} is not a valid buffer or {lnum} is not valid, an","\\t\\terror message is given. Example: >","\\t\\t\\t:let failed = appendbufline(13, 0, \\"# THE START\\")","<"],"argc":["\\t\\tThe result is the number of files in the argument list.  See","\\t\\t|arglist|.","\\t\\tIf {winid} is not supplied, the argument list of the current","\\t\\twindow is used.","\\t\\tIf {winid} is -1, the global argument list is used.","\\t\\tOtherwise {winid} specifies the window of which the argument","\\t\\tlist is used: either the window number or the window ID.","\\t\\tReturns -1 if the {winid} argument is invalid.",""],"argidx":["\\t\\tthe first file.  argc() - 1 is the last one.  See |arglist|.",""],"arglistid":["\\t\\tReturn the argument list ID.  This is a number which","\\t\\tidentifies the argument list being used.  Zero is used for the","\\t\\tglobal argument list.  See |arglist|.","\\t\\tReturns -1 if the arguments are invalid.","","\\t\\tWithout arguments use the current window.","\\t\\tWith {winnr} only use this window in the current tab page.","\\t\\tWith {winnr} and {tabnr} use the window in the specified tab","\\t\\tpage.","\\t\\t{winnr} can be the window number or the |window-ID|.",""],"argv":["\\t\\tThe result is the {nr}th file in the argument list.  See","\\t\\t|arglist|.  \\"argv(0)\\" is the first one.  Example: >","\\t:let i = 0","\\t:while i < argc()","\\t:  let f = escape(fnameescape(argv(i)), \'.\')","\\t:  exe \'amenu Arg.\' . f . \' :e \' . f . \'<CR>\'","\\t:  let i = i + 1","\\t:endwhile","<\\t\\tWithout the {nr} argument, or when {nr} is -1, a |List| with","\\t\\tthe whole |arglist| is returned.","","\\t\\tThe {winid} argument specifies the window ID, see |argc()|."],"assert_beeps":["\\t\\tRun {cmd} and add an error message to |v:errors| if it does","\\t\\tNOT produce a beep or visual bell.","\\t\\tAlso see |assert_fails()| and |assert-return|.",""],"assert_equal":["\\t\\tWhen {expected} and {actual} are not equal an error message is","\\t\\tadded to |v:errors| and 1 is returned.  Otherwise zero is","\\t\\treturned |assert-return|.","\\t\\tThere is no automatic conversion, the String \\"4\\" is different","\\t\\tfrom the Number 4.  And the number 4 is different from the","\\t\\tFloat 4.0.  The value of \'ignorecase\' is not used here, case","\\t\\talways matters.","\\t\\tWhen {msg} is omitted an error in the form \\"Expected","\\t\\t{expected} but got {actual}\\" is produced.","\\t\\tExample: >","\\tassert_equal(\'foo\', \'bar\')","<\\t\\tWill result in a string to be added to |v:errors|:","\\ttest.vim line 12: Expected \'foo\' but got \'bar\' ~",""],"assert_equalfile":["\\t\\tWhen the files {fname-one} and {fname-two} do not contain","\\t\\texactly the same text an error message is added to |v:errors|.","\\t\\tAlso see |assert-return|.","\\t\\tWhen {fname-one} or {fname-two} does not exist the error will","\\t\\tmention that."],"assert_exception":["\\t\\tWhen v:exception does not contain the string {error} an error","\\t\\tmessage is added to |v:errors|.  Also see |assert-return|.","\\t\\tThis can be used to assert that a command throws an exception.","\\t\\tUsing the error number, followed by a colon, avoids problems","\\t\\twith translations: >","\\t\\t\\ttry","\\t\\t\\t  commandthatfails","\\t\\t\\t  call assert_false(1, \'command should have failed\')","\\t\\t\\tcatch","\\t\\t\\t  call assert_exception(\'E492:\')","\\t\\t\\tendtry"],"assert_fails":["\\t\\tRun {cmd} and add an error message to |v:errors| if it does","\\t\\tNOT produce an error.  Also see |assert-return|.","\\t\\tWhen {error} is given it must match in |v:errmsg|.","\\t\\tNote that beeping is not considered an error, and some failing","\\t\\tcommands only beep.  Use |assert_beeps()| for those."],"assert_false":["\\t\\tWhen {actual} is not false an error message is added to","\\t\\t|v:errors|, like with |assert_equal()|.","\\t\\tAlso see |assert-return|.","\\t\\tA value is false when it is zero or |v:false|. When \\"{actual}\\"","\\t\\tis not a number or |v:false| the assert fails.","\\t\\tWhen {msg} is omitted an error in the form","\\t\\t\\"Expected False but got {actual}\\" is produced."],"assert_inrange":["\\t\\tThis asserts number and |Float| values.  When {actual}  is lower","\\t\\tthan {lower} or higher than {upper} an error message is added","\\t\\tto |v:errors|.  Also see |assert-return|.","\\t\\tWhen {msg} is omitted an error in the form","\\t\\t\\"Expected range {lower} - {upper}, but got {actual}\\" is","\\t\\tproduced.",""],"assert_match":["\\t\\tWhen {pattern} does not match {actual} an error message is","\\t\\tadded to |v:errors|.  Also see |assert-return|.","","\\t\\t{pattern} is used as with |=~|: The matching is always done","\\t\\tlike \'magic\' was set and \'cpoptions\' is empty, no matter what","\\t\\tthe actual value of \'magic\' or \'cpoptions\' is.","","\\t\\t{actual} is used as a string, automatic conversion applies.","\\t\\tUse \\"^\\" and \\"$\\" to match with the start and end of the text.","\\t\\tUse both to match the whole text.","","\\t\\tWhen {msg} is omitted an error in the form","\\t\\t\\"Pattern {pattern} does not match {actual}\\" is produced.","\\t\\tExample: >","\\tassert_match(\'^f.*o$\', \'foobar\')","<\\t\\tWill result in a string to be added to |v:errors|:","\\ttest.vim line 12: Pattern \'^f.*o$\' does not match \'foobar\' ~",""],"assert_notequal":["\\t\\tThe opposite of `assert_equal()`: add an error message to","\\t\\t|v:errors| when {expected} and {actual} are equal.","\\t\\tAlso see |assert-return|.",""],"assert_notmatch":["\\t\\tThe opposite of `assert_match()`: add an error message to","\\t\\t|v:errors| when {pattern} matches {actual}.","\\t\\tAlso see |assert-return|."],"assert_report":["\\t\\tReport a test failure directly, using {msg}.","\\t\\tAlways returns one."],"assert_true":["\\t\\tWhen {actual} is not true an error message is added to","\\t\\t|v:errors|, like with |assert_equal()|.","\\t\\tAlso see |assert-return|.","\\t\\tA value is |TRUE| when it is a non-zero number or |v:true|.","\\t\\tWhen {actual} is not a number or |v:true| the assert fails.","\\t\\tWhen {msg} is omitted an error in the form \\"Expected True but","\\t\\tgot {actual}\\" is produced."],"asin":["\\t\\tReturn the arc sine of {expr} measured in radians, as a |Float|","\\t\\tin the range of [-pi/2, pi/2].","\\t\\t{expr} must evaluate to a |Float| or a |Number| in the range","\\t\\t[-1, 1].","\\t\\tExamples: >","\\t\\t\\t:echo asin(0.8)","<\\t\\t\\t0.927295 >","\\t\\t\\t:echo asin(-0.5)","<\\t\\t\\t-0.523599",""],"atan":["\\t\\tReturn the principal value of the arc tangent of {expr}, in","\\t\\tthe range [-pi/2, +pi/2] radians, as a |Float|.","\\t\\t{expr} must evaluate to a |Float| or a |Number|.","\\t\\tExamples: >","\\t\\t\\t:echo atan(100)","<\\t\\t\\t1.560797 >","\\t\\t\\t:echo atan(-4.01)","<\\t\\t\\t-1.326405",""],"atan2":["\\t\\tReturn the arc tangent of {expr1} / {expr2}, measured in","\\t\\tradians, as a |Float| in the range [-pi, pi].","\\t\\t{expr1} and {expr2} must evaluate to a |Float| or a |Number|.","\\t\\tExamples: >","\\t\\t\\t:echo atan2(-1, 1)","<\\t\\t\\t-0.785398 >","\\t\\t\\t:echo atan2(1, -1)","<\\t\\t\\t2.356194","",""],"browse":["\\t\\tPut up a file requester.  This only works when \\"has(\\"browse\\")\\"","\\t\\treturns |TRUE| (only in some GUI versions).","\\t\\tThe input fields are:","\\t\\t    {save}\\twhen |TRUE|, select file to write","\\t\\t    {title}\\ttitle for the requester","\\t\\t    {initdir}\\tdirectory to start browsing in","\\t\\t    {default}\\tdefault file name","\\t\\tWhen the \\"Cancel\\" button is hit, something went wrong, or","\\t\\tbrowsing is not possible, an empty string is returned.",""],"browsedir":["\\t\\tPut up a directory requester.  This only works when","\\t\\t\\"has(\\"browse\\")\\" returns |TRUE| (only in some GUI versions).","\\t\\tOn systems where a directory browser is not supported a file","\\t\\tbrowser is used.  In that case: select a file in the directory","\\t\\tto be used.","\\t\\tThe input fields are:","\\t\\t    {title}\\ttitle for the requester","\\t\\t    {initdir}\\tdirectory to start browsing in","\\t\\tWhen the \\"Cancel\\" button is hit, something went wrong, or","\\t\\tbrowsing is not possible, an empty string is returned."],"bufadd":["\\t\\tAdd a buffer to the buffer list with {name}.","\\t\\tIf a buffer for file {name} already exists, return that buffer","\\t\\tnumber.  Otherwise return the buffer number of the newly","\\t\\tcreated buffer.  When {name} is an empty string then a new","\\t\\tbuffer is always created.","\\t\\tThe buffer will not have\' \'buflisted\' set."],"bufexists":["\\t\\tThe result is a Number, which is |TRUE| if a buffer called","\\t\\t{expr} exists.","\\t\\tIf the {expr} argument is a number, buffer numbers are used.","\\t\\tNumber zero is the alternate buffer for the current window.","","\\t\\tIf the {expr} argument is a string it must match a buffer name","\\t\\texactly.  The name can be:","\\t\\t- Relative to the current directory.","\\t\\t- A full path.","\\t\\t- The name of a buffer with \'buftype\' set to \\"nofile\\".","\\t\\t- A URL name.","\\t\\tUnlisted buffers will be found.","\\t\\tNote that help files are listed by their short name in the","\\t\\toutput of |:buffers|, but bufexists() requires using their","\\t\\tlong name to be able to find them.","\\t\\tbufexists() may report a buffer exists, but to use the name","\\t\\twith a |:buffer| command you may need to use |expand()|.  Esp","\\t\\tfor MS-Windows 8.3 names in the form \\"c:\\\\DOCUME~1\\"","\\t\\tUse \\"bufexists(0)\\" to test for the existence of an alternate","\\t\\tfile name."],"buflisted":["\\t\\tThe result is a Number, which is |TRUE| if a buffer called","\\t\\t{expr} exists and is listed (has the \'buflisted\' option set).","\\t\\tThe {expr} argument is used like with |bufexists()|."],"bufload":["\\t\\tEnsure the buffer {expr} is loaded.  When the buffer name","\\t\\trefers to an existing file then the file is read.  Otherwise","\\t\\tthe buffer will be empty.  If the buffer was already loaded","\\t\\tthen there is no change.","\\t\\tIf there is an existing swap file for the file of the buffer,","\\t\\tthere will be no dialog, the buffer will be loaded anyway.","\\t\\tThe {expr} argument is used like with |bufexists()|."],"bufloaded":["\\t\\tThe result is a Number, which is |TRUE| if a buffer called","\\t\\t{expr} exists and is loaded (shown in a window or hidden).","\\t\\tThe {expr} argument is used like with |bufexists()|."],"bufname":["\\t\\tThe result is the name of a buffer, as it is displayed by the","\\t\\t\\":ls\\" command.","+\\t\\tIf {expr} is omitted the current buffer is used.","\\t\\tIf {expr} is a Number, that buffer number\'s name is given.","\\t\\tNumber zero is the alternate buffer for the current window.","\\t\\tIf {expr} is a String, it is used as a |file-pattern| to match","\\t\\twith the buffer names.  This is always done like \'magic\' is","\\t\\tset and \'cpoptions\' is empty.  When there is more than one","\\t\\tmatch an empty string is returned.","\\t\\t\\"\\" or \\"%\\" can be used for the current buffer, \\"#\\" for the","\\t\\talternate buffer.","\\t\\tA full match is preferred, otherwise a match at the start, end","\\t\\tor middle of the buffer name is accepted.  If you only want a","\\t\\tfull match then put \\"^\\" at the start and \\"$\\" at the end of the","\\t\\tpattern.","\\t\\tListed buffers are found first.  If there is a single match","\\t\\twith a listed buffer, that one is returned.  Next unlisted","\\t\\tbuffers are searched for.","\\t\\tIf the {expr} is a String, but you want to use it as a buffer","\\t\\tnumber, force it to be a Number by adding zero to it: >","\\t\\t\\t:echo bufname(\\"3\\" + 0)","<\\t\\tIf the buffer doesn\'t exist, or doesn\'t have a name, an empty","\\t\\tstring is returned. >","\\tbufname(\\"#\\")\\t\\talternate buffer name","\\tbufname(3)\\t\\tname of buffer 3","\\tbufname(\\"%\\")\\t\\tname of current buffer","\\tbufname(\\"file2\\")\\tname of buffer where \\"file2\\" matches.",""],"bufnr":["\\t\\tThe result is the number of a buffer, as it is displayed by","\\t\\tthe \\":ls\\" command.  For the use of {expr}, see |bufname()|","\\t\\tabove.","\\t\\tIf the buffer doesn\'t exist, -1 is returned.  Or, if the","\\t\\t{create} argument is present and not zero, a new, unlisted,","\\t\\tbuffer is created and its number is returned.","\\t\\tbufnr(\\"$\\") is the last buffer: >","\\t\\t\\t:let last_buffer = bufnr(\\"$\\")","<\\t\\tThe result is a Number, which is the highest buffer number","\\t\\tof existing buffers.  Note that not all buffers with a smaller","\\t\\tnumber necessarily exist, because \\":bwipeout\\" may have removed","\\t\\tthem.  Use bufexists() to test for the existence of a buffer."],"bufwinid":["\\t\\tThe result is a Number, which is the |window-ID| of the first","\\t\\twindow associated with buffer {expr}.  For the use of {expr},","\\t\\tsee |bufname()| above.  If buffer {expr} doesn\'t exist or","\\t\\tthere is no such window, -1 is returned.  Example: >","","\\techo \\"A window containing buffer 1 is \\" . (bufwinid(1))","<","\\t\\tOnly deals with the current tab page."],"bufwinnr":["\\t\\tThe result is a Number, which is the number of the first","\\t\\twindow associated with buffer {expr}.  For the use of {expr},","\\t\\tsee |bufname()| above.  If buffer {expr} doesn\'t exist or","\\t\\tthere is no such window, -1 is returned.  Example: >","","\\techo \\"A window containing buffer 1 is \\" . (bufwinnr(1))","","<\\t\\tThe number can be used with |CTRL-W_w| and \\":wincmd w\\"","\\t\\t|:wincmd|.","\\t\\tOnly deals with the current tab page.",""],"byte2line":["\\t\\tReturn the line number that contains the character at byte","\\t\\tcount {byte} in the current buffer.  This includes the","\\t\\tend-of-line character, depending on the \'fileformat\' option","\\t\\tfor the current buffer.  The first character has byte count","\\t\\tone.","\\t\\tAlso see |line2byte()|, |go| and |:goto|."],"byteidx":["\\t\\tReturn byte index of the {nr}\'th character in the string","\\t\\t{expr}.  Use zero for the first character, it returns zero.","\\t\\tThis function is only useful when there are multibyte","\\t\\tcharacters, otherwise the returned value is equal to {nr}.","\\t\\tComposing characters are not counted separately, their byte","\\t\\tlength is added to the preceding base character.  See","\\t\\t|byteidxcomp()| below for counting composing characters","\\t\\tseparately.","\\t\\tExample : >","\\t\\t\\techo matchstr(str, \\".\\", byteidx(str, 3))","<\\t\\twill display the fourth character.  Another way to do the","\\t\\tsame: >","\\t\\t\\tlet s = strpart(str, byteidx(str, 3))","\\t\\t\\techo strpart(s, 0, byteidx(s, 1))","<\\t\\tAlso see |strgetchar()| and |strcharpart()|.","","\\t\\tIf there are less than {nr} characters -1 is returned.","\\t\\tIf there are exactly {nr} characters the length of the string","\\t\\tin bytes is returned."],"byteidxcomp":["\\t\\tLike byteidx(), except that a composing character is counted","\\t\\tas a separate character.  Example: >","\\t\\t\\tlet s = \'e\' . nr2char(0x301)","\\t\\t\\techo byteidx(s, 1)","\\t\\t\\techo byteidxcomp(s, 1)","\\t\\t\\techo byteidxcomp(s, 2)","<\\t\\tThe first and third echo result in 3 (\'e\' plus composing","\\t\\tcharacter is 3 bytes), the second echo results in 1 (\'e\' is","\\t\\tone byte)."],"call":["\\t\\tCall function {func} with the items in |List| {arglist} as","\\t\\targuments.","\\t\\t{func} can either be a |Funcref| or the name of a function.","\\t\\ta:firstline and a:lastline are set to the cursor line.","\\t\\tReturns the return value of the called function.","\\t\\t{dict} is for functions with the \\"dict\\" attribute.  It will be","\\t\\tused to set the local variable \\"self\\". |Dictionary-function|"],"ceil":["\\t\\tReturn the smallest integral value greater than or equal to","\\t\\t{expr} as a |Float| (round up).","\\t\\t{expr} must evaluate to a |Float| or a |Number|.","\\t\\tExamples: >","\\t\\t\\techo ceil(1.456)","<\\t\\t\\t2.0  >","\\t\\t\\techo ceil(-5.456)","<\\t\\t\\t-5.0  >","\\t\\t\\techo ceil(4.0)","<\\t\\t\\t4.0"],"changenr":["\\t\\tReturn the number of the most recent change.  This is the same","\\t\\tnumber as what is displayed with |:undolist| and can be used","\\t\\twith the |:undo| command.","\\t\\tWhen a change was made it is the number of that change.  After","\\t\\tredo it is the number of the redone change.  After undo it is","\\t\\tone less than the number of the undone change."],"chanclose":["\\t\\tClose a channel or a specific stream associated with it.","\\t\\tFor a job, {stream} can be one of \\"stdin\\", \\"stdout\\",","\\t\\t\\"stderr\\" or \\"rpc\\" (closes stdin/stdout for a job started","\\t\\twith `\\"rpc\\":v:true`) If {stream} is omitted, all streams","\\t\\tare closed. If the channel is a pty, this will then close the","\\t\\tpty master, sending SIGHUP to the job process.","\\t\\tFor a socket, there is only one stream, and {stream} should be","\\t\\tommited."],"chansend":["\\t\\tSend data to channel {id}. For a job, it writes it to the","\\t\\tstdin of the process. For the stdio channel |channel-stdio|,","\\t\\tit writes to Nvim\'s stdout.  Returns the number of bytes","\\t\\twritten if the write succeeded, 0 otherwise.","\\t\\tSee |channel-bytes| for more information.","","\\t\\t{data} may be a string, string convertible, or a list.  If","\\t\\t{data} is a list, the items will be joined by newlines; any","\\t\\tnewlines in an item will be sent as NUL. To send a final","\\t\\tnewline, include a final empty string. Example: >","\\t\\t\\t:call chansend(id, [\\"abc\\", \\"123\\\\n456\\", \\"\\"])","< \\t\\twill send \\"abc<NL>123<NUL>456<NL>\\".","","\\t\\tchansend() writes raw data, not RPC messages.  If the channel","\\t\\twas created with `\\"rpc\\":v:true` then the channel expects RPC","\\t\\tmessages, use |rpcnotify()| and |rpcrequest()| instead.",""],"char2nr":["\\t\\tReturn number value of the first char in {expr}.  Examples: >","\\t\\t\\tchar2nr(\\" \\")\\t\\treturns 32","\\t\\t\\tchar2nr(\\"ABC\\")\\t\\treturns 65","\\t\\t\\tchar2nr(\\"á\\")\\t\\treturns 225","\\t\\t\\tchar2nr(\\"á\\"[0])\\t\\treturns 195","\\t\\t\\tchar2nr(\\"\\\\<M-x>\\")\\treturns 128","<\\t\\tNon-ASCII characters are always treated as UTF-8 characters.","\\t\\t{utf8} is ignored, it exists only for backwards-compatibility.","\\t\\tA combining character is a separate character.","\\t\\t|nr2char()| does the opposite."],"cindent":["\\t\\tGet the amount of indent for line {lnum} according the C","\\t\\tindenting rules, as with \'cindent\'.","\\t\\tThe indent is counted in spaces, the value of \'tabstop\' is","\\t\\trelevant.  {lnum} is used just like in |getline()|.","\\t\\tWhen {lnum} is invalid -1 is returned.","\\t\\tSee |C-indenting|."],"clearmatches":["\\t\\tClears all matches previously defined for the current window","\\t\\tby |matchadd()| and the |:match| commands.",""],"col":["\\t\\tposition given with {expr}.  The accepted positions are:","\\t\\t    .\\t    the cursor position","\\t\\t    $\\t    the end of the cursor line (the result is the","\\t\\t\\t    number of bytes in the cursor line plus one)","\\t\\t    \'x\\t    position of mark x (if the mark is not set, 0 is","\\t\\t\\t    returned)","\\t\\t    v       In Visual mode: the start of the Visual area (the","\\t\\t\\t    cursor is the end).  When not in Visual mode","\\t\\t\\t    returns the cursor position.  Differs from |\'<| in","\\t\\t\\t    that it\'s updated right away.","\\t\\tAdditionally {expr} can be [lnum, col]: a |List| with the line","\\t\\tand column number. Most useful when the column is \\"$\\", to get","\\t\\tthe last column of a specific line.  When \\"lnum\\" or \\"col\\" is","\\t\\tout of range then col() returns zero.","\\t\\tTo get the line number use |line()|.  To get both use","\\t\\t|getpos()|.","\\t\\tFor the screen column position use |virtcol()|.","\\t\\tNote that only marks in the current file can be used.","\\t\\tExamples: >","\\t\\t\\tcol(\\".\\")\\t\\tcolumn of cursor","\\t\\t\\tcol(\\"$\\")\\t\\tlength of cursor line plus one","\\t\\t\\tcol(\\"\'t\\")\\t\\tcolumn of mark t","\\t\\t\\tcol(\\"\'\\" . markname)\\tcolumn of mark markname","<\\t\\tThe first column is 1.  0 is returned for an error.","\\t\\tFor an uppercase mark the column may actually be in another","\\t\\tbuffer.","\\t\\tFor the cursor position, when \'virtualedit\' is active, the","\\t\\tcolumn is one higher if the cursor is after the end of the","\\t\\tline.  This can be used to obtain the column in Insert mode: >","\\t\\t\\t:imap <F2> <C-O>:let save_ve = &ve<CR>","\\t\\t\\t\\t\\\\<C-O>:set ve=all<CR>","\\t\\t\\t\\t\\\\<C-O>:echo col(\\".\\") . \\"\\\\n\\" <Bar>","\\t\\t\\t\\t\\\\let &ve = save_ve<CR>","<"],"complete":["\\t\\tSet the matches for Insert mode completion.","\\t\\tCan only be used in Insert mode.  You need to use a mapping","\\t\\twith CTRL-R = (see |i_CTRL-R|).  It does not work after CTRL-O","\\t\\tor with an expression mapping.","\\t\\t{startcol} is the byte offset in the line where the completed","\\t\\ttext start.  The text up to the cursor is the original text","\\t\\tthat will be replaced by the matches.  Use col(\'.\') for an","\\t\\tempty string.  \\"col(\'.\') - 1\\" will replace one character by a","\\t\\tmatch.","\\t\\t{matches} must be a |List|.  Each |List| item is one match.","\\t\\tSee |complete-items| for the kind of items that are possible.","\\t\\tNote that the after calling this function you need to avoid","\\t\\tinserting anything that would cause completion to stop.","\\t\\tThe match can be selected with CTRL-N and CTRL-P as usual with","\\t\\tInsert mode completion.  The popup menu will appear if","\\t\\tspecified, see |ins-completion-menu|.","\\t\\tExample: >","\\tinoremap <F5> <C-R>=ListMonths()<CR>","","\\tfunc! ListMonths()","\\t  call complete(col(\'.\'), [\'January\', \'February\', \'March\',","\\t\\t\\\\ \'April\', \'May\', \'June\', \'July\', \'August\', \'September\',","\\t\\t\\\\ \'October\', \'November\', \'December\'])","\\t  return \'\'","\\tendfunc","<\\t\\tThis isn\'t very useful, but it shows how it works.  Note that","\\t\\tan empty string is returned to avoid a zero being inserted."],"complete_add":["\\t\\tAdd {expr} to the list of matches.  Only to be used by the","\\t\\tfunction specified with the \'completefunc\' option.","\\t\\tReturns 0 for failure (empty string or out of memory),","\\t\\t1 when the match was added, 2 when the match was already in","\\t\\tthe list.","\\t\\tSee |complete-functions| for an explanation of {expr}.  It is","\\t\\tthe same as one item in the list that \'omnifunc\' would return."],"complete_check":["\\t\\tCheck for a key typed while looking for completion matches.","\\t\\tThis is to be used when looking for matches takes some time.","\\t\\tReturns |TRUE| when searching for matches is to be aborted,","\\t\\tzero otherwise.","\\t\\tOnly to be used by the function specified with the","\\t\\t\'completefunc\' option.",""],"complete_info":["\\t\\tReturns a Dictionary with information about Insert mode","\\t\\tcompletion.  See |ins-completion|.","\\t\\tThe items are:","\\t\\t   mode\\t\\tCurrent completion mode name string.","\\t\\t\\t\\tSee |complete_info_mode| for the values.","\\t\\t   pum_visible\\t|TRUE| if popup menu is visible.","\\t\\t\\t\\tSee |pumvisible()|.","\\t\\t   items\\tList of completion matches.  Each item is a","\\t\\t\\t\\tdictionary containing the entries \\"word\\",","\\t\\t\\t\\t\\"abbr\\", \\"menu\\", \\"kind\\", \\"info\\" and \\"user_data\\".","\\t\\t\\t\\tSee |complete-items|.","\\t\\t   selected\\tSelected item index.  First index is zero.","\\t\\t\\t\\tIndex is -1 if no item is selected (showing","\\t\\t\\t\\ttyped text only)","\\t\\t   inserted\\tInserted string. [NOT IMPLEMENT YET]","","\\t\\t\\t\\t\\t\\t\\t*complete_info_mode*","\\t\\tmode values are:","\\t\\t   \\"\\"\\t\\t     Not in completion mode","\\t\\t   \\"keyword\\"\\t     Keyword completion |i_CTRL-X_CTRL-N|","\\t\\t   \\"ctrl_x\\"\\t     Just pressed CTRL-X |i_CTRL-X|","\\t\\t   \\"whole_line\\"\\t     Whole lines |i_CTRL-X_CTRL-L|","\\t\\t   \\"files\\"\\t     File names |i_CTRL-X_CTRL-F|","\\t\\t   \\"tags\\"\\t     Tags |i_CTRL-X_CTRL-]|","\\t\\t   \\"path_defines\\"    Definition completion |i_CTRL-X_CTRL-D|","\\t\\t   \\"path_patterns\\"   Include completion |i_CTRL-X_CTRL-I|","\\t\\t   \\"dictionary\\"\\t     Dictionary |i_CTRL-X_CTRL-K|","\\t\\t   \\"thesaurus\\"\\t     Thesaurus |i_CTRL-X_CTRL-T|","\\t\\t   \\"cmdline\\"\\t     Vim Command line |i_CTRL-X_CTRL-V|","\\t\\t   \\"function\\"\\t     User defined completion |i_CTRL-X_CTRL-U|","\\t\\t   \\"omni\\"\\t     Omni completion |i_CTRL-X_CTRL-O|","\\t\\t   \\"spell\\"\\t     Spelling suggestions |i_CTRL-X_s|","\\t\\t   \\"eval\\"            |complete()| completion","\\t\\t   \\"unknown\\"\\t     Other internal modes","","\\t\\tIf the optional {what} list argument is supplied, then only","\\t\\tthe items listed in {what} are returned.  Unsupported items in","\\t\\t{what} are silently ignored.","","\\t\\tTo get the position and size of the popup menu, see","\\t\\t|pum_getpos()|. It\'s also available in |v:event| during the","\\t\\t|CompleteChanged| event.","","\\t\\tExamples: >","\\t\\t\\t\\" Get all items","\\t\\t\\tcall complete_info()","\\t\\t\\t\\" Get only \'mode\'","\\t\\t\\tcall complete_info([\'mode\'])","\\t\\t\\t\\" Get only \'mode\' and \'pum_visible\'","\\t\\t\\tcall complete_info([\'mode\', \'pum_visible\'])","<"],"confirm":["\\t\\tConfirm() offers the user a dialog, from which a choice can be","\\t\\tmade.  It returns the number of the choice.  For the first","\\t\\tchoice this is 1.","","\\t\\t{msg} is displayed in a dialog with {choices} as the","\\t\\talternatives.  When {choices} is missing or empty, \\"&OK\\" is","\\t\\tused (and translated).","\\t\\t{msg} is a String, use \'\\\\n\' to include a newline.  Only on","\\t\\tsome systems the string is wrapped when it doesn\'t fit.","","\\t\\t{choices} is a String, with the individual choices separated","\\t\\tby \'\\\\n\', e.g. >","\\t\\t\\tconfirm(\\"Save changes?\\", \\"&Yes\\\\n&No\\\\n&Cancel\\")","<\\t\\tThe letter after the \'&\' is the shortcut key for that choice.","\\t\\tThus you can type \'c\' to select \\"Cancel\\".  The shortcut does","\\t\\tnot need to be the first letter: >","\\t\\t\\tconfirm(\\"file has been modified\\", \\"&Save\\\\nSave &All\\")","<\\t\\tFor the console, the first letter of each choice is used as","\\t\\tthe default shortcut key.","","\\t\\tThe optional {default} argument is the number of the choice","\\t\\tthat is made if the user hits <CR>.  Use 1 to make the first","\\t\\tchoice the default one.  Use 0 to not set a default.  If","\\t\\t{default} is omitted, 1 is used.","","\\t\\tThe optional {type} argument gives the type of dialog.  This","\\t\\tis only used for the icon of the Win32 GUI.  It can be one of","\\t\\tthese values: \\"Error\\", \\"Question\\", \\"Info\\", \\"Warning\\" or","\\t\\t\\"Generic\\".  Only the first character is relevant.","\\t\\tWhen {type} is omitted, \\"Generic\\" is used.","","\\t\\tIf the user aborts the dialog by pressing <Esc>, CTRL-C,","\\t\\tor another valid interrupt key, confirm() returns 0.","","\\t\\tAn example: >","   :let choice = confirm(\\"What do you want?\\", \\"&Apples\\\\n&Oranges\\\\n&Bananas\\", 2)","   :if choice == 0","   :\\techo \\"make up your mind!\\"","   :elseif choice == 3","   :\\techo \\"tasteful\\"","   :else","   :\\techo \\"I prefer bananas myself.\\"","   :endif","<\\t\\tIn a GUI dialog, buttons are used.  The layout of the buttons","\\t\\tdepends on the \'v\' flag in \'guioptions\'.  If it is included,","\\t\\tthe buttons are always put vertically.  Otherwise,  confirm()","\\t\\ttries to put the buttons in one horizontal line.  If they","\\t\\tdon\'t fit, a vertical layout is used anyway.  For some systems","\\t\\tthe horizontal layout is always used.",""],"copy":["\\t\\tdifferent from using {expr} directly.","\\t\\tWhen {expr} is a |List| a shallow copy is created.  This means","\\t\\tthat the original |List| can be changed without changing the","\\t\\tcopy, and vice versa.  But the items are identical, thus","\\t\\tchanging an item changes the contents of both |Lists|.","\\t\\tA |Dictionary| is copied in a similar way as a |List|.","\\t\\tAlso see |deepcopy()|."],"cos":["\\t\\tReturn the cosine of {expr}, measured in radians, as a |Float|.","\\t\\t{expr} must evaluate to a |Float| or a |Number|.","\\t\\tExamples: >","\\t\\t\\t:echo cos(100)","<\\t\\t\\t0.862319 >","\\t\\t\\t:echo cos(-4.01)","<\\t\\t\\t-0.646043",""],"cosh":["\\t\\tReturn the hyperbolic cosine of {expr} as a |Float| in the range","\\t\\t[1, inf].","\\t\\t{expr} must evaluate to a |Float| or a |Number|.","\\t\\tExamples: >","\\t\\t\\t:echo cosh(0.5)","<\\t\\t\\t1.127626 >","\\t\\t\\t:echo cosh(-0.5)","<\\t\\t\\t-1.127626",""],"count":["\\t\\tReturn the number of times an item with value {expr} appears","\\t\\tin |String|, |List| or |Dictionary| {comp}.","","\\t\\tIf {start} is given then start with the item with this index.","\\t\\t{start} can only be used with a |List|.","","\\t\\tWhen {ic} is given and it\'s |TRUE| then case is ignored.","","\\t\\tWhen {comp} is a string then the number of not overlapping","\\t\\toccurrences of {expr} is returned. Zero is returned when","\\t\\t{expr} is an empty string.",""],"cscope_connection":["\\t\\tChecks for the existence of a |cscope| connection.  If no","\\t\\tparameters are specified, then the function returns:","\\t\\t\\t0, if cscope was not available (not compiled in), or","\\t\\t\\t   if there are no cscope connections;","\\t\\t\\t1, if there is at least one cscope connection.","","\\t\\tIf parameters are specified, then the value of {num}","\\t\\tdetermines how existence of a cscope connection is checked:","","\\t\\t{num}\\tDescription of existence check","\\t\\t-----\\t------------------------------","\\t\\t0\\tSame as no parameters (e.g., \\"cscope_connection()\\").","\\t\\t1\\tIgnore {prepend}, and use partial string matches for","\\t\\t\\t{dbpath}.","\\t\\t2\\tIgnore {prepend}, and use exact string matches for","\\t\\t\\t{dbpath}.","\\t\\t3\\tUse {prepend}, use partial string matches for both","\\t\\t\\t{dbpath} and {prepend}.","\\t\\t4\\tUse {prepend}, use exact string matches for both","\\t\\t\\t{dbpath} and {prepend}.","","\\t\\tNote: All string comparisons are case sensitive!","","\\t\\tExamples.  Suppose we had the following (from \\":cs show\\"): >","","  # pid    database name\\t\\t\\tprepend path","  0 27664  cscope.out\\t\\t\\t\\t/usr/local","<","\\t\\tInvocation\\t\\t\\t\\t\\tReturn Val ~","\\t\\t----------\\t\\t\\t\\t\\t---------- >","\\t\\tcscope_connection()\\t\\t\\t\\t\\t1","\\t\\tcscope_connection(1, \\"out\\")\\t\\t\\t\\t1","\\t\\tcscope_connection(2, \\"out\\")\\t\\t\\t\\t0","\\t\\tcscope_connection(3, \\"out\\")\\t\\t\\t\\t0","\\t\\tcscope_connection(3, \\"out\\", \\"local\\")\\t\\t\\t1","\\t\\tcscope_connection(4, \\"out\\")\\t\\t\\t\\t0","\\t\\tcscope_connection(4, \\"out\\", \\"local\\")\\t\\t\\t0","\\t\\tcscope_connection(4, \\"cscope.out\\", \\"/usr/local\\")\\t1","<"],"ctxget":["\\t\\tReturns a |Dictionary| representing the |context| at {index}","\\t\\tfrom the top of the |context-stack| (see |context-dict|).","\\t\\tIf {index} is not given, it is assumed to be 0 (i.e.: top)."],"ctxpop":["\\t\\tPops and restores the |context| at the top of the","\\t\\t|context-stack|."],"ctxpush":["\\t\\tPushes the current editor state (|context|) on the","\\t\\t|context-stack|.","\\t\\tIf {types} is given and is a |List| of |String|s, it specifies","\\t\\twhich |context-types| to include in the pushed context.","\\t\\tOtherwise, all context types are included."],"ctxset":["\\t\\tSets the |context| at {index} from the top of the","\\t\\t|context-stack| to that represented by {context}.","\\t\\t{context} is a Dictionary with context data (|context-dict|).","\\t\\tIf {index} is not given, it is assumed to be 0 (i.e.: top)."],"ctxsize":["\\t\\tReturns the size of the |context-stack|."],"cursor":["\\t\\tPositions the cursor at the column (byte count) {col} in the","\\t\\tline {lnum}.  The first column is one.","","\\t\\tWhen there is one argument {list} this is used as a |List|","\\t\\twith two, three or four item:","\\t\\t\\t[{lnum}, {col}]","\\t\\t\\t[{lnum}, {col}, {off}]","\\t\\t\\t[{lnum}, {col}, {off}, {curswant}]","\\t\\tThis is like the return value of |getpos()| or |getcurpos()|,","\\t\\tbut without the first item.","","\\t\\tDoes not change the jumplist.","\\t\\tIf {lnum} is greater than the number of lines in the buffer,","\\t\\tthe cursor will be positioned at the last line in the buffer.","\\t\\tIf {lnum} is zero, the cursor will stay in the current line.","\\t\\tIf {col} is greater than the number of bytes in the line,","\\t\\tthe cursor will be positioned at the last character in the","\\t\\tline.","\\t\\tIf {col} is zero, the cursor will stay in the current column.","\\t\\tIf {curswant} is given it is used to set the preferred column","\\t\\tfor vertical movement.  Otherwise {col} is used.","","\\t\\tWhen \'virtualedit\' is used {off} specifies the offset in","\\t\\tscreen columns from the start of the character.  E.g., a","\\t\\tposition within a <Tab> or after the last character.","\\t\\tReturns 0 when the position could be set, -1 otherwise.",""],"deepcopy":["\\t\\tMake a copy of {expr}.  For Numbers and Strings this isn\'t","\\t\\tdifferent from using {expr} directly.","\\t\\tWhen {expr} is a |List| a full copy is created.  This means","\\t\\tthat the original |List| can be changed without changing the","\\t\\tcopy, and vice versa.  When an item is a |List|, a copy for it","\\t\\tis made, recursively.  Thus changing an item in the copy does","\\t\\tnot change the contents of the original |List|.","\\t\\tWhen {noref} is omitted or zero a contained |List| or","\\t\\t|Dictionary| is only copied once.  All references point to","\\t\\tthis single copy.  With {noref} set to 1 every occurrence of a","\\t\\t|List| or |Dictionary| results in a new copy.  This also means","\\t\\tthat a cyclic reference causes deepcopy() to fail.","\\t\\t\\t\\t\\t\\t\\t\\t*E724*","\\t\\tNesting is possible up to 100 levels.  When there is an item","\\t\\tthat refers back to a higher level making a deep copy with","\\t\\t{noref} set to 1 will fail.","\\t\\tAlso see |copy()|."],"delete":["\\t\\tWithout {flags} or with {flags} empty: Deletes the file by the","\\t\\tname {fname}.  This also works when {fname} is a symbolic link.","\\t\\tA symbolic link itself is deleted, not what it points to.","","\\t\\tWhen {flags} is \\"d\\": Deletes the directory by the name","\\t\\t{fname}.  This fails when directory {fname} is not empty.","","\\t\\tWhen {flags} is \\"rf\\": Deletes the directory by the name","\\t\\t{fname} and everything in it, recursively.  BE CAREFUL!","\\t\\tNote: on MS-Windows it is not possible to delete a directory","\\t\\tthat is being used.","","\\t\\tThe result is a Number, which is 0 if the delete operation was","\\t\\tsuccessful and -1 when the deletion failed or partly failed."],"deletebufline":["\\t\\tDelete lines {first} to {last} (inclusive) from buffer {expr}.","\\t\\tIf {last} is omitted then delete line {first} only.","\\t\\tOn success 0 is returned, on failure 1 is returned.","","\\t\\tFor the use of {expr}, see |bufname()| above.","","\\t\\t{first} and {last} are used like with |setline()|. Note that","\\t\\twhen using |line()| this refers to the current buffer. Use \\"$\\"","\\t\\tto refer to the last line in buffer {expr}."],"dictwatcheradd":["\\t\\tAdds a watcher to a dictionary. A dictionary watcher is","\\t\\tidentified by three components:","","\\t\\t- A dictionary({dict});","\\t\\t- A key pattern({pattern}).","\\t\\t- A function({callback}).","","\\t\\tAfter this is called, every change on {dict} and on keys","\\t\\tmatching {pattern} will result in {callback} being invoked.","","\\t\\tFor example, to watch all global variables: >","\\t\\t\\tsilent! call dictwatcherdel(g:, \'*\', \'OnDictChanged\')","\\t\\t\\tfunction! OnDictChanged(d,k,z)","\\t\\t\\t  echomsg string(a:k) string(a:z)","\\t\\t\\tendfunction","\\t\\t\\tcall dictwatcheradd(g:, \'*\', \'OnDictChanged\')","<","\\t\\tFor now {pattern} only accepts very simple patterns that can","\\t\\tcontain a \'*\' at the end of the string, in which case it will","\\t\\tmatch every key that begins with the substring before the \'*\'.","\\t\\tThat means if \'*\' is not the last character of {pattern}, only","\\t\\tkeys that are exactly equal as {pattern} will be matched.","","\\t\\tThe {callback} receives three arguments:","","\\t\\t- The dictionary being watched.","\\t\\t- The key which changed.","\\t\\t- A dictionary containing the new and old values for the key.","","\\t\\tThe type of change can be determined by examining the keys","\\t\\tpresent on the third argument:","","\\t\\t- If contains both `old` and `new`, the key was updated.","\\t\\t- If it contains only `new`, the key was added.","\\t\\t- If it contains only `old`, the key was deleted.","","\\t\\tThis function can be used by plugins to implement options with","\\t\\tvalidation and parsing logic."],"dictwatcherdel":["\\t\\tRemoves a watcher added  with |dictwatcheradd()|. All three","\\t\\targuments must match the ones passed to |dictwatcheradd()| in","\\t\\torder for the watcher to be successfully deleted.",""],"did_filetype":["\\t\\tFileType event has been triggered at least once.  Can be used","\\t\\tto avoid triggering the FileType event again in the scripts","\\t\\tthat detect the file type. |FileType|","\\t\\tReturns |FALSE| when `:setf FALLBACK` was used.","\\t\\tWhen editing another file, the counter is reset, thus this","\\t\\treally checks if the FileType event has been triggered for the","\\t\\tcurrent buffer.  This allows an autocommand that starts","\\t\\tediting another buffer to set \'filetype\' and load a syntax","\\t\\tfile."],"diff_filler":["\\t\\tReturns the number of filler lines above line {lnum}.","\\t\\tThese are the lines that were inserted at this point in","\\t\\tanother diff\'ed window.  These filler lines are shown in the","\\t\\tdisplay but don\'t exist in the buffer.","\\t\\t{lnum} is used like with |getline()|.  Thus \\".\\" is the current","\\t\\tline, \\"\'m\\" mark m, etc.","\\t\\tReturns 0 if the current window is not in diff mode."],"diff_hlID":["\\t\\tReturns the highlight ID for diff mode at line {lnum} column","\\t\\t{col} (byte index).  When the current line does not have a","\\t\\tdiff change zero is returned.","\\t\\t{lnum} is used like with |getline()|.  Thus \\".\\" is the current","\\t\\tline, \\"\'m\\" mark m, etc.","\\t\\t{col} is 1 for the leftmost column, {lnum} is 1 for the first","\\t\\tline.","\\t\\tThe highlight ID can be used with |synIDattr()| to obtain","\\t\\tsyntax information about the highlighting."],"environ":["\\t\\tReturn all of environment variables as dictionary. You can","\\t\\tcheck if an environment variable exists like this: >","\\t\\t\\t:echo has_key(environ(), \'HOME\')","<\\t\\tNote that the variable name may be CamelCase; to ignore case","\\t\\tuse this: >","\\t\\t\\t:echo index(keys(environ()), \'HOME\', 0, 1) != -1"],"empty":["\\t\\tReturn the Number 1 if {expr} is empty, zero otherwise.","\\t\\tA |List| or |Dictionary| is empty when it does not have any","\\t\\titems.  A Number is empty when its value is zero.  Special","\\t\\tvariable is empty when it is |v:false| or |v:null|."],"escape":["\\t\\tEscape the characters in {chars} that occur in {string} with a","\\t\\tbackslash.  Example: >","\\t\\t\\t:echo escape(\'c:\\\\program files\\\\vim\', \' \\\\\')","<\\t\\tresults in: >","\\t\\t\\tc:\\\\\\\\program\\\\ files\\\\\\\\vim","<\\t\\tAlso see |shellescape()| and |fnameescape()|.",""],"eval":["\\t\\tturn the result of |string()| back into the original value.","\\t\\tThis works for Numbers, Floats, Strings and composites of","\\t\\tthem.  Also works for |Funcref|s that refer to existing","\\t\\tfunctions."],"eventhandler":["\\t\\tReturns 1 when inside an event handler.  That is that Vim got","\\t\\tinterrupted while waiting for the user to type a character,","\\t\\te.g., when dropping a file on Vim.  This means interactive","\\t\\tcommands cannot be used.  Otherwise zero is returned."],"executable":["\\t\\tThis function checks if an executable with the name {expr}","\\t\\texists.  {expr} must be the name of the program without any","\\t\\targuments.","\\t\\texecutable() uses the value of $PATH and/or the normal","\\t\\tsearchpath for programs.\\t\\t*PATHEXT*","\\t\\tOn Windows the \\".exe\\", \\".bat\\", etc. can","\\t\\toptionally be included.  Then the extensions in $PATHEXT are","\\t\\ttried.  Thus if \\"foo.exe\\" does not exist, \\"foo.exe.bat\\" can be","\\t\\tfound.  If $PATHEXT is not set then \\".exe;.com;.bat;.cmd\\" is","\\t\\tused.  A dot by itself can be used in $PATHEXT to try using","\\t\\tthe name without an extension.  When \'shell\' looks like a","\\t\\tUnix shell, then the name is also tried without adding an","\\t\\textension.","\\t\\tOn Windows it only checks if the file exists and","\\t\\tis not a directory, not if it\'s really executable.","\\t\\tOn Windows an executable in the same directory as Vim is","\\t\\talways found (it is added to $PATH at |startup|).","\\t\\tThe result is a Number:","\\t\\t\\t1\\texists","\\t\\t\\t0\\tdoes not exist","\\t\\t\\t-1\\tnot implemented on this system","\\t\\t|exepath()| can be used to get the full path of an executable."],"execute":["\\t\\tExecute {command} and capture its output.","\\t\\tIf {command} is a |String|, returns {command} output.","\\t\\tIf {command} is a |List|, returns concatenated outputs.","\\t\\tExamples: >","\\t\\t\\techo execute(\'echon \\"foo\\"\')","<\\t\\t\\tfoo >","\\t\\t\\techo execute([\'echon \\"foo\\"\', \'echon \\"bar\\"\'])","<\\t\\t\\tfoobar","","\\t\\tThe optional {silent} argument can have these values:","\\t\\t\\t\\"\\"\\t\\tno `:silent` used","\\t\\t\\t\\"silent\\"\\t`:silent` used","\\t\\t\\t\\"silent!\\"\\t`:silent!` used","\\t\\tThe default is \\"silent\\".  Note that with \\"silent!\\", unlike","\\t\\t`:redir`, error messages are dropped.","","\\t\\tTo get a list of lines use |split()| on the result: >","\\t\\t\\tsplit(execute(\'args\'), \\"\\\\n\\")","","<\\t\\tThis function is not available in the |sandbox|.","\\t\\tNote: If nested, an outer execute() will not observe output of","\\t\\tthe inner calls.","\\t\\tNote: Text attributes (highlights) are not captured."],"exepath":["\\t\\tReturns the full path of {expr} if it is an executable and","\\t\\tgiven as a (partial or full) path or is found in $PATH.","\\t\\tReturns empty string otherwise.","\\t\\tIf {expr} starts with \\"./\\" the |current-directory| is used.",""],"exists":["\\t\\tdefined, zero otherwise.","","\\t\\tFor checking for a supported feature use |has()|.","\\t\\tFor checking if a file exists use |filereadable()|.","","\\t\\tThe {expr} argument is a string, which contains one of these:","\\t\\t\\t&option-name\\tVim option (only checks if it exists,","\\t\\t\\t\\t\\tnot if it really works)","\\t\\t\\t+option-name\\tVim option that works.","\\t\\t\\t$ENVNAME\\tenvironment variable (could also be","\\t\\t\\t\\t\\tdone by comparing with an empty","\\t\\t\\t\\t\\tstring)","\\t\\t\\t*funcname\\tbuilt-in function (see |functions|)","\\t\\t\\t\\t\\tor user defined function (see","\\t\\t\\t\\t\\t|user-function|). Also works for a","\\t\\t\\t\\t\\tvariable that is a Funcref.","\\t\\t\\tvarname\\t\\tinternal variable (see","\\t\\t\\t\\t\\t|internal-variables|).  Also works","\\t\\t\\t\\t\\tfor |curly-braces-names|, |Dictionary|","\\t\\t\\t\\t\\tentries, |List| items, etc.  Beware","\\t\\t\\t\\t\\tthat evaluating an index may cause an","\\t\\t\\t\\t\\terror message for an invalid","\\t\\t\\t\\t\\texpression.  E.g.: >","\\t\\t\\t\\t\\t   :let l = [1, 2, 3]","\\t\\t\\t\\t\\t   :echo exists(\\"l[5]\\")","<\\t\\t\\t\\t\\t   0 >","\\t\\t\\t\\t\\t   :echo exists(\\"l[xx]\\")","<\\t\\t\\t\\t\\t   E121: Undefined variable: xx","\\t\\t\\t\\t\\t   0","\\t\\t\\t:cmdname\\tEx command: built-in command, user","\\t\\t\\t\\t\\tcommand or command modifier |:command|.","\\t\\t\\t\\t\\tReturns:","\\t\\t\\t\\t\\t1  for match with start of a command","\\t\\t\\t\\t\\t2  full match with a command","\\t\\t\\t\\t\\t3  matches several user commands","\\t\\t\\t\\t\\tTo check for a supported command","\\t\\t\\t\\t\\talways check the return value to be 2.","\\t\\t\\t:2match\\t\\tThe |:2match| command.","\\t\\t\\t:3match\\t\\tThe |:3match| command.","\\t\\t\\t#event\\t\\tautocommand defined for this event","\\t\\t\\t#event#pattern\\tautocommand defined for this event and","\\t\\t\\t\\t\\tpattern (the pattern is taken","\\t\\t\\t\\t\\tliterally and compared to the","\\t\\t\\t\\t\\tautocommand patterns character by","\\t\\t\\t\\t\\tcharacter)","\\t\\t\\t#group\\t\\tautocommand group exists","\\t\\t\\t#group#event\\tautocommand defined for this group and","\\t\\t\\t\\t\\tevent.","\\t\\t\\t#group#event#pattern","\\t\\t\\t\\t\\tautocommand defined for this group,","\\t\\t\\t\\t\\tevent and pattern.","\\t\\t\\t##event\\t\\tautocommand for this event is","\\t\\t\\t\\t\\tsupported.","","\\t\\tExamples: >","\\t\\t\\texists(\\"&mouse\\")","\\t\\t\\texists(\\"$HOSTNAME\\")","\\t\\t\\texists(\\"*strftime\\")","\\t\\t\\texists(\\"*s:MyFunc\\")","\\t\\t\\texists(\\"bufcount\\")","\\t\\t\\texists(\\":Make\\")","\\t\\t\\texists(\\"#CursorHold\\")","\\t\\t\\texists(\\"#BufReadPre#*.gz\\")","\\t\\t\\texists(\\"#filetypeindent\\")","\\t\\t\\texists(\\"#filetypeindent#FileType\\")","\\t\\t\\texists(\\"#filetypeindent#FileType#*\\")","\\t\\t\\texists(\\"##ColorScheme\\")","<\\t\\tThere must be no space between the symbol (&/$/*/#) and the","\\t\\tname.","\\t\\tThere must be no extra characters after the name, although in","\\t\\ta few cases this is ignored.  That may become more strict in","\\t\\tthe future, thus don\'t count on it!","\\t\\tWorking example: >","\\t\\t\\texists(\\":make\\")","<\\t\\tNOT working example: >","\\t\\t\\texists(\\":make install\\")","","<\\t\\tNote that the argument must be a string, not the name of the","\\t\\tvariable itself.  For example: >","\\t\\t\\texists(bufcount)","<\\t\\tThis doesn\'t check for existence of the \\"bufcount\\" variable,","\\t\\tbut gets the value of \\"bufcount\\", and checks if that exists."],"exp":["\\t\\tReturn the exponential of {expr} as a |Float| in the range","\\t\\t[0, inf].","\\t\\t{expr} must evaluate to a |Float| or a |Number|.","\\t\\tExamples: >","\\t\\t\\t:echo exp(2)","<\\t\\t\\t7.389056 >","\\t\\t\\t:echo exp(-1)","<\\t\\t\\t0.367879"],"debugbreak":["\\t\\tSpecifically used to interrupt a program being debugged.  It","\\t\\twill cause process {pid} to get a SIGTRAP.  Behavior for other","\\t\\tprocesses is undefined. See |terminal-debugger|.","\\t\\t{Sends a SIGINT to a process {pid} other than MS-Windows}"],"expand":["\\t\\tExpand wildcards and the following special keywords in {expr}.","\\t\\t\'wildignorecase\' applies.","","\\t\\tIf {list} is given and it is |TRUE|, a List will be returned.","\\t\\tOtherwise the result is a String and when there are several","\\t\\tmatches, they are separated by <NL> characters.","","\\t\\tIf the expansion fails, the result is an empty string.  A name","\\t\\tfor a non-existing file is not included, unless {expr} does","\\t\\tnot start with \'%\', \'#\' or \'<\', see below.","","\\t\\tWhen {expr} starts with \'%\', \'#\' or \'<\', the expansion is done","\\t\\tlike for the |cmdline-special| variables with their associated","\\t\\tmodifiers.  Here is a short overview:","","\\t\\t\\t%\\t\\tcurrent file name","\\t\\t\\t#\\t\\talternate file name","\\t\\t\\t#n\\t\\talternate file name n","\\t\\t\\t<cfile>\\t\\tfile name under the cursor","\\t\\t\\t<afile>\\t\\tautocmd file name","\\t\\t\\t<abuf>\\t\\tautocmd buffer number (as a String!)","\\t\\t\\t<amatch>\\tautocmd matched name","\\t\\t\\t<sfile>\\t\\tsourced script file or function name","\\t\\t\\t<slnum>\\t\\tsourced script line number or function","\\t\\t\\t\\t\\tline number","\\t\\t\\t<sflnum>\\tscript file line number, also when in","\\t\\t\\t\\t\\ta function","\\t\\t\\t<cword>\\t\\tword under the cursor","\\t\\t\\t<cWORD>\\t\\tWORD under the cursor","\\t\\t\\t<client>\\tthe {clientid} of the last received","\\t\\t\\t\\t\\tmessage |server2client()|","\\t\\tModifiers:","\\t\\t\\t:p\\t\\texpand to full path","\\t\\t\\t:h\\t\\thead (last path component removed)","\\t\\t\\t:t\\t\\ttail (last path component only)","\\t\\t\\t:r\\t\\troot (one extension removed)","\\t\\t\\t:e\\t\\textension only","","\\t\\tExample: >","\\t\\t\\t:let &tags = expand(\\"%:p:h\\") . \\"/tags\\"","<\\t\\tNote that when expanding a string that starts with \'%\', \'#\' or","\\t\\t\'<\', any following text is ignored.  This does NOT work: >","\\t\\t\\t:let doesntwork = expand(\\"%:h.bak\\")","<\\t\\tUse this: >","\\t\\t\\t:let doeswork = expand(\\"%:h\\") . \\".bak\\"","<\\t\\tAlso note that expanding \\"<cfile>\\" and others only returns the","\\t\\treferenced file name without further expansion.  If \\"<cfile>\\"","\\t\\tis \\"~/.cshrc\\", you need to do another expand() to have the","\\t\\t\\"~/\\" expanded into the path of the home directory: >","\\t\\t\\t:echo expand(expand(\\"<cfile>\\"))","<","\\t\\tThere cannot be white space between the variables and the","\\t\\tfollowing modifier.  The |fnamemodify()| function can be used","\\t\\tto modify normal file names.","","\\t\\tWhen using \'%\' or \'#\', and the current or alternate file name","\\t\\tis not defined, an empty string is used.  Using \\"%:p\\" in a","\\t\\tbuffer with no name, results in the current directory, with a","\\t\\t\'/\' added.","","\\t\\tWhen {expr} does not start with \'%\', \'#\' or \'<\', it is","\\t\\texpanded like a file name is expanded on the command line.","\\t\\t\'suffixes\' and \'wildignore\' are used, unless the optional","\\t\\t{nosuf} argument is given and it is |TRUE|.","\\t\\tNames for non-existing files are included.  The \\"**\\" item can","\\t\\tbe used to search in a directory tree.  For example, to find","\\t\\tall \\"README\\" files in the current directory and below: >","\\t\\t\\t:echo expand(\\"**/README\\")","<","\\t\\texpand() can also be used to expand variables and environment","\\t\\tvariables that are only known in a shell.  But this can be","\\t\\tslow, because a shell may be used to do the expansion.  See","\\t\\t|expr-env-expand|.","\\t\\tThe expanded variable is still handled like a list of file","\\t\\tnames.  When an environment variable cannot be expanded, it is","\\t\\tleft unchanged.  Thus \\":echo expand(\'$FOOBAR\')\\" results in","\\t\\t\\"$FOOBAR\\".","","\\t\\tSee |glob()| for finding existing files.  See |system()| for","\\t\\tgetting the raw output of an external command."],"expandcmd":["\\t\\tExpand special items in {expr} like what is done for an Ex","\\t\\tcommand such as `:edit`.  This expands special keywords, like","\\t\\twith |expand()|, and environment variables, anywhere in","\\t\\t{expr}.  Returns the expanded string.","\\t\\tExample: >","\\t\\t\\t:echo expandcmd(\'make %<.o\')"],"extend":["\\t\\t{expr1} and {expr2} must be both |Lists| or both","\\t\\t|Dictionaries|.","","\\t\\tIf they are |Lists|: Append {expr2} to {expr1}.","\\t\\tIf {expr3} is given insert the items of {expr2} before item","\\t\\t{expr3} in {expr1}.  When {expr3} is zero insert before the","\\t\\tfirst item.  When {expr3} is equal to len({expr1}) then","\\t\\t{expr2} is appended.","\\t\\tExamples: >","\\t\\t\\t:echo sort(extend(mylist, [7, 5]))","\\t\\t\\t:call extend(mylist, [2, 3], 1)","<\\t\\tWhen {expr1} is the same List as {expr2} then the number of","\\t\\titems copied is equal to the original length of the List.","\\t\\tE.g., when {expr3} is 1 you get N new copies of the first item","\\t\\t(where N is the original length of the List).","\\t\\tUse |add()| to concatenate one item to a list.  To concatenate","\\t\\ttwo lists into a new list use the + operator: >","\\t\\t\\t:let newlist = [1, 2, 3] + [4, 5]","<","\\t\\tIf they are |Dictionaries|:","\\t\\tAdd all entries from {expr2} to {expr1}.","\\t\\tIf a key exists in both {expr1} and {expr2} then {expr3} is","\\t\\tused to decide what to do:","\\t\\t{expr3} = \\"keep\\": keep the value of {expr1}","\\t\\t{expr3} = \\"force\\": use the value of {expr2}","\\t\\t{expr3} = \\"error\\": give an error message\\t\\t*E737*","\\t\\tWhen {expr3} is omitted then \\"force\\" is assumed.","","\\t\\t{expr1} is changed when {expr2} is not empty.  If necessary","\\t\\tmake a copy of {expr1} first.","\\t\\t{expr2} remains unchanged.","\\t\\tWhen {expr1} is locked and {expr2} is not empty the operation","\\t\\tfails.","\\t\\tReturns {expr1}.",""],"feedkeys":["\\t\\tCharacters in {string} are queued for processing as if they","\\t\\tcome from a mapping or were typed by the user.","","\\t\\tBy default the string is added to the end of the typeahead","\\t\\tbuffer, thus if a mapping is still being executed the","\\t\\tcharacters come after them.  Use the \'i\' flag to insert before","\\t\\tother characters, they will be executed next, before any","\\t\\tcharacters from a mapping.","","\\t\\tThe function does not wait for processing of keys contained in","\\t\\t{string}.","","\\t\\tTo include special keys into {string}, use double-quotes","\\t\\tand \\"\\\\...\\" notation |expr-quote|. For example,","\\t\\tfeedkeys(\\"\\\\<CR>\\") simulates pressing of the <Enter> key. But","\\t\\tfeedkeys(\'\\\\<CR>\') pushes 5 characters.","\\t\\tThe |<Ignore>| keycode may be used to exit the","\\t\\twait-for-character without doing anything.","","\\t\\t{mode} is a String, which can contain these character flags:","\\t\\t\'m\'\\tRemap keys. This is default.  If {mode} is absent,","\\t\\t\\tkeys are remapped.","\\t\\t\'n\'\\tDo not remap keys.","\\t\\t\'t\'\\tHandle keys as if typed; otherwise they are handled as","\\t\\t\\tif coming from a mapping.  This matters for undo,","\\t\\t\\topening folds, etc.","\\t\\t\'i\'\\tInsert the string instead of appending (see above).","\\t\\t\'x\'\\tExecute commands until typeahead is empty.  This is","\\t\\t\\tsimilar to using \\":normal!\\".  You can call feedkeys()","\\t\\t\\tseveral times without \'x\' and then one time with \'x\'","\\t\\t\\t(possibly with an empty {string}) to execute all the","\\t\\t\\ttypeahead.  Note that when Vim ends in Insert mode it","\\t\\t\\twill behave as if <Esc> is typed, to avoid getting","\\t\\t\\tstuck, waiting for a character to be typed before the","\\t\\t\\tscript continues.","\\t\\t\\tNote that if you manage to call feedkeys() while","\\t\\t\\texecuting commands, thus calling it recursively, the","\\t\\t\\tall typehead will be consumed by the last call.","\\t\\t\'!\'\\tWhen used with \'x\' will not end Insert mode. Can be","\\t\\t\\tused in a test when a timer is set to exit Insert mode","\\t\\t\\ta little later.  Useful for testing CursorHoldI.","","\\t\\tReturn value is always 0."],"filereadable":["\\t\\tThe result is a Number, which is |TRUE| when a file with the","\\t\\tname {file} exists, and can be read.  If {file} doesn\'t exist,","\\t\\tor is a directory, the result is |FALSE|.  {file} is any","\\t\\texpression, which is used as a String.","\\t\\tIf you don\'t care about the file being readable you can use","\\t\\t|glob()|.",""],"filewritable":["\\t\\tThe result is a Number, which is 1 when a file with the","\\t\\tname {file} exists, and can be written.  If {file} doesn\'t","\\t\\texist, or is not writable, the result is 0.  If {file} is a","\\t\\tdirectory, and we can write to it, the result is 2.",""],"filter":["\\t\\t{expr1} must be a |List| or a |Dictionary|.","\\t\\tFor each item in {expr1} evaluate {expr2} and when the result","\\t\\tis zero remove the item from the |List| or |Dictionary|.","\\t\\t{expr2} must be a |string| or |Funcref|.","","\\t\\tIf {expr2} is a |string|, inside {expr2} |v:val| has the value","\\t\\tof the current item.  For a |Dictionary| |v:key| has the key","\\t\\tof the current item and for a |List| |v:key| has the index of","\\t\\tthe current item.","\\t\\tFor a |Dictionary| |v:key| has the key of the current item.","\\t\\tExamples: >","\\t\\t\\tcall filter(mylist, \'v:val !~ \\"OLD\\"\')","<\\t\\tRemoves the items where \\"OLD\\" appears. >","\\t\\t\\tcall filter(mydict, \'v:key >= 8\')","<\\t\\tRemoves the items with a key below 8. >","\\t\\t\\tcall filter(var, 0)","<\\t\\tRemoves all the items, thus clears the |List| or |Dictionary|.","","\\t\\tNote that {expr2} is the result of expression and is then","\\t\\tused as an expression again.  Often it is good to use a","\\t\\t|literal-string| to avoid having to double backslashes.","","\\t\\tIf {expr2} is a |Funcref| it must take two arguments:","\\t\\t\\t1. the key or the index of the current item.","\\t\\t\\t2. the value of the current item.","\\t\\tThe function must return |TRUE| if the item should be kept.","\\t\\tExample that keeps the odd items of a list: >","\\t\\t\\tfunc Odd(idx, val)","\\t\\t\\t  return a:idx % 2 == 1","\\t\\t\\tendfunc","\\t\\t\\tcall filter(mylist, function(\'Odd\'))","<\\t\\tIt is shorter when using a |lambda|: >","\\t\\t\\tcall filter(myList, {idx, val -> idx * val <= 42})","<\\t\\tIf you do not use \\"val\\" you can leave it out: >","\\t\\t\\tcall filter(myList, {idx -> idx % 2 == 1})","<","\\t\\tThe operation is done in-place.  If you want a |List| or","\\t\\t|Dictionary| to remain unmodified make a copy first: >","\\t\\t\\t:let l = filter(copy(mylist), \'v:val =~ \\"KEEP\\"\')","","<\\t\\tReturns {expr1}, the |List| or |Dictionary| that was filtered.","\\t\\tWhen an error is encountered while evaluating {expr2} no","\\t\\tfurther items in {expr1} are processed. When {expr2} is a","\\t\\tFuncref errors inside a function are ignored, unless it was","\\t\\tdefined with the \\"abort\\" flag.",""],"finddir":["\\t\\tFind directory {name} in {path}.  Supports both downwards and","\\t\\tupwards recursive directory searches.  See |file-searching|","\\t\\tfor the syntax of {path}.","\\t\\tReturns the path of the first found match.  When the found","\\t\\tdirectory is below the current directory a relative path is","\\t\\treturned.  Otherwise a full path is returned.","\\t\\tIf {path} is omitted or empty then \'path\' is used.","\\t\\tIf the optional {count} is given, find {count}\'s occurrence of","\\t\\t{name} in {path} instead of the first one.","\\t\\tWhen {count} is negative return all the matches in a |List|.","\\t\\tThis is quite similar to the ex-command |:find|."],"findfile":["\\t\\tJust like |finddir()|, but find a file instead of a directory.","\\t\\tUses \'suffixesadd\'.","\\t\\tExample: >","\\t\\t\\t:echo findfile(\\"tags.vim\\", \\".;\\")","<\\t\\tSearches from the directory of the current file upwards until","\\t\\tit finds the file \\"tags.vim\\"."],"float2nr":["\\t\\tConvert {expr} to a Number by omitting the part after the","\\t\\tdecimal point.","\\t\\t{expr} must evaluate to a |Float| or a Number.","\\t\\tWhen the value of {expr} is out of range for a |Number| the","\\t\\tresult is truncated to 0x7fffffff or -0x7fffffff (or when","\\t\\t64-bit Number support is enabled, 0x7fffffffffffffff or","\\t\\t-0x7fffffffffffffff).  NaN results in -0x80000000 (or when","\\t\\t64-bit Number support is enabled, -0x8000000000000000).","\\t\\tExamples: >","\\t\\t\\techo float2nr(3.95)","<\\t\\t\\t3  >","\\t\\t\\techo float2nr(-23.45)","<\\t\\t\\t-23  >","\\t\\t\\techo float2nr(1.0e100)","<\\t\\t\\t2147483647  (or 9223372036854775807) >","\\t\\t\\techo float2nr(-1.0e150)","<\\t\\t\\t-2147483647 (or -9223372036854775807) >","\\t\\t\\techo float2nr(1.0e-100)","<\\t\\t\\t0",""],"floor":["\\t\\tReturn the largest integral value less than or equal to","\\t\\t{expr} as a |Float| (round down).","\\t\\t{expr} must evaluate to a |Float| or a |Number|.","\\t\\tExamples: >","\\t\\t\\techo floor(1.856)","<\\t\\t\\t1.0  >","\\t\\t\\techo floor(-5.456)","<\\t\\t\\t-6.0  >","\\t\\t\\techo floor(4.0)","<\\t\\t\\t4.0",""],"fmod":["\\t\\tReturn the remainder of {expr1} / {expr2}, even if the","\\t\\tdivision is not representable.  Returns {expr1} - i * {expr2}","\\t\\tfor some integer i such that if {expr2} is non-zero, the","\\t\\tresult has the same sign as {expr1} and magnitude less than","\\t\\tthe magnitude of {expr2}.  If {expr2} is zero, the value","\\t\\treturned is zero.  The value returned is a |Float|.","\\t\\t{expr1} and {expr2} must evaluate to a |Float| or a |Number|.","\\t\\tExamples: >","\\t\\t\\t:echo fmod(12.33, 1.22)","<\\t\\t\\t0.13 >","\\t\\t\\t:echo fmod(-12.33, 1.22)","<\\t\\t\\t-0.13",""],"fnameescape":["\\t\\tEscape {string} for use as file name command argument.  All","\\t\\tcharacters that have a special meaning, such as \'%\' and \'|\'","\\t\\tare escaped with a backslash.","\\t\\tFor most systems the characters escaped are","\\t\\t\\" \\\\t\\\\n*?[{`$\\\\\\\\%#\'\\\\\\"|!<\\".  For systems where a backslash","\\t\\tappears in a filename, it depends on the value of \'isfname\'.","\\t\\tA leading \'+\' and \'>\' is also escaped (special after |:edit|","\\t\\tand |:write|).  And a \\"-\\" by itself (special after |:cd|).","\\t\\tExample: >","\\t\\t\\t:let fname = \'+some str%nge|name\'","\\t\\t\\t:exe \\"edit \\" . fnameescape(fname)","<\\t\\tresults in executing: >","\\t\\t\\tedit \\\\+some\\\\ str\\\\%nge\\\\|name"],"fnamemodify":["\\t\\tModify file name {fname} according to {mods}.  {mods} is a","\\t\\tstring of characters like it is used for file names on the","\\t\\tcommand line.  See |filename-modifiers|.","\\t\\tExample: >","\\t\\t\\t:echo fnamemodify(\\"main.c\\", \\":p:h\\")","<\\t\\tresults in: >","\\t\\t\\t/home/mool/vim/vim/src","<\\t\\tNote: Environment variables don\'t work in {fname}, use","\\t\\t|expand()| first then."],"foldclosed":["\\t\\tThe result is a Number.  If the line {lnum} is in a closed","\\t\\tfold, the result is the number of the first line in that fold.","\\t\\tIf the line {lnum} is not in a closed fold, -1 is returned."],"foldclosedend":["\\t\\tThe result is a Number.  If the line {lnum} is in a closed","\\t\\tfold, the result is the number of the last line in that fold.","\\t\\tIf the line {lnum} is not in a closed fold, -1 is returned."],"foldlevel":["\\t\\tThe result is a Number, which is the foldlevel of line {lnum}","\\t\\tin the current buffer.  For nested folds the deepest level is","\\t\\treturned.  If there is no fold at line {lnum}, zero is","\\t\\treturned.  It doesn\'t matter if the folds are open or closed.","\\t\\tWhen used while updating folds (from \'foldexpr\') -1 is","\\t\\treturned for lines where folds are still to be updated and the","\\t\\tfoldlevel is unknown.  As a special case the level of the","\\t\\tprevious line is usually available.",""],"foldtext":["\\t\\tthe default function used for the \'foldtext\' option and should","\\t\\tonly be called from evaluating \'foldtext\'.  It uses the","\\t\\t|v:foldstart|, |v:foldend| and |v:folddashes| variables.","\\t\\tThe returned string looks like this: >","\\t\\t\\t+-- 45 lines: abcdef","<\\t\\tThe number of leading dashes depends on the foldlevel.  The","\\t\\t\\"45\\" is the number of lines in the fold.  \\"abcdef\\" is the text","\\t\\tin the first non-blank line of the fold.  Leading white space,","\\t\\t\\"//\\" or \\"/*\\" and the text from the \'foldmarker\' and","\\t\\t\'commentstring\' options is removed.","\\t\\tWhen used to draw the actual foldtext, the rest of the line","\\t\\twill be filled with the fold char from the \'fillchars\'","\\t\\tsetting."],"foldtextresult":["\\t\\tReturns the text that is displayed for the closed fold at line","\\t\\t{lnum}.  Evaluates \'foldtext\' in the appropriate context.","\\t\\tWhen there is no closed fold at {lnum} an empty string is","\\t\\treturned.","\\t\\t{lnum} is used like with |getline()|.  Thus \\".\\" is the current","\\t\\tline, \\"\'m\\" mark m, etc.","\\t\\tUseful when exporting folded text, e.g., to HTML.",""],"foreground":["\\t\\ta client to a Vim server. |remote_send()|","\\t\\tOn Win32 systems this might not work, the OS does not always","\\t\\tallow a window to bring itself to the foreground.  Use","\\t\\t|remote_foreground()| instead.","\\t\\t{only in the Win32 GUI and console version}",""],"funcref":["\\t\\tJust like |function()|, but the returned Funcref will lookup","\\t\\tthe function by reference, not by name.  This matters when the","\\t\\tfunction {name} is redefined later.","","\\t\\tUnlike |function()|, {name} must be an existing user function.","\\t\\tAlso for autoloaded functions. {name} cannot be a builtin","\\t\\tfunction.",""],"function":["\\t\\tReturn a |Funcref| variable that refers to function {name}.","\\t\\t{name} can be a user defined function or an internal function.","","\\t\\t{name} can also be a Funcref or a partial. When it is a","\\t\\tpartial the dict stored in it will be used and the {dict}","\\t\\targument is not allowed. E.g.: >","\\t\\t\\tlet FuncWithArg = function(dict.Func, [arg])","\\t\\t\\tlet Broken = function(dict.Func, [arg], dict)","<","\\t\\tWhen using the Funcref the function will be found by {name},","\\t\\talso when it was redefined later. Use |funcref()| to keep the","\\t\\tsame function.","","\\t\\tWhen {arglist} or {dict} is present this creates a partial.","\\t\\tThat means the argument list and/or the dictionary is stored in","\\t\\tthe Funcref and will be used when the Funcref is called.","","\\t\\tThe arguments are passed to the function in front of other","\\t\\targuments, but after any argument from |method|.  Example: >","\\t\\t\\tfunc Callback(arg1, arg2, name)","\\t\\t\\t...","\\t\\t\\tlet Partial = function(\'Callback\', [\'one\', \'two\'])","\\t\\t\\t...","\\t\\t\\tcall Partial(\'name\')","<\\t\\tInvokes the function as with: >","\\t\\t\\tcall Callback(\'one\', \'two\', \'name\')","","<\\t\\tThe Dictionary is only useful when calling a \\"dict\\" function.","\\t\\tIn that case the {dict} is passed in as \\"self\\". Example: >","\\t\\t\\tfunction Callback() dict","\\t\\t\\t   echo \\"called for \\" . self.name","\\t\\t\\tendfunction","\\t\\t\\t...","\\t\\t\\tlet context = {\\"name\\": \\"example\\"}","\\t\\t\\tlet Func = function(\'Callback\', context)","\\t\\t\\t...","\\t\\t\\tcall Func()\\t\\" will echo: called for example","","<\\t\\tThe argument list and the Dictionary can be combined: >","\\t\\t\\tfunction Callback(arg1, count) dict","\\t\\t\\t...","\\t\\t\\tlet context = {\\"name\\": \\"example\\"}","\\t\\t\\tlet Func = function(\'Callback\', [\'one\'], context)","\\t\\t\\t...","\\t\\t\\tcall Func(500)","<\\t\\tInvokes the function as with: >","\\t\\t\\tcall context.Callback(\'one\', 500)",""],"garbagecollect":["\\t\\tCleanup unused |Lists| and |Dictionaries| that have circular","\\t\\treferences.","\\t\\t","\\t\\tThere is hardly ever a need to invoke this function, as it is","\\t\\tautomatically done when Vim runs out of memory or is waiting","\\t\\tfor the user to press a key after \'updatetime\'.  Items without","\\t\\tcircular references are always freed when they become unused.","\\t\\tThis is useful if you have deleted a very big |List| and/or","\\t\\t|Dictionary| with circular references in a script that runs","\\t\\tfor a long time.","","\\t\\tWhen the optional {atexit} argument is one, garbage","\\t\\tcollection will also be done when exiting Vim, if it wasn\'t","\\t\\tdone before.  This is useful when checking for memory leaks.","","\\t\\tThe garbage collection is not done immediately but only when","\\t\\tit\'s safe to perform.  This is when waiting for the user to","\\t\\ttype a character."],"get":["\\t\\tGet item {idx} from |List| {list}.  When this item is not","\\t\\tavailable return {default}.  Return zero when {default} is","\\t\\tGet item with key {key} from |Dictionary| {dict}.  When this","\\t\\titem is not available return {default}.  Return zero when","\\t\\t{default} is omitted.  Useful example: >","\\t\\t\\tlet val = get(g:, \'var_name\', \'default\')","<\\t\\tThis gets the value of g:var_name if it exists, and uses","\\t\\tGet item {what} from Funcref {func}.  Possible values for","\\t\\t{what} are:","\\t\\t\\t\\"name\\"\\tThe function name","\\t\\t\\t\\"func\\"\\tThe function","\\t\\t\\t\\"dict\\"\\tThe dictionary","\\t\\t\\t\\"args\\"\\tThe list with arguments",""],"getbufinfo":["\\t\\tGet information about buffers as a List of Dictionaries.","","\\t\\tWithout an argument information about all the buffers is","\\t\\treturned.","","\\t\\tWhen the argument is a Dictionary only the buffers matching","\\t\\tthe specified criteria are returned.  The following keys can","\\t\\tbe specified in {dict}:","\\t\\t\\tbuflisted\\tinclude only listed buffers.","\\t\\t\\tbufloaded\\tinclude only loaded buffers.","\\t\\t\\tbufmodified\\tinclude only modified buffers.","","\\t\\tOtherwise, {expr} specifies a particular buffer to return","\\t\\tinformation for.  For the use of {expr}, see |bufname()|","\\t\\tabove.  If the buffer is found the returned List has one item.","\\t\\tOtherwise the result is an empty list.","","\\t\\tEach returned List item is a dictionary with the following","\\t\\tentries:","\\t\\t\\tbufnr\\t\\tbuffer number.","\\t\\t\\tchanged\\t\\tTRUE if the buffer is modified.","\\t\\t\\tchangedtick\\tnumber of changes made to the buffer.","\\t\\t\\thidden\\t\\tTRUE if the buffer is hidden.","\\t\\t\\tlisted\\t\\tTRUE if the buffer is listed.","\\t\\t\\tlnum\\t\\tcurrent line number in buffer.","\\t\\t\\tlinecount\\tnumber of lines in the buffer (only","\\t\\t\\t\\t\\tvalid when loaded)","\\t\\t\\tloaded\\t\\tTRUE if the buffer is loaded.","\\t\\t\\tname\\t\\tfull path to the file in the buffer.","\\t\\t\\tsigns\\t\\tlist of signs placed in the buffer.","\\t\\t\\t\\t\\tEach list item is a dictionary with","\\t\\t\\t\\t\\tthe following fields:","\\t\\t\\t\\t\\t    id\\t  sign identifier","\\t\\t\\t\\t\\t    lnum  line number","\\t\\t\\t\\t\\t    name  sign name","\\t\\t\\tvariables\\ta reference to the dictionary with","\\t\\t\\t\\t\\tbuffer-local variables.","\\t\\t\\twindows\\t\\tlist of |window-ID|s that display this","\\t\\t\\t\\t\\tbuffer","","\\t\\tExamples: >","\\t\\t\\tfor buf in getbufinfo()","\\t\\t\\t    echo buf.name","\\t\\t\\tendfor","\\t\\t\\tfor buf in getbufinfo({\'buflisted\':1})","\\t\\t\\t    if buf.changed","\\t\\t\\t\\t....","\\t\\t\\t    endif","\\t\\t\\tendfor","<","\\t\\tTo get buffer-local options use: >","\\t\\t\\tgetbufvar({bufnr}, \'&option_name\')","","<"],"getbufline":["\\t\\tReturn a |List| with the lines starting from {lnum} to {end}","\\t\\t(inclusive) in the buffer {expr}.  If {end} is omitted, a","\\t\\t|List| with only the line {lnum} is returned.","","\\t\\tFor the use of {expr}, see |bufname()| above.","","\\t\\tFor {lnum} and {end} \\"$\\" can be used for the last line of the","\\t\\tbuffer.  Otherwise a number must be used.","","\\t\\tWhen {lnum} is smaller than 1 or bigger than the number of","\\t\\tlines in the buffer, an empty |List| is returned.","","\\t\\tWhen {end} is greater than the number of lines in the buffer,","\\t\\tit is treated as {end} is set to the number of lines in the","\\t\\tbuffer.  When {end} is before {lnum} an empty |List| is","\\t\\treturned.","","\\t\\tThis function works only for loaded buffers.  For unloaded and","\\t\\tnon-existing buffers, an empty |List| is returned.","","\\t\\tExample: >","\\t\\t\\t:let lines = getbufline(bufnr(\\"myfile\\"), 1, \\"$\\")"],"getbufvar":["\\t\\tThe result is the value of option or local buffer variable","\\t\\t{varname} in buffer {expr}.  Note that the name without \\"b:\\"","\\t\\tmust be used.","\\t\\tWhen {varname} is empty returns a dictionary with all the","\\t\\tbuffer-local variables.","\\t\\tWhen {varname} is equal to \\"&\\" returns a dictionary with all","\\t\\tthe buffer-local options.","\\t\\tOtherwise, when {varname} starts with \\"&\\" returns the value of","\\t\\ta buffer-local option.","\\t\\tThis also works for a global or buffer-local option, but it","\\t\\tdoesn\'t work for a global variable, window-local variable or","\\t\\twindow-local option.","\\t\\tFor the use of {expr}, see |bufname()| above.","\\t\\tWhen the buffer or variable doesn\'t exist {def} or an empty","\\t\\tstring is returned, there is no error message.","\\t\\tExamples: >","\\t\\t\\t:let bufmodified = getbufvar(1, \\"&mod\\")","\\t\\t\\t:echo \\"todo myvar = \\" . getbufvar(\\"todo\\", \\"myvar\\")"],"getchangelist":["\\t\\tReturns the |changelist| for the buffer {expr}. For the use","\\t\\tof {expr}, see |bufname()| above. If buffer {expr} doesn\'t","\\t\\texist, an empty list is returned.","","\\t\\tThe returned list contains two entries: a list with the change","\\t\\tlocations and the current position in the list.  Each","\\t\\tentry in the change list is a dictionary with the following","\\t\\tentries:","\\t\\t\\tcol\\t\\tcolumn number","\\t\\t\\tcoladd\\t\\tcolumn offset for \'virtualedit\'","\\t\\t\\tlnum\\t\\tline number","\\t\\tIf buffer {expr} is the current buffer, then the current","\\t\\tposition refers to the position in the list. For other","\\t\\tbuffers, it is set to the length of the list."],"getchar":["\\t\\tGet a single character from the user or input stream.","\\t\\tIf [expr] is omitted, wait until a character is available.","\\t\\tIf [expr] is 0, only get a character when one is available.","\\t\\t\\tReturn zero otherwise.","\\t\\tIf [expr] is 1, only check if a character is available, it is","\\t\\t\\tnot consumed.  Return zero if no character available.","","\\t\\tWithout [expr] and when [expr] is 0 a whole character or","\\t\\tspecial key is returned.  If it is a single character, the","\\t\\tresult is a number.  Use nr2char() to convert it to a String.","\\t\\tOtherwise a String is returned with the encoded character.","\\t\\tFor a special key it\'s a String with a sequence of bytes","\\t\\tstarting with 0x80 (decimal: 128).  This is the same value as","\\t\\tthe String \\"\\\\<Key>\\", e.g., \\"\\\\<Left>\\".  The returned value is","\\t\\talso a String when a modifier (shift, control, alt) was used","\\t\\tthat is not included in the character.","","\\t\\tWhen [expr] is 0 and Esc is typed, there will be a short delay","\\t\\twhile Vim waits to see if this is the start of an escape","\\t\\tsequence.","","\\t\\tWhen [expr] is 1 only the first byte is returned.  For a","\\t\\tone-byte character it is the character itself as a number.","\\t\\tUse nr2char() to convert it to a String.","","\\t\\tUse getcharmod() to obtain any additional modifiers.","","\\t\\tWhen the user clicks a mouse button, the mouse event will be","\\t\\treturned.  The position can then be found in |v:mouse_col|,","\\t\\t|v:mouse_lnum|, |v:mouse_winid| and |v:mouse_win|.  This","\\t\\texample positions the mouse as it would normally happen: >","\\t\\t\\tlet c = getchar()","\\t\\t\\tif c == \\"\\\\<LeftMouse>\\" && v:mouse_win > 0","\\t\\t\\t  exe v:mouse_win . \\"wincmd w\\"","\\t\\t\\t  exe v:mouse_lnum","\\t\\t\\t  exe \\"normal \\" . v:mouse_col . \\"|\\"","\\t\\t\\tendif","<","\\t\\tThere is no prompt, you will somehow have to make clear to the","\\t\\tuser that a character has to be typed.","\\t\\tThere is no mapping for the character.","\\t\\tKey codes are replaced, thus when the user presses the <Del>","\\t\\tkey you get the code for the <Del> key, not the raw character","\\t\\tsequence.  Examples: >","\\t\\t\\tgetchar() == \\"\\\\<Del>\\"","\\t\\t\\tgetchar() == \\"\\\\<S-Left>\\"","<\\t\\tThis example redefines \\"f\\" to ignore case: >","\\t\\t\\t:nmap f :call FindChar()<CR>","\\t\\t\\t:function FindChar()","\\t\\t\\t:  let c = nr2char(getchar())","\\t\\t\\t:  while col(\'.\') < col(\'$\') - 1","\\t\\t\\t:    normal l","\\t\\t\\t:    if getline(\'.\')[col(\'.\') - 1] ==? c","\\t\\t\\t:      break","\\t\\t\\t:    endif","\\t\\t\\t:  endwhile","\\t\\t\\t:endfunction"],"getcharmod":["\\t\\tThe result is a Number which is the state of the modifiers for","\\t\\tthe last obtained character with getchar() or in another way.","\\t\\tThese values are added together:","\\t\\t\\t2\\tshift","\\t\\t\\t4\\tcontrol","\\t\\t\\t8\\talt (meta)","\\t\\t\\t16\\tmeta (when it\'s different from ALT)","\\t\\t\\t32\\tmouse double click","\\t\\t\\t64\\tmouse triple click","\\t\\t\\t96\\tmouse quadruple click (== 32 + 64)","\\t\\t\\t128\\tcommand (Macintosh only)","\\t\\tOnly the modifiers that have not been included in the","\\t\\tcharacter itself are obtained.  Thus Shift-a results in \\"A\\"","\\t\\twithout a modifier."],"getcharsearch":["\\t\\tReturn the current character search information as a {dict}","\\t\\twith the following entries:","","\\t\\t    char\\tcharacter previously used for a character","\\t\\t\\t\\tsearch (|t|, |f|, |T|, or |F|); empty string","\\t\\t\\t\\tif no character search has been performed","\\t\\t    forward\\tdirection of character search; 1 for forward,","\\t\\t\\t\\t0 for backward","\\t\\t    until\\ttype of character search; 1 for a |t| or |T|","\\t\\t\\t\\tcharacter search, 0 for an |f| or |F|","\\t\\t\\t\\tcharacter search","","\\t\\tThis can be useful to always have |;| and |,| search","\\t\\tforward/backward regardless of the direction of the previous","\\t\\tcharacter search: >","\\t\\t\\t:nnoremap <expr> ; getcharsearch().forward ? \';\' : \',\'","\\t\\t\\t:nnoremap <expr> , getcharsearch().forward ? \',\' : \';\'","<\\t\\tAlso see |setcharsearch()|."],"getcmdline":["\\t\\tReturn the current command-line.  Only works when the command","\\t\\tline is being edited, thus requires use of |c_CTRL-\\\\_e| or","\\t\\t|c_CTRL-R_=|.","\\t\\tExample: >","\\t\\t\\t:cmap <F7> <C-\\\\>eescape(getcmdline(), \' \\\\\')<CR>","<\\t\\tAlso see |getcmdtype()|, |getcmdpos()| and |setcmdpos()|.","\\t\\tReturns an empty string when entering a password or using","\\t\\t|inputsecret()|."],"getcmdpos":["\\t\\tReturn the position of the cursor in the command line as a","\\t\\tbyte count.  The first column is 1.","\\t\\tOnly works when editing the command line, thus requires use of","\\t\\t|c_CTRL-\\\\_e| or |c_CTRL-R_=| or an expression mapping.","\\t\\tReturns 0 otherwise.","\\t\\tAlso see |getcmdtype()|, |setcmdpos()| and |getcmdline()|."],"getcmdtype":["\\t\\tReturn the current command-line type. Possible return values","\\t\\tare:","\\t\\t    :\\tnormal Ex command","\\t\\t    >\\tdebug mode command |debug-mode|","\\t\\t    /\\tforward search command","\\t\\t    ?\\tbackward search command","\\t\\t    @\\t|input()| command","\\t\\t    -\\t|:insert| or |:append| command","\\t\\t    =\\t|i_CTRL-R_=|","\\t\\tOnly works when editing the command line, thus requires use of","\\t\\t|c_CTRL-\\\\_e| or |c_CTRL-R_=| or an expression mapping.","\\t\\tReturns an empty string otherwise.","\\t\\tAlso see |getcmdpos()|, |setcmdpos()| and |getcmdline()|."],"getcmdwintype":["\\t\\tReturn the current |command-line-window| type. Possible return","\\t\\tvalues are the same as |getcmdtype()|. Returns an empty string","\\t\\twhen not in the command-line window."],"getcompletion":["\\t\\tReturn a list of command-line completion matches. {type}","\\t\\tspecifies what for.  The following completion types are","\\t\\tsupported:","","\\t\\targlist\\t\\tfile names in argument list","\\t\\taugroup\\t\\tautocmd groups","\\t\\tbuffer\\t\\tbuffer names","\\t\\tbehave\\t\\t:behave suboptions","\\t\\tcmdline\\t\\t|cmdline-completion|","\\t\\tcolor\\t\\tcolor schemes","\\t\\tcommand\\t\\tEx command (and arguments)","\\t\\tcompiler\\tcompilers","\\t\\tcscope\\t\\t|:cscope| suboptions","\\t\\tdir\\t\\tdirectory names","\\t\\tenvironment\\tenvironment variable names","\\t\\tevent\\t\\tautocommand events","\\t\\texpression\\tVim expression","\\t\\tfile\\t\\tfile and directory names","\\t\\tfile_in_path\\tfile and directory names in |\'path\'|","\\t\\tfiletype\\tfiletype names |\'filetype\'|","\\t\\tfunction\\tfunction name","\\t\\thelp\\t\\thelp subjects","\\t\\thighlight\\thighlight groups","\\t\\thistory\\t\\t:history suboptions","\\t\\tlocale\\t\\tlocale names (as output of locale -a)","\\t\\tmapclear        buffer argument","\\t\\tmapping\\t\\tmapping name","\\t\\tmenu\\t\\tmenus","\\t\\tmessages\\t|:messages| suboptions","\\t\\toption\\t\\toptions","\\t\\tpackadd\\t\\toptional package |pack-add| names","\\t\\tshellcmd\\tShell command","\\t\\tsign\\t\\t|:sign| suboptions","\\t\\tsyntax\\t\\tsyntax file names |\'syntax\'|","\\t\\tsyntime\\t\\t|:syntime| suboptions","\\t\\ttag\\t\\ttags","\\t\\ttag_listfiles\\ttags, file names","\\t\\tuser\\t\\tuser names","\\t\\tvar\\t\\tuser variables","","\\t\\tIf {pat} is an empty string then all matches are returned.","\\t\\tOtherwise only items matching {pat} are returned. See","\\t\\t|wildcards| for the use of special characters in {pat}.","","\\t\\tIf the optional {filtered} flag is set to 1, then \'wildignore\'","\\t\\tis applied to filter the results.  Otherwise all the matches","\\t\\tare returned. The \'wildignorecase\' option always applies.","","\\t\\tIf there are no matches, an empty list is returned.  An","\\t\\tinvalid value for {type} produces an error.",""],"getcurpos":["\\t\\tincludes an extra item in the list:","\\t\\t    [bufnum, lnum, col, off, curswant] ~"," \\t\\tThe \\"curswant\\" number is the preferred column when moving the","\\t\\tcursor vertically.  Also see |getpos()|.",""," \\t\\tThis can be used to save and restore the cursor position: >"," \\t\\t\\tlet save_cursor = getcurpos()"," \\t\\t\\tMoveTheCursorAround"," \\t\\t\\tcall setpos(\'.\', save_cursor)","<\\t\\tNote that this only works within the window.  See","\\t\\t|winrestview()| for restoring more state."],"getcwd":["\\t\\tWith no arguments the result is a String, which is the name of","\\t\\tthe current effective working directory. With {winnr} or","\\t\\t{tabnr} the working directory of that scope is returned.","\\t\\tTabs and windows are identified by their respective numbers,","\\t\\t0 means current tab or window. Missing argument implies 0.","\\t\\tThus the following are equivalent: >","\\t\\t\\tgetcwd()","\\t\\t\\tgetcwd(0)","\\t\\t\\tgetcwd(0, 0)","<\\t\\tIf {winnr} is -1 it is ignored, only the tab is resolved.","\\t\\t{winnr} can be the window number or the |window-ID|."],"getenv":["\\t\\tReturn the value of environment variable {name}.","\\t\\tWhen the variable does not exist |v:null| is returned.  That","\\t\\tis different from a variable set to an empty string.","\\t\\tSee also |expr-env|."],"getfontname":["\\t\\tWithout an argument returns the name of the normal font being","\\t\\tused.  Like what is used for the Normal highlight group","\\t\\t|hl-Normal|.","\\t\\tWith an argument a check is done whether {name} is a valid","\\t\\tfont name.  If not then an empty string is returned.","\\t\\tOtherwise the actual font name is returned, or {name} if the","\\t\\tGUI does not support obtaining the real name.","\\t\\tOnly works when the GUI is running, thus not in your vimrc or","\\t\\tgvimrc file.  Use the |GUIEnter| autocommand to use this","\\t\\tfunction just after the GUI has started."],"getfperm":["\\t\\tThe result is a String, which is the read, write, and execute","\\t\\tpermissions of the given file {fname}.","\\t\\tIf {fname} does not exist or its directory cannot be read, an","\\t\\tempty string is returned.","\\t\\tThe result is of the form \\"rwxrwxrwx\\", where each group of","\\t\\t\\"rwx\\" flags represent, in turn, the permissions of the owner","\\t\\tof the file, the group the file belongs to, and other users.","\\t\\tIf a user does not have a given permission the flag for this","\\t\\tis replaced with the string \\"-\\".  Examples: >","\\t\\t\\t:echo getfperm(\\"/etc/passwd\\")","\\t\\t\\t:echo getfperm(expand(\\"~/.config/nvim/init.vim\\"))","<\\t\\tThis will hopefully (from a security point of view) display","\\t\\tthe string \\"rw-r--r--\\" or even \\"rw-------\\".","","\\t\\tFor setting permissions use |setfperm()|."],"getfsize":["\\t\\tThe result is a Number, which is the size in bytes of the","\\t\\tgiven file {fname}.","\\t\\tIf {fname} is a directory, 0 is returned.","\\t\\tIf the file {fname} can\'t be found, -1 is returned.","\\t\\tIf the size of {fname} is too big to fit in a Number then -2","\\t\\tis returned."],"getftime":["\\t\\tThe result is a Number, which is the last modification time of","\\t\\tthe given file {fname}.  The value is measured as seconds","\\t\\tsince 1st Jan 1970, and may be passed to strftime().  See also","\\t\\t|localtime()| and |strftime()|.","\\t\\tIf the file {fname} can\'t be found -1 is returned."],"getftype":["\\t\\tThe result is a String, which is a description of the kind of","\\t\\tfile of the given file {fname}.","\\t\\tIf {fname} does not exist an empty string is returned.","\\t\\tHere is a table over different kinds of files and their","\\t\\tresults:","\\t\\t\\tNormal file\\t\\t\\"file\\"","\\t\\t\\tDirectory\\t\\t\\"dir\\"","\\t\\t\\tSymbolic link\\t\\t\\"link\\"","\\t\\t\\tBlock device\\t\\t\\"bdev\\"","\\t\\t\\tCharacter device\\t\\"cdev\\"","\\t\\t\\tSocket\\t\\t\\t\\"socket\\"","\\t\\t\\tFIFO\\t\\t\\t\\"fifo\\"","\\t\\t\\tAll other\\t\\t\\"other\\"","\\t\\tExample: >","\\t\\t\\tgetftype(\\"/home\\")","<\\t\\tNote that a type such as \\"link\\" will only be returned on","\\t\\tsystems that support it.  On some systems only \\"dir\\" and","\\t\\t\\"file\\" are returned."],"getjumplist":["\\t\\tReturns the |jumplist| for the specified window.","","\\t\\tWithout arguments use the current window.","\\t\\tWith {winnr} only use this window in the current tab page.","\\t\\t{winnr} can also be a |window-ID|.","\\t\\tWith {winnr} and {tabnr} use the window in the specified tab","\\t\\tpage.","","\\t\\tThe returned list contains two entries: a list with the jump","\\t\\tlocations and the last used jump position number in the list.","\\t\\tEach entry in the jump location list is a dictionary with","\\t\\tthe following entries:","\\t\\t\\tbufnr\\t\\tbuffer number","\\t\\t\\tcol\\t\\tcolumn number","\\t\\t\\tcoladd\\t\\tcolumn offset for \'virtualedit\'","\\t\\t\\tfilename\\tfilename if available","\\t\\t\\tlnum\\t\\tline number",""],"getline":["\\t\\tWithout {end} the result is a String, which is line {lnum}","\\t\\tfrom the current buffer.  Example: >","\\t\\t\\tgetline(1)","<\\t\\tWhen {lnum} is a String that doesn\'t start with a","\\t\\tdigit, |line()| is called to translate the String into a Number.","\\t\\tTo get the line under the cursor: >","\\t\\t\\tgetline(\\".\\")","<\\t\\tWhen {lnum} is smaller than 1 or bigger than the number of","\\t\\tlines in the buffer, an empty string is returned.","","\\t\\tWhen {end} is given the result is a |List| where each item is","\\t\\ta line from the current buffer in the range {lnum} to {end},","\\t\\tincluding line {end}.","\\t\\t{end} is used in the same way as {lnum}.","\\t\\tNon-existing lines are silently omitted.","\\t\\tWhen {end} is before {lnum} an empty |List| is returned.","\\t\\tExample: >","\\t\\t\\t:let start = line(\'.\')","\\t\\t\\t:let end = search(\\"^$\\") - 1","\\t\\t\\t:let lines = getline(start, end)","","<\\t\\tTo get lines from another buffer see |getbufline()|"],"getloclist":["\\t\\tReturns a list with all the entries in the location list for","\\t\\twindow {nr}.  {nr} can be the window number or the |window-ID|.","\\t\\tWhen {nr} is zero the current window is used.","","\\t\\tFor a location list window, the displayed location list is","\\t\\treturned.  For an invalid window number {nr}, an empty list is","\\t\\treturned. Otherwise, same as |getqflist()|.","","\\t\\tIf the optional {what} dictionary argument is supplied, then","\\t\\treturns the items listed in {what} as a dictionary. Refer to","\\t\\t|getqflist()| for the supported items in {what}.","\\t\\tIf {what} contains \'filewinid\', then returns the id of the","\\t\\twindow used to display files from the location list. This","\\t\\tfield is applicable only when called from a location list","\\t\\twindow."],"getmatches":["\\t\\tReturns a |List| with all matches previously defined for the","\\t\\tcurrent window by |matchadd()| and the |:match| commands.","\\t\\t|getmatches()| is useful in combination with |setmatches()|,","\\t\\tas |setmatches()| can restore a list of matches saved by","\\t\\t|getmatches()|.","\\t\\tExample: >","\\t\\t\\t:echo getmatches()","<\\t\\t\\t[{\'group\': \'MyGroup1\', \'pattern\': \'TODO\',","\\t\\t\\t\'priority\': 10, \'id\': 1}, {\'group\': \'MyGroup2\',","\\t\\t\\t\'pattern\': \'FIXME\', \'priority\': 10, \'id\': 2}] >","\\t\\t\\t:let m = getmatches()","\\t\\t\\t:call clearmatches()","\\t\\t\\t:echo getmatches()","<\\t\\t\\t[] >","\\t\\t\\t:call setmatches(m)","\\t\\t\\t:echo getmatches()","<\\t\\t\\t[{\'group\': \'MyGroup1\', \'pattern\': \'TODO\',","\\t\\t\\t\'priority\': 10, \'id\': 1}, {\'group\': \'MyGroup2\',","\\t\\t\\t\'pattern\': \'FIXME\', \'priority\': 10, \'id\': 2}] >","\\t\\t\\t:unlet m","<"],"getpid":["\\t\\tThis is a unique number, until Vim exits.",""],"getpos":["\\t\\tsee |line()|.  For getting the cursor position see","\\t\\t|getcurpos()|.","\\t\\tThe result is a |List| with four numbers:","\\t\\t    [bufnum, lnum, col, off]","\\t\\t\\"bufnum\\" is zero, unless a mark like \'0 or \'A is used, then it","\\t\\tis the buffer number of the mark.","\\t\\t\\"lnum\\" and \\"col\\" are the position in the buffer.  The first","\\t\\tcolumn is 1.","\\t\\tThe \\"off\\" number is zero, unless \'virtualedit\' is used.  Then","\\t\\tit is the offset in screen columns from the start of the","\\t\\tcharacter.  E.g., a position within a <Tab> or after the last","\\t\\tcharacter.","\\t\\tNote that for \'< and \'> Visual mode matters: when it is \\"V\\"","\\t\\t(visual line mode) the column of \'< is zero and the column of","\\t\\t\'> is a large number.","\\t\\tThis can be used to save and restore the position of a mark: >","\\t\\t\\tlet save_a_mark = getpos(\\"\'a\\")","\\t\\t\\t...","\\t\\t\\tcall setpos(\\"\'a\\", save_a_mark)","<\\t\\tAlso see |getcurpos()| and |setpos()|.",""],"getqflist":["\\t\\tReturns a list with all the current quickfix errors.  Each","\\t\\tlist item is a dictionary with these entries:","\\t\\t\\tbufnr\\tnumber of buffer that has the file name, use","\\t\\t\\t\\tbufname() to get the name","\\t\\t\\tmodule\\tmodule name","\\t\\t\\tlnum\\tline number in the buffer (first line is 1)","\\t\\t\\tcol\\tcolumn number (first column is 1)","\\t\\t\\tvcol\\t|TRUE|: \\"col\\" is visual column","\\t\\t\\t\\t|FALSE|: \\"col\\" is byte index","\\t\\t\\tnr\\terror number","\\t\\t\\tpattern\\tsearch pattern used to locate the error","\\t\\t\\ttext\\tdescription of the error","\\t\\t\\ttype\\ttype of the error, \'E\', \'1\', etc.","\\t\\t\\tvalid\\t|TRUE|: recognized error message","","\\t\\tWhen there is no error list or it\'s empty, an empty list is","\\t\\treturned. Quickfix list entries with non-existing buffer","\\t\\tnumber are returned with \\"bufnr\\" set to zero.","","\\t\\tUseful application: Find pattern matches in multiple files and","\\t\\tdo something with them: >","\\t\\t\\t:vimgrep /theword/jg *.c","\\t\\t\\t:for d in getqflist()","\\t\\t\\t:   echo bufname(d.bufnr) \':\' d.lnum \'=\' d.text","\\t\\t\\t:endfor","<","\\t\\tIf the optional {what} dictionary argument is supplied, then","\\t\\treturns only the items listed in {what} as a dictionary. The","\\t\\tfollowing string items are supported in {what}:","\\t\\t\\tchangedtick\\tget the total number of changes made","\\t\\t\\t\\t\\tto the list |quickfix-changedtick|","\\t\\t\\tcontext\\tget the |quickfix-context|","\\t\\t\\tefm\\terrorformat to use when parsing \\"lines\\". If","\\t\\t\\t\\tnot present, then the \'errorformat\' option","\\t\\t\\t\\tvalue is used.","\\t\\t\\tid\\tget information for the quickfix list with","\\t\\t\\t\\t|quickfix-ID|; zero means the id for the","\\t\\t\\t\\tcurrent list or the list specified by \\"nr\\"","\\t\\t\\tidx\\tindex of the current entry in the list","\\t\\t\\titems\\tquickfix list entries","\\t\\t\\tlines\\tparse a list of lines using \'efm\' and return","\\t\\t\\t\\tthe resulting entries.  Only a |List| type is","\\t\\t\\t\\taccepted.  The current quickfix list is not","\\t\\t\\t\\tmodified. See |quickfix-parse|.","\\t\\t\\tnr\\tget information for this quickfix list; zero","\\t\\t\\t\\tmeans the current quickfix list and \\"$\\" means","\\t\\t\\t\\tthe last quickfix list","\\t\\t\\tsize\\tnumber of entries in the quickfix list","\\t\\t\\ttitle\\tget the list title |quickfix-title|","\\t\\t\\twinid\\tget the quickfix |window-ID|","\\t\\t\\tall\\tall of the above quickfix properties","\\t\\tNon-string items in {what} are ignored. To get the value of a","\\t\\tparticular item, set it to zero.","\\t\\tIf \\"nr\\" is not present then the current quickfix list is used.","\\t\\tIf both \\"nr\\" and a non-zero \\"id\\" are specified, then the list","\\t\\tspecified by \\"id\\" is used.","\\t\\tTo get the number of lists in the quickfix stack, set \\"nr\\" to","\\t\\t\\"$\\" in {what}. The \\"nr\\" value in the returned dictionary","\\t\\tcontains the quickfix stack size.","\\t\\tWhen \\"lines\\" is specified, all the other items except \\"efm\\"","\\t\\tare ignored.  The returned dictionary contains the entry","\\t\\t\\"items\\" with the list of entries.","","\\t\\tThe returned dictionary contains the following entries:","\\t\\t\\tchangedtick\\ttotal number of changes made to the","\\t\\t\\t\\t\\tlist |quickfix-changedtick|","\\t\\t\\tcontext\\tquickfix list context. See |quickfix-context|","\\t\\t\\t\\tIf not present, set to \\"\\".","\\t\\t\\tid\\tquickfix list ID |quickfix-ID|. If not","\\t\\t\\t\\tpresent, set to 0.","\\t\\t\\tidx\\tindex of the current entry in the list. If not","\\t\\t\\t\\tpresent, set to 0.","\\t\\t\\titems\\tquickfix list entries. If not present, set to","\\t\\t\\t\\tan empty list.","\\t\\t\\tnr\\tquickfix list number. If not present, set to 0","\\t\\t\\tsize\\tnumber of entries in the quickfix list. If not","\\t\\t\\t\\tpresent, set to 0.","\\t\\t\\ttitle\\tquickfix list title text. If not present, set","\\t\\t\\t\\tto \\"\\".","\\t\\t\\twinid\\tquickfix |window-ID|. If not present, set to 0","","\\t\\tExamples (See also |getqflist-examples|): >","\\t\\t\\t:echo getqflist({\'all\': 1})","\\t\\t\\t:echo getqflist({\'nr\': 2, \'title\': 1})","\\t\\t\\t:echo getqflist({\'lines\' : [\\"F1:10:L10\\"]})"],"getreg":["\\t\\tThe result is a String, which is the contents of register","\\t\\t{regname}.  Example: >","\\t\\t\\t:let cliptext = getreg(\'*\')","<\\t\\tWhen {regname} was not set the result is an empty string.","","\\t\\tgetreg(\'=\') returns the last evaluated value of the expression","\\t\\tregister.  (For use in maps.)","\\t\\tgetreg(\'=\', 1) returns the expression itself, so that it can","\\t\\tbe restored with |setreg()|.  For other registers the extra","\\t\\targument is ignored, thus you can always give it.","","\\t\\tIf {list} is present and |TRUE|, the result type is changed","\\t\\tto |List|. Each list item is one text line. Use it if you care","\\t\\tabout zero bytes possibly present inside register: without","\\t\\tthird argument both NLs and zero bytes are represented as NLs","\\t\\t(see |NL-used-for-Nul|).","\\t\\tWhen the register was not set an empty list is returned.","","\\t\\tIf {regname} is not specified, |v:register| is used.",""],"getregtype":["\\t\\tThe result is a String, which is type of register {regname}.","\\t\\tThe value will be one of:","\\t\\t    \\"v\\"\\t\\t\\tfor |charwise| text","\\t\\t    \\"V\\"\\t\\t\\tfor |linewise| text","\\t\\t    \\"<CTRL-V>{width}\\"\\tfor |blockwise-visual| text","\\t\\t    \\"\\"\\t\\t\\tfor an empty or unknown register","\\t\\t<CTRL-V> is one character with value 0x16.","\\t\\tIf {regname} is not specified, |v:register| is used."],"gettabinfo":["\\t\\tIf {arg} is not specified, then information about all the tab","\\t\\tpages is returned as a List. Each List item is a Dictionary.","\\t\\tOtherwise, {arg} specifies the tab page number and information","\\t\\tabout that one is returned.  If the tab page does not exist an","\\t\\tempty List is returned.","","\\t\\tEach List item is a Dictionary with the following entries:","\\t\\t\\ttabnr\\t\\ttab page number.","\\t\\t\\tvariables\\ta reference to the dictionary with","\\t\\t\\t\\t\\ttabpage-local variables","\\t\\t\\twindows\\t\\tList of |window-ID|s in the tab page."],"gettabvar":["\\t\\tGet the value of a tab-local variable {varname} in tab page","\\t\\t{tabnr}. |t:var|","\\t\\tTabs are numbered starting with one.","\\t\\tWhen {varname} is empty a dictionary with all tab-local","\\t\\tvariables is returned.","\\t\\tNote that the name without \\"t:\\" must be used.","\\t\\tWhen the tab or variable doesn\'t exist {def} or an empty","\\t\\tstring is returned, there is no error message."],"gettabwinvar":["\\t\\tGet the value of window-local variable {varname} in window","\\t\\t{winnr} in tab page {tabnr}.","\\t\\tWhen {varname} is empty a dictionary with all window-local","\\t\\tvariables is returned.","\\t\\tWhen {varname} is equal to \\"&\\" get the values of all","\\t\\twindow-local options in a Dictionary.","\\t\\tOtherwise, when {varname} starts with \\"&\\" get the value of a","\\t\\twindow-local option.","\\t\\tNote that {varname} must be the name without \\"w:\\".","\\t\\tTabs are numbered starting with one.  For the current tabpage","\\t\\tuse |getwinvar()|.","\\t\\t{winnr} can be the window number or the |window-ID|.","\\t\\tWhen {winnr} is zero the current window is used.","\\t\\tThis also works for a global option, buffer-local option and","\\t\\twindow-local option, but it doesn\'t work for a global variable","\\t\\tor buffer-local variable.","\\t\\tWhen the tab, window or variable doesn\'t exist {def} or an","\\t\\tempty string is returned, there is no error message.","\\t\\tExamples: >","\\t\\t\\t:let list_is_on = gettabwinvar(1, 2, \'&list\')","\\t\\t\\t:echo \\"myvar = \\" . gettabwinvar(3, 1, \'myvar\')","<","\\t\\tTo obtain all window-local variables use: >","\\t\\t\\tgettabwinvar({tabnr}, {winnr}, \'&\')"],"gettagstack":["\\t\\tThe result is a Dict, which is the tag stack of window {nr}.","\\t\\t{nr} can be the window number or the |window-ID|.","\\t\\tWhen {nr} is not specified, the current window is used.","\\t\\tWhen window {nr} doesn\'t exist, an empty Dict is returned.","","\\t\\tThe returned dictionary contains the following entries:","\\t\\t\\tcuridx\\t\\tCurrent index in the stack. When at","\\t\\t\\t\\t\\ttop of the stack, set to (length + 1).","\\t\\t\\t\\t\\tIndex of bottom of the stack is 1.","\\t\\t\\titems\\t\\tList of items in the stack. Each item","\\t\\t\\t\\t\\tis a dictionary containing the","\\t\\t\\t\\t\\tentries described below.","\\t\\t\\tlength\\t\\tNumber of entries in the stack.","","\\t\\tEach item in the stack is a dictionary with the following","\\t\\tentries:","\\t\\t\\tbufnr\\t\\tbuffer number of the current jump","\\t\\t\\tfrom\\t\\tcursor position before the tag jump.","\\t\\t\\t\\t\\tSee |getpos()| for the format of the","\\t\\t\\t\\t\\treturned list.","\\t\\t\\tmatchnr\\t\\tcurrent matching tag number. Used when","\\t\\t\\t\\t\\tmultiple matching tags are found for a","\\t\\t\\t\\t\\tname.","\\t\\t\\ttagname\\t\\tname of the tag","","\\t\\tSee |tagstack| for more information about the tag stack."],"getwininfo":["\\t\\tReturns information about windows as a List with Dictionaries.","","\\t\\tIf {winid} is given Information about the window with that ID","\\t\\tis returned.  If the window does not exist the result is an","\\t\\tempty list.","","\\t\\tWithout {winid} information about all the windows in all the","\\t\\ttab pages is returned.","","\\t\\tEach List item is a Dictionary with the following entries:","\\t\\t\\tbotline\\t\\tlast displayed buffer line","\\t\\t\\tbufnr\\t\\tnumber of buffer in the window","\\t\\t\\theight\\t\\twindow height (excluding winbar)","\\t\\t\\tloclist\\t\\t1 if showing a location list","\\t\\t\\tquickfix\\t1 if quickfix or location list window","\\t\\t\\tterminal\\t1 if a terminal window","\\t\\t\\ttabnr\\t\\ttab page number","\\t\\t\\ttopline\\t\\tfirst displayed buffer line ","\\t\\t\\tvariables\\ta reference to the dictionary with","\\t\\t\\t\\t\\twindow-local variables","\\t\\t\\twidth\\t\\twindow width","\\t\\t\\twinbar\\t\\t1 if the window has a toolbar, 0","\\t\\t\\t\\t\\totherwise","\\t\\t\\twincol\\t\\tleftmost screen column of the window","\\t\\t\\twinid\\t\\t|window-ID|","\\t\\t\\twinnr\\t\\twindow number","\\t\\t\\twinrow\\t\\ttopmost screen column of the window"],"getwinpos":["\\t\\tThe result is a list with two numbers, the result of","\\t\\tgetwinposx() and getwinposy() combined:","\\t\\t\\t[x-pos, y-pos]","\\t\\t{timeout} can be used to specify how long to wait in msec for","\\t\\ta response from the terminal.  When omitted 100 msec is used.",""],"getwinposx":["\\t\\tthe left hand side of the GUI Vim window.  The result will be","\\t\\t-1 if the information is not available.","\\t\\tThe value can be used with `:winpos`.",""],"getwinposy":["\\t\\tthe top of the GUI Vim window.  The result will be -1 if the","\\t\\tinformation is not available.","\\t\\tThe value can be used with `:winpos`."],"getwinvar":["\\t\\tLike |gettabwinvar()| for the current tabpage.","\\t\\tExamples: >","\\t\\t\\t:let list_is_on = getwinvar(2, \'&list\')","\\t\\t\\t:echo \\"myvar = \\" . getwinvar(1, \'myvar\')"],"glob":["\\t\\tExpand the file wildcards in {expr}.  See |wildcards| for the","\\t\\tuse of special characters.","","\\t\\tUnless the optional {nosuf} argument is given and is |TRUE|,","\\t\\tthe \'suffixes\' and \'wildignore\' options apply: Names matching","\\t\\tone of the patterns in \'wildignore\' will be skipped and","\\t\\t\'suffixes\' affect the ordering of matches.","\\t\\t\'wildignorecase\' always applies.","","\\t\\tWhen {list} is present and it is |TRUE| the result is a List","\\t\\twith all matching files. The advantage of using a List is,","\\t\\tyou also get filenames containing newlines correctly.","\\t\\tOtherwise the result is a String and when there are several","\\t\\tmatches, they are separated by <NL> characters.","","\\t\\tIf the expansion fails, the result is an empty String or List.","","\\t\\tYou can also use |readdir()| if you need to do complicated","\\t\\tthings, such as limiting the number of matches.","","\\t\\tA name for a non-existing file is not included.  A symbolic","\\t\\tlink is only included if it points to an existing file.","\\t\\tHowever, when the {alllinks} argument is present and it is","\\t\\t|TRUE| then all symbolic links are included.","","\\t\\tFor most systems backticks can be used to get files names from","\\t\\tany external command.  Example: >","\\t\\t\\t:let tagfiles = glob(\\"`find . -name tags -print`\\")","\\t\\t\\t:let &tags = substitute(tagfiles, \\"\\\\n\\", \\",\\", \\"g\\")","<\\t\\tThe result of the program inside the backticks should be one","\\t\\titem per line.  Spaces inside an item are allowed.","","\\t\\tSee |expand()| for expanding special Vim variables.  See","\\t\\t|system()| for getting the raw output of an external command."],"glob2regpat":["\\t\\tConvert a file pattern, as used by glob(), into a search","\\t\\tpattern.  The result can be used to match with a string that","\\t\\tis a file name.  E.g. >","\\t\\t\\tif filename =~ glob2regpat(\'Make*.mak\')","<\\t\\tThis is equivalent to: >","\\t\\t\\tif filename =~ \'^Make.*\\\\.mak$\'","<\\t\\tWhen {expr} is an empty string the result is \\"^$\\", match an","\\t\\tempty string.","\\t\\tNote that the result depends on the system.  On MS-Windows","\\t\\ta backslash usually means a path separator.",""],"globpath":["\\t\\tPerform glob() on all directories in {path} and concatenate","\\t\\tthe results.  Example: >","\\t\\t\\t:echo globpath(&rtp, \\"syntax/c.vim\\")","<","\\t\\t{path} is a comma-separated list of directory names.  Each","\\t\\tdirectory name is prepended to {expr} and expanded like with","\\t\\t|glob()|.  A path separator is inserted when needed.","\\t\\tTo add a comma inside a directory name escape it with a","\\t\\tbackslash.  Note that on MS-Windows a directory may have a","\\t\\ttrailing backslash, remove it if you put a comma after it.","\\t\\tIf the expansion fails for one of the directories, there is no","\\t\\terror message.","","\\t\\tUnless the optional {nosuf} argument is given and is |TRUE|,","\\t\\tthe \'suffixes\' and \'wildignore\' options apply: Names matching","\\t\\tone of the patterns in \'wildignore\' will be skipped and","\\t\\t\'suffixes\' affect the ordering of matches.","","\\t\\tWhen {list} is present and it is |TRUE| the result is a List","\\t\\twith all matching files. The advantage of using a List is, you","\\t\\talso get filenames containing newlines correctly. Otherwise","\\t\\tthe result is a String and when there are several matches,","\\t\\tthey are separated by <NL> characters.  Example: >","\\t\\t\\t:echo globpath(&rtp, \\"syntax/c.vim\\", 0, 1)","<","\\t\\t{allinks} is used as with |glob()|.","","\\t\\tThe \\"**\\" item can be used to search in a directory tree.","\\t\\tFor example, to find all \\"README.txt\\" files in the directories","\\t\\tin \'runtimepath\' and below: >","\\t\\t\\t:echo globpath(&rtp, \\"**/README.txt\\")","<\\t\\tUpwards search and limiting the depth of \\"**\\" is not","\\t\\tsupported, thus using \'path\' will not always work properly.",""],"has":["\\t\\t{feature} argument is a feature name like \\"nvim-0.2.1\\" or","\\t\\t\\"win32\\", see below.  See also |exists()|.","","\\t\\tVim\'s compile-time feature-names (prefixed with \\"+\\") are not","\\t\\trecognized because Nvim is always compiled with all possible","\\t\\tfeatures. |feature-compile| ","","\\t\\tFeature names can be:","\\t\\t1.  Nvim version. For example the \\"nvim-0.2.1\\" feature means","\\t\\t    that Nvim is version 0.2.1 or later: >","\\t\\t\\t:if has(\\"nvim-0.2.1\\")","","<\\t\\t2.  Runtime condition or other pseudo-feature. For example the","\\t\\t    \\"win32\\" feature checks if the current system is Windows: >","\\t\\t\\t:if has(\\"win32\\")","<\\t\\t\\t\\t\\t\\t\\t*feature-list*","\\t\\t    List of supported pseudo-feature names:","\\t\\t        acl\\t\\t|ACL| support","\\t\\t\\tbsd\\t\\tBSD system (not macOS, use \\"mac\\" for that).","\\t\\t        iconv\\t\\tCan use |iconv()| for conversion.","\\t\\t        +shellslash\\tCan use backslashes in filenames (Windows)","\\t\\t\\tclipboard\\t|clipboard| provider is available.","\\t\\t\\tmac\\t\\tMacOS system.","\\t\\t\\tnvim\\t\\tThis is Nvim.","\\t\\t\\tpython2\\t\\tLegacy Vim |python2| interface. |has-python|","\\t\\t\\tpython3\\t\\tLegacy Vim |python3| interface. |has-python|","\\t\\t\\tpythonx\\t\\tLegacy Vim |python_x| interface. |has-pythonx|","\\t\\t\\tttyin\\t\\tinput is a terminal (tty)","\\t\\t\\tttyout\\t\\toutput is a terminal (tty)","\\t\\t\\tunix\\t\\tUnix system.","\\t\\t\\t*vim_starting*\\tTrue during |startup|. ","\\t\\t\\twin32\\t\\tWindows system (32 or 64 bit).","\\t\\t\\twin64\\t\\tWindows system (64 bit).","\\t\\t\\twsl\\t\\tWSL (Windows Subsystem for Linux) system","","\\t\\t\\t\\t\\t\\t\\t*has-patch*","\\t\\t3.  Vim patch. For example the \\"patch123\\" feature means that","\\t\\t    Vim patch 123 at the current |v:version| was included: >","\\t\\t\\t:if v:version > 602 || v:version == 602 && has(\\"patch148\\")","","<\\t\\t4.  Vim version. For example the \\"patch-7.4.237\\" feature means","\\t\\t    that Nvim is Vim-compatible to version 7.4.237 or later. >","\\t\\t\\t:if has(\\"patch-7.4.237\\")",""],"has_key":["\\t\\tThe result is a Number, which is 1 if |Dictionary| {dict} has","\\t\\tan entry with key {key}.  Zero otherwise."],"haslocaldir":["\\t\\tThe result is a Number, which is 1 when the tabpage or window","\\t\\thas set a local path via |:tcd| or |:lcd|, otherwise 0.","","\\t\\tTabs and windows are identified by their respective numbers,","\\t\\t0 means current tab or window. Missing argument implies 0.","\\t\\tThus the following are equivalent: >","\\t\\t\\thaslocaldir()","\\t\\t\\thaslocaldir(0)","\\t\\t\\thaslocaldir(0, 0)","<\\t\\tWith {winnr} use that window in the current tabpage.","\\t\\tWith {winnr} and {tabnr} use the window in that tabpage.","\\t\\t{winnr} can be the window number or the |window-ID|.","\\t\\tIf {winnr} is -1 it is ignored, only the tab is resolved."],"hasmapto":["\\t\\tThe result is a Number, which is 1 if there is a mapping that","\\t\\tcontains {what} in somewhere in the rhs (what it is mapped to)","\\t\\tand this mapping exists in one of the modes indicated by","\\t\\t{mode}.","\\t\\tWhen {abbr} is there and it is |TRUE| use abbreviations","\\t\\tinstead of mappings.  Don\'t forget to specify Insert and/or","\\t\\tCommand-line mode.","\\t\\tBoth the global mappings and the mappings local to the current","\\t\\tbuffer are checked for a match.","\\t\\tIf no matching mapping is found 0 is returned.","\\t\\tThe following characters are recognized in {mode}:","\\t\\t\\tn\\tNormal mode","\\t\\t\\tv\\tVisual mode","\\t\\t\\to\\tOperator-pending mode","\\t\\t\\ti\\tInsert mode","\\t\\t\\tl\\tLanguage-Argument (\\"r\\", \\"f\\", \\"t\\", etc.)","\\t\\t\\tc\\tCommand-line mode","\\t\\tWhen {mode} is omitted, \\"nvo\\" is used.","","\\t\\tThis function is useful to check if a mapping already exists","\\t\\tto a function in a Vim script.  Example: >","\\t\\t\\t:if !hasmapto(\'\\\\ABCdoit\')","\\t\\t\\t:   map <Leader>d \\\\ABCdoit","\\t\\t\\t:endif","<\\t\\tThis installs the mapping to \\"\\\\ABCdoit\\" only if there isn\'t","\\t\\talready a mapping to \\"\\\\ABCdoit\\"."],"histadd":["\\t\\tAdd the String {item} to the history {history} which can be","\\t\\tone of:\\t\\t\\t\\t\\t*hist-names*","\\t\\t\\t\\"cmd\\"\\t or \\":\\"\\t  command line history","\\t\\t\\t\\"search\\" or \\"/\\"   search pattern history","\\t\\t\\t\\"expr\\"\\t or \\"=\\"   typed expression history","\\t\\t\\t\\"input\\"  or \\"@\\"\\t  input line history","\\t\\t\\t\\"debug\\"  or \\">\\"   debug command history","\\t\\t\\tempty\\t\\t  the current or last used history","\\t\\tThe {history} string does not need to be the whole name, one","\\t\\tcharacter is sufficient.","\\t\\tIf {item} does already exist in the history, it will be","\\t\\tshifted to become the newest entry.","\\t\\tThe result is a Number: 1 if the operation was successful,","\\t\\totherwise 0 is returned.","","\\t\\tExample: >","\\t\\t\\t:call histadd(\\"input\\", strftime(\\"%Y %b %d\\"))","\\t\\t\\t:let date=input(\\"Enter date: \\")","<\\t\\tThis function is not available in the |sandbox|."],"histdel":["\\t\\tClear {history}, i.e. delete all its entries.  See |hist-names|","\\t\\tfor the possible values of {history}.","","\\t\\tIf the parameter {item} evaluates to a String, it is used as a","\\t\\tregular expression.  All entries matching that expression will","\\t\\tbe removed from the history (if there are any).","\\t\\tUpper/lowercase must match, unless \\"\\\\c\\" is used |/\\\\c|.","\\t\\tIf {item} evaluates to a Number, it will be interpreted as","\\t\\tan index, see |:history-indexing|.  The respective entry will","\\t\\tbe removed if it exists.","","\\t\\tThe result is a Number: 1 for a successful operation,","\\t\\totherwise 0 is returned.","","\\t\\tExamples:","\\t\\tClear expression register history: >","\\t\\t\\t:call histdel(\\"expr\\")","<","\\t\\tRemove all entries starting with \\"*\\" from the search history: >","\\t\\t\\t:call histdel(\\"/\\", \'^\\\\*\')","<","\\t\\tThe following three are equivalent: >","\\t\\t\\t:call histdel(\\"search\\", histnr(\\"search\\"))","\\t\\t\\t:call histdel(\\"search\\", -1)","\\t\\t\\t:call histdel(\\"search\\", \'^\'.histget(\\"search\\", -1).\'$\')","<","\\t\\tTo delete the last search pattern and use the last-but-one for","\\t\\tthe \\"n\\" command and \'hlsearch\': >","\\t\\t\\t:call histdel(\\"search\\", -1)","\\t\\t\\t:let @/ = histget(\\"search\\", -1)"],"histget":["\\t\\tThe result is a String, the entry with Number {index} from","\\t\\t{history}.  See |hist-names| for the possible values of","\\t\\t{history}, and |:history-indexing| for {index}.  If there is","\\t\\tno such entry, an empty String is returned.  When {index} is","\\t\\tomitted, the most recent item from the history is used.","","\\t\\tExamples:","\\t\\tRedo the second last search from history. >","\\t\\t\\t:execute \'/\' . histget(\\"search\\", -2)","","<\\t\\tDefine an Ex command \\":H {num}\\" that supports re-execution of","\\t\\tthe {num}th entry from the output of |:history|. >","\\t\\t\\t:command -nargs=1 H execute histget(\\"cmd\\", 0+<args>)"],"histnr":["\\t\\tThe result is the Number of the current entry in {history}.","\\t\\tSee |hist-names| for the possible values of {history}.","\\t\\tIf an error occurred, -1 is returned.","","\\t\\tExample: >","\\t\\t\\t:let inp_index = histnr(\\"expr\\")"],"hlexists":["\\t\\tThe result is a Number, which is non-zero if a highlight group","\\t\\tcalled {name} exists.  This is when the group has been","\\t\\tdefined in some way.  Not necessarily when highlighting has","\\t\\tbeen defined for it, it may also have been used for a syntax","\\t\\titem.",""],"hlID":["\\t\\twith name {name}.  When the highlight group doesn\'t exist,","\\t\\tzero is returned.","\\t\\tThis can be used to retrieve information about the highlight","\\t\\tgroup.  For example, to get the background color of the","\\t\\t\\"Comment\\" group: >","\\t:echo synIDattr(synIDtrans(hlID(\\"Comment\\")), \\"bg\\")"],"hostname":["\\t\\tThe result is a String, which is the name of the machine on","\\t\\twhich Vim is currently running.  Machine names greater than","\\t\\t256 characters long are truncated."],"iconv":["\\t\\tThe result is a String, which is the text {expr} converted","\\t\\tfrom encoding {from} to encoding {to}.","\\t\\tWhen the conversion completely fails an empty string is","\\t\\treturned.  When some characters could not be converted they","\\t\\tare replaced with \\"?\\".","\\t\\tThe encoding names are whatever the iconv() library function","\\t\\tcan accept, see \\":!man 3 iconv\\".","\\t\\tMost conversions require Vim to be compiled with the |+iconv|","\\t\\tfeature.  Otherwise only UTF-8 to latin1 conversion and back","\\t\\tcan be done.","\\t\\tNote that Vim uses UTF-8 for all Unicode encodings, conversion","\\t\\tfrom/to UCS-2 is automatically changed to use UTF-8.  You","\\t\\tcannot use UCS-2 in a string anyway, because of the NUL bytes.",""],"indent":["\\t\\tcurrent buffer.  The indent is counted in spaces, the value","\\t\\tof \'tabstop\' is relevant.  {lnum} is used just like in","\\t\\t|getline()|.","\\t\\tWhen {lnum} is invalid -1 is returned.",""],"index":["\\t\\tReturn the lowest index in |List| {list} where the item has a","\\t\\tvalue equal to {expr}.  There is no automatic conversion, so","\\t\\tthe String \\"4\\" is different from the Number 4.  And the number","\\t\\t4 is different from the Float 4.0.  The value of \'ignorecase\'","\\t\\tis not used here, case always matters.","\\t\\tIf {start} is given then start looking at the item with index","\\t\\t{start} (may be negative for an item relative to the end).","\\t\\tWhen {ic} is given and it is |TRUE|, ignore case.  Otherwise","\\t\\tcase must match.","\\t\\t-1 is returned when {expr} is not found in {list}.","\\t\\tExample: >","\\t\\t\\t:let idx = index(words, \\"the\\")","\\t\\t\\t:if index(numbers, 123) >= 0",""],"input":["\\t\\tThe result is a String, which is whatever the user typed on","\\t\\tthe command-line.  The {prompt} argument is either a prompt","\\t\\tstring, or a blank string (for no prompt).  A \'\\\\n\' can be used","\\t\\tin the prompt to start a new line.","","\\t\\tIn the second form it accepts a single dictionary with the","\\t\\tfollowing keys, any of which may be omitted:","","\\t\\tKey           Default  Description ~","\\t\\tprompt        \\"\\"       Same as {prompt} in the first form.","\\t\\tdefault       \\"\\"       Same as {text} in the first form.","\\t\\tcompletion    nothing  Same as {completion} in the first form.","\\t\\tcancelreturn  \\"\\"       Same as {cancelreturn} from","\\t\\t                       |inputdialog()|. Also works with","\\t\\t                       input().","\\t\\thighlight     nothing  Highlight handler: |Funcref|.","","\\t\\tThe highlighting set with |:echohl| is used for the prompt.","\\t\\tThe input is entered just like a command-line, with the same","\\t\\tediting commands and mappings.  There is a separate history","\\t\\tfor lines typed for input().","\\t\\tExample: >","\\t\\t\\t:if input(\\"Coffee or beer? \\") == \\"beer\\"","\\t\\t\\t:  echo \\"Cheers!\\"","\\t\\t\\t:endif","<","\\t\\tIf the optional {text} argument is present and not empty, this","\\t\\tis used for the default reply, as if the user typed this.","\\t\\tExample: >","\\t\\t\\t:let color = input(\\"Color? \\", \\"white\\")","","<\\t\\tThe optional {completion} argument specifies the type of","\\t\\tcompletion supported for the input.  Without it completion is","\\t\\tnot performed.  The supported completion types are the same as","\\t\\tthat can be supplied to a user-defined command using the","\\t\\t\\"-complete=\\" argument.  Refer to |:command-completion| for","\\t\\tmore information.  Example: >","\\t\\t\\tlet fname = input(\\"File: \\", \\"\\", \\"file\\")","","<\\t\\t\\t\\t\\t*input()-highlight* *E5400* *E5402*","\\t\\tThe optional `highlight` key allows specifying function which","\\t\\twill be used for highlighting user input.  This function","\\t\\treceives user input as its only argument and must return","\\t\\ta list of 3-tuples [hl_start_col, hl_end_col + 1, hl_group]","\\t\\twhere","\\t\\t\\thl_start_col is the first highlighted column,","\\t\\t\\thl_end_col is the last highlighted column (+ 1!),","\\t\\t\\thl_group is |:hi| group used for highlighting.","\\t\\t\\t\\t\\t      *E5403* *E5404* *E5405* *E5406*","\\t\\tBoth hl_start_col and hl_end_col + 1 must point to the start","\\t\\tof the multibyte character (highlighting must not break","\\t\\tmultibyte characters), hl_end_col + 1 may be equal to the","\\t\\tinput length.  Start column must be in range [0, len(input)),","\\t\\tend column must be in range (hl_start_col, len(input)],","\\t\\tsections must be ordered so that next hl_start_col is greater","\\t\\tthen or equal to previous hl_end_col.","","\\t\\tExample (try some input with parentheses): >","\\t\\t\\thighlight RBP1 guibg=Red ctermbg=red","\\t\\t\\thighlight RBP2 guibg=Yellow ctermbg=yellow","\\t\\t\\thighlight RBP3 guibg=Green ctermbg=green","\\t\\t\\thighlight RBP4 guibg=Blue ctermbg=blue","\\t\\t\\tlet g:rainbow_levels = 4","\\t\\t\\tfunction! RainbowParens(cmdline)","\\t\\t\\t  let ret = []","\\t\\t\\t  let i = 0","\\t\\t\\t  let lvl = 0","\\t\\t\\t  while i < len(a:cmdline)","\\t\\t\\t    if a:cmdline[i] is# \'(\'","\\t\\t\\t      call add(ret, [i, i + 1, \'RBP\' . ((lvl % g:rainbow_levels) + 1)])","\\t\\t\\t      let lvl += 1","\\t\\t\\t    elseif a:cmdline[i] is# \')\'","\\t\\t\\t      let lvl -= 1","\\t\\t\\t      call add(ret, [i, i + 1, \'RBP\' . ((lvl % g:rainbow_levels) + 1)])","\\t\\t\\t    endif","\\t\\t\\t    let i += 1","\\t\\t\\t  endwhile","\\t\\t\\t  return ret","\\t\\t\\tendfunction","\\t\\t\\tcall input({\'prompt\':\'>\',\'highlight\':\'RainbowParens\'})","<","\\t\\tHighlight function is called at least once for each new","\\t\\tdisplayed input string, before command-line is redrawn.  It is","\\t\\texpected that function is pure for the duration of one input()","\\t\\tcall, i.e. it produces the same output for the same input, so","\\t\\toutput may be memoized.  Function is run like under |:silent|","\\t\\tmodifier. If the function causes any errors, it will be","\\t\\tskipped for the duration of the current input() call.","","\\t\\tHighlighting is disabled if command-line contains arabic","\\t\\tcharacters.","","\\t\\tNOTE: This function must not be used in a startup file, for","\\t\\tthe versions that only run in GUI mode (e.g., the Win32 GUI).","\\t\\tNote: When input() is called from within a mapping it will","\\t\\tconsume remaining characters from that mapping, because a","\\t\\tmapping is handled like the characters were typed.","\\t\\tUse |inputsave()| before input() and |inputrestore()|","\\t\\tafter input() to avoid that.  Another solution is to avoid","\\t\\tthat further characters follow in the mapping, e.g., by using","\\t\\t|:execute| or |:normal|.","","\\t\\tExample with a mapping: >","\\t\\t\\t:nmap \\\\x :call GetFoo()<CR>:exe \\"/\\" . Foo<CR>","\\t\\t\\t:function GetFoo()","\\t\\t\\t:  call inputsave()","\\t\\t\\t:  let g:Foo = input(\\"enter search pattern: \\")","\\t\\t\\t:  call inputrestore()","\\t\\t\\t:endfunction"],"inputlist":["\\t\\t{textlist} must be a |List| of strings.  This |List| is","\\t\\tdisplayed, one string per line.  The user will be prompted to","\\t\\tenter a number, which is returned.","\\t\\tThe user can also select an item by clicking on it with the","\\t\\tmouse.  For the first string 0 is returned.  When clicking","\\t\\tabove the first item a negative number is returned.  When","\\t\\tclicking on the prompt one more than the length of {textlist}","\\t\\tis returned.","\\t\\tMake sure {textlist} has less than \'lines\' entries, otherwise","\\t\\tit won\'t work.  It\'s a good idea to put the entry number at","\\t\\tthe start of the string.  And put a prompt in the first item.","\\t\\tExample: >","\\t\\t\\tlet color = inputlist([\'Select color:\', \'1. red\',","\\t\\t\\t\\t\\\\ \'2. green\', \'3. blue\'])"],"inputrestore":["\\t\\tRestore typeahead that was saved with a previous |inputsave()|.","\\t\\tShould be called the same number of times inputsave() is","\\t\\tcalled.  Calling it more often is harmless though.","\\t\\tReturns 1 when there is nothing to restore, 0 otherwise."],"inputsave":["\\t\\tPreserve typeahead (also from mappings) and clear it, so that","\\t\\ta following prompt gets input from the user.  Should be","\\t\\tfollowed by a matching inputrestore() after the prompt.  Can","\\t\\tbe used several times, in which case there must be just as","\\t\\tmany inputrestore() calls.","\\t\\tReturns 1 when out of memory, 0 otherwise."],"inputsecret":["\\t\\tThis function acts much like the |input()| function with but","\\t\\ttwo exceptions:","\\t\\ta) the user\'s response will be displayed as a sequence of","\\t\\tasterisks (\\"*\\") thereby keeping the entry secret, and","\\t\\tb) the user\'s response will not be recorded on the input","\\t\\t|history| stack.","\\t\\tThe result is a String, which is whatever the user actually","\\t\\ttyped on the command-line in response to the issued prompt.","\\t\\tNOTE: Command-line completion is not supported."],"insert":["\\t\\tInsert {item} at the start of |List| {list}.","\\t\\tIf {idx} is specified insert {item} before the item with index","\\t\\t{idx}.  If {idx} is zero it goes before the first item, just","\\t\\tlike omitting {idx}.  A negative {idx} is also possible, see","\\t\\t|list-index|.  -1 inserts just before the last item.","\\t\\tReturns the resulting |List|.  Examples: >","\\t\\t\\t:let mylist = insert([2, 3, 5], 1)","\\t\\t\\t:call insert(mylist, 4, -1)","\\t\\t\\t:call insert(mylist, 6, len(mylist))","<\\t\\tThe last example can be done simpler with |add()|.","\\t\\tNote that when {item} is a |List| it is inserted as a single","\\t\\titem.  Use |extend()| to concatenate |Lists|."],"invert":["\\t\\tBitwise invert.  The argument is converted to a number.  A","\\t\\tList, Dict or Float argument causes an error.  Example: >","\\t\\t\\t:let bits = invert(bits)"],"isdirectory":["\\t\\tThe result is a Number, which is |TRUE| when a directory","\\t\\twith the name {directory} exists.  If {directory} doesn\'t","\\t\\texist, or isn\'t a directory, the result is |FALSE|.  {directory}","\\t\\tis any expression, which is used as a String."],"isinf":["\\t\\tReturn 1 if {expr} is a positive infinity, or -1 a negative","\\t\\tinfinity, otherwise 0. >","\\t\\t\\t:echo isinf(1.0 / 0.0)","<\\t\\t\\t1 >","\\t\\t\\t:echo isinf(-1.0 / 0.0)","<\\t\\t\\t-1"],"islocked":["\\t\\tThe result is a Number, which is |TRUE| when {expr} is the","\\t\\tname of a locked variable.","\\t\\t{expr} must be the name of a variable, |List| item or","\\t\\t|Dictionary| entry, not the variable itself!  Example: >","\\t\\t\\t:let alist = [0, [\'a\', \'b\'], 2, 3]","\\t\\t\\t:lockvar 1 alist","\\t\\t\\t:echo islocked(\'alist\')\\t\\t\\" 1","\\t\\t\\t:echo islocked(\'alist[1]\')\\t\\" 0","","<\\t\\tWhen {expr} is a variable that does not exist you get an error","\\t\\tmessage.  Use |exists()| to check for existence."],"id":["\\t\\tReturns a |String| which is a unique identifier of the","\\t\\tcontainer type (|List|, |Dict| and |Partial|). It is","\\t\\tguaranteed that for the mentioned types `id(v1) ==# id(v2)`","\\t\\treturns true iff `type(v1) == type(v2) && v1 is v2` (note:","\\t\\t|v:_null_list| and |v:_null_dict| have the same `id()` with","\\t\\tdifferent types because they are internally represented as","\\t\\ta NULL pointers). Currently `id()` returns a hexadecimal","\\t\\trepresentanion of the pointers to the containers (i.e. like","\\t\\t`0x994a40`), same as `printf(\\"%p\\", {expr})`, but it is advised","\\t\\tagainst counting on exact format of return value.","","\\t\\tIt is not guaranteed that `id(no_longer_existing_container)`","\\t\\twill not be equal to some other `id()`: new containers may","\\t\\treuse identifiers of the garbage-collected ones."],"items":["\\t\\tReturn a |List| with all the key-value pairs of {dict}.  Each","\\t\\t|List| item is a list with two items: the key of a {dict}","\\t\\tentry and the value of this entry.  The |List| is in arbitrary","\\t\\torder."],"isnan":["\\t\\tReturn |TRUE| if {expr} is a float with value NaN. >","\\t\\t\\techo isnan(0.0 / 0.0)","<\\t\\t\\t1"],"jobpid":["\\t\\tReturn the PID (process id) of |job-id| {job}."],"jobresize":["\\t\\tResize the pseudo terminal window of |job-id| {job} to {width}","\\t\\tcolumns and {height} rows.","\\t\\tFails if the job was not started with `\\"pty\\":v:true`."],"jobstart":["\\t\\tSpawns {cmd} as a job.","\\t\\tIf {cmd} is a List it runs directly (no \'shell\').","\\t\\tIf {cmd} is a String it runs in the \'shell\', like this: >","\\t\\t  :call jobstart(split(&shell) + split(&shellcmdflag) + [\'{cmd}\'])","<\\t\\t(See |shell-unquoting| for details.)","","\\t\\tExample: >","\\t\\t  :call jobstart(\'nvim -h\', {\'on_stdout\':{j,d,e->append(line(\'.\'),d)}})","<","\\t\\tReturns |job-id| on success, 0 on invalid arguments (or job","\\t\\ttable is full), -1 if {cmd}[0] or \'shell\' is not executable.","\\t\\tThe returned job-id is a valid |channel-id| representing the","\\t\\tjob\'s stdio streams. Use |chansend()| (or |rpcnotify()| and","\\t\\t|rpcrequest()| if \\"rpc\\" was enabled) to send data to stdin and","\\t\\t|chanclose()| to close the streams without stopping the job.","","\\t\\tSee |job-control| and |RPC|.","","\\t\\tNOTE: on Windows if {cmd} is a List:","\\t\\t  - cmd[0] must be an executable (not a \\"built-in\\"). If it is","\\t\\t    in $PATH it can be called by name, without an extension: >","\\t\\t      :call jobstart([\'ping\', \'neovim.io\'])","<\\t\\t    If it is a full or partial path, extension is required: >","\\t\\t      :call jobstart([\'System32\\\\ping.exe\', \'neovim.io\'])","<\\t\\t  - {cmd} is collapsed to a string of quoted args as expected","\\t\\t    by CommandLineToArgvW https://msdn.microsoft.com/bb776391","\\t\\t    unless cmd[0] is some form of \\"cmd.exe\\".","","\\t\\t\\t\\t\\t\\t\\t*jobstart-options*","\\t\\t{opts} is a dictionary with these keys:","\\t\\t  clear_env:  (boolean) `env` defines the job environment","\\t\\t\\t      exactly, instead of merging current environment.","\\t\\t  cwd:\\t      (string, default=|current-directory|) Working","\\t\\t\\t      directory of the job.","\\t\\t  detach:     (boolean) Detach the job process: it will not be","\\t\\t\\t      killed when Nvim exits. If the process exits","\\t\\t\\t      before Nvim, `on_exit` will be invoked.","\\t\\t  env:\\t      (dict) Map of environment variable name:value","\\t\\t\\t      pairs extending (or replacing if |clear_env|)","\\t\\t\\t      the current environment.","\\t\\t  height:     (number) Height of the `pty` terminal.","\\t\\t  |on_exit|:    (function) Callback invoked when the job exits.","\\t\\t  |on_stdout|:  (function) Callback invoked when the job emits","\\t\\t\\t      stdout data.","\\t\\t  |on_stderr|:  (function) Callback invoked when the job emits","\\t\\t\\t      stderr data.","\\t\\t  pty:\\t      (boolean) Connect the job to a new pseudo","\\t\\t\\t      terminal, and its streams to the master file","\\t\\t\\t      descriptor. Then  `on_stderr` is ignored,","\\t\\t\\t      `on_stdout` receives all output.","\\t\\t  rpc:\\t      (boolean) Use |msgpack-rpc| to communicate with","\\t\\t\\t      the job over stdio. Then `on_stdout` is ignored,","\\t\\t\\t      but `on_stderr` can still be used.","\\t\\t  stderr_buffered: (boolean) Collect data until EOF (stream closed)","\\t\\t\\t      before invoking `on_stderr`. |channel-buffered|","\\t\\t  stdout_buffered: (boolean) Collect data until EOF (stream","\\t\\t\\t      closed) before invoking `on_stdout`. |channel-buffered|","\\t\\t  TERM:\\t      (string) Sets the `pty` $TERM environment variable.","\\t\\t  width:      (number) Width of the `pty` terminal.","","\\t\\t{opts} is passed as |self| dictionary to the callback; the","\\t\\tcaller may set other keys to pass application-specific data.","","\\t\\tReturns:","\\t\\t  - |channel-id| on success","\\t\\t  - 0 on invalid arguments","\\t\\t  - -1 if {cmd}[0] is not executable.","\\t\\tSee also |job-control|, |channel|, |msgpack-rpc|."],"jobstop":["\\t\\tStop |job-id| {id} by sending SIGTERM to the job process. If","\\t\\tthe process does not terminate after a timeout then SIGKILL","\\t\\twill be sent. When the job terminates its |on_exit| handler","\\t\\t(if any) will be invoked.","\\t\\tSee |job-control|.","","\\t\\tReturns 1 for valid job id, 0 for invalid id, including jobs have","\\t\\texited or stopped."],"jobwait":["\\t\\tWaits for jobs and their |on_exit| handlers to complete.","","\\t\\t{jobs} is a List of |job-id|s to wait for.","\\t\\t{timeout} is the maximum waiting time in milliseconds, -1","\\t\\tmeans forever.","","\\t\\tTimeout of 0 can be used to check the status of a job: >","\\t\\t\\tlet running = jobwait([{job-id}], 0)[0] == -1","<","\\t\\tDuring jobwait() callbacks for jobs not in the {jobs} list may","\\t\\tbe invoked. The screen will not redraw unless |:redraw| is","\\t\\tinvoked by a callback.","","\\t\\tReturns a list of len({jobs}) integers, where each integer is","\\t\\tthe status of the corresponding job:","\\t\\t\\tExit-code, if the job exited","\\t\\t\\t-1 if the timeout was exceeded","\\t\\t\\t-2 if the job was interrupted (by |CTRL-C|)","\\t\\t\\t-3 if the job-id is invalid"],"join":["\\t\\tJoin the items in {list} together into one String.","\\t\\tWhen {sep} is specified it is put in between the items.  If","\\t\\t{sep} is omitted a single space is used.","\\t\\tNote that {sep} is not added at the end.  You might want to","\\t\\tadd it there too: >","\\t\\t\\tlet lines = join(mylist, \\"\\\\n\\") . \\"\\\\n\\"","<\\t\\tString items are used as-is.  |Lists| and |Dictionaries| are","\\t\\tconverted into a string like with |string()|.","\\t\\tThe opposite function is |split()|."],"json_decode":["\\t\\tConvert {expr} from JSON object.  Accepts |readfile()|-style","\\t\\tlist as the input, as well as regular string.  May output any","\\t\\tVim value. In the following cases it will output","\\t\\t|msgpack-special-dict|:","\\t\\t1. Dictionary contains duplicate key.","\\t\\t2. Dictionary contains empty key.","\\t\\t3. String contains NUL byte.  Two special dictionaries: for","\\t\\t   dictionary and for string will be emitted in case string","\\t\\t   with NUL byte was a dictionary key.","","\\t\\tNote: function treats its input as UTF-8 always.  The JSON","\\t\\tstandard allows only a few encodings, of which UTF-8 is","\\t\\trecommended and the only one required to be supported.","\\t\\tNon-UTF-8 characters are an error."],"json_encode":["\\t\\tConvert {expr} into a JSON string.  Accepts","\\t\\t|msgpack-special-dict| as the input.  Will not convert","\\t\\t|Funcref|s, mappings with non-string keys (can be created as","\\t\\t|msgpack-special-dict|), values with self-referencing","\\t\\tcontainers, strings which contain non-UTF-8 characters,","\\t\\tpseudo-UTF-8 strings which contain codepoints reserved for","\\t\\tsurrogate pairs (such strings are not valid UTF-8 strings). ","\\t\\tNon-printable characters are converted into \\"\\\\u1234\\" escapes","\\t\\tor special escapes like \\"\\\\t\\", other are dumped as-is."],"keys":["\\t\\tReturn a |List| with all the keys of {dict}.  The |List| is in","\\t\\tarbitrary order.",""],"len":["\\t\\tWhen {expr} is a String or a Number the length in bytes is","\\t\\tused, as with |strlen()|.","\\t\\tWhen {expr} is a |List| the number of items in the |List| is","\\t\\treturned.","\\t\\tWhen {expr} is a |Blob| the number of bytes is returned.","\\t\\tWhen {expr} is a |Dictionary| the number of entries in the","\\t\\t|Dictionary| is returned.","\\t\\tOtherwise an error is given.",""],"libcall":["\\t\\tCall function {funcname} in the run-time library {libname}","\\t\\twith single argument {argument}.","\\t\\tThis is useful to call functions in a library that you","\\t\\tespecially made to be used with Vim.  Since only one argument","\\t\\tis possible, calling standard library functions is rather","\\t\\tlimited.","\\t\\tThe result is the String returned by the function.  If the","\\t\\tfunction returns NULL, this will appear as an empty string \\"\\"","\\t\\tto Vim.","\\t\\tIf the function returns a number, use libcallnr()!","\\t\\tIf {argument} is a number, it is passed to the function as an","\\t\\tint; if {argument} is a string, it is passed as a","\\t\\tnull-terminated string.","\\t\\tThis function will fail in |restricted-mode|.","","\\t\\tlibcall() allows you to write your own \'plug-in\' extensions to","\\t\\tVim without having to recompile the program.  It is NOT a","\\t\\tmeans to call system functions!  If you try to do so Vim will","\\t\\tvery probably crash.","","\\t\\tFor Win32, the functions you write must be placed in a DLL","\\t\\tand use the normal C calling convention (NOT Pascal which is","\\t\\tused in Windows System DLLs).  The function must take exactly","\\t\\tone parameter, either a character pointer or a long integer,","\\t\\tand must return a character pointer or NULL.  The character","\\t\\tpointer returned must point to memory that will remain valid","\\t\\tafter the function has returned (e.g. in static data in the","\\t\\tDLL).  If it points to allocated memory, that memory will","\\t\\tleak away.  Using a static buffer in the function should work,","\\t\\tit\'s then freed when the DLL is unloaded.","","\\t\\tWARNING: If the function returns a non-valid pointer, Vim may","\\t\\tcrash!\\tThis also happens if the function returns a number,","\\t\\tbecause Vim thinks it\'s a pointer.","\\t\\tFor Win32 systems, {libname} should be the filename of the DLL","\\t\\twithout the \\".DLL\\" suffix.  A full path is only required if","\\t\\tthe DLL is not in the usual places.","\\t\\tFor Unix: When compiling your own plugins, remember that the","\\t\\tobject code must be compiled as position-independent (\'PIC\').","\\t\\tExamples: >","\\t\\t\\t:echo libcall(\\"libc.so\\", \\"getenv\\", \\"HOME\\")","<"],"libcallnr":["\\t\\tJust like |libcall()|, but used for a function that returns an","\\t\\tint instead of a string.","\\t\\tExamples: >","\\t\\t\\t:echo libcallnr(\\"/usr/lib/libc.so\\", \\"getpid\\", \\"\\")","\\t\\t\\t:call libcallnr(\\"libc.so\\", \\"printf\\", \\"Hello World!\\\\n\\")","\\t\\t\\t:call libcallnr(\\"libc.so\\", \\"sleep\\", 10)","<"],"line":["\\t\\tposition given with {expr}.  The accepted positions are:","\\t\\t    .\\t    the cursor position","\\t\\t    $\\t    the last line in the current buffer","\\t\\t    \'x\\t    position of mark x (if the mark is not set, 0 is","\\t\\t\\t    returned)","\\t\\t    w0\\t    first line visible in current window (one if the","\\t\\t\\t    display isn\'t updated, e.g. in silent Ex mode)","\\t\\t    w$\\t    last line visible in current window (this is one","\\t\\t\\t    less than \\"w0\\" if no lines are visible)","\\t\\t    v\\t    In Visual mode: the start of the Visual area (the","\\t\\t\\t    cursor is the end).  When not in Visual mode","\\t\\t\\t    returns the cursor position.  Differs from |\'<| in","\\t\\t\\t    that it\'s updated right away.","\\t\\tNote that a mark in another file can be used.  The line number","\\t\\tthen applies to another buffer.","\\t\\tTo get the column number use |col()|.  To get both use","\\t\\t|getpos()|.","\\t\\tExamples: >","\\t\\t\\tline(\\".\\")\\t\\tline number of the cursor","\\t\\t\\tline(\\"\'t\\")\\t\\tline number of mark t","\\t\\t\\tline(\\"\'\\" . marker)\\tline number of mark marker"],"line2byte":["\\t\\tReturn the byte count from the start of the buffer for line","\\t\\t{lnum}.  This includes the end-of-line character, depending on","\\t\\tthe \'fileformat\' option for the current buffer.  The first","\\t\\tline returns 1. UTF-8 encoding is used, \'fileencoding\' is","\\t\\tignored.  This can also be used to get the byte count for the","\\t\\tline just below the last line: >","\\t\\t\\tline2byte(line(\\"$\\") + 1)","<\\t\\tThis is the buffer size plus one.  If \'fileencoding\' is empty","\\t\\tit is the file size plus one.","\\t\\tWhen {lnum} is invalid -1 is returned.","\\t\\tAlso see |byte2line()|, |go| and |:goto|."],"lispindent":["\\t\\tGet the amount of indent for line {lnum} according the lisp","\\t\\tindenting rules, as with \'lisp\'.","\\t\\tThe indent is counted in spaces, the value of \'tabstop\' is","\\t\\trelevant.  {lnum} is used just like in |getline()|.","\\t\\tWhen {lnum} is invalid or Vim was not compiled the","\\t\\t|+lispindent| feature, -1 is returned."],"list2str":["\\t\\tConvert each number in {list} to a character string can","\\t\\tconcatenate them all.  Examples: >","\\t\\t\\tlist2str([32])\\t\\treturns \\" \\"","\\t\\t\\tlist2str([65, 66, 67])\\treturns \\"ABC\\"","<\\t\\tThe same can be done (slowly) with: >","\\t\\t\\tjoin(map(list, {nr, val -> nr2char(val)}), \'\')","<\\t\\t|str2list()| does the opposite.","","\\t\\tWhen {utf8} is omitted or zero, the current \'encoding\' is used.","\\t\\tWith {utf8} is 1, always return utf-8 characters.","\\t\\tWith utf-8 composing characters work as expected: >","\\t\\t\\tlist2str([97, 769])\\treturns \\"á\\""],"localtime":["\\t\\tReturn the current time, measured as seconds since 1st Jan","\\t\\t1970.  See also |strftime()| and |getftime()|.",""],"log":["\\t\\tReturn the natural logarithm (base e) of {expr} as a |Float|.","\\t\\t{expr} must evaluate to a |Float| or a |Number| in the range","\\t\\t(0, inf].","\\t\\tExamples: >","\\t\\t\\t:echo log(10)","<\\t\\t\\t2.302585 >","\\t\\t\\t:echo log(exp(5))","<\\t\\t\\t5.0",""],"log10":["\\t\\tReturn the logarithm of Float {expr} to base 10 as a |Float|.","\\t\\t{expr} must evaluate to a |Float| or a |Number|.","\\t\\tExamples: >","\\t\\t\\t:echo log10(1000)","<\\t\\t\\t3.0 >","\\t\\t\\t:echo log10(0.01)","<\\t\\t\\t-2.0"],"luaeval":["\\t\\tEvaluate Lua expression {expr} and return its result converted","\\t\\tto Vim data structures. See |lua-eval| for more details."],"map":["\\t\\t{expr1} must be a |List| or a |Dictionary|.","\\t\\tReplace each item in {expr1} with the result of evaluating","\\t\\t{expr2}. {expr2} must be a |string| or |Funcref|.","\\t\\t","\\t\\tIf {expr2} is a |string|, inside {expr2} |v:val| has the value","\\t\\tof the current item. For a |Dictionary| |v:key| has the key","\\t\\tof the current item and for a |List| |v:key| has the index of","\\t\\tthe current item.","\\t\\tExample: >","\\t\\t\\t:call map(mylist, \'\\"> \\" . v:val . \\" <\\"\')","<\\t\\tThis puts \\"> \\" before and \\" <\\" after each item in \\"mylist\\".","","\\t\\tNote that {expr2} is the result of an expression and is then","\\t\\tused as an expression again.  Often it is good to use a","\\t\\t|literal-string| to avoid having to double backslashes.  You","\\t\\tstill have to double \' quotes","","\\t\\tIf {expr2} is a |Funcref| it is called with two arguments:","\\t\\t\\t1. The key or the index of the current item.","\\t\\t\\t2. the value of the current item.","\\t\\tThe function must return the new value of the item. Example","\\t\\tthat changes each value by \\"key-value\\": >","\\t\\t\\tfunc KeyValue(key, val)","\\t\\t\\t  return a:key . \'-\' . a:val","\\t\\t\\tendfunc","\\t\\t\\tcall map(myDict, function(\'KeyValue\'))","<\\t\\tIt is shorter when using a |lambda|: >","\\t\\t\\tcall map(myDict, {key, val -> key . \'-\' . val})","<\\t\\tIf you do not use \\"val\\" you can leave it out: >","\\t\\t\\tcall map(myDict, {key -> \'item: \' . key})","<\\t\\tIf you do not use \\"key\\" you can use a short name: >","\\t\\t\\tcall map(myDict, {_, val -> \'item: \' . val})","<","\\t\\tThe operation is done in-place.  If you want a |List| or","\\t\\t|Dictionary| to remain unmodified make a copy first: >","\\t\\t\\t:let tlist = map(copy(mylist), \' v:val . \\"\\\\t\\"\')","","<\\t\\tReturns {expr1}, the |List| or |Dictionary| that was filtered.","\\t\\tWhen an error is encountered while evaluating {expr2} no","\\t\\tfurther items in {expr1} are processed. When {expr2} is a","\\t\\tFuncref errors inside a function are ignored, unless it was","\\t\\tdefined with the \\"abort\\" flag.",""],"maparg":["\\t\\tWhen {dict} is omitted or zero: Return the rhs of mapping","\\t\\t{name} in mode {mode}.  The returned String has special","\\t\\tcharacters translated like in the output of the \\":map\\" command","\\t\\tlisting.","","\\t\\tWhen there is no mapping for {name}, an empty String is","\\t\\treturned.  When the mapping for {name} is empty, then \\"<Nop>\\"","\\t\\tis returned.","","\\t\\tThe {name} can have special key names, like in the \\":map\\"","\\t\\tcommand.","","\\t\\t{mode} can be one of these strings:","\\t\\t\\t\\"n\\"\\tNormal","\\t\\t\\t\\"v\\"\\tVisual (including Select)","\\t\\t\\t\\"o\\"\\tOperator-pending","\\t\\t\\t\\"i\\"\\tInsert","\\t\\t\\t\\"c\\"\\tCmd-line","\\t\\t\\t\\"s\\"\\tSelect","\\t\\t\\t\\"x\\"\\tVisual","\\t\\t\\t\\"l\\"\\tlangmap |language-mapping|","\\t\\t\\t\\"t\\"\\tTerminal","\\t\\t\\t\\"\\"\\tNormal, Visual and Operator-pending","\\t\\tWhen {mode} is omitted, the modes for \\"\\" are used.","","\\t\\tWhen {abbr} is there and it is |TRUE| use abbreviations","\\t\\tinstead of mappings.","","\\t\\tWhen {dict} is there and it is |TRUE| return a dictionary","\\t\\tcontaining all the information of the mapping with the","\\t\\tfollowing items:","\\t\\t  \\"lhs\\"\\t     The {lhs} of the mapping.","\\t\\t  \\"rhs\\"\\t     The {rhs} of the mapping as typed.","\\t\\t  \\"silent\\"   1 for a |:map-silent| mapping, else 0.","\\t\\t  \\"noremap\\"  1 if the {rhs} of the mapping is not remappable.","\\t\\t  \\"expr\\"     1 for an expression mapping (|:map-<expr>|).","\\t\\t  \\"buffer\\"   1 for a buffer local mapping (|:map-local|).","\\t\\t  \\"mode\\"     Modes for which the mapping is defined. In","\\t\\t\\t     addition to the modes mentioned above, these","\\t\\t\\t     characters will be used:","\\t\\t\\t     \\" \\"     Normal, Visual and Operator-pending","\\t\\t\\t     \\"!\\"     Insert and Commandline mode","\\t\\t\\t\\t     (|mapmode-ic|)","\\t\\t  \\"sid\\"\\t     The script local ID, used for <sid> mappings","\\t\\t\\t     (|<SID>|).","\\t\\t  \\"lnum\\"     The line number in \\"sid\\", zero if unknown.","\\t\\t  \\"nowait\\"   Do not wait for other, longer mappings.","\\t\\t\\t     (|:map-<nowait>|).","","\\t\\tThe mappings local to the current buffer are checked first,","\\t\\tthen the global mappings.","\\t\\tThis function can be used to map a key even when it\'s already","\\t\\tmapped, and have it do the original mapping too.  Sketch: >","\\t\\t\\texe \'nnoremap <Tab> ==\' . maparg(\'<Tab>\', \'n\')",""],"mapcheck":["\\t\\tCheck if there is a mapping that matches with {name} in mode","\\t\\t{mode}.  See |maparg()| for {mode} and special names in","\\t\\t{name}.","\\t\\tWhen {abbr} is there and it is non-zero use abbreviations","\\t\\tinstead of mappings.","\\t\\tA match happens with a mapping that starts with {name} and","\\t\\twith a mapping which is equal to the start of {name}.","","\\t\\t\\tmatches mapping \\"a\\"\\t\\"ab\\"\\t\\"abc\\" ~","\\t\\t   mapcheck(\\"a\\")\\tyes\\tyes\\t yes","\\t\\t   mapcheck(\\"abc\\")\\tyes\\tyes\\t yes","\\t\\t   mapcheck(\\"ax\\")\\tyes\\tno\\t no","\\t\\t   mapcheck(\\"b\\")\\tno\\tno\\t no","","\\t\\tThe difference with maparg() is that mapcheck() finds a","\\t\\tmapping that matches with {name}, while maparg() only finds a","\\t\\tmapping for {name} exactly.","\\t\\tWhen there is no mapping that starts with {name}, an empty","\\t\\tString is returned.  If there is one, the RHS of that mapping","\\t\\tis returned.  If there are several mappings that start with","\\t\\t{name}, the RHS of one of them is returned.  This will be","\\t\\t\\"<Nop>\\" if the RHS is empty.","\\t\\tThe mappings local to the current buffer are checked first,","\\t\\tthen the global mappings.","\\t\\tThis function can be used to check if a mapping can be added","\\t\\twithout being ambiguous.  Example: >","\\t:if mapcheck(\\"_vv\\") == \\"\\"","\\t:   map _vv :set guifont=7x13<CR>","\\t:endif","<\\t\\tThis avoids adding the \\"_vv\\" mapping when there already is a","\\t\\tmapping for \\"_v\\" or for \\"_vvv\\"."],"match":["\\t\\tWhen {expr} is a |List| then this returns the index of the","\\t\\tfirst item where {pat} matches.  Each item is used as a","\\t\\tString, |Lists| and |Dictionaries| are used as echoed.","","\\t\\tOtherwise, {expr} is used as a String.  The result is a","\\t\\tNumber, which gives the index (byte offset) in {expr} where","\\t\\t{pat} matches.","","\\t\\tA match at the first character or |List| item returns zero.","\\t\\tIf there is no match -1 is returned.","","\\t\\tFor getting submatches see |matchlist()|.","\\t\\tExample: >","\\t\\t\\t:echo match(\\"testing\\", \\"ing\\")\\t\\" results in 4","\\t\\t\\t:echo match([1, \'x\'], \'\\\\a\')\\t\\" results in 1","<\\t\\tSee |string-match| for how {pat} is used.","\\t\\t\\t\\t\\t\\t\\t\\t*strpbrk()*","\\t\\tVim doesn\'t have a strpbrk() function.  But you can do: >","\\t\\t\\t:let sepidx = match(line, \'[.,;: \\\\t]\')","<\\t\\t\\t\\t\\t\\t\\t\\t*strcasestr()*","\\t\\tVim doesn\'t have a strcasestr() function.  But you can add","\\t\\t\\"\\\\c\\" to the pattern to ignore case: >","\\t\\t\\t:let idx = match(haystack, \'\\\\cneedle\')","<","\\t\\tIf {start} is given, the search starts from byte index","\\t\\t{start} in a String or item {start} in a |List|.","\\t\\tThe result, however, is still the index counted from the","\\t\\tfirst character/item.  Example: >","\\t\\t\\t:echo match(\\"testing\\", \\"ing\\", 2)","<\\t\\tresult is again \\"4\\". >","\\t\\t\\t:echo match(\\"testing\\", \\"ing\\", 4)","<\\t\\tresult is again \\"4\\". >","\\t\\t\\t:echo match(\\"testing\\", \\"t\\", 2)","<\\t\\tresult is \\"3\\".","\\t\\tFor a String, if {start} > 0 then it is like the string starts","\\t\\t{start} bytes later, thus \\"^\\" will match at {start}.  Except","\\t\\twhen {count} is given, then it\'s like matches before the","\\t\\t{start} byte are ignored (this is a bit complicated to keep it","\\t\\tbackwards compatible).","\\t\\tFor a String, if {start} < 0, it will be set to 0.  For a list","\\t\\tthe index is counted from the end.","\\t\\tIf {start} is out of range ({start} > strlen({expr}) for a","\\t\\tString or {start} > len({expr}) for a |List|) -1 is returned.","","\\t\\tWhen {count} is given use the {count}\'th match.  When a match","\\t\\tis found in a String the search for the next one starts one","\\t\\tcharacter further.  Thus this example results in 1: >","\\t\\t\\techo match(\\"testing\\", \\"..\\", 0, 2)","<\\t\\tIn a |List| the search continues in the next item.","\\t\\tNote that when {count} is added the way {start} works changes,","\\t\\tsee above.","","\\t\\tSee |pattern| for the patterns that are accepted.","\\t\\tThe \'ignorecase\' option is used to set the ignore-caseness of","\\t\\tthe pattern.  \'smartcase\' is NOT used.  The matching is always","\\t\\tdone like \'magic\' is set and \'cpoptions\' is empty.",""],"matchadd":["\\t\\tDefines a pattern to be highlighted in the current window (a","\\t\\t\\"match\\").  It will be highlighted with {group}.  Returns an","\\t\\tidentification number (ID), which can be used to delete the","\\t\\tmatch using |matchdelete()|.","\\t\\tMatching is case sensitive and magic, unless case sensitivity","\\t\\tor magicness are explicitly overridden in {pattern}.  The","\\t\\t\'magic\', \'smartcase\' and \'ignorecase\' options are not used.","\\t\\tThe \\"Conceal\\" value is special, it causes the match to be","\\t\\tconcealed.","","\\t\\tThe optional {priority} argument assigns a priority to the","\\t\\tmatch.  A match with a high priority will have its","\\t\\thighlighting overrule that of a match with a lower priority.","\\t\\tA priority is specified as an integer (negative numbers are no","\\t\\texception).  If the {priority} argument is not specified, the","\\t\\tdefault priority is 10.  The priority of \'hlsearch\' is zero,","\\t\\thence all matches with a priority greater than zero will","\\t\\toverrule it.  Syntax highlighting (see \'syntax\') is a separate","\\t\\tmechanism, and regardless of the chosen priority a match will","\\t\\talways overrule syntax highlighting.","","\\t\\tThe optional {id} argument allows the request for a specific","\\t\\tmatch ID.  If a specified ID is already taken, an error","\\t\\tmessage will appear and the match will not be added.  An ID","\\t\\tis specified as a positive integer (zero excluded).  IDs 1, 2","\\t\\tand 3 are reserved for |:match|, |:2match| and |:3match|,","\\t\\trespectively.  If the {id} argument is not specified or -1,","\\t\\t|matchadd()| automatically chooses a free ID.","","\\t\\tThe optional {dict} argument allows for further custom","\\t\\tvalues. Currently this is used to specify a match specific","\\t\\tconceal character that will be shown for |hl-Conceal|","\\t\\thighlighted matches. The dict can have the following members:","","\\t\\t\\tconceal\\t    Special character to show instead of the","\\t\\t\\t\\t    match (only for |hl-Conceal| highlighed","\\t\\t\\t\\t    matches, see |:syn-cchar|)","\\t\\t\\twindow\\t    Instead of the current window use the","\\t\\t\\t\\t    window with this number or window ID.","","\\t\\tThe number of matches is not limited, as it is the case with","\\t\\tthe |:match| commands.","","\\t\\tExample: >","\\t\\t\\t:highlight MyGroup ctermbg=green guibg=green","\\t\\t\\t:let m = matchadd(\\"MyGroup\\", \\"TODO\\")","<\\t\\tDeletion of the pattern: >","\\t\\t\\t:call matchdelete(m)","","<\\t\\tA list of matches defined by |matchadd()| and |:match| are","\\t\\tavailable from |getmatches()|.  All matches can be deleted in","\\t\\tone operation by |clearmatches()|.",""],"matchaddpos":["\\t\\tSame as |matchadd()|, but requires a list of positions {pos}","\\t\\tinstead of a pattern. This command is faster than |matchadd()|","\\t\\tbecause it does not require to handle regular expressions and","\\t\\tsets buffer line boundaries to redraw screen. It is supposed","\\t\\tto be used when fast match additions and deletions are","\\t\\trequired, for example to highlight matching parentheses.","\\t\\t\\t\\t\\t\\t\\t*E5030* *E5031*","\\t\\tThe list {pos} can contain one of these items:","\\t\\t- A number.  This whole line will be highlighted.  The first","\\t\\t  line has number 1.","\\t\\t- A list with one number, e.g., [23]. The whole line with this","\\t\\t  number will be highlighted.","\\t\\t- A list with two numbers, e.g., [23, 11]. The first number is","\\t\\t  the line number, the second one is the column number (first","\\t\\t  column is 1, the value must correspond to the byte index as","\\t\\t  |col()| would return).  The character at this position will","\\t\\t  be highlighted.","\\t\\t- A list with three numbers, e.g., [23, 11, 3]. As above, but","\\t\\t  the third number gives the length of the highlight in bytes.","","\\t\\tEntries with zero and negative line numbers are silently ","\\t\\tignored, as well as entries with negative column numbers and ","\\t\\tlengths.","","\\t\\tThe maximum number of positions is 8.","","\\t\\tExample: >","\\t\\t\\t:highlight MyGroup ctermbg=green guibg=green","\\t\\t\\t:let m = matchaddpos(\\"MyGroup\\", [[23, 24], 34])","<\\t\\tDeletion of the pattern: >","\\t\\t\\t:call matchdelete(m)","","<\\t\\tMatches added by |matchaddpos()| are returned by","\\t\\t|getmatches()| with an entry \\"pos1\\", \\"pos2\\", etc., with the","\\t\\tvalue a list like the {pos} item."],"matcharg":["\\t\\tSelects the {nr} match item, as set with a |:match|,","\\t\\t|:2match| or |:3match| command.","\\t\\tReturn a |List| with two elements:","\\t\\t\\tThe name of the highlight group used","\\t\\t\\tThe pattern used.","\\t\\tWhen {nr} is not 1, 2 or 3 returns an empty |List|.","\\t\\tWhen there is no match item set returns [\'\', \'\'].","\\t\\tThis is useful to save and restore a |:match|.","\\t\\tHighlighting matches using the |:match| commands are limited","\\t\\tto three matches. |matchadd()| does not have this limitation."],"matchdelete":["\\t\\tDeletes a match with ID {id} previously defined by |matchadd()|","\\t\\tor one of the |:match| commands.  Returns 0 if successful,","\\t\\totherwise -1.  See example for |matchadd()|.  All matches can","\\t\\tbe deleted in one operation by |clearmatches()|."],"matchend":["\\t\\tSame as |match()|, but return the index of first character","\\t\\tafter the match.  Example: >","\\t\\t\\t:echo matchend(\\"testing\\", \\"ing\\")","<\\t\\tresults in \\"7\\".","\\t\\t\\t\\t\\t\\t\\t*strspn()* *strcspn()*","\\t\\tVim doesn\'t have a strspn() or strcspn() function, but you can","\\t\\tdo it with matchend(): >","\\t\\t\\t:let span = matchend(line, \'[a-zA-Z]\')","\\t\\t\\t:let span = matchend(line, \'[^a-zA-Z]\')","<\\t\\tExcept that -1 is returned when there are no matches.","","\\t\\tThe {start}, if given, has the same meaning as for |match()|. >","\\t\\t\\t:echo matchend(\\"testing\\", \\"ing\\", 2)","<\\t\\tresults in \\"7\\". >","\\t\\t\\t:echo matchend(\\"testing\\", \\"ing\\", 5)","<\\t\\tresult is \\"-1\\".","\\t\\tWhen {expr} is a |List| the result is equal to |match()|."],"matchlist":["\\t\\tSame as |match()|, but return a |List|.  The first item in the","\\t\\tlist is the matched string, same as what matchstr() would","\\t\\treturn.  Following items are submatches, like \\"\\\\1\\", \\"\\\\2\\", etc.","\\t\\tin |:substitute|.  When an optional submatch didn\'t match an","\\t\\tempty string is used.  Example: >","\\t\\t\\techo matchlist(\'acd\', \'\\\\(a\\\\)\\\\?\\\\(b\\\\)\\\\?\\\\(c\\\\)\\\\?\\\\(.*\\\\)\')","<\\t\\tResults in: [\'acd\', \'a\', \'\', \'c\', \'d\', \'\', \'\', \'\', \'\', \'\']","\\t\\tWhen there is no match an empty list is returned."],"matchstr":["\\t\\tSame as |match()|, but return the matched string.  Example: >","\\t\\t\\t:echo matchstr(\\"testing\\", \\"ing\\")","<\\t\\tresults in \\"ing\\".","\\t\\tWhen there is no match \\"\\" is returned.","\\t\\tThe {start}, if given, has the same meaning as for |match()|. >","\\t\\t\\t:echo matchstr(\\"testing\\", \\"ing\\", 2)","<\\t\\tresults in \\"ing\\". >","\\t\\t\\t:echo matchstr(\\"testing\\", \\"ing\\", 5)","<\\t\\tresult is \\"\\".","\\t\\tWhen {expr} is a |List| then the matching item is returned.","\\t\\tThe type isn\'t changed, it\'s not necessarily a String."],"matchstrpos":["\\t\\tSame as |matchstr()|, but return the matched string, the start","\\t\\tposition and the end position of the match.  Example: >","\\t\\t\\t:echo matchstrpos(\\"testing\\", \\"ing\\")","<\\t\\tresults in [\\"ing\\", 4, 7].","\\t\\tWhen there is no match [\\"\\", -1, -1] is returned.","\\t\\tThe {start}, if given, has the same meaning as for |match()|. >","\\t\\t\\t:echo matchstrpos(\\"testing\\", \\"ing\\", 2)","<\\t\\tresults in [\\"ing\\", 4, 7]. >","\\t\\t\\t:echo matchstrpos(\\"testing\\", \\"ing\\", 5)","<\\t\\tresult is [\\"\\", -1, -1].","\\t\\tWhen {expr} is a |List| then the matching item, the index","\\t\\tof first item where {pat} matches, the start position and the","\\t\\tend position of the match are returned. >","\\t\\t\\t:echo matchstrpos([1, \'__x\'], \'\\\\a\')","<\\t\\tresult is [\\"x\\", 1, 2, 3].","\\t\\tThe type isn\'t changed, it\'s not necessarily a String.",""],"max":["\\t\\t{expr} can be a list or a dictionary.  For a dictionary,","\\t\\tit returns the maximum of all values in the dictionary.","\\t\\tIf {expr} is neither a list nor a dictionary, or one of the","\\t\\titems in {expr} cannot be used as a Number this results in","                an error.  An empty |List| or |Dictionary| results in zero."],"menu_get":["\\t\\tReturns a |List| of |Dictionaries| describing |menus| (defined","\\t\\tby |:menu|, |:amenu|, …), including |hidden-menus|.","","\\t\\t{path} matches a menu by name, or all menus if {path} is an","\\t\\tempty string.  Example: >","\\t\\t\\t:echo menu_get(\'File\',\'\')","\\t\\t\\t:echo menu_get(\'\')","<","\\t\\t{modes} is a string of zero or more modes (see |maparg()| or","\\t\\t|creating-menus| for the list of modes). \\"a\\" means \\"all\\".","","\\t\\tExample: >","\\t\\t\\tnnoremenu &Test.Test inormal","\\t\\t\\tinoremenu Test.Test insert","\\t\\t\\tvnoremenu Test.Test x","\\t\\t\\techo menu_get(\\"\\")","","<\\t\\treturns something like this: >","","\\t\\t\\t[ {","\\t\\t\\t  \\"hidden\\": 0,","\\t\\t\\t  \\"name\\": \\"Test\\",","\\t\\t\\t  \\"priority\\": 500,","\\t\\t\\t  \\"shortcut\\": 84,","\\t\\t\\t  \\"submenus\\": [ {","\\t\\t\\t    \\"hidden\\": 0,","\\t\\t\\t    \\"mappings\\": {","\\t\\t\\t      i\\": {","\\t\\t\\t\\t\\"enabled\\": 1,","\\t\\t\\t\\t\\"noremap\\": 1,","\\t\\t\\t\\t\\"rhs\\": \\"insert\\",","\\t\\t\\t\\t\\"sid\\": 1,","\\t\\t\\t\\t\\"silent\\": 0","\\t\\t\\t      },","\\t\\t\\t      n\\": { ... },","\\t\\t\\t      s\\": { ... },","\\t\\t\\t      v\\": { ... }","\\t\\t\\t    },","\\t\\t\\t    \\"name\\": \\"Test\\",","\\t\\t\\t    \\"priority\\": 500,","\\t\\t\\t    \\"shortcut\\": 0","\\t\\t\\t  } ]","\\t\\t\\t} ]","<",""],"min":["\\t\\t{expr} can be a list or a dictionary.  For a dictionary,","\\t\\tit returns the minimum of all values in the dictionary.","\\t\\tIf {expr} is neither a list nor a dictionary, or one of the","\\t\\titems in {expr} cannot be used as a Number this results in","\\t\\tan error.  An empty |List| or |Dictionary| results in zero.",""],"mkdir":["\\t\\tCreate directory {name}.","\\t\\tIf {path} is \\"p\\" then intermediate directories are created as","\\t\\tnecessary.  Otherwise it must be \\"\\".","\\t\\tIf {prot} is given it is used to set the protection bits of","\\t\\tthe new directory.  The default is 0755 (rwxr-xr-x: r/w for","\\t\\tthe user readable for others).  Use 0700 to make it unreadable","\\t\\tfor others.","","\\t\\t{prot} is applied for all parts of {name}.  Thus if you create","\\t\\t/tmp/foo/bar then /tmp/foo will be created with 0700. Example: >","\\t\\t\\t:call mkdir($HOME . \\"/tmp/foo/bar\\", \\"p\\", 0700)","<\\t\\tThis function is not available in the |sandbox|.","","\\t\\tIf you try to create an existing directory with {path} set to","\\t\\t\\"p\\" mkdir() will silently exit.",""],"mode":["\\t\\tIf [expr] is supplied and it evaluates to a non-zero Number or","\\t\\ta non-empty String (|non-zero-arg|), then the full mode is","\\t\\treturned, otherwise only the first letter is returned.","","\\t\\t   n\\t    Normal","\\t\\t   no\\t    Operator-pending","\\t\\t   nov\\t    Operator-pending (forced charwise |o_v|)","\\t\\t   noV\\t    Operator-pending (forced linewise |o_V|)","\\t\\t   noCTRL-V Operator-pending (forced blockwise |o_CTRL-V|)","\\t\\t   niI\\t    Normal using |i_CTRL-O| in |Insert-mode|","\\t\\t   niR\\t    Normal using |i_CTRL-O| in |Replace-mode|","\\t\\t   niV\\t    Normal using |i_CTRL-O| in |Virtual-Replace-mode|","\\t\\t   v\\t    Visual by character","\\t\\t   V\\t    Visual by line","\\t\\t   CTRL-V   Visual blockwise","\\t\\t   s\\t    Select by character","\\t\\t   S\\t    Select by line","\\t\\t   CTRL-S   Select blockwise","\\t\\t   i\\t    Insert","\\t\\t   ic\\t    Insert mode completion |compl-generic|","\\t\\t   ix\\t    Insert mode |i_CTRL-X| completion","\\t\\t   R\\t    Replace |R|","\\t\\t   Rc\\t    Replace mode completion |compl-generic|","\\t\\t   Rv\\t    Virtual Replace |gR|","\\t\\t   Rx\\t    Replace mode |i_CTRL-X| completion","\\t\\t   c\\t    Command-line editing","\\t\\t   cv\\t    Vim Ex mode |gQ|","\\t\\t   ce\\t    Normal Ex mode |Q|","\\t\\t   r\\t    Hit-enter prompt","\\t\\t   rm\\t    The -- more -- prompt","\\t\\t   r?\\t    |:confirm| query of some sort","\\t\\t   !\\t    Shell or external command is executing","\\t\\t   t\\t    Terminal mode: keys go to the job","\\t\\tThis is useful in the \'statusline\' option or when used","\\t\\twith |remote_expr()| In most other places it always returns","\\t\\t\\"c\\" or \\"n\\".","\\t\\tNote that in the future more modes and more specific modes may","\\t\\tbe added. It\'s better not to compare the whole string but only","\\t\\tthe leading character(s).","\\t\\tAlso see |visualmode()|."],"msgpackdump":["\\t\\tConvert a list of VimL objects to msgpack. Returned value is","\\t\\t|readfile()|-style list. Example: >","\\t\\t\\tcall writefile(msgpackdump([{}]), \'fname.mpack\', \'b\')","<\\t\\tThis will write the single 0x80 byte to `fname.mpack` file","\\t\\t(dictionary with zero items is represented by 0x80 byte in","\\t\\tmessagepack).","","\\t\\tLimitations:\\t\\t\\t\\t*E5004* *E5005*","\\t\\t1. |Funcref|s cannot be dumped.","\\t\\t2. Containers that reference themselves cannot be dumped.","\\t\\t3. Dictionary keys are always dumped as STR strings.","\\t\\t4. Other strings are always dumped as BIN strings.","\\t\\t5. Points 3. and 4. do not apply to |msgpack-special-dict|s."],"msgpackparse":["\\t\\tConvert a |readfile()|-style list to a list of VimL objects.","\\t\\tExample: >","\\t\\t\\tlet fname = expand(\'~/.config/nvim/shada/main.shada\')","\\t\\t\\tlet mpack = readfile(fname, \'b\')","\\t\\t\\tlet shada_objects = msgpackparse(mpack)","<\\t\\tThis will read ~/.config/nvim/shada/main.shada file to","\\t\\t`shada_objects` list.","","\\t\\tLimitations:","\\t\\t1. Mapping ordering is not preserved unless messagepack","\\t\\t   mapping is dumped using generic  mapping","\\t\\t   (|msgpack-special-map|).","\\t\\t2. Since the parser aims to preserve all data untouched","\\t\\t   (except for 1.) some strings are parsed to","\\t\\t   |msgpack-special-dict| format which is not convenient to","\\t\\t   use.","\\t\\t\\t\\t\\t\\t\\t*msgpack-special-dict*","\\t\\tSome messagepack strings may be parsed to special","\\t\\tdictionaries. Special dictionaries are dictionaries which","","\\t\\t1. Contain exactly two keys: `_TYPE` and `_VAL`.","\\t\\t2. `_TYPE` key is one of the types found in |v:msgpack_types|","\\t\\t   variable.","\\t\\t3. Value for `_VAL` has the following format (Key column","\\t\\t   contains name of the key from |v:msgpack_types|):","","\\t\\tKey\\tValue ~","\\t\\tnil\\tZero, ignored when dumping.  Not returned by","\\t\\t\\t|msgpackparse()| since |v:null| was introduced.","\\t\\tboolean\\tOne or zero.  When dumping it is only checked that","\\t\\t\\tvalue is a |Number|.  Not returned by |msgpackparse()|","\\t\\t\\tsince |v:true| and |v:false| were introduced.","\\t\\tinteger\\t|List| with four numbers: sign (-1 or 1), highest two","\\t\\t\\tbits, number with bits from 62nd to 31st, lowest 31","\\t\\t\\tbits. I.e. to get actual number one will need to use","\\t\\t\\tcode like >","\\t\\t\\t\\t_VAL[0] * ((_VAL[1] << 62)","\\t\\t\\t\\t           & (_VAL[2] << 31)","\\t\\t\\t\\t           & _VAL[3])","<\\t\\t\\tSpecial dictionary with this type will appear in","\\t\\t\\t|msgpackparse()| output under one of the following","\\t\\t\\tcircumstances:","\\t\\t\\t1. |Number| is 32-bit and value is either above","\\t\\t\\t   INT32_MAX or below INT32_MIN.","\\t\\t\\t2. |Number| is 64-bit and value is above INT64_MAX. It","\\t\\t\\t   cannot possibly be below INT64_MIN because msgpack","\\t\\t\\t   C parser does not support such values.","\\t\\tfloat\\t|Float|. This value cannot possibly appear in","\\t\\t\\t|msgpackparse()| output.","\\t\\tstring\\t|readfile()|-style list of strings. This value will","\\t\\t\\tappear in |msgpackparse()| output if string contains","\\t\\t\\tzero byte or if string is a mapping key and mapping is","\\t\\t\\tbeing represented as special dictionary for other","\\t\\t\\treasons.","\\t\\tbinary\\t|readfile()|-style list of strings. This value will","\\t\\t\\tappear in |msgpackparse()| output if binary string","\\t\\t\\tcontains zero byte.","\\t\\tarray\\t|List|. This value cannot appear in |msgpackparse()|","\\t\\t\\toutput.","\\t\\t\\t\\t\\t\\t\\t*msgpack-special-map*","\\t\\tmap\\t|List| of |List|s with two items (key and value) each.","\\t\\t\\tThis value will appear in |msgpackparse()| output if","\\t\\t\\tparsed mapping contains one of the following keys:","\\t\\t\\t1. Any key that is not a string (including keys which","\\t\\t\\t   are binary strings).","\\t\\t\\t2. String with NUL byte inside.","\\t\\t\\t3. Duplicate key.","\\t\\t\\t4. Empty key.","\\t\\text\\t|List| with two values: first is a signed integer","\\t\\t\\trepresenting extension type. Second is","\\t\\t\\t|readfile()|-style list of strings."],"nextnonblank":["\\t\\tReturn the line number of the first line at or below {lnum}","\\t\\tthat is not blank.  Example: >","\\t\\t\\tif getline(nextnonblank(1)) =~ \\"Java\\"","<\\t\\tWhen {lnum} is invalid or there is no non-blank line at or","\\t\\tbelow it, zero is returned.","\\t\\tSee also |prevnonblank()|."],"nr2char":["\\t\\tReturn a string with a single character, which has the number","\\t\\tvalue {expr}.  Examples: >","\\t\\t\\tnr2char(64)\\t\\treturns \\"@\\"","\\t\\t\\tnr2char(32)\\t\\treturns \\" \\"","<\\t\\tExample for \\"utf-8\\": >","\\t\\t\\tnr2char(300)\\t\\treturns I with bow character","<\\t\\tUTF-8 encoding is always used, {utf8} option has no effect,","\\t\\tand exists only for backwards-compatibility.","\\t\\tNote that a NUL character in the file is specified with","\\t\\tnr2char(10), because NULs are represented with newline","\\t\\tcharacters.  nr2char(0) is a real NUL and terminates the","\\t\\tstring, thus results in an empty string.","","nvim_...({...})\\t\\t\\t\\t\\t*E5555* *nvim_...()* *eval-api*","\\t\\tCall nvim |api| functions. The type checking of arguments will","\\t\\tbe stricter than for most other builtins. For instance,","\\t\\tif Integer is expected, a |Number| must be passed in, a","\\t\\t|String| will not be autoconverted.","\\t\\tBuffer numbers, as returned by |bufnr()| could be used as","\\t\\tfirst argument to nvim_buf_... functions.  All functions","\\t\\texpecting an object (buffer, window or tabpage) can","\\t\\talso take the numerical value 0 to indicate the current","\\t\\t(focused) object."],"or":["\\t\\tBitwise OR on the two arguments.  The arguments are converted","\\t\\tto a number.  A List, Dict or Float argument causes an error.","\\t\\tExample: >","\\t\\t\\t:let bits = or(bits, 0x80)",""],"pathshorten":["\\t\\tShorten directory names in the path {expr} and return the","\\t\\tresult.  The tail, the file name, is kept as-is.  The other","\\t\\tcomponents in the path are reduced to single letters.  Leading","\\t\\t\'~\' and \'.\' characters are kept.  Example: >","\\t\\t\\t:echo pathshorten(\'~/.config/nvim/autoload/file1.vim\')","<\\t\\t\\t~/.c/n/a/file1.vim ~","\\t\\tIt doesn\'t matter if the path exists or not."],"pow":["\\t\\tReturn the power of {x} to the exponent {y} as a |Float|.","\\t\\t{x} and {y} must evaluate to a |Float| or a |Number|.","\\t\\tExamples: >","\\t\\t\\t:echo pow(3, 3)","<\\t\\t\\t27.0 >","\\t\\t\\t:echo pow(2, 16)","<\\t\\t\\t65536.0 >","\\t\\t\\t:echo pow(32, 0.20)","<\\t\\t\\t2.0"],"prevnonblank":["\\t\\tReturn the line number of the first line at or above {lnum}","\\t\\tthat is not blank.  Example: >","\\t\\t\\tlet ind = indent(prevnonblank(v:lnum - 1))","<\\t\\tWhen {lnum} is invalid or there is no non-blank line at or","\\t\\tabove it, zero is returned.","\\t\\tAlso see |nextnonblank()|.",""],"printf":["\\t\\tReturn a String with {fmt}, where \\"%\\" items are replaced by","\\t\\tthe formatted form of their respective arguments.  Example: >","\\t\\t\\tprintf(\\"%4d: E%d %.30s\\", lnum, errno, msg)","<\\t\\tMay result in:","\\t\\t\\t\\"  99: E42 asdfasdfasdfasdfasdfasdfasdfas\\" ~","","\\t\\tOften used items are:","\\t\\t  %s\\tstring","\\t\\t  %6S\\tstring right-aligned in 6 display cells","\\t\\t  %6s\\tstring right-aligned in 6 bytes","\\t\\t  %.9s\\tstring truncated to 9 bytes","\\t\\t  %c\\tsingle byte","\\t\\t  %d\\tdecimal number","\\t\\t  %5d\\tdecimal number padded with spaces to 5 characters","\\t\\t  %b\\tbinary number","\\t\\t  %08b\\tbinary number padded with zeros to at least 8 characters","\\t\\t  %B\\tbinary number using upper case letters","\\t\\t  %x\\thex number","\\t\\t  %04x\\thex number padded with zeros to at least 4 characters","\\t\\t  %X\\thex number using upper case letters","\\t\\t  %o\\toctal number","\\t\\t  %f\\tfloating point number as 12.23, inf, -inf or nan","\\t\\t  %F\\tfloating point number as 12.23, INF, -INF or NAN","\\t\\t  %e\\tfloating point number as 1.23e3, inf, -inf or nan","\\t\\t  %E\\tfloating point number as 1.23E3, INF, -INF or NAN","\\t\\t  %g\\tfloating point number, as %f or %e depending on value","\\t\\t  %G\\tfloating point number, as %F or %E depending on value","\\t\\t  %%\\tthe % character itself","\\t\\t  %p\\trepresentation of the pointer to the container","","\\t\\tConversion specifications start with \'%\' and end with the","\\t\\tconversion type.  All other characters are copied unchanged to","\\t\\tthe result.","","\\t\\tThe \\"%\\" starts a conversion specification.  The following","\\t\\targuments appear in sequence:","","\\t\\t\\t%  [flags]  [field-width]  [.precision]  type","","\\t\\tflags","\\t\\t\\tZero or more of the following flags:","","\\t\\t    #\\t      The value should be converted to an \\"alternate","\\t\\t\\t      form\\".  For c, d, and s conversions, this option","\\t\\t\\t      has no effect.  For o conversions, the precision","\\t\\t\\t      of the number is increased to force the first","\\t\\t\\t      character of the output string to a zero (except","\\t\\t\\t      if a zero value is printed with an explicit","\\t\\t\\t      precision of zero).","\\t\\t\\t      For x and X conversions, a non-zero result has","\\t\\t\\t      the string \\"0x\\" (or \\"0X\\" for X conversions)","\\t\\t\\t      prepended to it.","","\\t\\t    0 (zero)  Zero padding.  For all conversions the converted","\\t\\t\\t      value is padded on the left with zeros rather","\\t\\t\\t      than blanks.  If a precision is given with a","\\t\\t\\t      numeric conversion (d, o, x, and X), the 0 flag","\\t\\t\\t      is ignored.","","\\t\\t    -\\t      A negative field width flag; the converted value","\\t\\t\\t      is to be left adjusted on the field boundary.","\\t\\t\\t      The converted value is padded on the right with","\\t\\t\\t      blanks, rather than on the left with blanks or","\\t\\t\\t      zeros.  A - overrides a 0 if both are given.","","\\t\\t    \' \' (space)  A blank should be left before a positive","\\t\\t\\t      number produced by a signed conversion (d).","","\\t\\t    +\\t      A sign must always be placed before a number","\\t\\t\\t      produced by a signed conversion.  A + overrides","\\t\\t\\t      a space if both are used.","","\\t\\tfield-width","\\t\\t\\tAn optional decimal digit string specifying a minimum","\\t\\t\\tfield width.  If the converted value has fewer bytes","\\t\\t\\tthan the field width, it will be padded with spaces on","\\t\\t\\tthe left (or right, if the left-adjustment flag has","\\t\\t\\tbeen given) to fill out the field width.","","\\t\\t.precision","\\t\\t\\tAn optional precision, in the form of a period \'.\'","\\t\\t\\tfollowed by an optional digit string.  If the digit","\\t\\t\\tstring is omitted, the precision is taken as zero.","\\t\\t\\tThis gives the minimum number of digits to appear for","\\t\\t\\td, o, x, and X conversions, or the maximum number of","\\t\\t\\tbytes to be printed from a string for s conversions.","\\t\\t\\tFor floating point it is the number of digits after","\\t\\t\\tthe decimal point.","","\\t\\ttype","\\t\\t\\tA character that specifies the type of conversion to","\\t\\t\\tbe applied, see below.","","\\t\\tA field width or precision, or both, may be indicated by an","\\t\\tasterisk \'*\' instead of a digit string.  In this case, a","\\t\\tNumber argument supplies the field width or precision.  A","\\t\\tnegative field width is treated as a left adjustment flag","\\t\\tfollowed by a positive field width; a negative precision is","\\t\\ttreated as though it were missing.  Example: >","\\t\\t\\t:echo printf(\\"%d: %.*s\\", nr, width, line)","<\\t\\tThis limits the length of the text used from \\"line\\" to","\\t\\t\\"width\\" bytes.","","\\t\\tThe conversion specifiers and their meanings are:","","\\t\\t\\t\\t*printf-d* *printf-b* *printf-B* *printf-o* *printf-x* *printf-X*","\\t\\tdbBoxX\\tThe Number argument is converted to signed decimal (d),","\\t\\t\\tunsigned binary (b and B), unsigned octal (o), or","\\t\\t\\tunsigned hexadecimal (x and X) notation.  The letters","\\t\\t\\t\\"abcdef\\" are used for x conversions; the letters","\\t\\t\\t\\"ABCDEF\\" are used for X conversions.  The precision, if","\\t\\t\\tany, gives the minimum number of digits that must","\\t\\t\\tappear; if the converted value requires fewer digits, it","\\t\\t\\tis padded on the left with zeros.  In no case does a","\\t\\t\\tnon-existent or small field width cause truncation of a","\\t\\t\\tnumeric field; if the result of a conversion is wider","\\t\\t\\tthan the field width, the field is expanded to contain","\\t\\t\\tthe conversion result.","\\t\\t\\tThe \'h\' modifier indicates the argument is 16 bits.","\\t\\t\\tThe \'l\' modifier indicates the argument is 32 bits.","\\t\\t\\tThe \'L\' modifier indicates the argument is 64 bits.","\\t\\t\\tGenerally, these modifiers are not useful. They are","\\t\\t\\tignored when type is known from the argument.","","\\t\\ti\\talias for d","\\t\\tD\\talias for ld","\\t\\tU\\talias for lu","\\t\\tO\\talias for lo","","\\t\\t\\t\\t\\t\\t\\t*printf-c*","\\t\\tc\\tThe Number argument is converted to a byte, and the","\\t\\t\\tresulting character is written.","","\\t\\t\\t\\t\\t\\t\\t*printf-s*","\\t\\ts\\tThe text of the String argument is used.  If a","\\t\\t\\tprecision is specified, no more bytes than the number","\\t\\t\\tspecified are used.","\\t\\t\\tIf the argument is not a String type, it is","\\t\\t\\tautomatically converted to text with the same format","\\t\\t\\tas \\":echo\\".","\\t\\t\\t\\t\\t\\t\\t*printf-S*","\\t\\tS\\tThe text of the String argument is used.  If a","\\t\\t\\tprecision is specified, no more display cells than the","\\t\\t\\tnumber specified are used.","","\\t\\t\\t\\t\\t\\t\\t*printf-f* *E807*","\\t\\tf F\\tThe Float argument is converted into a string of the","\\t\\t\\tform 123.456.  The precision specifies the number of","\\t\\t\\tdigits after the decimal point.  When the precision is","\\t\\t\\tzero the decimal point is omitted.  When the precision","\\t\\t\\tis not specified 6 is used.  A really big number","\\t\\t\\t(out of range or dividing by zero) results in \\"inf\\"","\\t\\t\\t or \\"-inf\\" with %f (INF or -INF with %F).","\\t\\t\\t \\"0.0 / 0.0\\" results in \\"nan\\" with %f (NAN with %F).","\\t\\t\\tExample: >","\\t\\t\\t\\techo printf(\\"%.2f\\", 12.115)","<\\t\\t\\t\\t12.12","\\t\\t\\tNote that roundoff depends on the system libraries.","\\t\\t\\tUse |round()| when in doubt.","","\\t\\t\\t\\t\\t\\t\\t*printf-e* *printf-E*","\\t\\te E\\tThe Float argument is converted into a string of the","\\t\\t\\tform 1.234e+03 or 1.234E+03 when using \'E\'.  The","\\t\\t\\tprecision specifies the number of digits after the","\\t\\t\\tdecimal point, like with \'f\'.","","\\t\\t\\t\\t\\t\\t\\t*printf-g* *printf-G*","\\t\\tg G\\tThe Float argument is converted like with \'f\' if the","\\t\\t\\tvalue is between 0.001 (inclusive) and 10000000.0","\\t\\t\\t(exclusive).  Otherwise \'e\' is used for \'g\' and \'E\'","\\t\\t\\tfor \'G\'.  When no precision is specified superfluous","\\t\\t\\tzeroes and \'+\' signs are removed, except for the zero","\\t\\t\\timmediately after the decimal point.  Thus 10000000.0","\\t\\t\\tresults in 1.0e7.","","\\t\\t\\t\\t\\t\\t\\t*printf-%*","\\t\\t%\\tA \'%\' is written.  No argument is converted.  The","\\t\\t\\tcomplete conversion specification is \\"%%\\".","","\\t\\tWhen a Number argument is expected a String argument is also","\\t\\taccepted and automatically converted.","\\t\\tWhen a Float or String argument is expected a Number argument","\\t\\tis also accepted and automatically converted.","\\t\\tAny other argument type results in an error message.","","\\t\\t\\t\\t\\t\\t\\t*E766* *E767*","\\t\\tThe number of {exprN} arguments must exactly match the number","\\t\\tof \\"%\\" items.  If there are not sufficient or too many","\\t\\targuments an error is given.  Up to 18 arguments can be used."],"prompt_setcallback":["\\t\\tSet prompt callback for buffer {buf} to {expr}.  When {expr}","\\t\\tis an empty string the callback is removed.  This has only","\\t\\teffect if {buf} has \'buftype\' set to \\"prompt\\".","","\\t\\tThe callback is invoked when pressing Enter.  The current","\\t\\tbuffer will always be the prompt buffer.  A new line for a","\\t\\tprompt is added before invoking the callback, thus the prompt","\\t\\tfor which the callback was invoked will be in the last but one","\\t\\tline.","\\t\\tIf the callback wants to add text to the buffer, it must","\\t\\tinsert it above the last line, since that is where the current","\\t\\tprompt is.  This can also be done asynchronously.","\\t\\tThe callback is invoked with one argument, which is the text","\\t\\tthat was entered at the prompt.  This can be an empty string","\\t\\tif the user only typed Enter.","\\t\\tExample: >","\\t\\t   call prompt_setcallback(bufnr(\'\'), function(\'s:TextEntered\'))","\\t\\t   func s:TextEntered(text)","\\t\\t     if a:text == \'exit\' || a:text == \'quit\'","\\t\\t       stopinsert","\\t\\t       close","\\t\\t     else","\\t\\t       call append(line(\'$\') - 1, \'Entered: \\"\' . a:text . \'\\"\')","\\t\\t       \\" Reset \'modified\' to allow the buffer to be closed.","\\t\\t       set nomodified","\\t\\t     endif","\\t\\t   endfunc"],"prompt_setinterrupt":["\\t\\tSet a callback for buffer {buf} to {expr}.  When {expr} is an","\\t\\tempty string the callback is removed.  This has only effect if","\\t\\t{buf} has \'buftype\' set to \\"prompt\\".","","\\t\\tThis callback will be invoked when pressing CTRL-C in Insert","\\t\\tmode.  Without setting a callback Vim will exit Insert mode,","\\t\\tas in any buffer."],"prompt_setprompt":["\\t\\tSet prompt for buffer {buf} to {text}.  You most likely want","\\t\\t{text} to end in a space.","\\t\\tThe result is only visible if {buf} has \'buftype\' set to","\\t\\t\\"prompt\\".  Example: >","\\t\\t\\tcall prompt_setprompt(bufnr(\'\'), \'command: \')"],"pum_getpos":[" \\t\\tIf the popup menu (see |ins-completion-menu|) is not visible,"," \\t\\treturns an empty |Dictionary|, otherwise, returns a"," \\t\\t|Dictionary| with the following keys:"," \\t\\t\\theight\\t\\tnr of items visible"," \\t\\t\\twidth\\t\\tscreen cells"," \\t\\t\\trow\\t\\ttop screen row (0 first row)"," \\t\\t\\tcol\\t\\tleftmost screen column (0 first col)"," \\t\\t\\tsize\\t\\ttotal nr of items"," \\t\\t\\tscrollbar\\t|TRUE| if visible","","  \\t\\tThe values are the same as in |v:event| during |CompleteChanged|."],"pumvisible":["\\t\\tReturns non-zero when the popup menu is visible, zero","\\t\\totherwise.  See |ins-completion-menu|.","\\t\\tThis can be used to avoid some things that would remove the","\\t\\tpopup menu."],"py3eval":["\\t\\tEvaluate Python expression {expr} and return its result","\\t\\tconverted to Vim data structures.","\\t\\tNumbers and strings are returned as they are (strings are","\\t\\tcopied though, Unicode strings are additionally converted to","\\t\\tUTF-8).","\\t\\tLists are represented as Vim |List| type.","\\t\\tDictionaries are represented as Vim |Dictionary| type with","\\t\\tkeys converted to strings.",""],"pyeval":["\\t\\tEvaluate Python expression {expr} and return its result","\\t\\tconverted to Vim data structures.","\\t\\tNumbers and strings are returned as they are (strings are","\\t\\tcopied though).","\\t\\tLists are represented as Vim |List| type.","\\t\\tDictionaries are represented as Vim |Dictionary| type,","\\t\\tnon-string keys result in error."],"pyxeval":["\\t\\tEvaluate Python expression {expr} and return its result","\\t\\tconverted to Vim data structures.","\\t\\tUses Python 2 or 3, see |python_x| and \'pyxversion\'.","\\t\\tSee also: |pyeval()|, |py3eval()|",""],"range":["\\t\\tReturns a |List| with Numbers:","\\t\\t- If only {expr} is specified: [0, 1, ..., {expr} - 1]","\\t\\t- If {max} is specified: [{expr}, {expr} + 1, ..., {max}]","\\t\\t- If {stride} is specified: [{expr}, {expr} + {stride}, ...,","\\t\\t  {max}] (increasing {expr} with {stride} each time, not","\\t\\t  producing a value past {max}).","\\t\\tWhen the maximum is one before the start the result is an","\\t\\tempty list.  When the maximum is more than one before the","\\t\\tstart this is an error.","\\t\\tExamples: >","\\t\\t\\trange(4)\\t\\t\\" [0, 1, 2, 3]","\\t\\t\\trange(2, 4)\\t\\t\\" [2, 3, 4]","\\t\\t\\trange(2, 9, 3)\\t\\t\\" [2, 5, 8]","\\t\\t\\trange(2, -2, -1)\\t\\" [2, 1, 0, -1, -2]","\\t\\t\\trange(0)\\t\\t\\" []","\\t\\t\\trange(2, 0)\\t\\t\\" error!","<"],"readfile":["\\t\\tRead file {fname} and return a |List|, each line of the file","\\t\\tas an item.  Lines are broken at NL characters.  Macintosh","\\t\\tfiles separated with CR will result in a single long line","\\t\\t(unless a NL appears somewhere).","\\t\\tAll NUL characters are replaced with a NL character.","\\t\\tWhen {binary} contains \\"b\\" binary mode is used:","\\t\\t- When the last line ends in a NL an extra empty list item is","\\t\\t  added.","\\t\\t- No CR characters are removed.","\\t\\tOtherwise:","\\t\\t- CR characters that appear before a NL are removed.","\\t\\t- Whether the last line ends in a NL or not does not matter.","\\t\\t- Any UTF-8 byte order mark is removed from the text.","\\t\\tWhen {max} is given this specifies the maximum number of lines","\\t\\tto be read.  Useful if you only want to check the first ten","\\t\\tlines of a file: >","\\t\\t\\t:for line in readfile(fname, \'\', 10)","\\t\\t\\t:  if line =~ \'Date\' | echo line | endif","\\t\\t\\t:endfor","<\\t\\tWhen {max} is negative -{max} lines from the end of the file","\\t\\tare returned, or as many as there are.","\\t\\tWhen {max} is zero the result is an empty list.","\\t\\tNote that without {max} the whole file is read into memory.","\\t\\tAlso note that there is no recognition of encoding.  Read a","\\t\\tfile into a buffer if you need to.","\\t\\tWhen the file can\'t be opened an error message is given and","\\t\\tthe result is an empty list.","\\t\\tAlso see |writefile()|.",""],"readdir":["\\t\\tReturn a list with file and directory names in {directory}.","\\t\\tYou can also use |glob()| if you don\'t need to do complicated","\\t\\tthings, such as limiting the number of matches.","","\\t\\tWhen {expr} is omitted all entries are included.","\\t\\tWhen {expr} is given, it is evaluated to check what to do:","\\t\\t\\tIf {expr} results in -1 then no further entries will","\\t\\t\\tbe handled."],"reg_executing":["\\t\\tReturns the single letter name of the register being executed.","\\t\\tReturns an empty string when no register is being executed.","\\t\\tSee |@|."],"reg_recording":["\\t\\tReturns the single letter name of the register being recorded.","\\t\\tReturns an empty string string when not recording.  See |q|."],"reltime":["\\t\\tReturn an item that represents a time value.  The format of","\\t\\tthe item depends on the system.  It can be passed to","\\t\\t|reltimestr()| to convert it to a string or |reltimefloat()|","\\t\\tto convert to a float.","","\\t\\tWithout an argument it returns the current \\"relative time\\", an","\\t\\timplementation-defined value meaningful only when used as an","\\t\\targument to |reltime()|, |reltimestr()| and |reltimefloat()|.","","\\t\\tWith one argument it returns the time passed since the time","\\t\\tspecified in the argument.","\\t\\tWith two arguments it returns the time passed between {start}","\\t\\tand {end}.","\\t\\tThe {start} and {end} arguments must be values returned by","\\t\\treltime().","","\\t\\tNote: |localtime()| returns the current (non-relative) time."],"reltimefloat":["\\t\\tReturn a Float that represents the time value of {time}.","\\t\\tUnit of time is seconds.","\\t\\tExample:","\\t\\t\\tlet start = reltime()","\\t\\t\\tcall MyFunction()","\\t\\t\\tlet seconds = reltimefloat(reltime(start))","\\t\\tSee the note of reltimestr() about overhead."," \\t\\tAlso see |profiling|."],"reltimestr":["\\t\\tReturn a String that represents the time value of {time}.","\\t\\tThis is the number of seconds, a dot and the number of","\\t\\tmicroseconds.  Example: >","\\t\\t\\tlet start = reltime()","\\t\\t\\tcall MyFunction()","\\t\\t\\techo reltimestr(reltime(start))","<\\t\\tNote that overhead for the commands will be added to the time.","\\t\\tLeading spaces are used to make the string align nicely.  You","\\t\\tcan use split() to remove it. >","\\t\\t\\techo split(reltimestr(reltime(start)))[0]","<\\t\\tAlso see |profiling|.",""],"remote_expr":["\\t\\tSend the {string} to {server}.  The string is sent as an","\\t\\texpression and the result is returned after evaluation.","\\t\\tThe result must be a String or a |List|.  A |List| is turned","\\t\\tinto a String by joining the items with a line break in","\\t\\tbetween (not at the end), like with join(expr, \\"\\\\n\\").","\\t\\tIf {idvar} is present and not empty, it is taken as the name","\\t\\tof a variable and a {serverid} for later use with","\\t\\t|remote_read()| is stored there.","\\t\\tIf {timeout} is given the read times out after this many","\\t\\tseconds.  Otherwise a timeout of 600 seconds is used.","\\t\\tSee also |clientserver| |RemoteReply|.","\\t\\tThis function is not available in the |sandbox|.","\\t\\tNote: Any errors will cause a local error message to be issued","\\t\\tand the result will be the empty string.","","\\t\\tVariables will be evaluated in the global namespace,","\\t\\tindependent of a function currently being active.  Except","\\t\\twhen in debug mode, then local function variables and","\\t\\targuments can be evaluated.","","\\t\\tExamples: >","\\t\\t\\t:echo remote_expr(\\"gvim\\", \\"2+2\\")","\\t\\t\\t:echo remote_expr(\\"gvim1\\", \\"b:current_syntax\\")","<"],"remote_foreground":["\\t\\tMove the Vim server with the name {server} to the foreground.","\\t\\tThis works like: >","\\t\\t\\tremote_expr({server}, \\"foreground()\\")","<\\t\\tExcept that on Win32 systems the client does the work, to work","\\t\\taround the problem that the OS doesn\'t always allow the server","\\t\\tto bring itself to the foreground.","\\t\\tNote: This does not restore the window if it was minimized,","\\t\\tlike foreground() does.","\\t\\tThis function is not available in the |sandbox|.","\\t\\t{only in the Win32 GUI and the Win32 console version}",""],"remote_peek":["\\t\\tReturns a positive number if there are available strings","\\t\\tfrom {serverid}.  Copies any reply string into the variable","\\t\\t{retvar} if specified.  {retvar} must be a string with the","\\t\\tname of a variable.","\\t\\tReturns zero if none are available.","\\t\\tReturns -1 if something is wrong.","\\t\\tSee also |clientserver|.","\\t\\tThis function is not available in the |sandbox|.","\\t\\tExamples: >","\\t\\t\\t:let repl = \\"\\"","\\t\\t\\t:echo \\"PEEK: \\".remote_peek(id, \\"repl\\").\\": \\".repl"],"remote_read":["\\t\\tReturn the oldest available reply from {serverid} and consume","\\t\\tit.  Unless a {timeout} in seconds is given, it blocks until a","\\t\\treply is available.","\\t\\tSee also |clientserver|.","\\t\\tThis function is not available in the |sandbox|.","\\t\\tExample: >","\\t\\t\\t:echo remote_read(id)","<"],"remote_send":["\\t\\tSend the {string} to {server}.  The string is sent as input","\\t\\tkeys and the function returns immediately.  At the Vim server","\\t\\tthe keys are not mapped |:map|.","\\t\\tIf {idvar} is present, it is taken as the name of a variable","\\t\\tand a {serverid} for later use with remote_read() is stored","\\t\\tthere.","\\t\\tSee also |clientserver| |RemoteReply|.","\\t\\tThis function is not available in the |sandbox|.","","\\t\\tNote: Any errors will be reported in the server and may mess","\\t\\tup the display.","\\t\\tExamples: >","\\t\\t:echo remote_send(\\"gvim\\", \\":DropAndReply \\".file, \\"serverid\\").","\\t\\t \\\\ remote_read(serverid)","","\\t\\t:autocmd NONE RemoteReply *","\\t\\t \\\\ echo remote_read(expand(\\"<amatch>\\"))","\\t\\t:echo remote_send(\\"gvim\\", \\":sleep 10 | echo \\".","\\t\\t \\\\ \'server2client(expand(\\"<client>\\"), \\"HELLO\\")<CR>\')","<"],"remote_startserver":["\\t\\tBecome the server {name}.  This fails if already running as a","\\t\\tserver, when |v:servername| is not empty."],"remove":["\\t\\tWithout {end}: Remove the item at {idx} from |List| {list} and","\\t\\treturn the item.","\\t\\tWith {end}: Remove items from {idx} to {end} (inclusive) and","\\t\\treturn a List with these items.  When {idx} points to the same","\\t\\titem as {end} a list with one item is returned.  When {end}","\\t\\tpoints to an item before {idx} this is an error.","\\t\\tSee |list-index| for possible values of {idx} and {end}.","\\t\\tExample: >","\\t\\t\\t:echo \\"last item: \\" . remove(mylist, -1)","\\t\\tRemove the entry from {dict} with key {key} and return it.","\\t\\tExample: >","\\t\\t\\t:echo \\"removed \\" . remove(dict, \\"one\\")","<\\t\\tIf there is no {key} in {dict} this is an error.","","\\t\\tUse |delete()| to remove a file."],"rename":["\\t\\tRename the file by the name {from} to the name {to}.  This","\\t\\tshould also work to move files across file systems.  The","\\t\\tresult is a Number, which is 0 if the file was renamed","\\t\\tsuccessfully, and non-zero when the renaming failed.","\\t\\tNOTE: If {to} exists it is overwritten without warning.","\\t\\tThis function is not available in the |sandbox|."],"repeat":["\\t\\tRepeat {expr} {count} times and return the concatenated","\\t\\tresult.  Example: >","\\t\\t\\t:let separator = repeat(\'-\', 80)","<\\t\\tWhen {count} is zero or negative the result is empty.","\\t\\tWhen {expr} is a |List| the result is {expr} concatenated","\\t\\t{count} times.  Example: >","\\t\\t\\t:let longlist = repeat([\'a\', \'b\'], 3)","<\\t\\tResults in [\'a\', \'b\', \'a\', \'b\', \'a\', \'b\'].",""],"resolve":["\\t\\tOn MS-Windows, when {filename} is a shortcut (a .lnk file),","\\t\\treturns the path the shortcut points to in a simplified form.","\\t\\tOn Unix, repeat resolving symbolic links in all path","\\t\\tcomponents of {filename} and return the simplified result.","\\t\\tTo cope with link cycles, resolving of symbolic links is","\\t\\tstopped after 100 iterations.","\\t\\tOn other systems, return the simplified {filename}.","\\t\\tThe simplification step is done as by |simplify()|.","\\t\\tresolve() keeps a leading path component specifying the","\\t\\tcurrent directory (provided the result is still a relative","\\t\\tpath name) and also keeps a trailing path separator.",""],"reverse":["\\t\\t{list}.","\\t\\tIf you want a list to remain unmodified make a copy first: >","\\t\\t\\t:let revlist = reverse(copy(mylist))"],"round":["\\t\\tRound off {expr} to the nearest integral value and return it","\\t\\tas a |Float|.  If {expr} lies halfway between two integral","\\t\\tvalues, then use the larger one (away from zero).","\\t\\t{expr} must evaluate to a |Float| or a |Number|.","\\t\\tExamples: >","\\t\\t\\techo round(0.456)","<\\t\\t\\t0.0  >","\\t\\t\\techo round(4.5)","<\\t\\t\\t5.0 >","\\t\\t\\techo round(-4.5)","<\\t\\t\\t-5.0"],"rpcnotify":["\\t\\tSends {event} to {channel} via |RPC| and returns immediately.","\\t\\tIf {channel} is 0, the event is broadcast to all channels.","\\t\\tExample: >","\\t\\t\\t:au VimLeave call rpcnotify(0, \\"leaving\\")"],"rpcrequest":["\\t\\tSends a request to {channel} to invoke {method} via","\\t\\t|RPC| and blocks until a response is received.","\\t\\tExample: >","\\t\\t\\t:let result = rpcrequest(rpc_chan, \\"func\\", 1, 2, 3)"],"rpcstart":["\\t\\tDeprecated. Replace  >","\\t\\t\\t:let id = rpcstart(\'prog\', [\'arg1\', \'arg2\'])","<\\t\\twith >","\\t\\t\\t:let id = jobstart([\'prog\', \'arg1\', \'arg2\'], {\'rpc\': v:true})"],"screenattr":["\\t\\tLike |screenchar()|, but return the attribute.  This is a rather","\\t\\tarbitrary number that can only be used to compare to the","\\t\\tattribute at other positions."],"screenchar":["\\t\\tThe result is a Number, which is the character at position","\\t\\t[row, col] on the screen.  This works for every possible","\\t\\tscreen position, also status lines, window separators and the","\\t\\tcommand line.  The top left position is row one, column one","\\t\\tThe character excludes composing characters.  For double-byte","\\t\\tencodings it may only be the first byte.","\\t\\tThis is mainly to be used for testing.","\\t\\tReturns -1 when row or col is out of range."],"screencol":["\\t\\tThe result is a Number, which is the current screen column of","\\t\\tthe cursor. The leftmost column has number 1.","\\t\\tThis function is mainly used for testing.","","\\t\\tNote: Always returns the current screen column, thus if used","\\t\\tin a command (e.g. \\":echo screencol()\\") it will return the","\\t\\tcolumn inside the command line, which is 1 when the command is","\\t\\texecuted. To get the cursor position in the file use one of","\\t\\tthe following mappings: >","\\t\\t\\tnnoremap <expr> GG \\":echom \\".screencol().\\"\\\\n\\"","\\t\\t\\tnnoremap <silent> GG :echom screencol()<CR>","\\t\\t\\tnoremap GG <Cmd>echom screencol()<Cr>"],"screenpos":["\\t\\tThe result is a Dict with the screen position of the text","\\t\\tcharacter in window {winid} at buffer line {lnum} and column","\\t\\t{col}.  {col} is a one-based byte index.","\\t\\tThe Dict has these members:","\\t\\t\\trow\\tscreen row","\\t\\t\\tcol\\tfirst screen column","\\t\\t\\tendcol\\tlast screen column","\\t\\t\\tcurscol\\tcursor screen column","\\t\\tIf the specified position is not visible, all values are zero.","\\t\\tThe \\"endcol\\" value differs from \\"col\\" when the character","\\t\\toccupies more than one screen cell.  E.g. for a Tab \\"col\\" can","\\t\\tbe 1 and \\"endcol\\" can be 8.","\\t\\tThe \\"curscol\\" value is where the cursor would be placed.  For","\\t\\ta Tab it would be the same as \\"endcol\\", while for a double","\\t\\twidth character it would be the same as \\"col\\"."],"screenrow":["\\t\\tThe result is a Number, which is the current screen row of the","\\t\\tcursor.  The top line has number one.","\\t\\tThis function is mainly used for testing.","\\t\\tAlternatively you can use |winline()|.","","\\t\\tNote: Same restrictions as with |screencol()|."],"search":["\\t\\tSearch for regexp pattern {pattern}.  The search starts at the","\\t\\tcursor position (you can use |cursor()| to set it).","","\\t\\tWhen a match has been found its line number is returned.","\\t\\tIf there is no match a 0 is returned and the cursor doesn\'t","\\t\\tmove.  No error message is given.","","\\t\\t{flags} is a String, which can contain these character flags:","\\t\\t\'b\'\\tsearch Backward instead of forward","\\t\\t\'c\'\\taccept a match at the Cursor position","\\t\\t\'e\'\\tmove to the End of the match","\\t\\t\'n\'\\tdo Not move the cursor","\\t\\t\'p\'\\treturn number of matching sub-Pattern (see below)","\\t\\t\'s\'\\tSet the \' mark at the previous location of the cursor","\\t\\t\'w\'\\tWrap around the end of the file","\\t\\t\'W\'\\tdon\'t Wrap around the end of the file","\\t\\t\'z\'\\tstart searching at the cursor column instead of Zero","\\t\\tIf neither \'w\' or \'W\' is given, the \'wrapscan\' option applies.","","\\t\\tIf the \'s\' flag is supplied, the \' mark is set, only if the","\\t\\tcursor is moved. The \'s\' flag cannot be combined with the \'n\'","\\t\\tflag.","","\\t\\t\'ignorecase\', \'smartcase\' and \'magic\' are used.","","\\t\\tWhen the \'z\' flag is not given, searching always starts in","\\t\\tcolumn zero and then matches before the cursor are skipped.","\\t\\tWhen the \'c\' flag is present in \'cpo\' the next search starts","\\t\\tafter the match.  Without the \'c\' flag the next search starts","\\t\\tone column further.","","\\t\\tWhen the {stopline} argument is given then the search stops","\\t\\tafter searching this line.  This is useful to restrict the","\\t\\tsearch to a range of lines.  Examples: >","\\t\\t\\tlet match = search(\'(\', \'b\', line(\\"w0\\"))","\\t\\t\\tlet end = search(\'END\', \'\', line(\\"w$\\"))","<\\t\\tWhen {stopline} is used and it is not zero this also implies","\\t\\tthat the search does not wrap around the end of the file.","\\t\\tA zero value is equal to not giving the argument.","","\\t\\tWhen the {timeout} argument is given the search stops when","\\t\\tmore than this many milliseconds have passed.  Thus when","\\t\\t{timeout} is 500 the search stops after half a second.","\\t\\tThe value must not be negative.  A zero value is like not","\\t\\tgiving the argument.","","\\t\\t\\t\\t\\t\\t\\t*search()-sub-match*","\\t\\tWith the \'p\' flag the returned value is one more than the","\\t\\tfirst sub-match in \\\\(\\\\).  One if none of them matched but the","\\t\\twhole pattern did match.","\\t\\tTo get the column number too use |searchpos()|.","","\\t\\tThe cursor will be positioned at the match, unless the \'n\'","\\t\\tflag is used.","","\\t\\tExample (goes over all files in the argument list): >","\\t\\t    :let n = 1","\\t\\t    :while n <= argc()\\t    \\" loop over all files in arglist","\\t\\t    :  exe \\"argument \\" . n","\\t\\t    :  \\" start at the last char in the file and wrap for the","\\t\\t    :  \\" first search to find match at start of file","\\t\\t    :  normal G$","\\t\\t    :  let flags = \\"w\\"","\\t\\t    :  while search(\\"foo\\", flags) > 0","\\t\\t    :\\t s/foo/bar/g","\\t\\t    :\\t let flags = \\"W\\"","\\t\\t    :  endwhile","\\t\\t    :  update\\t\\t    \\" write the file if modified","\\t\\t    :  let n = n + 1","\\t\\t    :endwhile","<","\\t\\tExample for using some flags: >","\\t\\t    :echo search(\'\\\\<if\\\\|\\\\(else\\\\)\\\\|\\\\(endif\\\\)\', \'ncpe\')","<\\t\\tThis will search for the keywords \\"if\\", \\"else\\", and \\"endif\\"","\\t\\tunder or after the cursor.  Because of the \'p\' flag, it","\\t\\treturns 1, 2, or 3 depending on which keyword is found, or 0","\\t\\tif the search fails.  With the cursor on the first word of the","\\t\\tline:","\\t\\t    if (foo == 0) | let foo = foo + 1 | endif ~","\\t\\tthe function returns 1.  Without the \'c\' flag, the function","\\t\\tfinds the \\"endif\\" and returns 3.  The same thing happens","\\t\\twithout the \'e\' flag if the cursor is on the \\"f\\" of \\"if\\".","\\t\\tThe \'n\' flag tells the function not to move the cursor.",""],"searchdecl":["\\t\\tSearch for the declaration of {name}.","","\\t\\tWith a non-zero {global} argument it works like |gD|, find","\\t\\tfirst match in the file.  Otherwise it works like |gd|, find","\\t\\tfirst match in the function.","","\\t\\tWith a non-zero {thisblock} argument matches in a {} block","\\t\\tthat ends before the cursor position are ignored.  Avoids","\\t\\tfinding variable declarations only valid in another scope.","","\\t\\tMoves the cursor to the found match.","\\t\\tReturns zero for success, non-zero for failure.","\\t\\tExample: >","\\t\\t\\tif searchdecl(\'myvar\') == 0","\\t\\t\\t   echo getline(\'.\')","\\t\\t\\tendif","<","\\t\\t\\t\\t\\t\\t\\t*searchpair()*","searchpair({start}, {middle}, {end} [, {flags} [, {skip}","\\t\\t\\t\\t[, {stopline} [, {timeout}]]]])","\\t\\tSearch for the match of a nested start-end pair.  This can be","\\t\\tused to find the \\"endif\\" that matches an \\"if\\", while other","\\t\\tif/endif pairs in between are ignored.","\\t\\tThe search starts at the cursor.  The default is to search","\\t\\tforward, include \'b\' in {flags} to search backward.","\\t\\tIf a match is found, the cursor is positioned at it and the","\\t\\tline number is returned.  If no match is found 0 or -1 is","\\t\\treturned and the cursor doesn\'t move.  No error message is","\\t\\tgiven.","","\\t\\t{start}, {middle} and {end} are patterns, see |pattern|.  They","\\t\\tmust not contain \\\\( \\\\) pairs.  Use of \\\\%( \\\\) is allowed.  When","\\t\\t{middle} is not empty, it is found when searching from either","\\t\\tdirection, but only when not in a nested start-end pair.  A","\\t\\ttypical use is: >","\\t\\t\\tsearchpair(\'\\\\<if\\\\>\', \'\\\\<else\\\\>\', \'\\\\<endif\\\\>\')","<\\t\\tBy leaving {middle} empty the \\"else\\" is skipped.","","\\t\\t{flags} \'b\', \'c\', \'n\', \'s\', \'w\' and \'W\' are used like with","\\t\\t|search()|.  Additionally:","\\t\\t\'r\'\\tRepeat until no more matches found; will find the","\\t\\t\\touter pair.  Implies the \'W\' flag.","\\t\\t\'m\'\\tReturn number of matches instead of line number with","\\t\\t\\tthe match; will be > 1 when \'r\' is used.","\\t\\tNote: it\'s nearly always a good idea to use the \'W\' flag, to","\\t\\tavoid wrapping around the end of the file.","","\\t\\tWhen a match for {start}, {middle} or {end} is found, the","\\t\\t{skip} expression is evaluated with the cursor positioned on","\\t\\tthe start of the match.  It should return non-zero if this","\\t\\tmatch is to be skipped.  E.g., because it is inside a comment","\\t\\tor a string.","\\t\\tWhen {skip} is omitted or empty, every match is accepted.","\\t\\tWhen evaluating {skip} causes an error the search is aborted","\\t\\tand -1 returned."," \\t\\t{skip} can be a string, a lambda, a funcref or a partial.","\\t\\tAnything else makes the function fail.","","\\t\\tFor {stopline} and {timeout} see |search()|.","","\\t\\tThe value of \'ignorecase\' is used.  \'magic\' is ignored, the","\\t\\tpatterns are used like it\'s on.","","\\t\\tThe search starts exactly at the cursor.  A match with","\\t\\t{start}, {middle} or {end} at the next character, in the","\\t\\tdirection of searching, is the first one found.  Example: >","\\t\\t\\tif 1","\\t\\t\\t  if 2","\\t\\t\\t  endif 2","\\t\\t\\tendif 1","<\\t\\tWhen starting at the \\"if 2\\", with the cursor on the \\"i\\", and","\\t\\tsearching forwards, the \\"endif 2\\" is found.  When starting on","\\t\\tthe character just before the \\"if 2\\", the \\"endif 1\\" will be","\\t\\tfound.  That\'s because the \\"if 2\\" will be found first, and","\\t\\tthen this is considered to be a nested if/endif from \\"if 2\\" to","\\t\\t\\"endif 2\\".","\\t\\tWhen searching backwards and {end} is more than one character,","\\t\\tit may be useful to put \\"\\\\zs\\" at the end of the pattern, so","\\t\\tthat when the cursor is inside a match with the end it finds","\\t\\tthe matching start.","","\\t\\tExample, to find the \\"endif\\" command in a Vim script: >","","\\t:echo searchpair(\'\\\\<if\\\\>\', \'\\\\<el\\\\%[seif]\\\\>\', \'\\\\<en\\\\%[dif]\\\\>\', \'W\',","\\t\\t\\t\\\\ \'getline(\\".\\") =~ \\"^\\\\\\\\s*\\\\\\"\\"\')","","<\\t\\tThe cursor must be at or after the \\"if\\" for which a match is","\\t\\tto be found.  Note that single-quote strings are used to avoid","\\t\\thaving to double the backslashes.  The skip expression only","\\t\\tcatches comments at the start of a line, not after a command.","\\t\\tAlso, a word \\"en\\" or \\"if\\" halfway through a line is considered","\\t\\ta match.","\\t\\tAnother example, to search for the matching \\"{\\" of a \\"}\\": >","","\\t:echo searchpair(\'{\', \'\', \'}\', \'bW\')","","<\\t\\tThis works when the cursor is at or before the \\"}\\" for which a","\\t\\tmatch is to be found.  To reject matches that syntax","\\t\\thighlighting recognized as strings: >","","\\t:echo searchpair(\'{\', \'\', \'}\', \'bW\',","\\t     \\\\ \'synIDattr(synID(line(\\".\\"), col(\\".\\"), 0), \\"name\\") =~? \\"string\\"\')","<","\\t\\t\\t\\t\\t\\t\\t*searchpairpos()*","searchpairpos({start}, {middle}, {end} [, {flags} [, {skip}","\\t\\t\\t\\t[, {stopline} [, {timeout}]]]])","\\t\\tSame as |searchpair()|, but returns a |List| with the line and","\\t\\tcolumn position of the match. The first element of the |List|","\\t\\tis the line number and the second element is the byte index of","\\t\\tthe column position of the match.  If no match is found,","\\t\\treturns [0, 0]. >","","\\t\\t\\t:let [lnum,col] = searchpairpos(\'{\', \'\', \'}\', \'n\')","<","\\t\\tSee |match-parens| for a bigger and more useful example."],"searchpos":["\\t\\tSame as |search()|, but returns a |List| with the line and","\\t\\tcolumn position of the match. The first element of the |List|","\\t\\tis the line number and the second element is the byte index of","\\t\\tthe column position of the match. If no match is found,","\\t\\treturns [0, 0].","\\t\\tExample: >","\\t:let [lnum, col] = searchpos(\'mypattern\', \'n\')","","<\\t\\tWhen the \'p\' flag is given then there is an extra item with","\\t\\tthe sub-pattern match number |search()-sub-match|.  Example: >","\\t:let [lnum, col, submatch] = searchpos(\'\\\\(\\\\l\\\\)\\\\|\\\\(\\\\u\\\\)\', \'np\')","<\\t\\tIn this example \\"submatch\\" is 2 when a lowercase letter is","\\t\\tfound |/\\\\l|, 3 when an uppercase letter is found |/\\\\u|."],"server2client":["\\t\\tSend a reply string to {clientid}.  The most recent {clientid}","\\t\\tthat sent a string can be retrieved with expand(\\"<client>\\").","\\t\\tNote:","\\t\\tThis id has to be stored before the next command can be","\\t\\treceived.  I.e. before returning from the received command and","\\t\\tbefore calling any commands that waits for input.","\\t\\tSee also |clientserver|.","\\t\\tExample: >","\\t\\t\\t:echo server2client(expand(\\"<client>\\"), \\"HELLO\\")"],"serverlist":["\\t\\tReturns a list of server addresses, or empty if all servers","\\t\\twere stopped. |serverstart()| |serverstop()|","\\t\\tExample: >","\\t\\t\\t:echo serverlist()"],"serverstart":["\\t\\tOpens a socket or named pipe at {address} and listens for","\\t\\t|RPC| messages. Clients can send |API| commands to the address","\\t\\tto control Nvim. Returns the address string.","","\\t\\tIf {address} does not contain a colon \\":\\" it is interpreted as","\\t\\ta named pipe or Unix domain socket path.","","\\t\\tExample: >","\\t\\t\\tif has(\'win32\')","\\t\\t\\t  call serverstart(\'\\\\\\\\.\\\\pipe\\\\nvim-pipe-1234\')","\\t\\t\\telse","\\t\\t\\t  call serverstart(\'nvim.sock\')","\\t\\t\\tendif","<","\\t\\tIf {address} contains a colon \\":\\" it is interpreted as a TCP","\\t\\taddress where the last \\":\\" separates the host and port.","\\t\\tAssigns a random port if it is empty or 0. Supports IPv4/IPv6.","","\\t\\tExample: >","\\t\\t\\t:call serverstart(\'::1:12345\')","<","\\t\\tIf no address is given, it is equivalent to: >","\\t\\t\\t:call serverstart(tempname())","","< \\t\\t|$NVIM_LISTEN_ADDRESS| is set to {address} if not already set."],"serverstop":["\\t\\tCloses the pipe or socket at {address}.","\\t\\tReturns TRUE if {address} is valid, else FALSE.","\\t\\tIf |$NVIM_LISTEN_ADDRESS| is stopped it is unset.","\\t\\tIf |v:servername| is stopped it is set to the next available","\\t\\taddress returned by |serverlist()|."],"setbufline":["\\t\\tSet line {lnum} to {text} in buffer {expr}.  To insert","\\t\\tlines use |append()|.","","\\t\\tFor the use of {expr}, see |bufname()| above.","","\\t\\t{lnum} is used like with |setline()|.","\\t\\tThis works like |setline()| for the specified buffer.","\\t\\tOn success 0 is returned, on failure 1 is returned.","","\\t\\tIf {expr} is not a valid buffer or {lnum} is not valid, an","\\t\\terror message is given."],"setbufvar":["\\t\\tSet option or local variable {varname} in buffer {expr} to","\\t\\t{val}.","\\t\\tThis also works for a global or local window option, but it","\\t\\tdoesn\'t work for a global or local window variable.","\\t\\tFor a local window option the global value is unchanged.","\\t\\tFor the use of {expr}, see |bufname()| above.","\\t\\tNote that the variable name without \\"b:\\" must be used.","\\t\\tExamples: >","\\t\\t\\t:call setbufvar(1, \\"&mod\\", 1)","\\t\\t\\t:call setbufvar(\\"todo\\", \\"myvar\\", \\"foobar\\")","<\\t\\tThis function is not available in the |sandbox|."],"setcharsearch":["\\t\\tSet the current character search information to {dict},","\\t\\twhich contains one or more of the following entries:","","\\t\\t    char\\tcharacter which will be used for a subsequent","\\t\\t\\t\\t|,| or |;| command; an empty string clears the","\\t\\t\\t\\tcharacter search","\\t\\t    forward\\tdirection of character search; 1 for forward,","\\t\\t\\t\\t0 for backward","\\t\\t    until\\ttype of character search; 1 for a |t| or |T|","\\t\\t\\t\\tcharacter search, 0 for an |f| or |F|","\\t\\t\\t\\tcharacter search","","\\t\\tThis can be useful to save/restore a user\'s character search","\\t\\tfrom a script: >","\\t\\t\\t:let prevsearch = getcharsearch()","\\t\\t\\t:\\" Perform a command which clobbers user\'s search","\\t\\t\\t:call setcharsearch(prevsearch)","<\\t\\tAlso see |getcharsearch()|."],"setcmdpos":["\\t\\tSet the cursor position in the command line to byte position","\\t\\t{pos}.  The first position is 1.","\\t\\tUse |getcmdpos()| to obtain the current position.","\\t\\tOnly works while editing the command line, thus you must use","\\t\\t|c_CTRL-\\\\_e|, |c_CTRL-R_=| or |c_CTRL-R_CTRL-R| with \'=\'.  For","\\t\\t|c_CTRL-\\\\_e| and |c_CTRL-R_CTRL-R| with \'=\' the position is","\\t\\tset after the command line is set to the expression.  For","\\t\\t|c_CTRL-R_=| it is set after evaluating the expression but","\\t\\tbefore inserting the resulting text.","\\t\\tWhen the number is too big the cursor is put at the end of the","\\t\\tline.  A number smaller than one has undefined results.","\\t\\tReturns 0 when successful, 1 when not editing the command","\\t\\tline."],"setenv":["\\t\\tSet environment variable {name} to {val}.","\\t\\tWhen {val} is |v:null| the environment variable is deleted.","\\t\\tSee also |expr-env|."],"setfperm":["\\t\\tSet the file permissions for {fname} to {mode}.","\\t\\t{mode} must be a string with 9 characters.  It is of the form","\\t\\t\\"rwxrwxrwx\\", where each group of \\"rwx\\" flags represent, in","\\t\\tturn, the permissions of the owner of the file, the group the","\\t\\tfile belongs to, and other users.  A \'-\' character means the","\\t\\tpermission is off, any other character means on.  Multi-byte","\\t\\tcharacters are not supported.","","\\t\\tFor example \\"rw-r-----\\" means read-write for the user,","\\t\\treadable by the group, not accessible by others.  \\"xx-x-----\\"","\\t\\twould do the same thing.","","\\t\\tReturns non-zero for success, zero for failure.","","\\t\\tTo read permissions see |getfperm()|."],"setline":["\\t\\tSet line {lnum} of the current buffer to {text}.  To insert","\\t\\tlines use |append()|. To set lines in another buffer use","\\t\\t|setbufline()|.","","\\t\\t{lnum} is used like with |getline()|.","\\t\\tWhen {lnum} is just below the last line the {text} will be","\\t\\tadded as a new line.","","\\t\\tIf this succeeds, 0 is returned.  If this fails (most likely","\\t\\tbecause {lnum} is invalid) 1 is returned.","","\\t\\tExample: >","\\t\\t\\t:call setline(5, strftime(\\"%c\\"))","","<\\t\\tWhen {text} is a |List| then line {lnum} and following lines","\\t\\twill be set to the items in the list.  Example: >","\\t\\t\\t:call setline(5, [\'aaa\', \'bbb\', \'ccc\'])","<\\t\\tThis is equivalent to: >","\\t\\t\\t:for [n, l] in [[5, \'aaa\'], [6, \'bbb\'], [7, \'ccc\']]","\\t\\t\\t:  call setline(n, l)","\\t\\t\\t:endfor","","<\\t\\tNote: The \'[ and \'] marks are not set."],"setloclist":["\\t\\tCreate or replace or add to the location list for window {nr}.","\\t\\t{nr} can be the window number or the |window-ID|.","\\t\\tWhen {nr} is zero the current window is used.","","\\t\\tFor a location list window, the displayed location list is","\\t\\tmodified.  For an invalid window number {nr}, -1 is returned.","\\t\\tOtherwise, same as |setqflist()|.","\\t\\tAlso see |location-list|.","","\\t\\tIf the optional {what} dictionary argument is supplied, then","\\t\\tonly the items listed in {what} are set. Refer to |setqflist()|","\\t\\tfor the list of supported keys in {what}."],"setmatches":["\\t\\tRestores a list of matches saved by |getmatches() for the","\\t\\tcurrent window|.  Returns 0 if successful, otherwise -1.  All","\\t\\tcurrent matches are cleared before the list is restored.  See","\\t\\texample for |getmatches()|.",""],"setpos":["\\t\\tSet the position for {expr}.  Possible values:","\\t\\t\\t.\\tthe cursor","\\t\\t\\t\'x\\tmark x","","\\t\\t{list} must be a |List| with four or five numbers:","\\t\\t    [bufnum, lnum, col, off]","\\t\\t    [bufnum, lnum, col, off, curswant]","","\\t\\t\\"bufnum\\" is the buffer number.\\tZero can be used for the","\\t\\tcurrent buffer.  When setting an uppercase mark \\"bufnum\\" is","\\t\\tused for the mark position.  For other marks it specifies the","\\t\\tbuffer to set the mark in.  You can use the |bufnr()| function","\\t\\tto turn a file name into a buffer number.","\\t\\tFor setting the cursor and the \' mark \\"bufnum\\" is ignored,","\\t\\tsince these are associated with a window, not a buffer.","\\t\\tDoes not change the jumplist.","","\\t\\t\\"lnum\\" and \\"col\\" are the position in the buffer.  The first","\\t\\tcolumn is 1.  Use a zero \\"lnum\\" to delete a mark.  If \\"col\\" is","\\t\\tsmaller than 1 then 1 is used.","","\\t\\tThe \\"off\\" number is only used when \'virtualedit\' is set. Then","\\t\\tit is the offset in screen columns from the start of the","\\t\\tcharacter.  E.g., a position within a <Tab> or after the last","\\t\\tcharacter.","","\\t\\tThe \\"curswant\\" number is only used when setting the cursor","\\t\\tposition.  It sets the preferred column for when moving the","\\t\\tcursor vertically.  When the \\"curswant\\" number is missing the","\\t\\tpreferred column is not set.  When it is present and setting a","\\t\\tmark position it is not used.","","\\t\\tNote that for \'< and \'> changing the line number may result in","\\t\\tthe marks to be effectively be swapped, so that \'< is always","\\t\\tbefore \'>.","","\\t\\tReturns 0 when the position could be set, -1 otherwise.","\\t\\tAn error message is given if {expr} is invalid.","","\\t\\tAlso see |getpos()| and |getcurpos()|.","","\\t\\tThis does not restore the preferred column for moving","\\t\\tvertically; if you set the cursor position with this, |j| and","\\t\\t|k| motions will jump to previous columns!  Use |cursor()| to","\\t\\talso set the preferred column.  Also see the \\"curswant\\" key in","\\t\\t|winrestview()|.",""],"setqflist":["\\t\\tCreate or replace or add to the quickfix list.","\\t\\t","\\t\\tWhen {what} is not present, use the items in {list}.  Each","\\t\\titem must be a dictionary.  Non-dictionary items in {list} are","\\t\\tignored.  Each dictionary item can contain the following","\\t\\tentries:","","\\t\\t    bufnr\\tbuffer number; must be the number of a valid","\\t\\t\\t\\tbuffer","\\t\\t    filename\\tname of a file; only used when \\"bufnr\\" is not","\\t\\t\\t\\tpresent or it is invalid.","\\t\\t    module\\tname of a module; if given it will be used in","\\t\\t\\t\\tquickfix error window instead of the filename","\\t\\t    lnum\\tline number in the file","\\t\\t    pattern\\tsearch pattern used to locate the error","\\t\\t    col\\t\\tcolumn number","\\t\\t    vcol\\twhen non-zero: \\"col\\" is visual column","\\t\\t\\t\\twhen zero: \\"col\\" is byte index","\\t\\t    nr\\t\\terror number","\\t\\t    text\\tdescription of the error","\\t\\t    type\\tsingle-character error type, \'E\', \'W\', etc.","\\t\\t    valid\\trecognized error message","","\\t\\tThe \\"col\\", \\"vcol\\", \\"nr\\", \\"type\\" and \\"text\\" entries are","\\t\\toptional.  Either \\"lnum\\" or \\"pattern\\" entry can be used to","\\t\\tlocate a matching error line.","\\t\\tIf the \\"filename\\" and \\"bufnr\\" entries are not present or","\\t\\tneither the \\"lnum\\" or \\"pattern\\" entries are present, then the","\\t\\titem will not be handled as an error line.","\\t\\tIf both \\"pattern\\" and \\"lnum\\" are present then \\"pattern\\" will","\\t\\tbe used.","\\t\\tIf the \\"valid\\" entry is not supplied, then the valid flag is","\\t\\tset when \\"bufnr\\" is a valid buffer or \\"filename\\" exists.","\\t\\tIf you supply an empty {list}, the quickfix list will be","\\t\\tcleared.","\\t\\tNote that the list is not exactly the same as what","\\t\\t|getqflist()| returns.","","\\t\\t{action} values:\\t\\t\\t\\t*E927*","\\t\\t\'a\'\\tThe items from {list} are added to the existing","\\t\\t\\tquickfix list. If there is no existing list, then a","\\t\\t\\tnew list is created.","\\t\\t","\\t\\t\'r\'\\tThe items from the current quickfix list are replaced","\\t\\t\\twith the items from {list}.  This can also be used to","\\t\\t\\tclear the list: >","\\t\\t\\t\\t:call setqflist([], \'r\')","<\\t","\\t\\t\'f\'\\tAll the quickfix lists in the quickfix stack are","\\t\\t\\tfreed.","","\\t\\tIf {action} is not present or is set to \' \', then a new list","\\t\\tis created. The new quickfix list is added after the current","\\t\\tquickfix list in the stack and all the following lists are","\\t\\tfreed. To add a new quickfix list at the end of the stack,","\\t\\tset \\"nr\\" in {what} to \\"$\\".","","\\t\\tIf the optional {what} dictionary argument is supplied, then","\\t\\tonly the items listed in {what} are set. The first {list}","\\t\\targument is ignored.  The following items can be specified in","\\t\\t{what}:","\\t\\t    context\\tquickfix list context. See |quickfix-context|","\\t\\t    efm\\t\\terrorformat to use when parsing text from","\\t\\t\\t\\t\\"lines\\". If this is not present, then the","\\t\\t\\t\\t\'errorformat\' option value is used.","\\t\\t    id\\t\\tquickfix list identifier |quickfix-ID|","\\t\\t    items\\tlist of quickfix entries. Same as the {list}","\\t\\t\\t\\targument.","\\t\\t    lines\\tuse \'errorformat\' to parse a list of lines and","\\t\\t\\t\\tadd the resulting entries to the quickfix list","\\t\\t\\t\\t{nr} or {id}.  Only a |List| value is supported.","\\t\\t    nr\\t\\tlist number in the quickfix stack; zero","\\t\\t\\t\\tmeans the current quickfix list and \\"$\\" means","\\t\\t\\t\\tthe last quickfix list","\\t\\t    title\\tquickfix list title text","\\t\\tUnsupported keys in {what} are ignored.","\\t\\tIf the \\"nr\\" item is not present, then the current quickfix list","\\t\\tis modified. When creating a new quickfix list, \\"nr\\" can be","\\t\\tset to a value one greater than the quickfix stack size.","\\t\\tWhen modifying a quickfix list, to guarantee that the correct","\\t\\tlist is modified, \\"id\\" should be used instead of \\"nr\\" to","\\t\\tspecify the list.","","\\t\\tExamples (See also |setqflist-examples|): >","\\t\\t   :call setqflist([], \'r\', {\'title\': \'My search\'})","\\t\\t   :call setqflist([], \'r\', {\'nr\': 2, \'title\': \'Errors\'})","\\t\\t   :call setqflist([], \'a\', {\'id\':qfid, \'lines\':[\\"F1:10:L10\\"]})","<","\\t\\tReturns zero for success, -1 for failure.","","\\t\\tThis function can be used to create a quickfix list","\\t\\tindependent of the \'errorformat\' setting.  Use a command like","\\t\\t`:cc 1` to jump to the first position.","",""],"setreg":["\\t\\tSet the register {regname} to {value}.","\\t\\t{value} may be any value returned by |getreg()|, including","\\t\\ta |List|.","\\t\\tIf {options} contains \\"a\\" or {regname} is upper case,","\\t\\tthen the value is appended.","\\t\\t{options} can also contain a register type specification:","\\t\\t    \\"c\\" or \\"v\\"\\t      |charwise| mode","\\t\\t    \\"l\\" or \\"V\\"\\t      |linewise| mode","\\t\\t    \\"b\\" or \\"<CTRL-V>\\" |blockwise-visual| mode","\\t\\tIf a number immediately follows \\"b\\" or \\"<CTRL-V>\\" then this is","\\t\\tused as the width of the selection - if it is not specified","\\t\\tthen the width of the block is set to the number of characters","\\t\\tin the longest line (counting a <Tab> as 1 character).","\\t\\tIf {options} contains \\"u\\" or \'\\"\', then the unnamed register is","\\t\\tset to point to register {regname}.","","\\t\\tIf {options} contains no register settings, then the default","\\t\\tis to use character mode unless {value} ends in a <NL> for","\\t\\tstring {value} and linewise mode for list {value}. Blockwise","\\t\\tmode is never selected automatically.","\\t\\tReturns zero for success, non-zero for failure.","","\\t\\t\\t\\t\\t\\t\\t*E883*","\\t\\tNote: you may not use |List| containing more than one item to","\\t\\t      set search and expression registers. Lists containing no","\\t\\t      items act like empty strings.","","\\t\\tExamples: >","\\t\\t\\t:call setreg(v:register, @*)","\\t\\t\\t:call setreg(\'*\', @%, \'ac\')","\\t\\t\\t:call setreg(\'a\', \\"1\\\\n2\\\\n3\\", \'b5\')","","<\\t\\tThis example shows using the functions to save and restore a","\\t\\tregister: >","\\t\\t\\t:let var_a = getreg(\'a\', 1, 1)","\\t\\t\\t:let var_amode = getregtype(\'a\')","\\t\\t\\t    ....","\\t\\t\\t:call setreg(\'a\', var_a, var_amode)","<\\t\\tNote: you may not reliably restore register value","\\t\\twithout using the third argument to |getreg()| as without it","\\t\\tnewlines are represented as newlines AND Nul bytes are","\\t\\trepresented as newlines as well, see |NL-used-for-Nul|.","","\\t\\tYou can also change the type of a register by appending","\\t\\tnothing: >","\\t\\t\\t:call setreg(\'a\', \'\', \'al\')"],"settabvar":["\\t\\tSet tab-local variable {varname} to {val} in tab page {tabnr}.","\\t\\t|t:var|","\\t\\tNote that the variable name without \\"t:\\" must be used.","\\t\\tTabs are numbered starting with one.","\\t\\tThis function is not available in the |sandbox|."],"settabwinvar":["\\t\\tSet option or local variable {varname} in window {winnr} to","\\t\\t{val}.","\\t\\tTabs are numbered starting with one.  For the current tabpage","\\t\\tuse |setwinvar()|.","\\t\\t{winnr} can be the window number or the |window-ID|.","\\t\\tWhen {winnr} is zero the current window is used.","\\t\\tThis also works for a global or local buffer option, but it","\\t\\tdoesn\'t work for a global or local buffer variable.","\\t\\tFor a local buffer option the global value is unchanged.","\\t\\tNote that the variable name without \\"w:\\" must be used.","\\t\\tExamples: >","\\t\\t\\t:call settabwinvar(1, 1, \\"&list\\", 0)","\\t\\t\\t:call settabwinvar(3, 2, \\"myvar\\", \\"foobar\\")","<\\t\\tThis function is not available in the |sandbox|."],"settagstack":["\\t\\tModify the tag stack of the window {nr} using {dict}.","\\t\\t{nr} can be the window number or the |window-ID|.","","\\t\\tFor a list of supported items in {dict}, refer to","\\t\\t|gettagstack()|. \\"curidx\\" takes effect before changing the tag","\\t\\tstack.","\\t\\t\\t\\t\\t\\t\\t*E962*","\\t\\tHow the tag stack is modified depends on the {action}","\\t\\targument:","\\t\\t- If {action} is not present or is set to \'r\', then the tag","\\t\\t  stack is replaced.","\\t\\t- If {action} is set to \'a\', then new entries from {dict} are","\\t\\t  pushed (added) onto the tag stack.","\\t\\t- If {action} is set to \'t\', then all the entries from the","\\t\\t  current entry in the tag stack or \\"curidx\\" in {dict} are","\\t\\t  removed and then new entries are pushed to the stack.","","\\t\\tThe current index is set to one after the length of the tag","\\t\\tstack after the modification.","","\\t\\tReturns zero for success, -1 for failure.","","\\t\\tExamples:","\\t\\t    Set current index of the tag stack to 4: >","\\t\\t\\tcall settagstack(1005, {\'curidx\' : 4})","","<\\t\\t    Empty the tag stack of window 3: >","\\t\\t\\tcall settagstack(3, {\'items\' : []})","","<\\t\\t    Push a new item onto the tag stack: >","\\t\\t\\tlet pos = [bufnr(\'myfile.txt\'), 10, 1, 0]","\\t\\t\\tlet newtag = [{\'tagname\' : \'mytag\', \'from\' : pos}]","\\t\\t\\tcall settagstack(2, {\'items\' : newtag}, \'a\')","","<\\t\\t    Save and restore the tag stack: >","\\t\\t\\tlet stack = gettagstack(1003)","\\t\\t\\t\\" do something else","\\t\\t\\tcall settagstack(1003, stack)","\\t\\t\\tunlet stack","<"],"setwinvar":["\\t\\tLike |settabwinvar()| for the current tab page.","\\t\\tExamples: >","\\t\\t\\t:call setwinvar(1, \\"&list\\", 0)","\\t\\t\\t:call setwinvar(2, \\"myvar\\", \\"foobar\\")"],"sha256":["\\t\\tReturns a String with 64 hex characters, which is the SHA256","\\t\\tchecksum of {string}."],"shellescape":["\\t\\tEscape {string} for use as a shell command argument.","\\t\\tOn Windows when \'shellslash\' is not set, it","\\t\\twill enclose {string} in double quotes and double all double","\\t\\tquotes within {string}.","\\t\\tOtherwise, it will enclose {string} in single quotes and","\\t\\treplace all \\"\'\\" with \\"\'\\\\\'\'\\".","","\\t\\tWhen the {special} argument is present and it\'s a non-zero","\\t\\tNumber or a non-empty String (|non-zero-arg|), then special","\\t\\titems such as \\"!\\", \\"%\\", \\"#\\" and \\"<cword>\\" will be preceded by","\\t\\ta backslash.  This backslash will be removed again by the |:!|","\\t\\tcommand.","","\\t\\tThe \\"!\\" character will be escaped (again with a |non-zero-arg|","\\t\\t{special}) when \'shell\' contains \\"csh\\" in the tail.  That is","\\t\\tbecause for csh and tcsh \\"!\\" is used for history replacement","\\t\\teven when inside single quotes.","","\\t\\tWith a |non-zero-arg| {special} the <NL> character is also","\\t\\tescaped.  When \'shell\' containing \\"csh\\" in the tail it\'s","\\t\\tescaped a second time.","","\\t\\tExample of use with a |:!| command: >","\\t\\t    :exe \'!dir \' . shellescape(expand(\'<cfile>\'), 1)","<\\t\\tThis results in a directory listing for the file under the","\\t\\tcursor.  Example of use with |system()|: >","\\t\\t    :call system(\\"chmod +w -- \\" . shellescape(expand(\\"%\\")))","<\\t\\tSee also |::S|.",""],"shiftwidth":["\\t\\tReturns the effective value of \'shiftwidth\'. This is the","\\t\\t\'shiftwidth\' value unless it is zero, in which case it is the","\\t\\t\'tabstop\' value.  To be backwards compatible in indent","\\t\\tplugins, use this: >","\\t\\t\\tif exists(\'*shiftwidth\')","\\t\\t\\t  func s:sw()","\\t\\t\\t    return shiftwidth()","\\t\\t\\t  endfunc","\\t\\t\\telse","\\t\\t\\t  func s:sw()","\\t\\t\\t    return &sw","\\t\\t\\t  endfunc","\\t\\t\\tendif","<\\t\\tAnd then use s:sw() instead of &sw."],"sign_define":["\\t\\tDefine a new sign named {name} or modify the attributes of an","\\t\\texisting sign.  This is similar to the |:sign-define| command.","","\\t\\tPrefix {name} with a unique text to avoid name collisions.","\\t\\tThere is no {group} like with placing signs.","","\\t\\tThe {name} can be a String or a Number.  The optional {dict}","\\t\\targument specifies the sign attributes.  The following values","\\t\\tare supported:","\\t\\t    icon\\tfull path to the bitmap file for the sign.","\\t\\t    linehl\\thighlight group used for the whole line the","\\t\\t\\t\\tsign is placed in.","\\t\\t    text\\ttext that is displayed when there is no icon","\\t\\t\\t\\tor the GUI is not being used.","\\t\\t    texthl\\thighlight group used for the text item","\\t\\t    numhl\\thighlight group used for \'number\' column at the","\\t\\t\\t\\tassociated line. Overrides |hl-LineNr|,","\\t\\t\\t\\t|hl-CursorLineNr|.","","\\t\\tIf the sign named {name} already exists, then the attributes","\\t\\tof the sign are updated.","","\\t\\tReturns 0 on success and -1 on failure.","","\\t\\tExamples: >","\\t\\t\\tcall sign_define(\\"mySign\\", {\\"text\\" : \\"=>\\", \\"texthl\\" :","\\t\\t\\t\\t\\t\\\\ \\"Error\\", \\"linehl\\" : \\"Search\\"})"],"sign_getdefined":["\\t\\tGet a list of defined signs and their attributes.","\\t\\tThis is similar to the |:sign-list| command.","","\\t\\tIf the {name} is not supplied, then a list of all the defined","\\t\\tsigns is returned. Otherwise the attribute of the specified","\\t\\tsign is returned.","","\\t\\tEach list item in the returned value is a dictionary with the","\\t\\tfollowing entries:","\\t\\t\\ticon\\tfull path to the bitmap file of the sign","\\t\\t\\tlinehl\\thighlight group used for the whole line the","\\t\\t\\t\\tsign is placed in.","\\t\\t\\tname\\tname of the sign","\\t\\t\\ttext\\ttext that is displayed when there is no icon","\\t\\t\\t\\tor the GUI is not being used.","\\t\\t\\ttexthl\\thighlight group used for the text item","\\t\\t\\tnumhl\\thighlight group used for \'number\' column at the","\\t\\t\\t\\tassociated line. Overrides |hl-LineNr|,","\\t\\t\\t\\t|hl-CursorLineNr|.","","\\t\\tReturns an empty List if there are no signs and when {name} is","\\t\\tnot found.","","\\t\\tExamples: >","\\t\\t\\t\\" Get a list of all the defined signs","\\t\\t\\techo sign_getdefined()","","\\t\\t\\t\\" Get the attribute of the sign named mySign","\\t\\t\\techo sign_getdefined(\\"mySign\\")"],"sign_getplaced":["\\t\\tReturn a list of signs placed in a buffer or all the buffers.","\\t\\tThis is similar to the |:sign-place-list| command.","","\\t\\tIf the optional buffer name {expr} is specified, then only the","\\t\\tlist of signs placed in that buffer is returned.  For the use","\\t\\tof {expr}, see |bufname()|. The optional {dict} can contain","\\t\\tthe following entries:","\\t\\t   group\\tselect only signs in this group","\\t\\t   id\\t\\tselect sign with this identifier","\\t\\t   lnum\\t\\tselect signs placed in this line. For the use","\\t\\t\\t\\tof {lnum}, see |line()|.","\\t\\tIf {group} is \'*\', then signs in all the groups including the","\\t\\tglobal group are returned. If {group} is not supplied or is an","\\t\\tempty string, then only signs in the global group are","\\t\\treturned.  If no arguments are supplied, then signs in the","\\t\\tglobal group placed in all the buffers are returned.","\\t\\tSee |sign-group|.","","\\t\\tEach list item in the returned value is a dictionary with the","\\t\\tfollowing entries:","\\t\\t\\tbufnr\\tnumber of the buffer with the sign","\\t\\t\\tsigns\\tlist of signs placed in {bufnr}. Each list","\\t\\t\\t\\titem is a dictionary with the below listed","\\t\\t\\t\\tentries","","\\t\\tThe dictionary for each sign contains the following entries:","\\t\\t\\tgroup\\tsign group. Set to \'\' for the global group.","\\t\\t\\tid\\tidentifier of the sign","\\t\\t\\tlnum\\tline number where the sign is placed","\\t\\t\\tname\\tname of the defined sign","\\t\\t\\tpriority\\tsign priority","","\\t\\tThe returned signs in a buffer are ordered by their line","\\t\\tnumber and priority.","","\\t\\tReturns an empty list on failure or if there are no placed","\\t\\tsigns.","","\\t\\tExamples: >","\\t\\t\\t\\" Get a List of signs placed in eval.c in the","\\t\\t\\t\\" global group","\\t\\t\\techo sign_getplaced(\\"eval.c\\")","","\\t\\t\\t\\" Get a List of signs in group \'g1\' placed in eval.c","\\t\\t\\techo sign_getplaced(\\"eval.c\\", {\'group\' : \'g1\'})","","\\t\\t\\t\\" Get a List of signs placed at line 10 in eval.c","\\t\\t\\techo sign_getplaced(\\"eval.c\\", {\'lnum\' : 10})","","\\t\\t\\t\\" Get sign with identifier 10 placed in a.py","\\t\\t\\techo sign_getplaced(\\"a.py\\", {\'id\' : 10})","","\\t\\t\\t\\" Get sign with id 20 in group \'g1\' placed in a.py","\\t\\t\\techo sign_getplaced(\\"a.py\\", {\'group\' : \'g1\',","\\t\\t\\t\\t\\t\\t\\t\\\\  \'id\' : 20})","","\\t\\t\\t\\" Get a List of all the placed signs","\\t\\t\\techo sign_getplaced()","<"],"sign_jump":["\\t\\tOpen the buffer {expr} or jump to the window that contains","\\t\\t{expr} and position the cursor at sign {id} in group {group}.","\\t\\tThis is similar to the |:sign-jump| command.","","\\t\\tFor the use of {expr}, see |bufname()|.","","\\t\\tReturns the line number of the sign. Returns -1 if the","\\t\\targuments are invalid.","","\\t\\tExample: >","\\t\\t\\t\\" Jump to sign 10 in the current buffer","\\t\\t\\tcall sign_jump(10, \'\', \'\')","<"],"sign_place":["\\t\\tPlace the sign defined as {name} at line {lnum} in file {expr}","\\t\\tand assign {id} and {group} to sign.  This is similar to the","\\t\\t|:sign-place| command.","","\\t\\tIf the sign identifier {id} is zero, then a new identifier is","\\t\\tallocated.  Otherwise the specified number is used. {group} is","\\t\\tthe sign group name. To use the global sign group, use an","\\t\\tempty string.  {group} functions as a namespace for {id}, thus","\\t\\ttwo groups can use the same IDs. Refer to |sign-identifier|","\\t\\tfor more information.","\\t\\t","\\t\\t{name} refers to a defined sign.","\\t\\t{expr} refers to a buffer name or number. For the accepted","\\t\\tvalues, see |bufname()|.","","\\t\\tThe optional {dict} argument supports the following entries:","\\t\\t\\tlnum\\t\\tline number in the buffer {expr} where","\\t\\t\\t\\t\\tthe sign is to be placed. For the","\\t\\t\\t\\t\\taccepted values, see |line()|.","\\t\\t\\tpriority\\tpriority of the sign. See","\\t\\t\\t\\t\\t|sign-priority| for more information.","","\\t\\tIf the optional {dict} is not specified, then it modifies the","\\t\\tplaced sign {id} in group {group} to use the defined sign","\\t\\t{name}.","","\\t\\tReturns the sign identifier on success and -1 on failure.","","\\t\\tExamples: >","\\t\\t\\t\\" Place a sign named sign1 with id 5 at line 20 in","\\t\\t\\t\\" buffer json.c","\\t\\t\\tcall sign_place(5, \'\', \'sign1\', \'json.c\',","\\t\\t\\t\\t\\t\\t\\t\\\\ {\'lnum\' : 20})","","\\t\\t\\t\\" Updates sign 5 in buffer json.c to use sign2","\\t\\t\\tcall sign_place(5, \'\', \'sign2\', \'json.c\')","","\\t\\t\\t\\" Place a sign named sign3 at line 30 in","\\t\\t\\t\\" buffer json.c with a new identifier","\\t\\t\\tlet id = sign_place(0, \'\', \'sign3\', \'json.c\',","\\t\\t\\t\\t\\t\\t\\t\\\\ {\'lnum\' : 30})","","\\t\\t\\t\\" Place a sign named sign4 with id 10 in group \'g3\'","\\t\\t\\t\\" at line 40 in buffer json.c with priority 90","\\t\\t\\tcall sign_place(10, \'g3\', \'sign4\', \'json.c\',","\\t\\t\\t\\t\\t\\\\ {\'lnum\' : 40, \'priority\' : 90})"],"sign_undefine":["\\t\\tDeletes a previously defined sign {name}. This is similar to","\\t\\tthe |:sign-undefine| command. If {name} is not supplied, then","\\t\\tdeletes all the defined signs.","","\\t\\tReturns 0 on success and -1 on failure.","","\\t\\tExamples: >","\\t\\t\\t\\" Delete a sign named mySign","\\t\\t\\tcall sign_undefine(\\"mySign\\")","","\\t\\t\\t\\" Delete all the signs","\\t\\t\\tcall sign_undefine()"],"sign_unplace":["\\t\\tRemove a previously placed sign in one or more buffers.  This","\\t\\tis similar to the |:sign-unplace| command.","","\\t\\t{group} is the sign group name. To use the global sign group,","\\t\\tuse an empty string.  If {group} is set to \'*\', then all the","\\t\\tgroups including the global group are used.","\\t\\tThe signs in {group} are selected based on the entries in","\\t\\t{dict}.  The following optional entries in {dict} are","\\t\\tsupported:","\\t\\t\\tbuffer\\tbuffer name or number. See |bufname()|.","\\t\\t\\tid\\tsign identifier","\\t\\tIf {dict} is not supplied, then all the signs in {group} are","\\t\\tremoved.","","\\t\\tReturns 0 on success and -1 on failure.","","\\t\\tExamples: >","\\t\\t\\t\\" Remove sign 10 from buffer a.vim","\\t\\t\\tcall sign_unplace(\'\', {\'buffer\' : \\"a.vim\\", \'id\' : 10})","","\\t\\t\\t\\" Remove sign 20 in group \'g1\' from buffer 3","\\t\\t\\tcall sign_unplace(\'g1\', {\'buffer\' : 3, \'id\' : 20})","","\\t\\t\\t\\" Remove all the signs in group \'g2\' from buffer 10","\\t\\t\\tcall sign_unplace(\'g2\', {\'buffer\' : 10})","","\\t\\t\\t\\" Remove sign 30 in group \'g3\' from all the buffers","\\t\\t\\tcall sign_unplace(\'g3\', {\'id\' : 30})","","\\t\\t\\t\\" Remove all the signs placed in buffer 5","\\t\\t\\tcall sign_unplace(\'*\', {\'buffer\' : 5})","","\\t\\t\\t\\" Remove the signs in group \'g4\' from all the buffers","\\t\\t\\tcall sign_unplace(\'g4\')","","\\t\\t\\t\\" Remove sign 40 from all the buffers","\\t\\t\\tcall sign_unplace(\'*\', {\'id\' : 40})","","\\t\\t\\t\\" Remove all the placed signs from all the buffers","\\t\\t\\tcall sign_unplace(\'*\')"],"simplify":["\\t\\tSimplify the file name as much as possible without changing","\\t\\tthe meaning.  Shortcuts (on MS-Windows) or symbolic links (on","\\t\\tUnix) are not resolved.  If the first path component in","\\t\\t{filename} designates the current directory, this will be","\\t\\tvalid for the result as well.  A trailing path separator is","\\t\\tnot removed either.","\\t\\tExample: >","\\t\\t\\tsimplify(\\"./dir/.././/file/\\") == \\"./file/\\"","<\\t\\tNote: The combination \\"dir/..\\" is only removed if \\"dir\\" is","\\t\\ta searchable directory or does not exist.  On Unix, it is also","\\t\\tremoved when \\"dir\\" is a symbolic link within the same","\\t\\tdirectory.  In order to resolve all the involved symbolic","\\t\\tlinks before simplifying the path name, use |resolve()|.",""],"sin":["\\t\\tReturn the sine of {expr}, measured in radians, as a |Float|.","\\t\\t{expr} must evaluate to a |Float| or a |Number|.","\\t\\tExamples: >","\\t\\t\\t:echo sin(100)","<\\t\\t\\t-0.506366 >","\\t\\t\\t:echo sin(-4.01)","<\\t\\t\\t0.763301",""],"sinh":["\\t\\tReturn the hyperbolic sine of {expr} as a |Float| in the range","\\t\\t[-inf, inf].","\\t\\t{expr} must evaluate to a |Float| or a |Number|.","\\t\\tExamples: >","\\t\\t\\t:echo sinh(0.5)","<\\t\\t\\t0.521095 >","\\t\\t\\t:echo sinh(-0.9)","<\\t\\t\\t-1.026517"],"sockconnect":["\\t\\tConnect a socket to an address. If {mode} is \\"pipe\\" then","\\t\\t{address} should be the path of a named pipe. If {mode} is","\\t\\t\\"tcp\\" then {address} should be of the form \\"host:port\\" where","\\t\\tthe host should be an ip adderess or host name, and port the","\\t\\tport number.","","\\t\\tReturns a |channel| ID. Close the socket with |chanclose()|.","\\t\\tUse |chansend()| to send data over a bytes socket, and","\\t\\t|rpcrequest()| and |rpcnotify()| to communicate with a RPC","\\t\\tsocket.","","\\t\\t{opts} is a dictionary with these keys:","\\t\\t  |on_data| : callback invoked when data was read from socket","\\t\\t  data_buffered : read socket data in |channel-buffered| mode.","\\t\\t  rpc     : If set, |msgpack-rpc| will be used to communicate","\\t\\t\\t    over the socket.","\\t\\tReturns:","\\t\\t  - The channel ID on success (greater than zero)","\\t\\t  - 0 on invalid arguments or connection failure."],"sort":["\\t\\tSort the items in {list} in-place.  Returns {list}.","","\\t\\tIf you want a list to remain unmodified make a copy first: >","\\t\\t\\t:let sortedlist = sort(copy(mylist))","","<\\t\\tWhen {func} is omitted, is empty or zero, then sort() uses the","\\t\\tstring representation of each item to sort on.  Numbers sort","\\t\\tafter Strings, |Lists| after Numbers.  For sorting text in the","\\t\\tcurrent buffer use |:sort|.","","\\t\\tWhen {func} is given and it is \'1\' or \'i\' then case is","\\t\\tignored.","","\\t\\tWhen {func} is given and it is \'n\' then all items will be","\\t\\tsorted numerical (Implementation detail: This uses the","\\t\\tstrtod() function to parse numbers, Strings, Lists, Dicts and","\\t\\tFuncrefs will be considered as being 0).","","\\t\\tWhen {func} is given and it is \'N\' then all items will be","\\t\\tsorted numerical. This is like \'n\' but a string containing","\\t\\tdigits will be used as the number they represent.","","\\t\\tWhen {func} is given and it is \'f\' then all items will be","\\t\\tsorted numerical. All values must be a Number or a Float.","","\\t\\tWhen {func} is a |Funcref| or a function name, this function","\\t\\tis called to compare items.  The function is invoked with two","\\t\\titems as argument and must return zero if they are equal, 1 or","\\t\\tbigger if the first one sorts after the second one, -1 or","\\t\\tsmaller if the first one sorts before the second one.","","\\t\\t{dict} is for functions with the \\"dict\\" attribute.  It will be","\\t\\tused to set the local variable \\"self\\". |Dictionary-function|","","\\t\\tThe sort is stable, items which compare equal (as number or as","\\t\\tstring) will keep their relative position. E.g., when sorting","\\t\\ton numbers, text strings will sort next to each other, in the","\\t\\tsame order as they were originally.","","\\t\\tAlso see |uniq()|.","","\\t\\tExample: >","\\t\\t\\tfunc MyCompare(i1, i2)","\\t\\t\\t   return a:i1 == a:i2 ? 0 : a:i1 > a:i2 ? 1 : -1","\\t\\t\\tendfunc","\\t\\t\\tlet sortedlist = sort(mylist, \\"MyCompare\\")","<\\t\\tA shorter compare version for this specific simple case, which","\\t\\tignores overflow: >","\\t\\t\\tfunc MyCompare(i1, i2)","\\t\\t\\t   return a:i1 - a:i2","\\t\\t\\tendfunc","<"],"soundfold":["\\t\\tReturn the sound-folded equivalent of {word}.  Uses the first","\\t\\tlanguage in \'spelllang\' for the current window that supports","\\t\\tsoundfolding.  \'spell\' must be set.  When no sound folding is","\\t\\tpossible the {word} is returned unmodified.","\\t\\tThis can be used for making spelling suggestions.  Note that","\\t\\tthe method can be quite slow.",""],"spellbadword":["\\t\\tWithout argument: The result is the badly spelled word under","\\t\\tor after the cursor.  The cursor is moved to the start of the","\\t\\tbad word.  When no bad word is found in the cursor line the","\\t\\tresult is an empty string and the cursor doesn\'t move.","","\\t\\tWith argument: The result is the first word in {sentence} that","\\t\\tis badly spelled.  If there are no spelling mistakes the","\\t\\tresult is an empty string.","","\\t\\tThe return value is a list with two items:","\\t\\t- The badly spelled word or an empty string.","\\t\\t- The type of the spelling error:","\\t\\t\\t\\"bad\\"\\t\\tspelling mistake","\\t\\t\\t\\"rare\\"\\t\\trare word","\\t\\t\\t\\"local\\"\\t\\tword only valid in another region","\\t\\t\\t\\"caps\\"\\t\\tword should start with Capital","\\t\\tExample: >","\\t\\t\\techo spellbadword(\\"the quik brown fox\\")","<\\t\\t\\t[\'quik\', \'bad\'] ~","","\\t\\tThe spelling information for the current window is used.  The","\\t\\t\'spell\' option must be set and the value of \'spelllang\' is","\\t\\tused.",""],"spellsuggest":["\\t\\tReturn a |List| with spelling suggestions to replace {word}.","\\t\\tWhen {max} is given up to this number of suggestions are","\\t\\treturned.  Otherwise up to 25 suggestions are returned.","","\\t\\tWhen the {capital} argument is given and it\'s non-zero only","\\t\\tsuggestions with a leading capital will be given.  Use this","\\t\\tafter a match with \'spellcapcheck\'.","","\\t\\t{word} can be a badly spelled word followed by other text.","\\t\\tThis allows for joining two words that were split.  The","\\t\\tsuggestions also include the following text, thus you can","\\t\\treplace a line.","","\\t\\t{word} may also be a good word.  Similar words will then be","\\t\\treturned.  {word} itself is not included in the suggestions,","\\t\\talthough it may appear capitalized.","","\\t\\tThe spelling information for the current window is used.  The","\\t\\t\'spell\' option must be set and the values of \'spelllang\' and","\\t\\t\'spellsuggest\' are used.",""],"split":["\\t\\tMake a |List| out of {expr}.  When {pattern} is omitted or","\\t\\tempty each white-separated sequence of characters becomes an","\\t\\titem.","\\t\\tOtherwise the string is split where {pattern} matches,","\\t\\tremoving the matched characters. \'ignorecase\' is not used","\\t\\there, add \\\\c to ignore case. |/\\\\c|","\\t\\tWhen the first or last item is empty it is omitted, unless the","\\t\\t{keepempty} argument is given and it\'s non-zero.","\\t\\tOther empty items are kept when {pattern} matches at least one","\\t\\tcharacter or when {keepempty} is non-zero.","\\t\\tExample: >","\\t\\t\\t:let words = split(getline(\'.\'), \'\\\\W\\\\+\')","<\\t\\tTo split a string in individual characters: >","\\t\\t\\t:for c in split(mystring, \'\\\\zs\')","<\\t\\tIf you want to keep the separator you can also use \'\\\\zs\' at","\\t\\tthe end of the pattern: >","\\t\\t\\t:echo split(\'abc:def:ghi\', \':\\\\zs\')","<\\t\\t\\t[\'abc:\', \'def:\', \'ghi\'] ~","\\t\\tSplitting a table where the first element can be empty: >","\\t\\t\\t:let items = split(line, \':\', 1)","<\\t\\tThe opposite function is |join()|.",""],"sqrt":["\\t\\tReturn the non-negative square root of Float {expr} as a","\\t\\t|Float|.","\\t\\t{expr} must evaluate to a |Float| or a |Number|.  When {expr}","\\t\\tis negative the result is NaN (Not a Number).","\\t\\tExamples: >","\\t\\t\\t:echo sqrt(100)","<\\t\\t\\t10.0 >","\\t\\t\\t:echo sqrt(-4.01)","<\\t\\t\\tnan","\\t\\t\\"nan\\" may be different, it depends on system libraries.",""],"stdioopen":["\\t\\tIn a nvim launched with the |--headless| option, this opens","\\t\\tstdin and stdout as a |channel|. This function can only be","\\t\\tinvoked once per instance. See |channel-stdio| for more","\\t\\tinformation and examples. Note that stderr is not handled by","\\t\\tthis function, see |v:stderr|.","","\\t\\tReturns a |channel| ID. Close the stdio descriptors with |chanclose()|.","\\t\\tUse |chansend()| to send data to stdout, and","\\t\\t|rpcrequest()| and |rpcnotify()| to communicate over RPC.","","\\t\\t{opts} is a dictionary with these keys:","\\t\\t  |on_stdin| : callback invoked when stdin is written to.","\\t\\t  stdin_buffered : read stdin in |channel-buffered| mode.","\\t\\t  rpc      : If set, |msgpack-rpc| will be used to communicate","\\t\\t\\t     over stdio","\\t\\tReturns:","\\t\\t  - The channel ID on success (this is always 1)","\\t\\t  - 0 on invalid arguments",""],"stdpath":["\\t\\tReturns |standard-path| locations of various default files and","\\t\\tdirectories.","","\\t\\t{what}       Type    Description ~","\\t\\tcache        String  Cache directory. Arbitrary temporary","\\t\\t                     storage for plugins, etc.","\\t\\tconfig       String  User configuration directory. The","\\t\\t                     |init.vim| is stored here.","\\t\\tconfig_dirs  List    Additional configuration directories.","\\t\\tdata         String  User data directory. The |shada-file|","\\t\\t                     is stored here.","\\t\\tdata_dirs    List    Additional data directories.","","\\t\\tExample: >","\\t\\t\\t:echo stdpath(\\"config\\")",""],"str2float":["\\t\\tConvert String {expr} to a Float.  This mostly works the same","\\t\\tas when using a floating point number in an expression, see","\\t\\t|floating-point-format|.  But it\'s a bit more permissive.","\\t\\tE.g., \\"1e40\\" is accepted, while in an expression you need to","\\t\\twrite \\"1.0e40\\".  The hexadecimal form \\"0x123\\" is also","\\t\\taccepted, but not others, like binary or octal.","\\t\\tText after the number is silently ignored.","\\t\\tThe decimal point is always \'.\', no matter what the locale is","\\t\\tset to.  A comma ends the number: \\"12,345.67\\" is converted to","\\t\\t12.0.  You can strip out thousands separators with","\\t\\t|substitute()|: >","\\t\\t\\tlet f = str2float(substitute(text, \',\', \'\', \'g\'))"],"str2list":["\\t\\tReturn a list containing the number values which represent","\\t\\teach character in String {expr}.  Examples: >","\\t\\t\\tstr2list(\\" \\")\\t\\treturns [32]","\\t\\t\\tstr2list(\\"ABC\\")\\t\\treturns [65, 66, 67]","<\\t\\t|list2str()| does the opposite.","","\\t\\tWhen {utf8} is omitted or zero, the current \'encoding\' is used.","\\t\\tWith {utf8} set to 1, always treat the String as utf-8","\\t\\tcharacters.  With utf-8 composing characters are handled","\\t\\tproperly: >","\\t\\t\\tstr2list(\\"á\\")\\t\\treturns [97, 769]"],"str2nr":["\\t\\tConvert string {expr} to a number.","\\t\\t{base} is the conversion base, it can be 2, 8, 10 or 16.","\\t\\tWhen {base} is omitted base 10 is used.  This also means that","\\t\\ta leading zero doesn\'t cause octal conversion to be used, as","\\t\\twith the default String to Number conversion.","\\t\\tWhen {base} is 16 a leading \\"0x\\" or \\"0X\\" is ignored.  With a","\\t\\tdifferent base the result will be zero. Similarly, when {base}","\\t\\tis 8 a leading \\"0\\" is ignored, and when {base} is 2 a leading","\\t\\t\\"0b\\" or \\"0B\\" is ignored.","\\t\\tText after the number is silently ignored.",""],"strchars":["\\t\\tThe result is a Number, which is the number of characters","\\t\\tin String {expr}.","\\t\\tWhen {skipcc} is omitted or zero, composing characters are","\\t\\tcounted separately.","\\t\\tWhen {skipcc} set to 1, Composing characters are ignored.","\\t\\tAlso see |strlen()|, |strdisplaywidth()| and |strwidth()|.","","\\t\\t{skipcc} is only available after 7.4.755.  For backward","\\t\\tcompatibility, you can define a wrapper function: >","\\t\\t    if has(\\"patch-7.4.755\\")","\\t\\t      function s:strchars(str, skipcc)","\\t\\t\\treturn strchars(a:str, a:skipcc)","\\t\\t      endfunction","\\t\\t    else","\\t\\t      function s:strchars(str, skipcc)","\\t\\t\\tif a:skipcc","\\t\\t\\t  return strlen(substitute(a:str, \\".\\", \\"x\\", \\"g\\"))","\\t\\t\\telse","\\t\\t\\t  return strchars(a:str)","\\t\\t\\tendif","\\t\\t      endfunction","\\t\\t    endif"],"strcharpart":["\\t\\tLike |strpart()| but using character index and length instead","\\t\\tof byte index and length.","\\t\\tWhen a character index is used where a character does not","\\t\\texist it is assumed to be one character.  For example: >","\\t\\t\\tstrcharpart(\'abc\', -1, 2)","<\\t\\tresults in \'a\'."],"strdisplaywidth":["\\t\\tThe result is a Number, which is the number of display cells","\\t\\tString {expr} occupies on the screen when it starts at {col}","\\t\\t(first column is zero).  When {col} is omitted zero is used.","\\t\\tOtherwise it is the screen column where to start.  This","\\t\\tmatters for Tab characters.","\\t\\tThe option settings of the current window are used.  This","\\t\\tmatters for anything that\'s displayed differently, such as","\\t\\t\'tabstop\' and \'display\'.","\\t\\tWhen {expr} contains characters with East Asian Width Class","\\t\\tAmbiguous, this function\'s return value depends on \'ambiwidth\'.","\\t\\tAlso see |strlen()|, |strwidth()| and |strchars()|."],"strftime":["\\t\\tThe result is a String, which is a formatted date and time, as","\\t\\tspecified by the {format} string.  The given {time} is used,","\\t\\tor the current time if no time is given.  The accepted","\\t\\t{format} depends on your system, thus this is not portable!","\\t\\tSee the manual page of the C function strftime() for the","\\t\\tformat.  The maximum length of the result is 80 characters.","\\t\\tSee also |localtime()| and |getftime()|.","\\t\\tThe language can be changed with the |:language| command.","\\t\\tExamples: >","\\t\\t  :echo strftime(\\"%c\\")\\t\\t   Sun Apr 27 11:49:23 1997","\\t\\t  :echo strftime(\\"%Y %b %d %X\\")\\t   1997 Apr 27 11:53:25","\\t\\t  :echo strftime(\\"%y%m%d %T\\")\\t   970427 11:53:55","\\t\\t  :echo strftime(\\"%H:%M\\")\\t   11:55","\\t\\t  :echo strftime(\\"%c\\", getftime(\\"file.c\\"))","\\t\\t\\t\\t\\t\\t   Show mod time of file.c.","<\\t\\tNot available on all systems.  To check use: >","\\t\\t\\t:if exists(\\"*strftime\\")"],"strgetchar":["\\t\\tGet character {index} from {str}.  This uses a character","\\t\\tindex, not a byte index.  Composing characters are considered","\\t\\tseparate characters here.","\\t\\tAlso see |strcharpart()| and |strchars()|."],"stridx":["\\t\\tThe result is a Number, which gives the byte index in","\\t\\t{haystack} of the first occurrence of the String {needle}.","\\t\\tIf {start} is specified, the search starts at index {start}.","\\t\\tThis can be used to find a second match: >","\\t\\t\\t:let colon1 = stridx(line, \\":\\")","\\t\\t\\t:let colon2 = stridx(line, \\":\\", colon1 + 1)","<\\t\\tThe search is done case-sensitive.","\\t\\tFor pattern searches use |match()|.","\\t\\t-1 is returned if the {needle} does not occur in {haystack}.","\\t\\tSee also |strridx()|.","\\t\\tExamples: >","\\t\\t  :echo stridx(\\"An Example\\", \\"Example\\")\\t     3","\\t\\t  :echo stridx(\\"Starting point\\", \\"Start\\")    0","\\t\\t  :echo stridx(\\"Starting point\\", \\"start\\")   -1","<\\t\\t\\t\\t\\t\\t*strstr()* *strchr()*","\\t\\tstridx() works similar to the C function strstr().  When used","\\t\\twith a single character it works similar to strchr().",""],"string":["\\t\\tFloat, String or a composition of them, then the result can be","\\t\\tparsed back with |eval()|.","\\t\\t\\t{expr} type\\tresult ~","\\t\\t\\tString\\t\\t\'string\'","\\t\\t\\tNumber\\t\\t123","\\t\\t\\tFloat\\t\\t123.123456 or 1.123456e8 or","\\t\\t\\t\\t\\t`str2float(\'inf\')`","\\t\\t\\tFuncref\\t\\t`function(\'name\')`","\\t\\t\\tList\\t\\t[item, item]","\\t\\t\\tDictionary\\t{key: value, key: value}","\\t\\tNote that in String values the \' character is doubled.","\\t\\tAlso see |strtrans()|.","\\t\\tNote 2: Output format is mostly compatible with YAML, except","\\t\\tfor infinite and NaN floating-point values representations","\\t\\twhich use |str2float()|.  Strings are also dumped literally,","\\t\\tonly single quote is escaped, which does not allow using YAML","\\t\\tfor parsing back binary strings.  |eval()| should always work for","\\t\\tstrings and floats though and this is the only official","\\t\\tmethod, use |msgpackdump()| or |json_encode()| if you need to","\\t\\tshare data with other application.",""],"strlen":["\\t\\t{expr} in bytes.","\\t\\tIf the argument is a Number it is first converted to a String.","\\t\\tFor other types an error is given.","\\t\\tIf you want to count the number of multi-byte characters use","\\t\\t|strchars()|.","\\t\\tAlso see |len()|, |strdisplaywidth()| and |strwidth()|."],"strpart":["\\t\\tThe result is a String, which is part of {src}, starting from","\\t\\tbyte {start}, with the byte length {len}.","\\t\\tTo count characters instead of bytes use |strcharpart()|.","","\\t\\tWhen bytes are selected which do not exist, this doesn\'t","\\t\\tresult in an error, the bytes are simply omitted.","\\t\\tIf {len} is missing, the copy continues from {start} till the","\\t\\tend of the {src}. >","\\t\\t\\tstrpart(\\"abcdefg\\", 3, 2)    == \\"de\\"","\\t\\t\\tstrpart(\\"abcdefg\\", -2, 4)   == \\"ab\\"","\\t\\t\\tstrpart(\\"abcdefg\\", 5, 4)    == \\"fg\\"","\\t\\t\\tstrpart(\\"abcdefg\\", 3)\\t    == \\"defg\\"","","<\\t\\tNote: To get the first character, {start} must be 0.  For","\\t\\texample, to get three bytes under and after the cursor: >","\\t\\t\\tstrpart(getline(\\".\\"), col(\\".\\") - 1, 3)"],"strridx":["\\t\\tThe result is a Number, which gives the byte index in","\\t\\t{haystack} of the last occurrence of the String {needle}.","\\t\\tWhen {start} is specified, matches beyond this index are","\\t\\tignored.  This can be used to find a match before a previous","\\t\\tmatch: >","\\t\\t\\t:let lastcomma = strridx(line, \\",\\")","\\t\\t\\t:let comma2 = strridx(line, \\",\\", lastcomma - 1)","<\\t\\tThe search is done case-sensitive.","\\t\\tFor pattern searches use |match()|.","\\t\\t-1 is returned if the {needle} does not occur in {haystack}.","\\t\\tIf the {needle} is empty the length of {haystack} is returned.","\\t\\tSee also |stridx()|.  Examples: >","\\t\\t  :echo strridx(\\"an angry armadillo\\", \\"an\\")\\t     3","<\\t\\t\\t\\t\\t\\t\\t*strrchr()*","\\t\\tWhen used with a single character it works similar to the C","\\t\\tfunction strrchr()."],"strtrans":["\\t\\tThe result is a String, which is {expr} with all unprintable","\\t\\tcharacters translated into printable characters |\'isprint\'|.","\\t\\tLike they are shown in a window.  Example: >","\\t\\t\\techo strtrans(@a)","<\\t\\tThis displays a newline in register a as \\"^@\\" instead of","\\t\\tstarting a new line."],"strwidth":["\\t\\tThe result is a Number, which is the number of display cells","\\t\\tString {expr} occupies.  A Tab character is counted as one","\\t\\tcell, alternatively use |strdisplaywidth()|.","\\t\\tWhen {expr} contains characters with East Asian Width Class","\\t\\tAmbiguous, this function\'s return value depends on \'ambiwidth\'.","\\t\\tAlso see |strlen()|, |strdisplaywidth()| and |strchars()|."],"submatch":["\\t\\tOnly for an expression in a |:substitute| command or","\\t\\tsubstitute() function.","\\t\\tReturns the {nr}\'th submatch of the matched text.  When {nr}","\\t\\tis 0 the whole matched text is returned.","\\t\\tNote that a NL in the string can stand for a line break of a","\\t\\tmulti-line match or a NUL character in the text.","\\t\\tAlso see |sub-replace-expression|.","","\\t\\tIf {list} is present and non-zero then submatch() returns","\\t\\ta list of strings, similar to |getline()| with two arguments.","\\t\\tNL characters in the text represent NUL characters in the","\\t\\ttext.","\\t\\tOnly returns more than one item for |:substitute|, inside","\\t\\t|substitute()| this list will always contain one or zero","\\t\\titems, since there are no real line breaks.","","\\t\\tWhen substitute() is used recursively only the submatches in","\\t\\tthe current (deepest) call can be obtained.","","\\t\\tExamples: >","\\t\\t\\t:s/\\\\d\\\\+/\\\\=submatch(0) + 1/","\\t\\t\\t:echo substitute(text, \'\\\\d\\\\+\', \'\\\\=submatch(0) + 1\', \'\')","<\\t\\tThis finds the first number in the line and adds one to it.","\\t\\tA line break is included as a newline character."],"substitute":["\\t\\tThe result is a String, which is a copy of {expr}, in which","\\t\\tthe first match of {pat} is replaced with {sub}.","\\t\\tWhen {flags} is \\"g\\", all matches of {pat} in {expr} are","\\t\\treplaced.  Otherwise {flags} should be \\"\\".","","\\t\\tThis works like the \\":substitute\\" command (without any flags).","\\t\\tBut the matching with {pat} is always done like the \'magic\'","\\t\\toption is set and \'cpoptions\' is empty (to make scripts","\\t\\tportable).  \'ignorecase\' is still relevant, use |/\\\\c| or |/\\\\C|","\\t\\tif you want to ignore or match case and ignore \'ignorecase\'.","\\t\\t\'smartcase\' is not used.  See |string-match| for how {pat} is","\\t\\tused.","","\\t\\tA \\"~\\" in {sub} is not replaced with the previous {sub}.","\\t\\tNote that some codes in {sub} have a special meaning","\\t\\t|sub-replace-special|.  For example, to replace something with","\\t\\t\\"\\\\n\\" (two characters), use \\"\\\\\\\\\\\\\\\\n\\" or \'\\\\\\\\n\'.","","\\t\\tWhen {pat} does not match in {expr}, {expr} is returned","\\t\\tunmodified.","","\\t\\tExample: >","\\t\\t\\t:let &path = substitute(&path, \\",\\\\\\\\=[^,]*$\\", \\"\\", \\"\\")","<\\t\\tThis removes the last component of the \'path\' option. >","\\t\\t\\t:echo substitute(\\"testing\\", \\".*\\", \\"\\\\\\\\U\\\\\\\\0\\", \\"\\")","<\\t\\tresults in \\"TESTING\\".","","\\t\\tWhen {sub} starts with \\"\\\\=\\", the remainder is interpreted as","\\t\\tan expression. See |sub-replace-expression|.  Example: >","\\t\\t\\t:echo substitute(s, \'%\\\\(\\\\x\\\\x\\\\)\',","\\t\\t\\t   \\\\ \'\\\\=nr2char(\\"0x\\" . submatch(1))\', \'g\')","","<\\t\\tWhen {sub} is a Funcref that function is called, with one","\\t\\toptional argument.  Example: >","\\t\\t   :echo substitute(s, \'%\\\\(\\\\x\\\\x\\\\)\', SubNr, \'g\')","<\\t\\tThe optional argument is a list which contains the whole","\\t\\tmatched string and up to nine submatches, like what","\\t\\t|submatch()| returns.  Example: >","\\t\\t   :echo substitute(s, \'%\\\\(\\\\x\\\\x\\\\)\', {m -> \'0x\' . m[1]}, \'g\')"],"swapinfo":["\\t\\tThe result is a dictionary, which holds information about the","\\t\\tswapfile {fname}. The available fields are:","\\t\\t\\tversion VIM version","\\t\\t\\tuser\\tuser name","\\t\\t\\thost\\thost name","\\t\\t\\tfname\\toriginal file name","\\t\\t\\tpid\\tPID of the VIM process that created the swap","\\t\\t\\t\\tfile","\\t\\t\\tmtime\\tlast modification time in seconds","\\t\\t\\tinode\\tOptional: INODE number of the file","\\t\\t\\tdirty\\t1 if file was modified, 0 if not","\\t\\tIn case of failure an \\"error\\" item is added with the reason:","\\t\\t\\tCannot open file: file not found or in accessible","\\t\\t\\tCannot read file: cannot read first block","\\t\\t\\tNot a swap file: does not contain correct block ID","\\t\\t\\tMagic number mismatch: Info in first block is invalid"],"swapname":["\\t\\tThe result is the swap file path of the buffer {expr}.","\\t\\tFor the use of {expr}, see |bufname()| above.","\\t\\tIf buffer {expr} is the current buffer, the result is equal to","\\t\\t|:swapname| (unless no swap file).","\\t\\tIf buffer {expr} has no swap file, returns an empty string."],"synID":["\\t\\tThe result is a Number, which is the syntax ID at the position","\\t\\t{lnum} and {col} in the current window.","\\t\\tThe syntax ID can be used with |synIDattr()| and","\\t\\t|synIDtrans()| to obtain syntax information about text.","","\\t\\t{col} is 1 for the leftmost column, {lnum} is 1 for the first","\\t\\tline.  \'synmaxcol\' applies, in a longer line zero is returned.","\\t\\tNote that when the position is after the last character,","\\t\\tthat\'s where the cursor can be in Insert mode, synID() returns","\\t\\tzero.","","\\t\\tWhen {trans} is |TRUE|, transparent items are reduced to the","\\t\\titem that they reveal.  This is useful when wanting to know","\\t\\tthe effective color.  When {trans} is |FALSE|, the transparent","\\t\\titem is returned.  This is useful when wanting to know which","\\t\\tsyntax item is effective (e.g. inside parens).","\\t\\tWarning: This function can be very slow.  Best speed is","\\t\\tobtained by going through the file in forward direction.","","\\t\\tExample (echoes the name of the syntax item under the cursor): >","\\t\\t\\t:echo synIDattr(synID(line(\\".\\"), col(\\".\\"), 1), \\"name\\")","<"],"synIDattr":["\\t\\tThe result is a String, which is the {what} attribute of","\\t\\tsyntax ID {synID}.  This can be used to obtain information","\\t\\tabout a syntax item.","\\t\\t{mode} can be \\"gui\\", \\"cterm\\" or \\"term\\", to get the attributes","\\t\\tfor that mode.  When {mode} is omitted, or an invalid value is","\\t\\tused, the attributes for the currently active highlighting are","\\t\\tused (GUI, cterm or term).","\\t\\tUse synIDtrans() to follow linked highlight groups.","\\t\\t{what}\\t\\tresult","\\t\\t\\"name\\"\\t\\tthe name of the syntax item","\\t\\t\\"fg\\"\\t\\tforeground color (GUI: color name used to set","\\t\\t\\t\\tthe color, cterm: color number as a string,","\\t\\t\\t\\tterm: empty string)","\\t\\t\\"bg\\"\\t\\tbackground color (as with \\"fg\\")","\\t\\t\\"font\\"\\t\\tfont name (only available in the GUI)","\\t\\t\\t\\t|highlight-font|","\\t\\t\\"sp\\"\\t\\tspecial color (as with \\"fg\\") |highlight-guisp|","\\t\\t\\"fg#\\"\\t\\tlike \\"fg\\", but for the GUI and the GUI is","\\t\\t\\t\\trunning the name in \\"#RRGGBB\\" form","\\t\\t\\"bg#\\"\\t\\tlike \\"fg#\\" for \\"bg\\"","\\t\\t\\"sp#\\"\\t\\tlike \\"fg#\\" for \\"sp\\"","\\t\\t\\"bold\\"\\t\\t\\"1\\" if bold","\\t\\t\\"italic\\"\\t\\"1\\" if italic","\\t\\t\\"reverse\\"\\t\\"1\\" if reverse","\\t\\t\\"inverse\\"\\t\\"1\\" if inverse (= reverse)","\\t\\t\\"standout\\"\\t\\"1\\" if standout","\\t\\t\\"underline\\"\\t\\"1\\" if underlined","\\t\\t\\"undercurl\\"\\t\\"1\\" if undercurled","\\t\\t\\"strikethrough\\"\\t\\"1\\" if struckthrough","","\\t\\tExample (echoes the color of the syntax item under the","\\t\\tcursor): >","\\t:echo synIDattr(synIDtrans(synID(line(\\".\\"), col(\\".\\"), 1)), \\"fg\\")"],"synIDtrans":["\\t\\tThe result is a Number, which is the translated syntax ID of","\\t\\t{synID}.  This is the syntax group ID of what is being used to","\\t\\thighlight the character.  Highlight links given with","\\t\\t\\":highlight link\\" are followed."],"synconcealed":["\\t\\tThe result is a List with currently three items:","\\t\\t1. The first item in the list is 0 if the character at the","\\t\\t   position {lnum} and {col} is not part of a concealable","\\t\\t   region, 1 if it is.","\\t\\t2. The second item in the list is a string. If the first item","\\t\\t   is 1, the second item contains the text which will be","\\t\\t   displayed in place of the concealed text, depending on the","\\t\\t   current setting of \'conceallevel\' and \'listchars\'.","\\t\\t3. The third and final item in the list is a number","\\t\\t   representing the specific syntax region matched in the","\\t\\t   line. When the character is not concealed the value is","\\t\\t   zero. This allows detection of the beginning of a new","\\t\\t   concealable region if there are two consecutive regions","\\t\\t   with the same replacement character.  For an example, if","\\t\\t   the text is \\"123456\\" and both \\"23\\" and \\"45\\" are concealed","\\t\\t   and replaced by the character \\"X\\", then:","\\t\\t\\tcall\\t\\t\\treturns ~","\\t\\t   \\tsynconcealed(lnum, 1)   [0, \'\', 0]","\\t\\t   \\tsynconcealed(lnum, 2)   [1, \'X\', 1]","\\t\\t   \\tsynconcealed(lnum, 3)   [1, \'X\', 1]","\\t\\t   \\tsynconcealed(lnum, 4)   [1, \'X\', 2]","\\t\\t   \\tsynconcealed(lnum, 5)   [1, \'X\', 2]","\\t\\t   \\tsynconcealed(lnum, 6)   [0, \'\', 0]",""],"synstack":["\\t\\tReturn a |List|, which is the stack of syntax items at the","\\t\\tposition {lnum} and {col} in the current window.  Each item in","\\t\\tthe List is an ID like what |synID()| returns.","\\t\\tThe first item in the List is the outer region, following are","\\t\\titems contained in that one.  The last one is what |synID()|","\\t\\treturns, unless not the whole item is highlighted or it is a","\\t\\ttransparent item.","\\t\\tThis function is useful for debugging a syntax file.","\\t\\tExample that shows the syntax stack under the cursor: >","\\t\\t\\tfor id in synstack(line(\\".\\"), col(\\".\\"))","\\t\\t\\t   echo synIDattr(id, \\"name\\")","\\t\\t\\tendfor","<\\t\\tWhen the position specified with {lnum} and {col} is invalid","\\t\\tnothing is returned.  The position just after the last","\\t\\tcharacter in a line and the first column in an empty line are","\\t\\tvalid positions."],"system":["\\t\\tGet the output of {cmd} as a |string| (use |systemlist()| to","\\t\\tget a |List|). {cmd} is treated exactly as in |jobstart()|.","\\t\\tNot to be used for interactive commands.","","\\t\\tIf {input} is a string it is written to a pipe and passed as","\\t\\tstdin to the command.  The string is written as-is, line","\\t\\tseparators are not changed.","\\t\\tIf {input} is a |List| it is written to the pipe as","\\t\\t|writefile()| does with {binary} set to \\"b\\" (i.e. with","\\t\\ta newline between each list item, and newlines inside list","\\t\\titems converted to NULs).","\\t\\tWhen {input} is given and is a valid buffer id, the content of","\\t\\tthe buffer is written to the file line by line, each line","\\t\\tterminated by NL (and NUL where the text has NL).","\\t\\t\\t\\t\\t\\t\\t\\t*E5677*","\\t\\tNote: system() cannot write to or read from backgrounded (\\"&\\")","\\t\\tshell commands, e.g.: >","\\t\\t    :echo system(\\"cat - &\\", \\"foo\\"))","<\\t\\twhich is equivalent to: >","\\t\\t    $ echo foo | bash -c \'cat - &\'","<\\t\\tThe pipes are disconnected (unless overridden by shell","\\t\\tredirection syntax) before input can reach it. Use","\\t\\t|jobstart()| instead.","","\\t\\tNote: Use |shellescape()| or |::S| with |expand()| or","\\t\\t|fnamemodify()| to escape special characters in a command","\\t\\targument.  Newlines in {cmd} may cause the command to fail. ","\\t\\tThe characters in \'shellquote\' and \'shellxquote\' may also","\\t\\tcause trouble.","","\\t\\tResult is a String.  Example: >","\\t\\t    :let files = system(\\"ls \\" .  shellescape(expand(\'%:h\')))","\\t\\t    :let files = system(\'ls \' . expand(\'%:h:S\'))","","<\\t\\tTo make the result more system-independent, the shell output","\\t\\tis filtered to replace <CR> with <NL> for Macintosh, and","\\t\\t<CR><NL> with <NL> for DOS-like systems.","\\t\\tTo avoid the string being truncated at a NUL, all NUL","\\t\\tcharacters are replaced with SOH (0x01).","","\\t\\tThe command executed is constructed using several options when","\\t\\t{cmd} is a string: \'shell\' \'shellcmdflag\' {cmd}","","\\t\\tThe resulting error code can be found in |v:shell_error|.","\\t\\tThis function will fail in |restricted-mode|.","","\\t\\tNote that any wrong value in the options mentioned above may","\\t\\tmake the function fail.  It has also been reported to fail","\\t\\twhen using a security agent application.","\\t\\tUnlike \\":!cmd\\" there is no automatic check for changed files.","\\t\\tUse |:checktime| to force a check.",""],"systemlist":["\\t\\tSame as |system()|, but returns a |List| with lines (parts of","\\t\\toutput separated by NL) with NULs transformed into NLs. Output","\\t\\tis the same as |readfile()| will output with {binary} argument","\\t\\tset to \\"b\\", except that a final newline is not preserved,","\\t\\tunless {keepempty} is non-zero.","\\t\\tNote that on MS-Windows you may get trailing CR characters.","","\\t\\tReturns an empty string on error.",""],"tabpagebuflist":["\\t\\tThe result is a |List|, where each item is the number of the","\\t\\tbuffer associated with each window in the current tab page.","\\t\\t{arg} specifies the number of the tab page to be used. When","\\t\\tomitted the current tab page is used.","\\t\\tWhen {arg} is invalid the number zero is returned.","\\t\\tTo get a list of all buffers in all tabs use this: >","\\t\\t\\tlet buflist = []","\\t\\t\\tfor i in range(tabpagenr(\'$\'))","\\t\\t\\t   call extend(buflist, tabpagebuflist(i + 1))","\\t\\t\\tendfor","<\\t\\tNote that a buffer may appear in more than one window.",""],"tabpagenr":["\\t\\tThe result is a Number, which is the number of the current","\\t\\ttab page.  The first tab page has number 1.","\\t\\tThe optional argument {arg} supports the following values:","\\t\\t\\t$\\tthe number of the last tab page (the tab page","\\t\\t\\t\\tcount).","\\t\\t\\t#\\tthe number of the last accessed tab page (where","\\t\\t\\t\\t|g<Tab>| goes to).  If there is no previous","\\t\\t\\t\\ttab page, 0 is returned.","\\t\\tThe number can be used with the |:tab| command.",""],"tabpagewinnr":["\\t\\tLike |winnr()| but for tab page {tabarg}.","\\t\\t{tabarg} specifies the number of tab page to be used.","\\t\\t{arg} is used like with |winnr()|:","\\t\\t- When omitted the current window number is returned.  This is","\\t\\t  the window which will be used when going to this tab page.","\\t\\t- When \\"$\\" the number of windows is returned.","\\t\\t- When \\"#\\" the previous window nr is returned.","\\t\\tUseful examples: >","\\t\\t    tabpagewinnr(1)\\t    \\" current window of tab page 1","\\t\\t    tabpagewinnr(4, \'$\')    \\" number of windows in tab page 4","<\\t\\tWhen {tabarg} is invalid zero is returned.",""],"tagfiles":["\\t\\tfor the current buffer.  This is the \'tags\' option expanded.",""],"taglist":["\\t\\tReturns a list of tags matching the regular expression {expr}.","","\\t\\tIf {filename} is passed it is used to prioritize the results","\\t\\tin the same way that |:tselect| does. See |tag-priority|.","\\t\\t{filename} should be the full path of the file.","","\\t\\tEach list item is a dictionary with at least the following","\\t\\tentries:","\\t\\t\\tname\\t\\tName of the tag.","\\t\\t\\tfilename\\tName of the file where the tag is","\\t\\t\\t\\t\\tdefined.  It is either relative to the","\\t\\t\\t\\t\\tcurrent directory or a full path.","\\t\\t\\tcmd\\t\\tEx command used to locate the tag in","\\t\\t\\t\\t\\tthe file.","\\t\\t\\tkind\\t\\tType of the tag.  The value for this","\\t\\t\\t\\t\\tentry depends on the language specific","\\t\\t\\t\\t\\tkind values.  Only available when","\\t\\t\\t\\t\\tusing a tags file generated by","\\t\\t\\t\\t\\tExuberant ctags or hdrtag.","\\t\\t\\tstatic\\t\\tA file specific tag.  Refer to","\\t\\t\\t\\t\\t|static-tag| for more information.","\\t\\tMore entries may be present, depending on the content of the","\\t\\ttags file: access, implementation, inherits and signature.","\\t\\tRefer to the ctags documentation for information about these","\\t\\tfields.  For C code the fields \\"struct\\", \\"class\\" and \\"enum\\"","\\t\\tmay appear, they give the name of the entity the tag is","\\t\\tcontained in.","","\\t\\tThe ex-command \\"cmd\\" can be either an ex search pattern, a","\\t\\tline number or a line number followed by a byte number.","","\\t\\tIf there are no matching tags, then an empty list is returned.","","\\t\\tTo get an exact tag match, the anchors \'^\' and \'$\' should be","\\t\\tused in {expr}.  This also make the function work faster.","\\t\\tRefer to |tag-regexp| for more information about the tag","\\t\\tsearch regular expression pattern.","","\\t\\tRefer to |\'tags\'| for information about how the tags file is","\\t\\tlocated by Vim. Refer to |tags-file-format| for the format of","\\t\\tthe tags file generated by the different ctags tools."],"tempname":["\\t\\tThe result is a String, which is the name of a file that","\\t\\tdoesn\'t exist.  It can be used for a temporary file.  Example: >","\\t\\t\\t:let tmpfile = tempname()","\\t\\t\\t:exe \\"redir > \\" . tmpfile","<\\t\\tFor Unix, the file will be in a private directory |tempfile|.","\\t\\tFor MS-Windows forward slashes are used when the \'shellslash\'","\\t\\toption is set or when \'shellcmdflag\' starts with \'-\'."],"termopen":["\\t\\tSpawns {cmd} in a new pseudo-terminal session connected","\\t\\tto the current buffer.  {cmd} is the same as the one passed to","\\t\\t|jobstart()|.  This function fails if the current buffer is","\\t\\tmodified (all buffer contents are destroyed).","","\\t\\tThe {opts} dict is similar to the one passed to |jobstart()|,","\\t\\tbut the `pty`, `width`, `height`, and `TERM` fields are","\\t\\tignored: `height`/`width` are taken from the current window","\\t\\tand `$TERM` is set to \\"xterm-256color\\".","\\t\\tReturns the same values as |jobstart()|.","","\\t\\tSee |terminal| for more information."],"test_garbagecollect_now":["\\t\\tLike |garbagecollect()|, but executed right away.  This must","\\t\\tonly be called directly to avoid any structure to exist","\\t\\tinternally, and |v:testing| must have been set before calling","\\t\\tany function."],"tan":["\\t\\tReturn the tangent of {expr}, measured in radians, as a |Float|","\\t\\tin the range [-inf, inf].","\\t\\t{expr} must evaluate to a |Float| or a |Number|.","\\t\\tExamples: >","\\t\\t\\t:echo tan(10)","<\\t\\t\\t0.648361 >","\\t\\t\\t:echo tan(-4.01)","<\\t\\t\\t-1.181502",""],"tanh":["\\t\\tReturn the hyperbolic tangent of {expr} as a |Float| in the","\\t\\trange [-1, 1].","\\t\\t{expr} must evaluate to a |Float| or a |Number|.","\\t\\tExamples: >","\\t\\t\\t:echo tanh(0.5)","<\\t\\t\\t0.462117 >","\\t\\t\\t:echo tanh(-1)","<\\t\\t\\t-0.761594","",""],"timer_info":["\\t\\tReturn a list with information about timers.","\\t\\tWhen {id} is given only information about this timer is","\\t\\treturned.  When timer {id} does not exist an empty list is","\\t\\treturned.","\\t\\tWhen {id} is omitted information about all timers is returned.","","\\t\\tFor each timer the information is stored in a Dictionary with","\\t\\tthese items:","\\t\\t    \\"id\\"\\t    the timer ID","\\t\\t    \\"time\\"\\t    time the timer was started with","\\t\\t    \\"repeat\\"\\t    number of times the timer will still fire;","\\t\\t\\t\\t    -1 means forever","\\t\\t    \\"callback\\"\\t    the callback"],"timer_pause":["\\t\\tPause or unpause a timer.  A paused timer does not invoke its","\\t\\tcallback when its time expires.  Unpausing a timer may cause","\\t\\tthe callback to be invoked almost immediately if enough time","\\t\\thas passed.","","\\t\\tPausing a timer is useful to avoid the callback to be called","\\t\\tfor a short time.","","\\t\\tIf {paused} evaluates to a non-zero Number or a non-empty","\\t\\tString, then the timer is paused, otherwise it is unpaused.","\\t\\tSee |non-zero-arg|.",""],"timer_start":["\\t\\tCreate a timer and return the timer ID.","","\\t\\t{time} is the waiting time in milliseconds. This is the","\\t\\tminimum time before invoking the callback.  When the system is","\\t\\tbusy or Vim is not waiting for input the time will be longer.","","\\t\\t{callback} is the function to call.  It can be the name of a","\\t\\tfunction or a |Funcref|.  It is called with one argument, which","\\t\\tis the timer ID.  The callback is only invoked when Vim is","\\t\\twaiting for input.","","\\t\\t{options} is a dictionary.  Supported entries:","\\t\\t   \\"repeat\\"\\tNumber of times to repeat the callback.","\\t\\t\\t\\t-1 means forever.  Default is 1.","\\t\\t\\t\\tIf the timer causes an error three times in a","\\t\\t\\t\\trow the repeat is cancelled.","","\\t\\tExample: >","\\t\\t\\tfunc MyHandler(timer)","\\t\\t\\t  echo \'Handler called\'","\\t\\t\\tendfunc","\\t\\t\\tlet timer = timer_start(500, \'MyHandler\',","\\t\\t\\t\\t\\\\ {\'repeat\': 3})","<\\t\\tThis invokes MyHandler() three times at 500 msec intervals."],"timer_stop":["\\t\\tStop a timer.  The timer callback will no longer be invoked.","\\t\\t{timer} is an ID returned by timer_start(), thus it must be a","\\t\\tNumber.  If {timer} does not exist there is no error."],"timer_stopall":["\\t\\tStop all timers.  The timer callbacks will no longer be","\\t\\tinvoked.  Useful if some timers is misbehaving.  If there are","\\t\\tno timers there is no error."],"tolower":["\\t\\tThe result is a copy of the String given, with all uppercase","\\t\\tcharacters turned into lowercase (just like applying |gu| to","\\t\\tthe string)."],"toupper":["\\t\\tThe result is a copy of the String given, with all lowercase","\\t\\tcharacters turned into uppercase (just like applying |gU| to","\\t\\tthe string)."],"tr":["\\t\\tThe result is a copy of the {src} string with all characters","\\t\\twhich appear in {fromstr} replaced by the character in that","\\t\\tposition in the {tostr} string.  Thus the first character in","\\t\\t{fromstr} is translated into the first character in {tostr}","\\t\\tand so on.  Exactly like the unix \\"tr\\" command.","\\t\\tThis code also deals with multibyte characters properly.","","\\t\\tExamples: >","\\t\\t\\techo tr(\\"hello there\\", \\"ht\\", \\"HT\\")","<\\t\\treturns \\"Hello THere\\" >","\\t\\t\\techo tr(\\"<blob>\\", \\"<>\\", \\"{}\\")","<\\t\\treturns \\"{blob}\\""],"trim":["\\t\\tReturn {text} as a String where any character in {mask} is","\\t\\tremoved from the beginning and  end of {text}.","\\t\\tIf {mask} is not given, {mask} is all characters up to 0x20,","\\t\\twhich includes Tab, space, NL and CR, plus the non-breaking","\\t\\tspace character 0xa0.","\\t\\tThis code deals with multibyte characters properly.","","\\t\\tExamples: >","\\t\\t\\techo trim(\\"   some text \\")","<\\t\\treturns \\"some text\\" >","\\t\\t\\techo trim(\\"  \\\\r\\\\t\\\\t\\\\r RESERVE \\\\t\\\\n\\\\x0B\\\\xA0\\") . \\"_TAIL\\"","<\\t\\treturns \\"RESERVE_TAIL\\" >","\\t\\t\\techo trim(\\"rm<Xrm<>X>rrm\\", \\"rm<>\\")","<\\t\\treturns \\"Xrm<>X\\" (characters in the middle are not removed)"],"trunc":["\\t\\tReturn the largest integral value with magnitude less than or","\\t\\tequal to {expr} as a |Float| (truncate towards zero).","\\t\\t{expr} must evaluate to a |Float| or a |Number|.","\\t\\tExamples: >","\\t\\t\\techo trunc(1.456)","<\\t\\t\\t1.0  >","\\t\\t\\techo trunc(-5.456)","<\\t\\t\\t-5.0  >","\\t\\t\\techo trunc(4.0)","<\\t\\t\\t4.0"],"type":["\\t\\tThe result is a Number representing the type of {expr}.","\\t\\tInstead of using the number directly, it is better to use the","\\t\\tv:t_ variable that has the value:","\\t\\t        Number:     0 (|v:t_number|)","\\t\\t\\tString:     1 (|v:t_string|)","\\t\\t\\tFuncref:    2 (|v:t_func|)","\\t\\t\\tList:       3 (|v:t_list|)","\\t\\t\\tDictionary: 4 (|v:t_dict|)","\\t\\t\\tFloat:      5 (|v:t_float|)","\\t\\t\\tBoolean:    6 (|v:true| and |v:false|)","\\t\\t\\tNull:       7 (|v:null|)","\\t\\tFor backward compatibility, this method can be used: >","\\t\\t\\t:if type(myvar) == type(0)","\\t\\t\\t:if type(myvar) == type(\\"\\")","\\t\\t\\t:if type(myvar) == type(function(\\"tr\\"))","\\t\\t\\t:if type(myvar) == type([])","\\t\\t\\t:if type(myvar) == type({})","\\t\\t\\t:if type(myvar) == type(0.0)","\\t\\t\\t:if type(myvar) == type(v:true)","<\\t\\tIn place of checking for |v:null| type it is better to check","\\t\\tfor |v:null| directly as it is the only value of this type: >","\\t\\t\\t:if myvar is v:null","<               To check if the v:t_ variables exist use this: >","                        :if exists(\'v:t_number\')"],"undofile":["\\t\\tReturn the name of the undo file that would be used for a file","\\t\\twith name {name} when writing.  This uses the \'undodir\'","\\t\\toption, finding directories that exist.  It does not check if","\\t\\tthe undo file exists.","\\t\\t{name} is always expanded to the full path, since that is what","\\t\\tis used internally.","\\t\\tIf {name} is empty undofile() returns an empty string, since a","\\t\\tbuffer without a file name will not write an undo file.","\\t\\tUseful in combination with |:wundo| and |:rundo|.","\\t\\tWhen compiled without the |+persistent_undo| option this always","\\t\\treturns an empty string."],"undotree":["\\t\\tReturn the current state of the undo tree in a dictionary with","\\t\\tthe following items:","\\t\\t  \\"seq_last\\"\\tThe highest undo sequence number used.","\\t\\t  \\"seq_cur\\"\\tThe sequence number of the current position in","\\t\\t\\t\\tthe undo tree.  This differs from \\"seq_last\\"","\\t\\t\\t\\twhen some changes were undone.","\\t\\t  \\"time_cur\\"\\tTime last used for |:earlier| and related","\\t\\t\\t\\tcommands.  Use |strftime()| to convert to","\\t\\t\\t\\tsomething readable.","\\t\\t  \\"save_last\\"\\tNumber of the last file write.  Zero when no","\\t\\t\\t\\twrite yet.","\\t\\t  \\"save_cur\\"\\tNumber of the current position in the undo","\\t\\t\\t\\ttree.","\\t\\t  \\"synced\\"\\tNon-zero when the last undo block was synced.","\\t\\t\\t\\tThis happens when waiting from input from the","\\t\\t\\t\\tuser.  See |undo-blocks|.","\\t\\t  \\"entries\\"\\tA list of dictionaries with information about","\\t\\t\\t\\tundo blocks.","","\\t\\tThe first item in the \\"entries\\" list is the oldest undo item.","\\t\\tEach List item is a Dictionary with these items:","\\t\\t  \\"seq\\"\\t\\tUndo sequence number.  Same as what appears in","\\t\\t\\t\\t|:undolist|.","\\t\\t  \\"time\\"\\tTimestamp when the change happened.  Use","\\t\\t\\t\\t|strftime()| to convert to something readable.","\\t\\t  \\"newhead\\"\\tOnly appears in the item that is the last one","\\t\\t\\t\\tthat was added.  This marks the last change","\\t\\t\\t\\tand where further changes will be added.","\\t\\t  \\"curhead\\"\\tOnly appears in the item that is the last one","\\t\\t\\t\\tthat was undone.  This marks the current","\\t\\t\\t\\tposition in the undo tree, the block that will","\\t\\t\\t\\tbe used by a redo command.  When nothing was","\\t\\t\\t\\tundone after the last change this item will","\\t\\t\\t\\tnot appear anywhere.","\\t\\t  \\"save\\"\\tOnly appears on the last block before a file","\\t\\t\\t\\twrite.  The number is the write count.  The","\\t\\t\\t\\tfirst write has number 1, the last one the","\\t\\t\\t\\t\\"save_last\\" mentioned above.","\\t\\t  \\"alt\\"\\t\\tAlternate entry.  This is again a List of undo","\\t\\t\\t\\tblocks.  Each item may again have an \\"alt\\"","\\t\\t\\t\\titem."],"uniq":["\\t\\tRemove second and succeeding copies of repeated adjacent","\\t\\t{list} items in-place.  Returns {list}.  If you want a list","\\t\\tto remain unmodified make a copy first: >","\\t\\t\\t:let newlist = uniq(copy(mylist))","<\\t\\tThe default compare function uses the string representation of","\\t\\teach item.  For the use of {func} and {dict} see |sort()|."],"values":["\\t\\tReturn a |List| with all the values of {dict}.  The |List| is","\\t\\tin arbitrary order.",""],"virtcol":["\\t\\tThe result is a Number, which is the screen column of the file","\\t\\tposition given with {expr}.  That is, the last screen position","\\t\\toccupied by the character at that position, when the screen","\\t\\twould be of unlimited width.  When there is a <Tab> at the","\\t\\tposition, the returned Number will be the column at the end of","\\t\\tthe <Tab>.  For example, for a <Tab> in column 1, with \'ts\'","\\t\\tset to 8, it returns 8. |conceal| is ignored.","\\t\\tFor the byte position use |col()|.","\\t\\tFor the use of {expr} see |col()|.","\\t\\tWhen \'virtualedit\' is used {expr} can be [lnum, col, off], where","\\t\\t\\"off\\" is the offset in screen columns from the start of the","\\t\\tcharacter.  E.g., a position within a <Tab> or after the last","\\t\\tcharacter.  When \\"off\\" is omitted zero is used.","\\t\\tWhen Virtual editing is active in the current mode, a position","\\t\\tbeyond the end of the line can be returned. |\'virtualedit\'|","\\t\\tThe accepted positions are:","\\t\\t    .\\t    the cursor position","\\t\\t    $\\t    the end of the cursor line (the result is the","\\t\\t\\t    number of displayed characters in the cursor line","\\t\\t\\t    plus one)","\\t\\t    \'x\\t    position of mark x (if the mark is not set, 0 is","\\t\\t\\t    returned)","\\t\\t    v       In Visual mode: the start of the Visual area (the","\\t\\t\\t    cursor is the end).  When not in Visual mode","\\t\\t\\t    returns the cursor position.  Differs from |\'<| in","\\t\\t\\t    that it\'s updated right away.","\\t\\tNote that only marks in the current file can be used.","\\t\\tExamples: >","  virtcol(\\".\\")\\t   with text \\"foo^Lbar\\", with cursor on the \\"^L\\", returns 5","  virtcol(\\"$\\")\\t   with text \\"foo^Lbar\\", returns 9","  virtcol(\\"\'t\\")    with text \\"\\t  there\\", with \'t at \'h\', returns 6","<\\t\\tThe first column is 1.  0 is returned for an error.","\\t\\tA more advanced example that echoes the maximum length of","\\t\\tall lines: >","\\t\\t    echo max(map(range(1, line(\'$\')), \\"virtcol([v:val, \'$\'])\\"))",""],"visualmode":["\\t\\tThe result is a String, which describes the last Visual mode","\\t\\tused in the current buffer.  Initially it returns an empty","\\t\\tstring, but once Visual mode has been used, it returns \\"v\\",","\\t\\t\\"V\\", or \\"<CTRL-V>\\" (a single CTRL-V character) for","\\t\\tcharacter-wise, line-wise, or block-wise Visual mode","\\t\\trespectively.","\\t\\tExample: >","\\t\\t\\t:exe \\"normal \\" . visualmode()","<\\t\\tThis enters the same Visual mode as before.  It is also useful","\\t\\tin scripts if you wish to act differently depending on the","\\t\\tVisual mode that was used.","\\t\\tIf Visual mode is active, use |mode()| to get the Visual mode","\\t\\t(e.g., in a |:vmap|).","\\t\\tIf [expr] is supplied and it evaluates to a non-zero Number or","\\t\\ta non-empty String, then the Visual mode will be cleared and","\\t\\tthe old value is returned.  See |non-zero-arg|."],"wait":["\\t\\tWaits until {condition} evaluates to |TRUE|, where {condition}","\\t\\tis a |Funcref| or |string| containing an expression.","","\\t\\t{timeout} is the maximum waiting time in milliseconds, -1","\\t\\tmeans forever.","","\\t\\tCondition is evaluated on user events, internal events, and","\\t\\tevery {interval} milliseconds (default: 200).","","\\t\\tReturns a status integer:","\\t\\t\\t0 if the condition was satisfied before timeout","\\t\\t\\t-1 if the timeout was exceeded","\\t\\t\\t-2 if the function was interrupted (by |CTRL-C|)","\\t\\t\\t-3 if an error occurred"],"wildmenumode":["\\t\\tReturns |TRUE| when the wildmenu is active and |FALSE|","\\t\\totherwise.  See \'wildmenu\' and \'wildmode\'.","\\t\\tThis can be used in mappings to handle the \'wildcharm\' option","\\t\\tgracefully. (Makes only sense with |mapmode-c| mappings).","","\\t\\tFor example to make <c-j> work like <down> in wildmode, use: >","    :cnoremap <expr> <C-j> wildmenumode() ? \\"\\\\<Down>\\\\<Tab>\\" : \\"\\\\<c-j>\\"","<","\\t\\t(Note, this needs the \'wildcharm\' option set appropriately).",""],"win_findbuf":["\\t\\tReturns a list with |window-ID|s for windows that contain","\\t\\tbuffer {bufnr}.  When there is none the list is empty."],"win_getid":["\\t\\tGet the |window-ID| for the specified window.","\\t\\tWhen {win} is missing use the current window.","\\t\\tWith {win} this is the window number.  The top window has","\\t\\tnumber 1.","\\t\\tWithout {tab} use the current tab, otherwise the tab with","\\t\\tnumber {tab}.  The first tab has number one.","\\t\\tReturn zero if the window cannot be found."],"win_gotoid":["\\t\\tGo to window with ID {expr}.  This may also change the current","\\t\\ttabpage.","\\t\\tReturn 1 if successful, 0 if the window cannot be found."],"win_id2tabwin":["\\t\\tReturn a list with the tab number and window number of window","\\t\\twith ID {expr}: [tabnr, winnr].","\\t\\tReturn [0, 0] if the window cannot be found."],"win_id2win":["\\t\\tReturn the window number of window with ID {expr}.","\\t\\tReturn 0 if the window cannot be found in the current tabpage."],"win_screenpos":["\\t\\tReturn the screen position of window {nr} as a list with two","\\t\\tnumbers: [row, col].  The first window always has position","\\t\\t[1, 1], unless there is a tabline, then it is [2, 1].","\\t\\t{nr} can be the window number or the |window-ID|.","\\t\\tReturn [0, 0] if the window cannot be found in the current","\\t\\ttabpage.",""],"winbufnr":["\\t\\tassociated with window {nr}.  {nr} can be the window number or","\\t\\tthe |window-ID|.","\\t\\tWhen {nr} is zero, the number of the buffer in the current","\\t\\twindow is returned.","\\t\\tWhen window {nr} doesn\'t exist, -1 is returned.","\\t\\tExample: >","  :echo \\"The file in the current window is \\" . bufname(winbufnr(0))","<"],"wincol":["\\t\\tcursor in the window.  This is counting screen cells from the","\\t\\tleft side of the window.  The leftmost column is one."],"winheight":["\\t\\tThe result is a Number, which is the height of window {nr}.","\\t\\t{nr} can be the window number or the |window-ID|.","\\t\\tWhen {nr} is zero, the height of the current window is","\\t\\treturned.  When window {nr} doesn\'t exist, -1 is returned.","\\t\\tAn existing window always has a height of zero or more.","\\t\\tThis excludes any window toolbar line.","\\t\\tExamples: >","  :echo \\"The current window has \\" . winheight(0) . \\" lines.\\""],"winlayout":["\\t\\tThe result is a nested List containing the layout of windows","\\t\\tin a tabpage.","","\\t\\tWithout {tabnr} use the current tabpage, otherwise the tabpage","\\t\\twith number {tabnr}. If the tabpage {tabnr} is not found,","\\t\\treturns an empty list.","","\\t\\tFor a leaf window, it returns:","\\t\\t\\t[\'leaf\', {winid}]","\\t\\tFor horizontally split windows, which form a column, it","\\t\\treturns:","\\t\\t\\t[\'col\', [{nested list of windows}]]","\\t\\tFor vertically split windows, which form a row, it returns:","\\t\\t\\t[\'row\', [{nested list of windows}]]","","\\t\\tExample: >","\\t\\t\\t\\" Only one window in the tab page","\\t\\t\\t:echo winlayout()","\\t\\t\\t[\'leaf\', 1000]","\\t\\t\\t\\" Two horizontally split windows","\\t\\t\\t:echo winlayout()","\\t\\t\\t[\'col\', [[\'leaf\', 1000], [\'leaf\', 1001]]]","\\t\\t\\t\\" Three horizontally split windows, with two","\\t\\t\\t\\" vertically split windows in the middle window","\\t\\t\\t:echo winlayout(2)","\\t\\t\\t[\'col\', [[\'leaf\', 1002], [\'row\', [\'leaf\', 1003],","\\t\\t\\t\\t\\t     [\'leaf\', 1001]]], [\'leaf\', 1000]]","<"],"winline":["\\t\\tin the window.  This is counting screen lines from the top of","\\t\\tthe window.  The first line is one.","\\t\\tIf the cursor was moved the view on the file will be updated","\\t\\tfirst, this may cause a scroll.",""],"winnr":["\\t\\twindow.  The top window has number 1.","","\\t\\tThe optional argument {arg} supports the following values:","\\t\\t\\t$\\tthe number of the last window (the window","\\t\\t\\t\\tcount).","\\t\\t\\t#\\tthe number of the last accessed window (where","\\t\\t\\t\\t|CTRL-W_p| goes to).  If there is no previous","\\t\\t\\t\\twindow or it is in another tab page 0 is","\\t\\t\\t\\treturned.","\\t\\t\\t{N}j\\tthe number of the Nth window below the","\\t\\t\\t\\tcurrent window (where |CTRL-W_j| goes to).","\\t\\t\\t{N}k\\tthe number of the Nth window above the current","\\t\\t\\t\\twindow (where |CTRL-W_k| goes to).","\\t\\t\\t{N}h\\tthe number of the Nth window left of the","\\t\\t\\t\\tcurrent window (where |CTRL-W_h| goes to).","\\t\\t\\t{N}l\\tthe number of the Nth window right of the","\\t\\t\\t\\tcurrent window (where |CTRL-W_l| goes to).","\\t\\tThe number can be used with |CTRL-W_w| and \\":wincmd w\\"","\\t\\t|:wincmd|.","\\t\\tAlso see |tabpagewinnr()| and |win_getid()|.","\\t\\tExamples: >","\\t\\t\\tlet window_count = winnr(\'$\')","\\t\\t\\tlet prev_window = winnr(\'#\')","\\t\\t\\tlet wnum = winnr(\'3k\')","<"],"winrestcmd":["\\t\\tthe current window sizes.  Only works properly when no windows","\\t\\tare opened or closed and the current window and tab page is","\\t\\tunchanged.","\\t\\tExample: >","\\t\\t\\t:let cmd = winrestcmd()","\\t\\t\\t:call MessWithWindowSizes()","\\t\\t\\t:exe cmd","<"],"winrestview":["\\t\\tUses the |Dictionary| returned by |winsaveview()| to restore","\\t\\tthe view of the current window.","\\t\\tNote: The {dict} does not have to contain all values, that are","\\t\\treturned by |winsaveview()|. If values are missing, those","\\t\\tsettings won\'t be restored. So you can use: >","\\t\\t    :call winrestview({\'curswant\': 4})","<","\\t\\tThis will only set the curswant value (the column the cursor","\\t\\twants to move on vertical movements) of the cursor to column 5","\\t\\t(yes, that is 5), while all other settings will remain the","\\t\\tsame. This is useful, if you set the cursor position manually.","","\\t\\tIf you have changed the values the result is unpredictable.","\\t\\tIf the window size changed the result won\'t be the same.",""],"winsaveview":["\\t\\tthe view of the current window.  Use |winrestview()| to","\\t\\trestore the view.","\\t\\tThis is useful if you have a mapping that jumps around in the","\\t\\tbuffer and you want to go back to the original view.","\\t\\tThis does not save fold information.  Use the \'foldenable\'","\\t\\toption to temporarily switch off folding, so that folds are","\\t\\tnot opened when moving around. This may have side effects.","\\t\\tThe return value includes:","\\t\\t\\tlnum\\t\\tcursor line number","\\t\\t\\tcol\\t\\tcursor column (Note: the first column","\\t\\t\\t\\t\\tzero, as opposed to what getpos()","\\t\\t\\t\\t\\treturns)","\\t\\t\\tcoladd\\t\\tcursor column offset for \'virtualedit\'","\\t\\t\\tcurswant\\tcolumn for vertical movement","\\t\\t\\ttopline\\t\\tfirst line in the window","\\t\\t\\ttopfill\\t\\tfiller lines, only in diff mode","\\t\\t\\tleftcol\\t\\tfirst column displayed","\\t\\t\\tskipcol\\t\\tcolumns skipped","\\t\\tNote that no option values are saved.",""],"winwidth":["\\t\\tThe result is a Number, which is the width of window {nr}.","\\t\\t{nr} can be the window number or the |window-ID|.","\\t\\tWhen {nr} is zero, the width of the current window is","\\t\\treturned.  When window {nr} doesn\'t exist, -1 is returned.","\\t\\tAn existing window always has a width of zero or more.","\\t\\tExamples: >","  :echo \\"The current window has \\" . winwidth(0) . \\" columns.\\"","  :if winwidth(0) <= 50","  :  50 wincmd |","  :endif","<\\t\\tFor getting the terminal or screen size, see the \'columns\'","\\t\\toption.",""],"wordcount":["\\t\\tThe result is a dictionary of byte/chars/word statistics for","\\t\\tthe current buffer.  This is the same info as provided by","\\t\\t|g_CTRL-G|","\\t\\tThe return value includes:","\\t\\t\\tbytes\\t\\tNumber of bytes in the buffer","\\t\\t\\tchars\\t\\tNumber of chars in the buffer","\\t\\t\\twords\\t\\tNumber of words in the buffer","\\t\\t\\tcursor_bytes    Number of bytes before cursor position","\\t\\t\\t\\t\\t(not in Visual mode)","\\t\\t\\tcursor_chars    Number of chars before cursor position","\\t\\t\\t\\t\\t(not in Visual mode)","\\t\\t\\tcursor_words    Number of words before cursor position","\\t\\t\\t\\t\\t(not in Visual mode)","\\t\\t\\tvisual_bytes    Number of bytes visually selected","\\t\\t\\t\\t\\t(only in Visual mode)","\\t\\t\\tvisual_chars    Number of chars visually selected","\\t\\t\\t\\t\\t(only in Visual mode)","\\t\\t\\tvisual_words    Number of chars visually selected","\\t\\t\\t\\t\\t(only in Visual mode)","",""],"writefile":["\\t\\tWrite |List| {list} to file {fname}.  Each list item is","\\t\\tseparated with a NL.  Each list item must be a String or","\\t\\tNumber.","\\t\\tWhen {flags} contains \\"b\\" then binary mode is used: There will","\\t\\tnot be a NL after the last list item.  An empty item at the","\\t\\tend does cause the last line in the file to end in a NL.","","\\t\\tWhen {flags} contains \\"a\\" then append mode is used, lines are","\\t\\tappended to the file: >","\\t\\t\\t:call writefile([\\"foo\\"], \\"event.log\\", \\"a\\")","\\t\\t\\t:call writefile([\\"bar\\"], \\"event.log\\", \\"a\\")","<","\\t\\tWhen {flags} contains \\"S\\" fsync() call is not used, with \\"s\\"","\\t\\tit is used, \'fsync\' option applies by default. No fsync()","\\t\\tmeans that writefile() will finish faster, but writes may be","\\t\\tleft in OS buffers and not yet written to disk. Such changes","\\t\\twill disappear if system crashes before OS does writing.","","\\t\\tAll NL characters are replaced with a NUL character.","\\t\\tInserting CR characters needs to be done before passing {list}","\\t\\tto writefile().","\\t\\tAn existing file is overwritten, if possible.","\\t\\tWhen the write fails -1 is returned, otherwise 0.  There is an","\\t\\terror message if the file can\'t be created or when writing","\\t\\tfails.","\\t\\tAlso see |readfile()|.","\\t\\tTo copy a file byte for byte: >","\\t\\t\\t:let fl = readfile(\\"foo\\", \\"b\\")","\\t\\t\\t:call writefile(fl, \\"foocopy\\", \\"b\\")",""],"xor":["\\t\\tBitwise XOR on the two arguments.  The arguments are converted","\\t\\tto a number.  A List, Dict or Float argument causes an error.","\\t\\tExample: >","\\t\\t\\t:let bits = xor(bits, 0x80)","<",""],"nvim__id":["                Returns object given as argument.","","                This API function is used for testing. One should not rely on","                its presence in plugins.","","                Parameters: ~","                    {obj}  Object to return.","","                Return: ~","                    its argument."],"nvim__id_array":["                Returns array given as argument.","","                This API function is used for testing. One should not rely on","                its presence in plugins.","","                Parameters: ~","                    {arr}  Array to return.","","                Return: ~","                    its argument."],"nvim__id_dictionary":["                Returns dictionary given as argument.","","                This API function is used for testing. One should not rely on","                its presence in plugins.","","                Parameters: ~","                    {dct}  Dictionary to return.","","                Return: ~","                    its argument."],"nvim__id_float":["                Returns floating-point value given as argument.","","                This API function is used for testing. One should not rely on","                its presence in plugins.","","                Parameters: ~","                    {flt}  Value to return.","","                Return: ~","                    its argument."],"nvim__inspect_cell":["                TODO: Documentation"],"nvim__put_attr":["                Set attrs in nvim__buf_set_lua_hl callbacks","","                TODO(bfredl): This is rather pedestrian. The final interface","                should probably be derived from a reformed bufhl/virttext","                interface with full support for multi-line ranges etc"],"nvim__stats":["                Gets internal stats.","","                Return: ~","                    Map of various internal stats."],"nvim_call_atomic":["                Calls many API methods atomically.","","                This has two main usages:","                1. To perform several requests from an async context","                   atomically, i.e. without interleaving redraws, RPC requests","                   from other clients, or user interactions (however API","                   methods may trigger autocommands or event processing which","                   have such side-effects, e.g. |:sleep| may wake timers).","                2. To minimize RPC overhead (roundtrips) of a sequence of many","                   requests.","","                Parameters: ~","                    {calls}  an array of calls, where each call is described","                             by an array with two elements: the request name,","                             and an array of arguments.","","                Return: ~","                    Array of two elements. The first is an array of return","                    values. The second is NIL if all calls succeeded. If a","                    call resulted in an error, it is a three-element array","                    with the zero-based index of the call which resulted in an","                    error, the error type and the error message. If an error","                    occurred, the values from all preceding calls will still","                    be returned.",""],"nvim_call_dict_function":["                Calls a VimL |Dictionary-function| with the given arguments.","","                On execution error: fails with VimL error, does not update","                v:errmsg.","","                Parameters: ~","                    {dict}  Dictionary, or String evaluating to a VimL |self|","                            dict","                    {fn}    Name of the function defined on the VimL dict","                    {args}  Function arguments packed in an Array","","                Return: ~","                    Result of the function call"],"nvim_call_function":["                Calls a VimL function with the given arguments.","","                On execution error: fails with VimL error, does not update","                v:errmsg.","","                Parameters: ~","                    {fn}    Function to call","                    {args}  Function arguments packed in an Array","","                Return: ~","                    Result of the function call"],"nvim_command":["                Executes an ex-command.","","                On execution error: fails with VimL error, does not update","                v:errmsg.","","                Parameters: ~","                    {command}  Ex-command string","","                See also: ~","                    |nvim_exec()|"],"nvim_create_buf":["                Creates a new, empty, unnamed buffer.","","                Parameters: ~","                    {listed}   Sets \'buflisted\'","                    {scratch}  Creates a \\"throwaway\\" |scratch-buffer| for","                               temporary work (always \'nomodified\')","","                Return: ~","                    Buffer handle, or 0 on error","","                See also: ~","                    buf_open_scratch"],"nvim_create_namespace":["                Creates a new namespace, or gets an existing one.","","                Namespaces are used for buffer highlights and virtual text,","                see |nvim_buf_add_highlight()| and","                |nvim_buf_set_virtual_text()|.","","                Namespaces can be named or anonymous. If `name` matches an","                existing namespace, the associated id is returned. If `name`","                is an empty string a new, anonymous namespace is created.","","                Parameters: ~","                    {name}  Namespace name or empty string","","                Return: ~","                    Namespace id"],"nvim_del_current_line":["                Deletes the current line."],"nvim_del_keymap":["                Unmaps a global |mapping| for the given mode.","","                To unmap a buffer-local mapping, use |nvim_buf_del_keymap()|.","","                See also: ~","                    |nvim_set_keymap()|"],"nvim_del_var":["                Removes a global (g:) variable.","","                Parameters: ~","                    {name}  Variable name"],"nvim_err_write":["                Writes a message to the Vim error buffer. Does not append","                \\"\\\\n\\", the message is buffered (won\'t display) until a linefeed","                is written.","","                Parameters: ~","                    {str}  Message"],"nvim_err_writeln":["                Writes a message to the Vim error buffer. Appends \\"\\\\n\\", so the","                buffer is flushed (and displayed).","","                Parameters: ~","                    {str}  Message","","                See also: ~","                    nvim_err_write()"],"nvim_eval":["                Evaluates a VimL |expression|. Dictionaries and Lists are","                recursively expanded.","","                On execution error: fails with VimL error, does not update","                v:errmsg.","","                Parameters: ~","                    {expr}  VimL expression string","","                Return: ~","                    Evaluation result or expanded object"],"nvim_exec":["                Executes Vimscript (multiline block of Ex-commands), like","                anonymous |:source|.","","                Unlike |nvim_command()| this function supports heredocs,","                script-scope (s:), etc.","","                On execution error: fails with VimL error, does not update","                v:errmsg.","","                Parameters: ~","                    {src}     Vimscript code","                    {output}  Capture and return all (non-error, non-shell","                              |:!|) output","","                Return: ~","                    Output (non-error, non-shell |:!|) if `output` is true,","                    else empty string.","","                See also: ~","                    |execute()|","                    |nvim_command()|"],"nvim_exec_lua":["                Execute Lua code. Parameters (if any) are available as `...`","                inside the chunk. The chunk can return a value.","","                Only statements are executed. To evaluate an expression,","                prefix it with `return` : return my_function(...)","","                Parameters: ~","                    {code}  Lua code to execute","                    {args}  Arguments to the code","","                Return: ~","                    Return value of Lua code if present or NIL."],"nvim_feedkeys":["                Sends input-keys to Nvim, subject to various quirks controlled","                by `mode` flags. This is a blocking call, unlike","                |nvim_input()|.","","                On execution error: does not fail, but updates v:errmsg.","","                Parameters: ~","                    {keys}        to be typed","                    {mode}        behavior flags, see |feedkeys()|","                    {escape_csi}  If true, escape K_SPECIAL/CSI bytes in","                                  `keys`","","                See also: ~","                    feedkeys()","                    vim_strsave_escape_csi"],"nvim_get_api_info":["                Returns a 2-tuple (Array), where item 0 is the current channel","                id and item 1 is the |api-metadata| map (Dictionary).","","                Return: ~","                    2-tuple [{channel-id}, {api-metadata}]","","                Attributes: ~","                    {fast}"],"nvim_get_chan_info":["                Get information about a channel.","","                Return: ~","                    Dictionary describing a channel, with these keys:","                    • \\"stream\\" the stream underlying the channel","                      • \\"stdio\\" stdin and stdout of this Nvim instance","                      • \\"stderr\\" stderr of this Nvim instance","                      • \\"socket\\" TCP/IP socket or named pipe","                      • \\"job\\" job with communication over its stdio","","                    • \\"mode\\" how data received on the channel is interpreted","                      • \\"bytes\\" send and receive raw bytes","                      • \\"terminal\\" a |terminal| instance interprets ASCII","                        sequences","                      • \\"rpc\\" |RPC| communication on the channel is active","","                    • \\"pty\\" Name of pseudoterminal, if one is used (optional).","                      On a POSIX system, this will be a device path like","                      /dev/pts/1. Even if the name is unknown, the key will","                      still be present to indicate a pty is used. This is","                      currently the case when using winpty on windows.","                    • \\"buffer\\" buffer with connected |terminal| instance","                      (optional)","                    • \\"client\\" information about the client on the other end","                      of the RPC channel, if it has added it using","                      |nvim_set_client_info()|. (optional)"],"nvim_get_color_by_name":["                Returns the 24-bit RGB value of a |nvim_get_color_map()| color","                name or \\"#rrggbb\\" hexadecimal string.","","                Example: >","                    :echo nvim_get_color_by_name(\\"Pink\\")","                    :echo nvim_get_color_by_name(\\"#cbcbcb\\")","<","","                Parameters: ~","                    {name}  Color name or \\"#rrggbb\\" string","","                Return: ~","                    24-bit RGB value, or -1 for invalid argument."],"nvim_get_color_map":["                Returns a map of color names and RGB values.","","                Keys are color names (e.g. \\"Aqua\\") and values are 24-bit RGB","                color values (e.g. 65535).","","                Return: ~","                    Map of color names and RGB values."],"nvim_get_commands":["                Gets a map of global (non-buffer-local) Ex commands.","","                Currently only |user-commands| are supported, not builtin Ex","                commands.","","                Parameters: ~","                    {opts}  Optional parameters. Currently only supports","                            {\\"builtin\\":false}","","                Return: ~","                    Map of maps describing commands."],"nvim_get_context":["                Gets a map of the current editor state.","","                Parameters: ~","                    {opts}  Optional parameters.","                            • types: List of |context-types| (\\"regs\\", \\"jumps\\",","                              \\"bufs\\", \\"gvars\\", …) to gather, or empty for","                              \\"all\\".","","                Return: ~","                    map of global |context|."],"nvim_get_current_buf":["                Gets the current buffer.","","                Return: ~","                    Buffer handle"],"nvim_get_current_line":["                Gets the current line.","","                Return: ~","                    Current line string"],"nvim_get_current_tabpage":["                Gets the current tabpage.","","                Return: ~","                    Tabpage handle"],"nvim_get_current_win":["                Gets the current window.","","                Return: ~","                    Window handle"],"nvim_get_hl_by_id":["                Gets a highlight definition by id. |hlID()|","","                Parameters: ~","                    {hl_id}  Highlight id as returned by |hlID()|","                    {rgb}    Export RGB colors","","                Return: ~","                    Highlight definition map","","                See also: ~","                    nvim_get_hl_by_name"],"nvim_get_hl_by_name":["                Gets a highlight definition by name.","","                Parameters: ~","                    {name}  Highlight group name","                    {rgb}   Export RGB colors","","                Return: ~","                    Highlight definition map","","                See also: ~","                    nvim_get_hl_by_id"],"nvim_get_hl_id_by_name":["                Gets a highlight group by name","","                similar to |hlID()|, but allocates a new ID if not present."],"nvim_get_keymap":["                Gets a list of global (non-buffer-local) |mapping|","                definitions.","","                Parameters: ~","                    {mode}  Mode short-name (\\"n\\", \\"i\\", \\"v\\", ...)","","                Return: ~","                    Array of maparg()-like dictionaries describing mappings.","                    The \\"buffer\\" key is always zero."],"nvim_get_mode":["                Gets the current mode. |mode()| \\"blocking\\" is true if Nvim is","                waiting for input.","","                Return: ~","                    Dictionary { \\"mode\\": String, \\"blocking\\": Boolean }","","                Attributes: ~","                    {fast}"],"nvim_get_namespaces":["                Gets existing, non-anonymous namespaces.","","                Return: ~","                    dict that maps from names to namespace ids."],"nvim_get_option":["                Gets an option value string.","","                Parameters: ~","                    {name}  Option name","","                Return: ~","                    Option value (global)"],"nvim_get_proc":["                Gets info describing process `pid` .","","                Return: ~","                    Map of process properties, or NIL if process not found."],"nvim_get_proc_children":["                Gets the immediate children of process `pid` .","","                Return: ~","                    Array of child process ids, empty if process not found."],"nvim_get_var":["                Gets a global (g:) variable.","","                Parameters: ~","                    {name}  Variable name","","                Return: ~","                    Variable value"],"nvim_get_vvar":["                Gets a v: variable.","","                Parameters: ~","                    {name}  Variable name","","                Return: ~","                    Variable value"],"nvim_input":["                Queues raw user-input. Unlike |nvim_feedkeys()|, this uses a","                low-level input buffer and the call is non-blocking (input is","                processed asynchronously by the eventloop).","","                On execution error: does not fail, but updates v:errmsg.","","                Note:","                    |keycodes| like <CR> are translated, so \\"<\\" is special. To","                    input a literal \\"<\\", send <LT>.","                Note:","                    For mouse events use |nvim_input_mouse()|. The pseudokey","                    form \\"<LeftMouse><col,row>\\" is deprecated since","                    |api-level| 6.","","                Attributes: ~","                    {fast}","","                Parameters: ~","                    {keys}  to be typed","","                Return: ~","                    Number of bytes actually written (can be fewer than","                    requested if the buffer becomes full).",""],"nvim_input_mouse":["                Send mouse event from GUI.","","                Non-blocking: does not wait on any result, but queues the","                event to be processed soon by the event loop.","","                Note:","                    Currently this doesn\'t support \\"scripting\\" multiple mouse","                    events by calling it multiple times in a loop: the","                    intermediate mouse positions will be ignored. It should be","                    used to implement real-time mouse input in a GUI. The","                    deprecated pseudokey form (\\"<LeftMouse><col,row>\\") of","                    |nvim_input()| has the same limitiation.","","                Attributes: ~","                    {fast}","","                Parameters: ~","                    {button}    Mouse button: one of \\"left\\", \\"right\\",","                                \\"middle\\", \\"wheel\\".","                    {action}    For ordinary buttons, one of \\"press\\", \\"drag\\",","                                \\"release\\". For the wheel, one of \\"up\\", \\"down\\",","                                \\"left\\", \\"right\\".","                    {modifier}  String of modifiers each represented by a","                                single char. The same specifiers are used as","                                for a key press, except that the \\"-\\" separator","                                is optional, so \\"C-A-\\", \\"c-a\\" and \\"CA\\" can all","                                be used to specify Ctrl+Alt+click.","                    {grid}      Grid number if the client uses |ui-multigrid|,","                                else 0.","                    {row}       Mouse row-position (zero-based, like redraw","                                events)","                    {col}       Mouse column-position (zero-based, like redraw","                                events)"],"nvim_list_bufs":["                Gets the current list of buffer handles","","                Includes unlisted (unloaded/deleted) buffers, like `:ls!` .","                Use |nvim_buf_is_loaded()| to check if a buffer is loaded.","","                Return: ~","                    List of buffer handles"],"nvim_list_chans":["                Get information about all open channels.","","                Return: ~","                    Array of Dictionaries, each describing a channel with the","                    format specified at |nvim_get_chan_info()|."],"nvim_list_runtime_paths":["                Gets the paths contained in \'runtimepath\'.","","                Return: ~","                    List of paths"],"nvim_list_tabpages":["                Gets the current list of tabpage handles.","","                Return: ~","                    List of tabpage handles"],"nvim_list_uis":["                Gets a list of dictionaries representing attached UIs.","","                Return: ~","                    Array of UI dictionaries, each with these keys:","                    • \\"height\\" Requested height of the UI","                    • \\"width\\" Requested width of the UI","                    • \\"rgb\\" true if the UI uses RGB colors (false implies","                      |cterm-colors|)","                    • \\"ext_...\\" Requested UI extensions, see |ui-option|","                    • \\"chan\\" Channel id of remote UI (not present for TUI)"],"nvim_list_wins":["                Gets the current list of window handles.","","                Return: ~","                    List of window handles"],"nvim_load_context":["                Sets the current editor state from the given |context| map.","","                Parameters: ~","                    {dict}  |Context| map."],"nvim_open_win":["                Open a new window.","","                Currently this is used to open floating and external windows.","                Floats are windows that are drawn above the split layout, at","                some anchor position in some other window. Floats can be drawn","                internally or by external GUI with the |ui-multigrid|","                extension. External windows are only supported with multigrid","                GUIs, and are displayed as separate top-level windows.","","                For a general overview of floats, see |api-floatwin|.","","                Exactly one of `external` and `relative` must be specified.","                The `width` and `height` of the new window must be specified.","","                With relative=editor (row=0,col=0) refers to the top-left","                corner of the screen-grid and (row=Lines-1,col=Columns-1)","                refers to the bottom-right corner. Fractional values are","                allowed, but the builtin implementation (used by non-multigrid","                UIs) will always round down to nearest integer.","","                Out-of-bounds values, and configurations that make the float","                not fit inside the main editor, are allowed. The builtin","                implementation truncates values so floats are fully within the","                main screen grid. External GUIs could let floats hover outside","                of the main window like a tooltip, but this should not be used","                to specify arbitrary WM screen positions.","","                Example (Lua): window-relative float >","                    vim.api.nvim_open_win(0, false,","                      {relative=\'win\', row=3, col=3, width=12, height=3})","<","","                Example (Lua): buffer-relative float (travels as buffer is","                scrolled) >","                    vim.api.nvim_open_win(0, false,","                      {relative=\'win\', width=12, height=3, bufpos={100,10}})","<","","                Parameters: ~","                    {buffer}  Buffer to display, or 0 for current buffer","                    {enter}   Enter the window (make it the current window)","                    {config}  Map defining the window configuration. Keys:","                              • `relative`: Sets the window layout to \\"floating\\", placed","                                at (row,col) coordinates relative to:","                                • \\"editor\\" The global editor grid","                                • \\"win\\" Window given by the `win` field, or","                                  current window.","                                • \\"cursor\\" Cursor position in current window.","","                              • `win` : |window-ID| for relative=\\"win\\".","                              • `anchor`: Decides which corner of the float to place","                                at (row,col):","                                • \\"NW\\" northwest (default)","                                • \\"NE\\" northeast","                                • \\"SW\\" southwest","                                • \\"SE\\" southeast","","                              • `width` : Window width (in character cells).","                                Minimum of 1.","                              • `height` : Window height (in character cells).","                                Minimum of 1.","                              • `bufpos` : Places float relative to buffer","                                text (only when relative=\\"win\\"). Takes a tuple","                                of zero-indexed [line, column]. `row` and","                                `col` if given are applied relative to this","                                position, else they default to `row=1` and","                                `col=0` (thus like a tooltip near the buffer","                                text).","                              • `row` : Row position in units of \\"screen cell","                                height\\", may be fractional.","                              • `col` : Column position in units of \\"screen","                                cell width\\", may be fractional.","                              • `focusable` : Enable focus by user actions","                                (wincmds, mouse events). Defaults to true.","                                Non-focusable windows can be entered by","                                |nvim_set_current_win()|.","                              • `external` : GUI should display the window as","                                an external top-level window. Currently","                                accepts no other positioning configuration","                                together with this.","                              • `style`: Configure the appearance of the window.","                                Currently only takes one non-empty value:","                                • \\"minimal\\" Nvim will display the window with","                                  many UI options disabled. This is useful","                                  when displaying a temporary float where the","                                  text should not be edited. Disables","                                  \'number\', \'relativenumber\', \'cursorline\',","                                  \'cursorcolumn\', \'foldcolumn\', \'spell\' and","                                  \'list\' options. \'signcolumn\' is changed to","                                  `auto` and \'colorcolumn\' is cleared. The","                                  end-of-buffer region is hidden by setting","                                  `eob` flag of \'fillchars\' to a space char,","                                  and clearing the |EndOfBuffer| region in","                                  \'winhighlight\'.","","                Return: ~","                    Window handle, or 0 on error"],"nvim_out_write":["                Writes a message to the Vim output buffer. Does not append","                \\"\\\\n\\", the message is buffered (won\'t display) until a linefeed","                is written.","","                Parameters: ~","                    {str}  Message",""],"nvim_parse_expression":["                Parse a VimL expression.","","                Attributes: ~","                    {fast}","","                Parameters: ~","                    {expr}       Expression to parse. Always treated as a","                                 single line.","                    {flags}      Flags:","                                 • \\"m\\" if multiple expressions in a row are","                                   allowed (only the first one will be","                                   parsed),","                                 • \\"E\\" if EOC tokens are not allowed","                                   (determines whether they will stop parsing","                                   process or be recognized as an","                                   operator/space, though also yielding an","                                   error).","                                 • \\"l\\" when needing to start parsing with","                                   lvalues for \\":let\\" or \\":for\\". Common flag","                                   sets:","                                 • \\"m\\" to parse like for \\":echo\\".","                                 • \\"E\\" to parse like for \\"<C-r>=\\".","                                 • empty string for \\":call\\".","                                 • \\"lm\\" to parse for \\":let\\".","                    {highlight}  If true, return value will also include","                                 \\"highlight\\" key containing array of 4-tuples","                                 (arrays) (Integer, Integer, Integer, String),","                                 where first three numbers define the","                                 highlighted region and represent line,","                                 starting column and ending column (latter","                                 exclusive: one should highlight region","                                 [start_col, end_col)).","","                Return: ~","","                    • AST: top-level dictionary with these keys:","                      • \\"error\\": Dictionary with error, present only if parser","                        saw some error. Contains the following keys:","                        • \\"message\\": String, error message in printf format,","                          translated. Must contain exactly one \\"%.*s\\".","                        • \\"arg\\": String, error message argument.","","                      • \\"len\\": Amount of bytes successfully parsed. With flags","                        equal to \\"\\" that should be equal to the length of expr","                        string. (“Sucessfully parsed” here means “participated","                        in AST creation”, not “till the first error”.)","                      • \\"ast\\": AST, either nil or a dictionary with these","                        keys:","                        • \\"type\\": node type, one of the value names from","                          ExprASTNodeType stringified without \\"kExprNode\\"","                          prefix.","                        • \\"start\\": a pair [line, column] describing where node","                          is \\"started\\" where \\"line\\" is always 0 (will not be 0","                          if you will be using nvim_parse_viml() on e.g.","                          \\":let\\", but that is not present yet). Both elements","                          are Integers.","                        • \\"len\\": “length” of the node. This and \\"start\\" are","                          there for debugging purposes primary (debugging","                          parser and providing debug information).","                        • \\"children\\": a list of nodes described in top/\\"ast\\".","                          There always is zero, one or two children, key will","                          not be present if node has no children. Maximum","                          number of children may be found in node_maxchildren","                          array.","","                    • Local values (present only for certain nodes):","                      • \\"scope\\": a single Integer, specifies scope for","                        \\"Option\\" and \\"PlainIdentifier\\" nodes. For \\"Option\\" it","                        is one of ExprOptScope values, for \\"PlainIdentifier\\"","                        it is one of ExprVarScope values.","                      • \\"ident\\": identifier (without scope, if any), present","                        for \\"Option\\", \\"PlainIdentifier\\", \\"PlainKey\\" and","                        \\"Environment\\" nodes.","                      • \\"name\\": Integer, register name (one character) or -1.","                        Only present for \\"Register\\" nodes.","                      • \\"cmp_type\\": String, comparison type, one of the value","                        names from ExprComparisonType, stringified without","                        \\"kExprCmp\\" prefix. Only present for \\"Comparison\\"","                        nodes.","                      • \\"ccs_strategy\\": String, case comparison strategy, one","                        of the value names from ExprCaseCompareStrategy,","                        stringified without \\"kCCStrategy\\" prefix. Only present","                        for \\"Comparison\\" nodes.","                      • \\"augmentation\\": String, augmentation type for","                        \\"Assignment\\" nodes. Is either an empty string, \\"Add\\",","                        \\"Subtract\\" or \\"Concat\\" for \\"=\\", \\"+=\\", \\"-=\\" or \\".=\\"","                        respectively.","                      • \\"invert\\": Boolean, true if result of comparison needs","                        to be inverted. Only present for \\"Comparison\\" nodes.","                      • \\"ivalue\\": Integer, integer value for \\"Integer\\" nodes.","                      • \\"fvalue\\": Float, floating-point value for \\"Float\\"","                        nodes.","                      • \\"svalue\\": String, value for \\"SingleQuotedString\\" and","                        \\"DoubleQuotedString\\" nodes."],"nvim_paste":["                Pastes at cursor, in any mode.","","                Invokes the `vim.paste` handler, which handles each mode","                appropriately. Sets redo/undo. Faster than |nvim_input()|.","                Lines break at LF (\\"\\\\n\\").","","                Errors (\'nomodifiable\', `vim.paste()` failure, …) are","                reflected in `err` but do not affect the return value (which","                is strictly decided by `vim.paste()` ). On error, subsequent","                calls are ignored (\\"drained\\") until the next paste is","                initiated (phase 1 or -1).","","                Parameters: ~","                    {data}   Multiline input. May be binary (containing NUL","                             bytes).","                    {crlf}   Also break lines at CR and CRLF.","                    {phase}  -1: paste in a single call (i.e. without","                             streaming). To \\"stream\\" a paste, call `nvim_paste` sequentially with these `phase` values:","                             • 1: starts the paste (exactly once)","                             • 2: continues the paste (zero or more times)","                             • 3: ends the paste (exactly once)","","                Return: ~","","                    • true: Client may continue pasting.","                    • false: Client must cancel the paste."],"nvim_put":["                Puts text at cursor, in any mode.","","                Compare |:put| and |p| which are always linewise.","","                Parameters: ~","                    {lines}   |readfile()|-style list of lines.","                              |channel-lines|","                    {type}    Edit behavior: any |getregtype()| result, or:","                              • \\"b\\" |blockwise-visual| mode (may include","                                width, e.g. \\"b3\\")","                              • \\"c\\" |charwise| mode","                              • \\"l\\" |linewise| mode","                              • \\"\\" guess by contents, see |setreg()|","                    {after}   Insert after cursor (like |p|), or before (like","                              |P|).","                    {follow}  Place cursor at end of inserted text.",""],"nvim_replace_termcodes":["                Replaces terminal codes and |keycodes| (<CR>, <Esc>, ...) in a","                string with the internal representation.","","                Parameters: ~","                    {str}        String to be converted.","                    {from_part}  Legacy Vim parameter. Usually true.","                    {do_lt}      Also translate <lt>. Ignored if `special` is","                                 false.","                    {special}    Replace |keycodes|, e.g. <CR> becomes a \\"\\\\n\\"","                                 char.","","                See also: ~","                    replace_termcodes","                    cpoptions",""],"nvim_select_popupmenu_item":["                Selects an item in the completion popupmenu.","","                If |ins-completion| is not active this API call is silently","                ignored. Useful for an external UI using |ui-popupmenu| to","                control the popupmenu with the mouse. Can also be used in a","                mapping; use <cmd> |:map-cmd| to ensure the mapping doesn\'t","                end completion mode.","","                Parameters: ~","                    {item}    Index (zero-based) of the item to select. Value","                              of -1 selects nothing and restores the original","                              text.","                    {insert}  Whether the selection should be inserted in the","                              buffer.","                    {finish}  Finish the completion and dismiss the popupmenu.","                              Implies `insert` .","                    {opts}    Optional parameters. Reserved for future use.",""],"nvim_set_client_info":["                Self-identifies the client.","","                The client/plugin/application should call this after","                connecting, to provide hints about its identity and purpose,","                for debugging and orchestration.","","                Can be called more than once; the caller should merge old info","                if appropriate. Example: library first identifies the channel,","                then a plugin using that library later identifies itself.","","                Note:","                    \\"Something is better than nothing\\". You don\'t need to","                    include all the fields.","","                Parameters: ~","                    {name}        Short name for the connected client","                    {version}     Dictionary describing the version, with","                                  these (optional) keys:","                                  • \\"major\\" major version (defaults to 0 if","                                    not set, for no release yet)","                                  • \\"minor\\" minor version","                                  • \\"patch\\" patch number","                                  • \\"prerelease\\" string describing a","                                    prerelease, like \\"dev\\" or \\"beta1\\"","                                  • \\"commit\\" hash or similar identifier of","                                    commit","                    {type}        Must be one of the following values. Client","                                  libraries should default to \\"remote\\" unless","                                  overridden by the user.","                                  • \\"remote\\" remote client connected to Nvim.","                                  • \\"ui\\" gui frontend","                                  • \\"embedder\\" application using Nvim as a","                                    component (for example, IDE/editor","                                    implementing a vim mode).","                                  • \\"host\\" plugin host, typically started by","                                    nvim","                                  • \\"plugin\\" single plugin, started by nvim","                    {methods}     Builtin methods in the client. For a host,","                                  this does not include plugin methods which","                                  will be discovered later. The key should be","                                  the method name, the values are dicts with","                                  these (optional) keys (more keys may be","                                  added in future versions of Nvim, thus","                                  unknown keys are ignored. Clients must only","                                  use keys defined in this or later versions","                                  of Nvim):","                                  • \\"async\\" if true, send as a notification.","                                    If false or unspecified, use a blocking","                                    request","                                  • \\"nargs\\" Number of arguments. Could be a","                                    single integer or an array of two","                                    integers, minimum and maximum inclusive.","                    {attributes}  Arbitrary string:string map of informal","                                  client properties. Suggested keys:","                                  • \\"website\\": Client homepage URL (e.g.","                                    GitHub repository)","                                  • \\"license\\": License description (\\"Apache","                                    2\\", \\"GPLv3\\", \\"MIT\\", …)","                                  • \\"logo\\": URI or path to image, preferably","                                    small logo or icon. .png or .svg format is","                                    preferred."],"nvim_set_current_buf":["                Sets the current buffer.","","                Parameters: ~","                    {buffer}  Buffer handle"],"nvim_set_current_dir":["                Changes the global working directory.","","                Parameters: ~","                    {dir}  Directory path"],"nvim_set_current_line":["                Sets the current line.","","                Parameters: ~","                    {line}  Line contents"],"nvim_set_current_tabpage":["                Sets the current tabpage.","","                Parameters: ~","                    {tabpage}  Tabpage handle"],"nvim_set_current_win":["                Sets the current window.","","                Parameters: ~","                    {window}  Window handle"],"nvim_set_keymap":["                Sets a global |mapping| for the given mode.","","                To set a buffer-local mapping, use |nvim_buf_set_keymap()|.","","                Unlike |:map|, leading/trailing whitespace is accepted as part","                of the {lhs} or {rhs}. Empty {rhs} is |<Nop>|. |keycodes| are","                replaced as usual.","","                Example: >","                    call nvim_set_keymap(\'n\', \' <NL>\', \'\', {\'nowait\': v:true})","<","","                is equivalent to: >","                    nmap <nowait> <Space><NL> <Nop>","<","","                Parameters: ~","                    {mode}  Mode short-name (map command prefix: \\"n\\", \\"i\\",","                            \\"v\\", \\"x\\", …) or \\"!\\" for |:map!|, or empty string","                            for |:map|.","                    {lhs}   Left-hand-side |{lhs}| of the mapping.","                    {rhs}   Right-hand-side |{rhs}| of the mapping.","                    {opts}  Optional parameters map. Accepts all","                            |:map-arguments| as keys excluding |<buffer>| but","                            including |noremap|. Values are Booleans. Unknown","                            key is an error."],"nvim_set_option":["                Sets an option value.","","                Parameters: ~","                    {name}   Option name","                    {value}  New option value"],"nvim_set_var":["                Sets a global (g:) variable.","","                Parameters: ~","                    {name}   Variable name","                    {value}  Variable value"],"nvim_set_vvar":["                Sets a v: variable, if it is not readonly.","","                Parameters: ~","                    {name}   Variable name","                    {value}  Variable value"],"nvim_strwidth":["                Calculates the number of display cells occupied by `text` .","                <Tab> counts as one cell.","","                Parameters: ~","                    {text}  Some text","","                Return: ~","                    Number of cells"],"nvim_subscribe":["                Subscribes to event broadcasts.","","                Parameters: ~","                    {event}  Event type string"],"nvim_unsubscribe":["                Unsubscribes to event broadcasts.","","                Parameters: ~","                    {event}  Event type string",""],"nvim__buf_redraw_range":["                TODO: Documentation"],"nvim__buf_set_luahl":["                Unstabilized interface for defining syntax hl in lua.","","                This is not yet safe for general use, lua callbacks will need","                to be restricted, like textlock and probably other stuff.","","                The API on_line/nvim__put_attr is quite raw and not intended","                to be the final shape. Ideally this should operate on chunks","                larger than a single line to reduce interpreter overhead, and","                generate annotation objects (bufhl/virttext) on the fly but","                using the same representation."],"nvim__buf_stats":["                TODO: Documentation",""],"nvim_buf_add_highlight":["                Adds a highlight to buffer.","","                Useful for plugins that dynamically generate highlights to a","                buffer (like a semantic highlighter or linter). The function","                adds a single highlight to a buffer. Unlike |matchaddpos()|","                highlights follow changes to line numbering (as lines are","                inserted/removed above the highlighted line), like signs and","                marks do.","","                Namespaces are used for batch deletion/updating of a set of","                highlights. To create a namespace, use |nvim_create_namespace|","                which returns a namespace id. Pass it in to this function as","                `ns_id` to add highlights to the namespace. All highlights in","                the same namespace can then be cleared with single call to","                |nvim_buf_clear_namespace|. If the highlight never will be","                deleted by an API call, pass `ns_id = -1` .","","                As a shorthand, `ns_id = 0` can be used to create a new","                namespace for the highlight, the allocated id is then","                returned. If `hl_group` is the empty string no highlight is","                added, but a new `ns_id` is still returned. This is supported","                for backwards compatibility, new code should use","                |nvim_create_namespace| to create a new empty namespace.","","                Parameters: ~","                    {buffer}     Buffer handle, or 0 for current buffer","                    {ns_id}      namespace to use or -1 for ungrouped","                                 highlight","                    {hl_group}   Name of the highlight group to use","                    {line}       Line to highlight (zero-indexed)","                    {col_start}  Start of (byte-indexed) column range to","                                 highlight","                    {col_end}    End of (byte-indexed) column range to","                                 highlight, or -1 to highlight to end of line","","                Return: ~","                    The ns_id that was used"],"nvim_buf_attach":["                Activates buffer-update events on a channel, or as Lua","                callbacks.","","                Example (Lua): capture buffer updates in a global `events` variable (use \\"print(vim.inspect(events))\\" to see its","                contents): >","                  events = {}","                  vim.api.nvim_buf_attach(0, false, {","                    on_lines=function(...) table.insert(events, {...}) end})","<","","                Parameters: ~","                    {buffer}       Buffer handle, or 0 for current buffer","                    {send_buffer}  True if the initial notification should","                                   contain the whole buffer: first","                                   notification will be `nvim_buf_lines_event`","                                   . Else the first notification will be","                                   `nvim_buf_changedtick_event` . Not for Lua","                                   callbacks.","                    {opts}         Optional parameters.","                                   • on_lines: Lua callback invoked on change.","                                     Return`true`to detach. Args:","                                     • buffer handle","                                     • b:changedtick","                                     • first line that changed (zero-indexed)","                                     • last line that was changed","                                     • last line in the updated range","                                     • byte count of previous contents","                                     • deleted_codepoints (if `utf_sizes` is","                                       true)","                                     • deleted_codeunits (if `utf_sizes` is","                                       true)","","                                   • on_changedtick: Lua callback invoked on","                                     changedtick increment without text","                                     change. Args:","                                     • buffer handle","                                     • b:changedtick","","                                   • on_detach: Lua callback invoked on","                                     detach. Args:","                                     • buffer handle","","                                   • utf_sizes: include UTF-32 and UTF-16 size","                                     of the replaced region, as args to","                                     `on_lines` .","","                Return: ~","                    False if attach failed (invalid parameter, or buffer isn\'t","                    loaded); otherwise True. TODO: LUA_API_NO_EVAL","","                See also: ~","                    |nvim_buf_detach()|","                    |api-buffer-updates-lua|",""],"nvim_buf_clear_namespace":["                Clears namespaced objects (highlights, extmarks, virtual text)","                from a region.","","                Lines are 0-indexed. |api-indexing| To clear the namespace in","                the entire buffer, specify line_start=0 and line_end=-1.","","                Parameters: ~","                    {buffer}      Buffer handle, or 0 for current buffer","                    {ns_id}       Namespace to clear, or -1 to clear all","                                  namespaces.","                    {line_start}  Start of range of lines to clear","                    {line_end}    End of range of lines to clear (exclusive)","                                  or -1 to clear to end of buffer."],"nvim_buf_del_extmark":["                Removes an extmark.","","                Parameters: ~","                    {buffer}  Buffer handle, or 0 for current buffer","                    {ns_id}   Namespace id from |nvim_create_namespace()|","                    {id}      Extmark id","","                Return: ~","                    true if the extmark was found, else false"],"nvim_buf_del_keymap":["                Unmaps a buffer-local |mapping| for the given mode.","","                Parameters: ~","                    {buffer}  Buffer handle, or 0 for current buffer","","                See also: ~","                    |nvim_del_keymap()|"],"nvim_buf_del_var":["                Removes a buffer-scoped (b:) variable","","                Parameters: ~","                    {buffer}  Buffer handle, or 0 for current buffer","                    {name}    Variable name"],"nvim_buf_detach":["                Deactivates buffer-update events on the channel.","","                Parameters: ~","                    {buffer}  Buffer handle, or 0 for current buffer","","                Return: ~","                    False if detach failed (because the buffer isn\'t loaded);","                    otherwise True.","","                See also: ~","                    |nvim_buf_attach()|","                    |api-lua-detach| for detaching Lua callbacks"],"nvim_buf_get_changedtick":["                Gets a changed tick of a buffer","","                Parameters: ~","                    {buffer}  Buffer handle, or 0 for current buffer","","                Return: ~","                    `b:changedtick` value."],"nvim_buf_get_commands":["                Gets a map of buffer-local |user-commands|.","","                Parameters: ~","                    {buffer}  Buffer handle, or 0 for current buffer","                    {opts}    Optional parameters. Currently not used.","","                Return: ~","                    Map of maps describing commands.",""],"nvim_buf_get_extmark_by_id":["                Returns position for a given extmark id","","                Parameters: ~","                    {buffer}  Buffer handle, or 0 for current buffer","                    {ns_id}   Namespace id from |nvim_create_namespace()|","                    {id}      Extmark id","","                Return: ~","                    (row, col) tuple or empty list () if extmark id was absent",""],"nvim_buf_get_extmarks":["                Gets extmarks in \\"traversal order\\" from a |charwise| region","                defined by buffer positions (inclusive, 0-indexed","                |api-indexing|).","","                Region can be given as (row,col) tuples, or valid extmark ids","                (whose positions define the bounds). 0 and -1 are understood","                as (0,0) and (-1,-1) respectively, thus the following are","                equivalent:",">","                  nvim_buf_get_extmarks(0, my_ns, 0, -1, {})","                  nvim_buf_get_extmarks(0, my_ns, [0,0], [-1,-1], {})","<","","                If `end` is less than `start` , traversal works backwards.","                (Useful with `limit` , to get the first marks prior to a given","                position.)","","                Example:",">","                  local a   = vim.api","                  local pos = a.nvim_win_get_cursor(0)","                  local ns  = a.nvim_create_namespace(\'my-plugin\')","                  -- Create new extmark at line 1, column 1.","                  local m1  = a.nvim_buf_set_extmark(0, ns, 0, 0, 0, {})","                  -- Create new extmark at line 3, column 1.","                  local m2  = a.nvim_buf_set_extmark(0, ns, 0, 2, 0, {})","                  -- Get extmarks only from line 3.","                  local ms  = a.nvim_buf_get_extmarks(0, ns, {2,0}, {2,0}, {})","                  -- Get all marks in this buffer + namespace.","                  local all = a.nvim_buf_get_extmarks(0, ns, 0, -1, {})","                  print(vim.inspect(ms))","<","","                Parameters: ~","                    {buffer}  Buffer handle, or 0 for current buffer","                    {ns_id}   Namespace id from |nvim_create_namespace()|","                    {start}   Start of range, given as (row, col) or valid","                              extmark id (whose position defines the bound)","                    {end}     End of range, given as (row, col) or valid","                              extmark id (whose position defines the bound)","                    {opts}    Optional parameters. Keys:","                              • limit: Maximum number of marks to return","","                Return: ~","                    List of [extmark_id, row, col] tuples in \\"traversal","                    order\\"."],"nvim_buf_get_keymap":["                Gets a list of buffer-local |mapping| definitions.","","                Parameters: ~","                    {mode}    Mode short-name (\\"n\\", \\"i\\", \\"v\\", ...)","                    {buffer}  Buffer handle, or 0 for current buffer","","                Return: ~","                    Array of maparg()-like dictionaries describing mappings.","                    The \\"buffer\\" key holds the associated buffer handle.",""],"nvim_buf_get_lines":["                Gets a line-range from the buffer.","","                Indexing is zero-based, end-exclusive. Negative indices are","                interpreted as length+1+index: -1 refers to the index past the","                end. So to get the last element use start=-2 and end=-1.","","                Out-of-bounds indices are clamped to the nearest valid value,","                unless `strict_indexing` is set.","","                Parameters: ~","                    {buffer}           Buffer handle, or 0 for current buffer","                    {start}            First line index","                    {end}              Last line index (exclusive)","                    {strict_indexing}  Whether out-of-bounds should be an","                                       error.","","                Return: ~","                    Array of lines, or empty array for unloaded buffer."],"nvim_buf_get_mark":["                Return a tuple (row,col) representing the position of the","                named mark.","","                Marks are (1,0)-indexed. |api-indexing|","","                Parameters: ~","                    {buffer}  Buffer handle, or 0 for current buffer","                    {name}    Mark name","","                Return: ~","                    (row, col) tuple"],"nvim_buf_get_name":["                Gets the full file name for the buffer","","                Parameters: ~","                    {buffer}  Buffer handle, or 0 for current buffer","","                Return: ~","                    Buffer name"],"nvim_buf_get_offset":["                Returns the byte offset of a line (0-indexed). |api-indexing|","","                Line 1 (index=0) has offset 0. UTF-8 bytes are counted. EOL is","                one byte. \'fileformat\' and \'fileencoding\' are ignored. The","                line index just after the last line gives the total byte-count","                of the buffer. A final EOL byte is counted if it would be","                written, see \'eol\'.","","                Unlike |line2byte()|, throws error for out-of-bounds indexing.","                Returns -1 for unloaded buffer.","","                Parameters: ~","                    {buffer}  Buffer handle, or 0 for current buffer","                    {index}   Line index","","                Return: ~","                    Integer byte offset, or -1 for unloaded buffer."],"nvim_buf_get_option":["                Gets a buffer option value","","                Parameters: ~","                    {buffer}  Buffer handle, or 0 for current buffer","                    {name}    Option name","","                Return: ~","                    Option value"],"nvim_buf_get_var":["                Gets a buffer-scoped (b:) variable.","","                Parameters: ~","                    {buffer}  Buffer handle, or 0 for current buffer","                    {name}    Variable name","","                Return: ~","                    Variable value",""],"nvim_buf_get_virtual_text":["                Get the virtual text (annotation) for a buffer line.","","                The virtual text is returned as list of lists, whereas the","                inner lists have either one or two elements. The first element","                is the actual text, the optional second element is the","                highlight group.","","                The format is exactly the same as given to","                nvim_buf_set_virtual_text().","","                If there is no virtual text associated with the given line, an","                empty list is returned.","","                Parameters: ~","                    {buffer}  Buffer handle, or 0 for current buffer","                    {line}    Line to get the virtual text from (zero-indexed)","","                Return: ~","                    List of virtual text chunks"],"nvim_buf_is_loaded":["                Checks if a buffer is valid and loaded. See |api-buffer| for","                more info about unloaded buffers.","","                Parameters: ~","                    {buffer}  Buffer handle, or 0 for current buffer","","                Return: ~","                    true if the buffer is valid and loaded, false otherwise."],"nvim_buf_is_valid":["                Checks if a buffer is valid.","","                Note:","                    Even if a buffer is valid it may have been unloaded. See","                    |api-buffer| for more info about unloaded buffers.","","                Parameters: ~","                    {buffer}  Buffer handle, or 0 for current buffer","","                Return: ~","                    true if the buffer is valid, false otherwise."],"nvim_buf_line_count":["                Gets the buffer line count","","                Parameters: ~","                    {buffer}  Buffer handle, or 0 for current buffer","","                Return: ~","                    Line count, or 0 for unloaded buffer. |api-buffer|",""],"nvim_buf_set_extmark":["                Creates or updates an extmark.","","                To create a new extmark, pass id=0. The extmark id will be","                returned. It is also allowed to create a new mark by passing","                in a previously unused id, but the caller must then keep track","                of existing and unused ids itself. (Useful over RPC, to avoid","                waiting for the return value.)","","                Parameters: ~","                    {buffer}  Buffer handle, or 0 for current buffer","                    {ns_id}   Namespace id from |nvim_create_namespace()|","                    {id}      Extmark id, or 0 to create new","                    {line}    Line number where to place the mark","                    {col}     Column where to place the mark","                    {opts}    Optional parameters. Currently not used.","","                Return: ~","                    Id of the created/updated extmark",""],"nvim_buf_set_keymap":["                Sets a buffer-local |mapping| for the given mode.","","                Parameters: ~","                    {buffer}  Buffer handle, or 0 for current buffer","","                See also: ~","                    |nvim_set_keymap()|",""],"nvim_buf_set_lines":["                Sets (replaces) a line-range in the buffer.","","                Indexing is zero-based, end-exclusive. Negative indices are","                interpreted as length+1+index: -1 refers to the index past the","                end. So to change or delete the last element use start=-2 and","                end=-1.","","                To insert lines at a given index, set `start` and `end` to the","                same index. To delete a range of lines, set `replacement` to","                an empty array.","","                Out-of-bounds indices are clamped to the nearest valid value,","                unless `strict_indexing` is set.","","                Parameters: ~","                    {buffer}           Buffer handle, or 0 for current buffer","                    {start}            First line index","                    {end}              Last line index (exclusive)","                    {strict_indexing}  Whether out-of-bounds should be an","                                       error.","                    {replacement}      Array of lines to use as replacement"],"nvim_buf_set_name":["                Sets the full file name for a buffer","","                Parameters: ~","                    {buffer}  Buffer handle, or 0 for current buffer","                    {name}    Buffer name"],"nvim_buf_set_option":["                Sets a buffer option value. Passing \'nil\' as value deletes the","                option (only works if there\'s a global fallback)","","                Parameters: ~","                    {buffer}  Buffer handle, or 0 for current buffer","                    {name}    Option name","                    {value}   Option value"],"nvim_buf_set_var":["                Sets a buffer-scoped (b:) variable","","                Parameters: ~","                    {buffer}  Buffer handle, or 0 for current buffer","                    {name}    Variable name","                    {value}   Variable value",""],"nvim_buf_set_virtual_text":["                Set the virtual text (annotation) for a buffer line.","","                By default (and currently the only option) the text will be","                placed after the buffer text. Virtual text will never cause","                reflow, rather virtual text will be truncated at the end of","                the screen line. The virtual text will begin one cell","                (|lcs-eol| or space) after the ordinary text.","","                Namespaces are used to support batch deletion/updating of","                virtual text. To create a namespace, use","                |nvim_create_namespace|. Virtual text is cleared using","                |nvim_buf_clear_namespace|. The same `ns_id` can be used for","                both virtual text and highlights added by","                |nvim_buf_add_highlight|, both can then be cleared with a","                single call to |nvim_buf_clear_namespace|. If the virtual text","                never will be cleared by an API call, pass `ns_id = -1` .","","                As a shorthand, `ns_id = 0` can be used to create a new","                namespace for the virtual text, the allocated id is then","                returned.","","                Parameters: ~","                    {buffer}  Buffer handle, or 0 for current buffer","                    {ns_id}   Namespace to use or 0 to create a namespace, or","                              -1 for a ungrouped annotation","                    {line}    Line to annotate with virtual text","                              (zero-indexed)","                    {chunks}  A list of [text, hl_group] arrays, each","                              representing a text chunk with specified","                              highlight. `hl_group` element can be omitted for","                              no highlight.","                    {opts}    Optional parameters. Currently not used.","","                Return: ~","                    The ns_id that was used",""],"nvim_win_close":["                Closes the window (like |:close| with a |window-ID|).","","                Parameters: ~","                    {window}  Window handle, or 0 for current window","                    {force}   Behave like `:close!` The last window of a","                              buffer with unwritten changes can be closed. The","                              buffer will become hidden, even if \'hidden\' is","                              not set."],"nvim_win_del_var":["                Removes a window-scoped (w:) variable","","                Parameters: ~","                    {window}  Window handle, or 0 for current window","                    {name}    Variable name"],"nvim_win_get_buf":["                Gets the current buffer in a window","","                Parameters: ~","                    {window}  Window handle, or 0 for current window","","                Return: ~","                    Buffer handle"],"nvim_win_get_config":["                Gets window configuration.","","                The returned value may be given to |nvim_open_win()|.","","                `relative` is empty for normal windows.","","                Parameters: ~","                    {window}  Window handle, or 0 for current window","","                Return: ~","                    Map defining the window configuration, see","                    |nvim_open_win()|"],"nvim_win_get_cursor":["                Gets the (1,0)-indexed cursor position in the window.","                |api-indexing|","","                Parameters: ~","                    {window}  Window handle, or 0 for current window","","                Return: ~","                    (row, col) tuple"],"nvim_win_get_height":["                Gets the window height","","                Parameters: ~","                    {window}  Window handle, or 0 for current window","","                Return: ~","                    Height as a count of rows"],"nvim_win_get_number":["                Gets the window number","","                Parameters: ~","                    {window}  Window handle, or 0 for current window","","                Return: ~","                    Window number"],"nvim_win_get_option":["                Gets a window option value","","                Parameters: ~","                    {window}  Window handle, or 0 for current window","                    {name}    Option name","","                Return: ~","                    Option value"],"nvim_win_get_position":["                Gets the window position in display cells. First position is","                zero.","","                Parameters: ~","                    {window}  Window handle, or 0 for current window","","                Return: ~","                    (row, col) tuple with the window position"],"nvim_win_get_tabpage":["                Gets the window tabpage","","                Parameters: ~","                    {window}  Window handle, or 0 for current window","","                Return: ~","                    Tabpage that contains the window"],"nvim_win_get_var":["                Gets a window-scoped (w:) variable","","                Parameters: ~","                    {window}  Window handle, or 0 for current window","                    {name}    Variable name","","                Return: ~","                    Variable value"],"nvim_win_get_width":["                Gets the window width","","                Parameters: ~","                    {window}  Window handle, or 0 for current window","","                Return: ~","                    Width as a count of columns"],"nvim_win_is_valid":["                Checks if a window is valid","","                Parameters: ~","                    {window}  Window handle, or 0 for current window","","                Return: ~","                    true if the window is valid, false otherwise"],"nvim_win_set_buf":["                Sets the current buffer in a window, without side-effects","","                Parameters: ~","                    {window}  Window handle, or 0 for current window","                    {buffer}  Buffer handle"],"nvim_win_set_config":["                Configures window layout. Currently only for floating and","                external windows (including changing a split window to those","                layouts).","","                When reconfiguring a floating window, absent option keys will","                not be changed. `row` / `col` and `relative` must be","                reconfigured together.","","                Parameters: ~","                    {window}  Window handle, or 0 for current window","                    {config}  Map defining the window configuration, see","                              |nvim_open_win()|","","                See also: ~","                    |nvim_open_win()|"],"nvim_win_set_cursor":["                Sets the (1,0)-indexed cursor position in the window.","                |api-indexing|","","                Parameters: ~","                    {window}  Window handle, or 0 for current window","                    {pos}     (row, col) tuple representing the new position"],"nvim_win_set_height":["                Sets the window height. This will only succeed if the screen","                is split horizontally.","","                Parameters: ~","                    {window}  Window handle, or 0 for current window","                    {height}  Height as a count of rows"],"nvim_win_set_option":["                Sets a window option value. Passing \'nil\' as value deletes the","                option(only works if there\'s a global fallback)","","                Parameters: ~","                    {window}  Window handle, or 0 for current window","                    {name}    Option name","                    {value}   Option value"],"nvim_win_set_var":["                Sets a window-scoped (w:) variable","","                Parameters: ~","                    {window}  Window handle, or 0 for current window","                    {name}    Variable name","                    {value}   Variable value"],"nvim_win_set_width":["                Sets the window width. This will only succeed if the screen is","                split vertically.","","                Parameters: ~","                    {window}  Window handle, or 0 for current window","                    {width}   Width as a count of columns",""],"nvim_tabpage_del_var":["                Removes a tab-scoped (t:) variable","","                Parameters: ~","                    {tabpage}  Tabpage handle, or 0 for current tabpage","                    {name}     Variable name"],"nvim_tabpage_get_number":["                Gets the tabpage number","","                Parameters: ~","                    {tabpage}  Tabpage handle, or 0 for current tabpage","","                Return: ~","                    Tabpage number"],"nvim_tabpage_get_var":["                Gets a tab-scoped (t:) variable","","                Parameters: ~","                    {tabpage}  Tabpage handle, or 0 for current tabpage","                    {name}     Variable name","","                Return: ~","                    Variable value"],"nvim_tabpage_get_win":["                Gets the current window in a tabpage","","                Parameters: ~","                    {tabpage}  Tabpage handle, or 0 for current tabpage","","                Return: ~","                    Window handle"],"nvim_tabpage_is_valid":["                Checks if a tabpage is valid","","                Parameters: ~","                    {tabpage}  Tabpage handle, or 0 for current tabpage","","                Return: ~","                    true if the tabpage is valid, false otherwise"],"nvim_tabpage_list_wins":["                Gets the windows in a tabpage","","                Parameters: ~","                    {tabpage}  Tabpage handle, or 0 for current tabpage","","                Return: ~","                    List of windows in `tabpage`",""],"nvim_tabpage_set_var":["                Sets a tab-scoped (t:) variable","","                Parameters: ~","                    {tabpage}  Tabpage handle, or 0 for current tabpage","                    {name}     Variable name","                    {value}    Variable value",""],"nvim_ui_attach":["                Activates UI events on the channel.","","                Entry point of all UI clients. Allows |--embed| to continue","                startup. Implies that the client is ready to show the UI. Adds","                the client to the list of UIs. |nvim_list_uis()|","","                Note:","                    If multiple UI clients are attached, the global screen","                    dimensions degrade to the smallest client. E.g. if client","                    A requests 80x40 but client B requests 200x100, the global","                    screen has size 80x40.","","                Parameters: ~","                    {width}    Requested screen columns","                    {height}   Requested screen rows","                    {options}  |ui-option| map"],"nvim_ui_detach":["                Deactivates UI events on the channel.","","                Removes the client from the list of UIs. |nvim_list_uis()|"],"nvim_ui_pum_set_height":["                Tells Nvim the number of elements displaying in the popumenu,","                to decide <PageUp> and <PageDown> movement.","","                Parameters: ~","                    {height}  Popupmenu height, must be greater than zero."],"nvim_ui_set_option":["                TODO: Documentation"],"nvim_ui_try_resize":["                TODO: Documentation",""],"nvim_ui_try_resize_grid":["                Tell Nvim to resize a grid. Triggers a grid_resize event with","                the requested grid size or the maximum size if it exceeds size","                limits.","","                On invalid grid handle, fails with error.","","                Parameters: ~","                    {grid}    The handle of the grid to be changed.","                    {width}   The new requested width.","                    {height}  The new requested height."],"balloon_gettext":["\\t\\tReturn the current text in the balloon.  Only for the string,","\\t\\tnot used for the List."],"balloon_show":["\\t\\tShow {expr} inside the balloon.  For the GUI {expr} is used as","\\t\\ta string.  For a terminal {expr} can be a list, which contains","\\t\\tthe lines of the balloon.  If {expr} is not a list it will be","\\t\\tsplit with |balloon_split()|.","\\t\\tIf {expr} is an empty string any existing balloon is removed.","","\\t\\tExample: >","\\t\\t\\tfunc GetBalloonContent()","\\t\\t\\t   \\" ... initiate getting the content","\\t\\t\\t   return \'\'","\\t\\t\\tendfunc","\\t\\t\\tset balloonexpr=GetBalloonContent()","","\\t\\t\\tfunc BalloonCallback(result)","\\t\\t\\t  call balloon_show(a:result)","\\t\\t\\tendfunc","<\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetText()->balloon_show()","<","\\t\\tThe intended use is that fetching the content of the balloon","\\t\\tis initiated from \'balloonexpr\'.  It will invoke an","\\t\\tasynchronous method, in which a callback invokes","\\t\\tballoon_show().  The \'balloonexpr\' itself can return an","\\t\\tempty string or a placeholder.","","\\t\\tWhen showing a balloon is not possible nothing happens, no","\\t\\terror message.","\\t\\t{only available when compiled with the |+balloon_eval| or","\\t\\t|+balloon_eval_term| feature}"],"balloon_split":["\\t\\tSplit {msg} into lines to be displayed in a balloon.  The","\\t\\tsplits are made for the current window size and optimize to","\\t\\tshow debugger output.","\\t\\tReturns a |List| with the split lines.","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetText()->balloon_split()->balloon_show()","","<\\t\\t{only available when compiled with the |+balloon_eval_term|","\\t\\tfeature}",""],"ch_canread":["\\t\\tReturn non-zero when there is something to read from {handle}.","\\t\\t{handle} can be a Channel or a Job that has a Channel.","","\\t\\tThis is useful to read from a channel at a convenient time,","\\t\\te.g. from a timer.","","\\t\\tNote that messages are dropped when the channel does not have","\\t\\ta callback.  Add a close callback to avoid that.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetChannel()->ch_canread()"],"ch_close":["\\t\\tClose {handle}.  See |channel-close|.","\\t\\t{handle} can be a Channel or a Job that has a Channel.","\\t\\tA close callback is not invoked.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetChannel()->ch_close()"],"ch_close_in":["\\t\\tClose the \\"in\\" part of {handle}.  See |channel-close-in|.","\\t\\t{handle} can be a Channel or a Job that has a Channel.","\\t\\tA close callback is not invoked.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetChannel()->ch_close_in()",""],"ch_evalexpr":["\\t\\tSend {expr} over {handle}.  The {expr} is encoded","\\t\\taccording to the type of channel.  The function cannot be used","\\t\\twith a raw channel.  See |channel-use|.","\\t\\t{handle} can be a Channel or a Job that has a Channel.","\\t\\t\\t\\t\\t\\t\\t\\t*E917*","\\t\\t{options} must be a Dictionary.  It must not have a \\"callback\\"","\\t\\tentry.  It can have a \\"timeout\\" entry to specify the timeout","\\t\\tfor this specific request.","","\\t\\tch_evalexpr() waits for a response and returns the decoded","\\t\\texpression.  When there is an error or timeout it returns an","\\t\\tempty string.","","\\t\\tNote that while waiting for the response, Vim handles other","\\t\\tmessages.  You need to make sure this doesn\'t cause trouble.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetChannel()->ch_evalexpr(expr)",""],"ch_evalraw":["\\t\\tSend {string} over {handle}.","\\t\\t{handle} can be a Channel or a Job that has a Channel.","","\\t\\tWorks like |ch_evalexpr()|, but does not encode the request or","\\t\\tdecode the response.  The caller is responsible for the","\\t\\tcorrect contents.  Also does not add a newline for a channel","\\t\\tin NL mode, the caller must do that.  The NL in the response","\\t\\tis removed.","\\t\\tNote that Vim does not know when the text received on a raw","\\t\\tchannel is complete, it may only return the first part and you","\\t\\tneed to use |ch_readraw()| to fetch the rest.","\\t\\tSee |channel-use|.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetChannel()->ch_evalraw(rawstring)"],"ch_getbufnr":["\\t\\tGet the buffer number that {handle} is using for {what}.","\\t\\t{handle} can be a Channel or a Job that has a Channel.","\\t\\t{what} can be \\"err\\" for stderr, \\"out\\" for stdout or empty for","\\t\\tsocket output.","\\t\\tReturns -1 when there is no buffer.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetChannel()->ch_getbufnr(what)"],"ch_getjob":["\\t\\tGet the Job associated with {channel}.","\\t\\tIf there is no job calling |job_status()| on the returned Job","\\t\\twill result in \\"fail\\".","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetChannel()->ch_getjob()",""],"ch_info":["\\t\\tReturns a Dictionary with information about {handle}.  The","\\t\\titems are:","\\t\\t   \\"id\\"\\t\\t  number of the channel","\\t\\t   \\"status\\"\\t  \\"open\\", \\"buffered\\" or \\"closed\\", like","\\t\\t\\t\\t  ch_status()","\\t\\tWhen opened with ch_open():","\\t\\t   \\"hostname\\"\\t  the hostname of the address","\\t\\t   \\"port\\"\\t  the port of the address","\\t\\t   \\"sock_status\\"  \\"open\\" or \\"closed\\"","\\t\\t   \\"sock_mode\\"\\t  \\"NL\\", \\"RAW\\", \\"JSON\\" or \\"JS\\"","\\t\\t   \\"sock_io\\"\\t  \\"socket\\"","\\t\\t   \\"sock_timeout\\" timeout in msec","\\t\\tWhen opened with job_start():","\\t\\t   \\"out_status\\"\\t  \\"open\\", \\"buffered\\" or \\"closed\\"","\\t\\t   \\"out_mode\\"\\t  \\"NL\\", \\"RAW\\", \\"JSON\\" or \\"JS\\"","\\t\\t   \\"out_io\\"\\t  \\"null\\", \\"pipe\\", \\"file\\" or \\"buffer\\"","\\t\\t   \\"out_timeout\\"  timeout in msec","\\t\\t   \\"err_status\\"\\t  \\"open\\", \\"buffered\\" or \\"closed\\"","\\t\\t   \\"err_mode\\"\\t  \\"NL\\", \\"RAW\\", \\"JSON\\" or \\"JS\\"","\\t\\t   \\"err_io\\"\\t  \\"out\\", \\"null\\", \\"pipe\\", \\"file\\" or \\"buffer\\"","\\t\\t   \\"err_timeout\\"  timeout in msec","\\t\\t   \\"in_status\\"\\t  \\"open\\" or \\"closed\\"","\\t\\t   \\"in_mode\\"\\t  \\"NL\\", \\"RAW\\", \\"JSON\\" or \\"JS\\"","\\t\\t   \\"in_io\\"\\t  \\"null\\", \\"pipe\\", \\"file\\" or \\"buffer\\"","\\t\\t   \\"in_timeout\\"\\t  timeout in msec","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetChannel()->ch_info()",""],"ch_log":["\\t\\tWrite {msg} in the channel log file, if it was opened with","\\t\\t|ch_logfile()|.","\\t\\tWhen {handle} is passed the channel number is used for the","\\t\\tmessage.","\\t\\t{handle} can be a Channel or a Job that has a Channel.  The","\\t\\tChannel must be open for the channel number to be used.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\t\'did something\'->ch_log()",""],"ch_logfile":["\\t\\tStart logging channel activity to {fname}.","\\t\\tWhen {fname} is an empty string: stop logging.","","\\t\\tWhen {mode} is omitted or \\"a\\" append to the file.","\\t\\tWhen {mode} is \\"w\\" start with an empty file.","","\\t\\tUse |ch_log()| to write log messages.  The file is flushed","\\t\\tafter every message, on Unix you can use \\"tail -f\\" to see what","\\t\\tis going on in real time.","","\\t\\tThis function is not available in the |sandbox|.","\\t\\tNOTE: the channel communication is stored in the file, be","\\t\\taware that this may contain confidential and privacy sensitive","\\t\\tinformation, e.g. a password you type in a terminal window.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\t\'logfile\'->ch_logfile(\'w\')",""],"ch_open":["\\t\\tOpen a channel to {address}.  See |channel|.","\\t\\tReturns a Channel.  Use |ch_status()| to check for failure.","","\\t\\t{address} has the form \\"hostname:port\\", e.g.,","\\t\\t\\"localhost:8765\\".","","\\t\\tIf {options} is given it must be a |Dictionary|.","\\t\\tSee |channel-open-options|.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetAddress()->ch_open()",""],"ch_read":["\\t\\tRead from {handle} and return the received message.","\\t\\t{handle} can be a Channel or a Job that has a Channel.","\\t\\tFor a NL channel this waits for a NL to arrive, except when","\\t\\tthere is nothing more to read (channel was closed).","\\t\\tSee |channel-more|.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetChannel()->ch_read()",""],"ch_readblob":["\\t\\tLike ch_read() but reads binary data and returns a |Blob|.","\\t\\tSee |channel-more|.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetChannel()->ch_readblob()",""],"ch_readraw":["\\t\\tLike ch_read() but for a JS and JSON channel does not decode","\\t\\tthe message.  For a NL channel it does not block waiting for","\\t\\tthe NL to arrive, but otherwise works like ch_read().","\\t\\tSee |channel-more|.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetChannel()->ch_readraw()",""],"ch_sendexpr":["\\t\\tSend {expr} over {handle}.  The {expr} is encoded","\\t\\taccording to the type of channel.  The function cannot be used","\\t\\twith a raw channel.","\\t\\tSee |channel-use|.\\t\\t\\t\\t*E912*","\\t\\t{handle} can be a Channel or a Job that has a Channel.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetChannel()->ch_sendexpr(expr)",""],"ch_sendraw":["\\t\\tSend |String| or |Blob| {expr} over {handle}.","\\t\\tWorks like |ch_sendexpr()|, but does not encode the request or","\\t\\tdecode the response.  The caller is responsible for the","\\t\\tcorrect contents.  Also does not add a newline for a channel","\\t\\tin NL mode, the caller must do that.  The NL in the response","\\t\\tis removed.","\\t\\tSee |channel-use|.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetChannel()->ch_sendraw(rawexpr)",""],"ch_setoptions":["\\t\\tSet options on {handle}:","\\t\\t\\t\\"callback\\"\\tthe channel callback","\\t\\t\\t\\"timeout\\"\\tdefault read timeout in msec","\\t\\t\\t\\"mode\\"\\t\\tmode for the whole channel","\\t\\tSee |ch_open()| for more explanation.","\\t\\t{handle} can be a Channel or a Job that has a Channel.","","\\t\\tNote that changing the mode may cause queued messages to be","\\t\\tlost.","","\\t\\tThese options cannot be changed:","\\t\\t\\t\\"waittime\\"\\tonly applies to |ch_open()|","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetChannel()->ch_setoptions(options)",""],"ch_status":["\\t\\tReturn the status of {handle}:","\\t\\t\\t\\"fail\\"\\t\\tfailed to open the channel","\\t\\t\\t\\"open\\"\\t\\tchannel can be used","\\t\\t\\t\\"buffered\\"\\tchannel can be read, not written to","\\t\\t\\t\\"closed\\"\\tchannel can not be used","\\t\\t{handle} can be a Channel or a Job that has a Channel.","\\t\\t\\"buffered\\" is used when the channel was closed but there is","\\t\\tstill data that can be obtained with |ch_read()|.","","\\t\\tIf {options} is given it can contain a \\"part\\" entry to specify","\\t\\tthe part of the channel to return the status for: \\"out\\" or","\\t\\t\\"err\\".  For example, to get the error status: >","\\t\\t\\tch_status(job, {\\"part\\": \\"err\\"})","<","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetChannel()->ch_status()"],"chdir":["\\t\\tChange the current working directory to {dir}.  The scope of","\\t\\tthe directory change depends on the directory of the current","\\t\\twindow:","\\t\\t\\t- If the current window has a window-local directory","\\t\\t\\t  (|:lcd|), then changes the window local directory.","\\t\\t\\t- Otherwise, if the current tabpage has a local","\\t\\t\\t  directory (|:tcd|) then changes the tabpage local","\\t\\t\\t  directory.","\\t\\t\\t- Otherwise, changes the global directory.","\\t\\tIf successful, returns the previous working directory.  Pass","\\t\\tthis to another chdir() to restore the directory.","\\t\\tOn failure, returns an empty string.","","\\t\\tExample: >","\\t\\t\\tlet save_dir = chdir(newdir)","\\t\\t\\tif save_dir != \\"\\"","\\t\\t\\t   \\" ... do some work","\\t\\t\\t   call chdir(save_dir)","\\t\\t\\tendif","","<\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetDir()->chdir()"],"getimstatus":["\\t\\tThe result is a Number, which is |TRUE| when the IME status is","\\t\\tactive.","\\t\\tSee \'imstatusfunc\'."],"getmousepos":["\\t\\tReturns a Dictionary with the last known position of the","\\t\\tmouse.  This can be used in a mapping for a mouse click or in","\\t\\ta filter of a popup window.  The items are:","\\t\\t\\tscreenrow\\tscreen row","\\t\\t\\tscreencol\\tscreen column","\\t\\t\\twinid\\t\\tWindow ID of the click","\\t\\t\\twinrow\\t\\trow inside \\"winid\\"","\\t\\t\\twincol\\t\\tcolumn inside \\"winid\\"","\\t\\t\\tline\\t\\ttext line inside \\"winid\\"","\\t\\t\\tcolumn\\t\\ttext column inside \\"winid\\"","\\t\\tAll numbers are 1-based.","","\\t\\tIf not over a window, e.g. when in the command line, then only","\\t\\t\\"screenrow\\" and \\"screencol\\" are valid, the others are zero.","","\\t\\tWhen on the status line below a window or the vertical","\\t\\tseparater right of a window, the \\"line\\" and \\"column\\" values","\\t\\tare zero.","","\\t\\tWhen the position is after the text then \\"column\\" is the","\\t\\tlength of the text in bytes.","","\\t\\tIf the mouse is over a popup window then that window is used.","","","\\t\\tWhen using |getchar()| the Vim variables |v:mouse_lnum|,","\\t\\t|v:mouse_col| and |v:mouse_winid| also provide these values.",""],"inputdialog":["\\t\\tLike |input()|, but when the GUI is running and text dialogs","\\t\\tare supported, a dialog window pops up to input the text.","\\t\\tExample: >","\\t\\t   :let n = inputdialog(\\"value for shiftwidth\\", shiftwidth())","\\t\\t   :if n != \\"\\"","\\t\\t   :  let &sw = n","\\t\\t   :endif","<\\t\\tWhen the dialog is cancelled {cancelreturn} is returned.  When","\\t\\tomitted an empty string is returned.","\\t\\tHitting <Enter> works like pressing the OK button.  Hitting","\\t\\t<Esc> works like pressing the Cancel button.","\\t\\tNOTE: Command-line completion is not supported.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetPrompt()->inputdialog()"],"interrupt":["\\t\\tInterrupt script execution.  It works more or less like the","\\t\\tuser typing CTRL-C, most commands won\'t execute and control","\\t\\treturns to the user.  This is useful to abort execution","\\t\\tfrom lower down, e.g. in an autocommand.  Example: >","\\t\\t:function s:check_typoname(file)","\\t\\t:   if fnamemodify(a:file, \':t\') == \'[\'","\\t\\t:       echomsg \'Maybe typo\'","\\t\\t:       call interrupt()","\\t\\t:   endif","\\t\\t:endfunction","\\t\\t:au BufWritePre * call s:check_typoname(expand(\'<amatch>\'))"],"job_getchannel":["\\t\\tGet the channel handle that {job} is using.","\\t\\tTo check if the job has no channel: >","\\t\\t\\tif string(job_getchannel()) == \'channel fail\'","<","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetJob()->job_getchannel()"],"job_info":["\\t\\tReturns a Dictionary with information about {job}:","\\t\\t   \\"status\\"\\twhat |job_status()| returns","\\t\\t   \\"channel\\"\\twhat |job_getchannel()| returns","\\t\\t   \\"cmd\\"\\tList of command arguments used to start the job","\\t\\t   \\"process\\"\\tprocess ID","\\t\\t   \\"tty_in\\"\\tterminal input name, empty when none","\\t\\t   \\"tty_out\\"\\tterminal output name, empty when none","\\t\\t   \\"exitval\\"\\tonly valid when \\"status\\" is \\"dead\\"","\\t\\t   \\"exit_cb\\"\\tfunction to be called on exit","\\t\\t   \\"stoponexit\\"\\t|job-stoponexit|","","\\t\\t   Only in Unix:","\\t\\t   \\"termsig\\"\\tthe signal which terminated the process","\\t\\t\\t\\t(See |job_stop()| for the values)","\\t\\t\\t\\tonly valid when \\"status\\" is \\"dead\\"","","\\t\\t   Only in MS-Windows:","\\t\\t   \\"tty_type\\"\\tType of virtual console in use.","\\t\\t\\t\\tValues are \\"winpty\\" or \\"conpty\\".","\\t\\t\\t\\tSee \'termwintype\'.","","\\t\\tWithout any arguments, returns a List with all Job objects.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetJob()->job_info()",""],"job_setoptions":["\\t\\tChange options for {job}.  Supported are:","\\t\\t   \\"stoponexit\\"\\t|job-stoponexit|","\\t\\t   \\"exit_cb\\"\\t|job-exit_cb|","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetJob()->job_setoptions(options)",""],"job_start":["\\t\\tStart a job and return a Job object.  Unlike |system()| and","\\t\\t|:!cmd| this does not wait for the job to finish.","\\t\\tTo start a job in a terminal window see |term_start()|.","","\\t\\tIf the job fails to start then |job_status()| on the returned","\\t\\tJob object results in \\"fail\\" and none of the callbacks will be","\\t\\tinvoked.","","\\t\\t{command} can be a String.  This works best on MS-Windows.  On","\\t\\tUnix it is split up in white-separated parts to be passed to","\\t\\texecvp().  Arguments in double quotes can contain white space.","","\\t\\t{command} can be a List, where the first item is the executable","\\t\\tand further items are the arguments.  All items are converted","\\t\\tto String.  This works best on Unix.","","\\t\\tOn MS-Windows, job_start() makes a GUI application hidden. If","\\t\\twant to show it, Use |:!start| instead.","","\\t\\tThe command is executed directly, not through a shell, the","\\t\\t\'shell\' option is not used.  To use the shell: >","\\tlet job = job_start([\\"/bin/sh\\", \\"-c\\", \\"echo hello\\"])","<\\t\\tOr: >","\\tlet job = job_start(\'/bin/sh -c \\"echo hello\\"\')","<\\t\\tNote that this will start two processes, the shell and the","\\t\\tcommand it executes.  If you don\'t want this use the \\"exec\\"","\\t\\tshell command.","","\\t\\tOn Unix $PATH is used to search for the executable only when","\\t\\tthe command does not contain a slash.","","\\t\\tThe job will use the same terminal as Vim.  If it reads from","\\t\\tstdin the job and Vim will be fighting over input, that","\\t\\tdoesn\'t work.  Redirect stdin and stdout to avoid problems: >","\\tlet job = job_start([\'sh\', \'-c\', \\"myserver </dev/null >/dev/null\\"])","<","\\t\\tThe returned Job object can be used to get the status with","\\t\\t|job_status()| and stop the job with |job_stop()|.","","\\t\\tNote that the job object will be deleted if there are no","\\t\\treferences to it.  This closes the stdin and stderr, which may","\\t\\tcause the job to fail with an error.  To avoid this keep a","\\t\\treference to the job.  Thus instead of: >","\\tcall job_start(\'my-command\')","<\\t\\tuse: >","\\tlet myjob = job_start(\'my-command\')","<\\t\\tand unlet \\"myjob\\" once the job is not needed or is past the","\\t\\tpoint where it would fail (e.g. when it prints a message on","\\t\\tstartup).  Keep in mind that variables local to a function","\\t\\twill cease to exist if the function returns.  Use a","\\t\\tscript-local variable if needed: >","\\tlet s:myjob = job_start(\'my-command\')","<","\\t\\t{options} must be a Dictionary.  It can contain many optional","\\t\\titems, see |job-options|.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tBuildCommand()->job_start()",""],"job_status":["\\t\\tReturns a String with the status of {job}:","\\t\\t\\t\\"run\\"\\tjob is running","\\t\\t\\t\\"fail\\"\\tjob failed to start","\\t\\t\\t\\"dead\\"\\tjob died or was stopped after running","","\\t\\tOn Unix a non-existing command results in \\"dead\\" instead of","\\t\\t\\"fail\\", because a fork happens before the failure can be","\\t\\tdetected.","","\\t\\tIf an exit callback was set with the \\"exit_cb\\" option and the","\\t\\tjob is now detected to be \\"dead\\" the callback will be invoked.","","\\t\\tFor more information see |job_info()|.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetJob()->job_status()",""],"job_stop":["\\t\\tStop the {job}.  This can also be used to signal the job.","","\\t\\tWhen {how} is omitted or is \\"term\\" the job will be terminated.","\\t\\tFor Unix SIGTERM is sent.  On MS-Windows the job will be","\\t\\tterminated forcedly (there is no \\"gentle\\" way).","\\t\\tThis goes to the process group, thus children may also be","\\t\\taffected.","","\\t\\tEffect for Unix:","\\t\\t\\t\\"term\\"\\t SIGTERM (default)","\\t\\t\\t\\"hup\\"\\t SIGHUP","\\t\\t\\t\\"quit\\"\\t SIGQUIT","\\t\\t\\t\\"int\\"\\t SIGINT","\\t\\t\\t\\"kill\\"\\t SIGKILL (strongest way to stop)","\\t\\t\\tnumber\\t signal with that number","","\\t\\tEffect for MS-Windows:","\\t\\t\\t\\"term\\"\\t terminate process forcedly (default)","\\t\\t\\t\\"hup\\"\\t CTRL_BREAK","\\t\\t\\t\\"quit\\"\\t CTRL_BREAK","\\t\\t\\t\\"int\\"\\t CTRL_C","\\t\\t\\t\\"kill\\"\\t terminate process forcedly","\\t\\t\\tOthers\\t CTRL_BREAK","","\\t\\tOn Unix the signal is sent to the process group.  This means","\\t\\tthat when the job is \\"sh -c command\\" it affects both the shell","\\t\\tand the command.","","\\t\\tThe result is a Number: 1 if the operation could be executed,","\\t\\t0 if \\"how\\" is not supported on the system.","\\t\\tNote that even when the operation was executed, whether the","\\t\\tjob was actually stopped needs to be checked with","\\t\\t|job_status()|.","","\\t\\tIf the status of the job is \\"dead\\", the signal will not be","\\t\\tsent.  This is to avoid to stop the wrong job (esp. on Unix,","\\t\\twhere process numbers are recycled).","","\\t\\tWhen using \\"kill\\" Vim will assume the job will die and close","\\t\\tthe channel.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetJob()->job_stop()",""],"js_decode":["\\t\\tThis is similar to |json_decode()| with these differences:","\\t\\t- Object key names do not have to be in quotes.","\\t\\t- Strings can be in single quotes.","\\t\\t- Empty items in an array (between two commas) are allowed and","\\t\\t  result in v:none items.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tReadObject()->js_decode()"],"js_encode":["\\t\\tThis is similar to |json_encode()| with these differences:","\\t\\t- Object key names are not in quotes.","\\t\\t- v:none items in an array result in an empty item between","\\t\\t  commas.","\\t\\tFor example, the Vim object:","\\t\\t\\t[1,v:none,{\\"one\\":1},v:none] ~","\\t\\tWill be encoded as:","\\t\\t\\t[1,,{one:1},,] ~","\\t\\tWhile json_encode() would produce:","\\t\\t\\t[1,null,{\\"one\\":1},null] ~","\\t\\tThis encoding is valid for JavaScript. It is more efficient","\\t\\tthan JSON, especially when using an array with optional items.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetObject()->js_encode()"],"listener_add":["\\t\\tAdd a callback function that will be invoked when changes have","\\t\\tbeen made to buffer {buf}.","\\t\\t{buf} refers to a buffer name or number. For the accepted","\\t\\tvalues, see |bufname()|.  When {buf} is omitted the current","\\t\\tbuffer is used.","\\t\\tReturns a unique ID that can be passed to |listener_remove()|.","","\\t\\tThe {callback} is invoked with five arguments:","\\t\\t    a:bufnr\\tthe buffer that was changed","\\t\\t    a:start\\tfirst changed line number","\\t\\t    a:end\\tfirst line number below the change","\\t\\t    a:added\\tnumber of lines added, negative if lines were","\\t\\t\\t\\tdeleted","\\t\\t    a:changes\\ta List of items with details about the changes","","\\t\\tExample: >","\\t    func Listener(bufnr, start, end, added, changes)","\\t      echo \'lines \' .. a:start .. \' until \' .. a:end .. \' changed\'","\\t    endfunc","\\t    call listener_add(\'Listener\', bufnr)","","<\\t\\tThe List cannot be changed.  Each item in a:changes is a","\\t\\tdictionary with these entries:","\\t\\t    lnum\\tthe first line number of the change","\\t\\t    end\\t\\tthe first line below the change","\\t\\t    added\\tnumber of lines added; negative if lines were","\\t\\t\\t\\tdeleted","\\t\\t    col\\t\\tfirst column in \\"lnum\\" that was affected by","\\t\\t\\t\\tthe change; one if unknown or the whole line","\\t\\t\\t\\twas affected; this is a byte index, first","\\t\\t\\t\\tcharacter has a value of one.","\\t\\tWhen lines are inserted the values are:","\\t\\t    lnum\\tline above which the new line is added","\\t\\t    end\\t\\tequal to \\"lnum\\"","\\t\\t    added\\tnumber of lines inserted","\\t\\t    col\\t\\t1","\\t\\tWhen lines are deleted the values are:","\\t\\t    lnum\\tthe first deleted line","\\t\\t    end\\t\\tthe line below the first deleted line, before","\\t\\t\\t\\tthe deletion was done","\\t\\t    added\\tnegative, number of lines deleted","\\t\\t    col\\t\\t1","\\t\\tWhen lines are changed:","\\t\\t    lnum\\tthe first changed line","\\t\\t    end\\t\\tthe line below the last changed line","\\t\\t    added\\t0","\\t\\t    col\\t\\tfirst column with a change or 1","","\\t\\tThe entries are in the order the changes were made, thus the","\\t\\tmost recent change is at the end.  The line numbers are valid","\\t\\twhen the callback is invoked, but later changes may make them","\\t\\tinvalid, thus keeping a copy for later might not work.","","\\t\\tThe {callback} is invoked just before the screen is updated,","\\t\\twhen |listener_flush()| is called or when a change is being","\\t\\tmade that changes the line count in a way it causes a line","\\t\\tnumber in the list of changes to become invalid.","","\\t\\tThe {callback} is invoked with the text locked, see","\\t\\t|textlock|.  If you do need to make changes to the buffer, use","\\t\\ta timer to do this later |timer_start()|.","","\\t\\tThe {callback} is not invoked when the buffer is first loaded.","\\t\\tUse the |BufReadPost| autocmd event to handle the initial text","\\t\\tof a buffer.","\\t\\tThe {callback} is also not invoked when the buffer is","\\t\\tunloaded, use the |BufUnload| autocmd event for that.","","\\t\\tCan also be used as a |method|, the base is passed as the","\\t\\tsecond argument: >","\\t\\t\\tGetBuffer()->listener_add(callback)"],"listener_flush":["\\t\\tInvoke listener callbacks for buffer {buf}.  If there are no","\\t\\tpending changes then no callbacks are invoked.","","\\t\\t{buf} refers to a buffer name or number. For the accepted","\\t\\tvalues, see |bufname()|.  When {buf} is omitted the current","\\t\\tbuffer is used.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetBuffer()->listener_flush()"],"listener_remove":["\\t\\tRemove a listener previously added with listener_add().","\\t\\tReturns zero when {id} could not be found, one when {id} was","\\t\\tremoved.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetListenerId()->listener_remove()"],"mzeval":["\\t\\tEvaluate MzScheme expression {expr} and return its result","\\t\\tconverted to Vim data structures.","\\t\\tNumbers and strings are returned as they are.","\\t\\tPairs (including lists and improper lists) and vectors are","\\t\\treturned as Vim |Lists|.","\\t\\tHash tables are represented as Vim |Dictionary| type with keys","\\t\\tconverted to strings.","\\t\\tAll other types are converted to string with display function.","\\t\\tExamples: >","\\t\\t    :mz (define l (list 1 2 3))","\\t\\t    :mz (define h (make-hash)) (hash-set! h \\"list\\" l)","\\t\\t    :echo mzeval(\\"l\\")","\\t\\t    :echo mzeval(\\"h\\")","<","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetExpr()->mzeval()","<","\\t\\t{only available when compiled with the |+mzscheme| feature}"],"perleval":["\\t\\tEvaluate Perl expression {expr} in scalar context and return","\\t\\tits result converted to Vim data structures. If value can\'t be","\\t\\tconverted, it is returned as a string Perl representation.","\\t\\tNote: If you want an array or hash, {expr} must return a","\\t\\treference to it.","\\t\\tExample: >","\\t\\t\\t:echo perleval(\'[1 .. 4]\')","<\\t\\t\\t[1, 2, 3, 4]","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetExpr()->perleval()","","<\\t\\t{only available when compiled with the |+perl| feature}","","","popup_ functions are documented here: |popup-functions|.",""],"popup_atcursor":["\\t\\tShow the {what} above the cursor, and close it when the cursor","\\t\\tmoves.  This works like: >","\\t\\t\\tcall popup_create({what}, #{","\\t\\t\\t\\t\\\\ pos: \'botleft\',","\\t\\t\\t\\t\\\\ line: \'cursor-1\',","\\t\\t\\t\\t\\\\ col: \'cursor\',","\\t\\t\\t\\t\\\\ moved: \'WORD\',","\\t\\t\\t\\t\\\\ })","<\\t\\tUse {options} to change the properties.","\\t\\tIf \\"pos\\" is passed as \\"topleft\\" then the default for \\"line\\"","\\t\\tbecomes \\"cursor+1\\".","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetText()->popup_atcursor({})",""],"popup_beval":["\\t\\tShow the {what} above the position from \'ballooneval\' and","\\t\\tclose it when the mouse moves.  This works like: >","\\t\\t  let pos = screenpos(v:beval_winnr, v:beval_lnum, v:beval_col)","\\t\\t  call popup_create({what}, #{","\\t\\t\\t\\\\ pos: \'botleft\',","\\t\\t\\t\\\\ line: pos.row - 1,","\\t\\t\\t\\\\ col: pos.col,","\\t\\t\\t\\\\ mousemoved: \'WORD\',","\\t\\t\\t\\\\ })","<\\t\\tUse {options} to change the properties.","\\t\\tSee |popup_beval_example| for an example.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetText()->popup_beval({})","<"],"popup_clear":["\\t\\twindows for the current tab and global popups.",""],"popup_close":["\\t\\tClose popup {id}.  The window and the associated buffer will","\\t\\tbe deleted.","","\\t\\tIf the popup has a callback it will be called just before the","\\t\\tpopup window is deleted.  If the optional {result} is present","\\t\\tit will be passed as the second argument of the callback.","\\t\\tOtherwise zero is passed to the callback.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetPopup()->popup_close()"],"popup_create":["\\t\\tOpen a popup window showing {what}, which is either:","\\t\\t- a buffer number","\\t\\t- a string","\\t\\t- a list of strings","\\t\\t- a list of text lines with text properties","\\t\\tWhen {what} is not a buffer number, a buffer is created with","\\t\\t\'buftype\' set to \\"popup\\".  That buffer will be wiped out once","\\t\\tthe popup closes.","","\\t\\t{options} is a dictionary with many possible entries.","\\t\\tSee |popup_create-arguments| for details.","","\\t\\tReturns a window-ID, which can be used with other popup","\\t\\tfunctions.  Use `winbufnr()` to get the number of the buffer","\\t\\tin the window: >","\\t\\t\\tlet winid = popup_create(\'hello\', {})","\\t\\t\\tlet bufnr = winbufnr(winid)","\\t\\t\\tcall setbufline(bufnr, 2, \'second line\')","<\\t\\tIn case of failure zero is returned.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetText()->popup_create({})"],"popup_dialog":["\\t\\tJust like |popup_create()| but with these default options: >","\\t\\t\\tcall popup_create({what}, #{","\\t\\t\\t\\t\\\\ pos: \'center\',","\\t\\t\\t\\t\\\\ zindex: 200,","\\t\\t\\t\\t\\\\ drag: 1,","\\t\\t\\t\\t\\\\ border: [],","\\t\\t\\t\\t\\\\ padding: [],","\\t\\t\\t\\t\\\\ mapping: 0,","\\t\\t\\t\\t\\\\})","<\\t\\tUse {options} to change the properties. E.g. add a \'filter\'","\\t\\toption with value \'popup_filter_yesno\'.  Example: >","\\t\\t\\tcall popup_create(\'do you want to quit (Yes/no)?\', #{","\\t\\t\\t\\t\\\\ filter: \'popup_filter_yesno\',","\\t\\t\\t\\t\\\\ callback: \'QuitCallback\',","\\t\\t\\t\\t\\\\ })","","<\\t\\tBy default the dialog can be dragged, so that text below it","\\t\\tcan be read if needed.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetText()->popup_dialog({})"],"popup_filter_menu":["\\t\\tFilter that can be used for a popup. These keys can be used:","\\t\\t    j <Down>\\t\\tselect item below","\\t\\t    k <Up>\\t\\tselect item above","\\t\\t    <Space> <Enter>\\taccept current selection","\\t\\t    x Esc CTRL-C\\tcancel the menu","\\t\\tOther keys are ignored.","","\\t\\tA match is set on that line to highlight it, see","\\t\\t|popup_menu()|.","","\\t\\tWhen the current selection is accepted the \\"callback\\" of the","\\t\\tpopup menu is invoked with the index of the selected line as","\\t\\tthe second argument.  The first entry has index one.","\\t\\tCancelling the menu invokes the callback with -1.","","\\t\\tTo add shortcut keys, see the example here:","\\t\\t|popup_menu-shortcut-example|",""],"popup_filter_yesno":["\\t\\tFilter that can be used for a popup. It handles only the keys","\\t\\t\'y\', \'Y\' and \'n\' or \'N\'.  Invokes the \\"callback\\" of the","\\t\\tpopup menu with the 1 for \'y\' or \'Y\' and zero for \'n\' or \'N\'","\\t\\tas the second argument.  Pressing Esc and \'x\' works like","\\t\\tpressing \'n\'.  CTRL-C invokes the callback with -1.  Other","\\t\\tkeys are ignored.","\\t\\tSee the example here: |popup_dialog-example|",""],"popup_findinfo":["\\t\\tGet the |window-ID| for the popup info window, as it used by","\\t\\tthe popup menu.  See |complete-popup|.  The info popup is","\\t\\thidden when not used, it can be deleted with |popup_clear()|","\\t\\tand |popup_close()|.  Use |popup_show()| to reposition it to","\\t\\tthe item in the popup menu.","\\t\\tReturns zero if there is none.",""],"popup_findpreview":["\\t\\tGet the |window-ID| for the popup preview window.","\\t\\tReturn zero if there is none.",""],"popup_getoptions":["\\t\\tReturn the {options} for popup {id} in a Dict.","\\t\\tA zero value means the option was not set.  For \\"zindex\\" the","\\t\\tdefault value is returned, not zero.","","\\t\\tThe \\"moved\\" entry is a list with line number, minimum and","\\t\\tmaximum column, [0, 0, 0] when not set.","","\\t\\tThe \\"mousemoved\\" entry is a list with screen row, minimum and","\\t\\tmaximum screen column, [0, 0, 0] when not set.","","\\t\\t\\"firstline\\" is the property set on the popup, unlike the","\\t\\t\\"firstline\\" obtained with |popup_getpos()| which is the actual","\\t\\tbuffer line at the top of the popup window.","","\\t\\t\\"border\\" and \\"padding\\" are not included when all values are","\\t\\tzero.  When all values are one then an empty list is included.","","\\t\\t\\"borderhighlight\\" is not included when all values are empty.","\\t\\t\\"scrollbarhighlight\\" and \\"thumbhighlight\\" are only included","\\t\\twhen set.","","\\t\\t\\"tabpage\\" will be -1 for a global popup, zero for a popup on","\\t\\tthe current tabpage and a positive number for a popup on","\\t\\tanother tabpage.","","\\t\\t\\"textprop\\", \\"textpropid\\" and \\"textpropwin\\" are only present","\\t\\twhen \\"textprop\\" was set.","","\\t\\tIf popup window {id} is not found an empty Dict is returned.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetPopup()->popup_getoptions()"],"popup_getpos":["\\t\\tReturn the position and size of popup {id}.  Returns a Dict","\\t\\twith these entries:","\\t\\t    col\\t\\tscreen column of the popup, one-based","\\t\\t    line\\tscreen line of the popup, one-based","\\t\\t    width\\twidth of the whole popup in screen cells","\\t\\t    height\\theight of the whole popup in screen cells","\\t\\t    core_col\\tscreen column of the text box","\\t\\t    core_line\\tscreen line of the text box","\\t\\t    core_width\\twidth of the text box in screen cells","\\t\\t    core_height\\theight of the text box in screen cells","\\t\\t    firstline\\tline of the buffer at top (1 unless scrolled)","\\t\\t\\t\\t(not the value of the \\"firstline\\" property)","\\t\\t    lastline\\tline of the buffer at the bottom (updated when","\\t\\t\\t\\tthe popup is redrawn)","\\t\\t    scrollbar\\tnon-zero if a scrollbar is displayed","\\t\\t    visible\\tone if the popup is displayed, zero if hidden","\\t\\tNote that these are the actual screen positions.  They differ","\\t\\tfrom the values in `popup_getoptions()` for the sizing and","\\t\\tpositioning mechanism applied.","","\\t\\tThe \\"core_\\" values exclude the padding and border.","","\\t\\tIf popup window {id} is not found an empty Dict is returned.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetPopup()->popup_getpos()"],"popup_hide":["\\t\\tIf {id} is a displayed popup, hide it now. If the popup has a","\\t\\tfilter it will not be invoked for so long as the popup is","\\t\\thidden.","\\t\\tIf window {id} does not exist nothing happens.  If window {id}","\\t\\texists but is not a popup window an error is given. *E993*","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetPopup()->popup_hide()"],"popup_menu":["\\t\\tShow the {what} near the cursor, handle selecting one of the","\\t\\titems with cursorkeys, and close it an item is selected with","\\t\\tSpace or Enter. {what} should have multiple lines to make this","\\t\\tuseful.  This works like: >","\\t\\t\\tcall popup_create({what}, #{","\\t\\t\\t\\t\\\\ pos: \'center\',","\\t\\t\\t\\t\\\\ zindex: 200,","\\t\\t\\t\\t\\\\ drag: 1,","\\t\\t\\t\\t\\\\ wrap: 0,","\\t\\t\\t\\t\\\\ border: [],","\\t\\t\\t\\t\\\\ cursorline: 1,","\\t\\t\\t\\t\\\\ padding: [0,1,0,1],","\\t\\t\\t\\t\\\\ filter: \'popup_filter_menu\',","\\t\\t\\t\\t\\\\ mapping: 0,","\\t\\t\\t\\t\\\\ })","<\\t\\tThe current line is highlighted with a match using","\\t\\t\\"PopupSelected\\", or \\"PmenuSel\\" if that is not defined.","","\\t\\tUse {options} to change the properties.  Should at least set","\\t\\t\\"callback\\" to a function that handles the selected item.","\\t\\tExample: >","\\t\\t\\tfunc ColorSelected(id, result)","\\t\\t\\t   \\" use a:result","\\t\\t\\tendfunc","\\t\\t\\tcall popup_menu([\'red\', \'green\', \'blue\'], #{","\\t\\t\\t\\t\\\\ callback: \'ColorSelected\',","\\t\\t\\t\\t\\\\ })","","<\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetChoices()->popup_menu({})"],"popup_move":["\\t\\tMove popup {id} to the position specified with {options}.","\\t\\t{options} may contain the items from |popup_create()| that","\\t\\tspecify the popup position:","\\t\\t\\tline","\\t\\t\\tcol","\\t\\t\\tpos","\\t\\t\\tmaxheight","\\t\\t\\tminheight","\\t\\t\\tmaxwidth","\\t\\t\\tminwidth","\\t\\t\\tfixed","\\t\\tFor {id} see `popup_hide()`.","\\t\\tFor other options see |popup_setoptions()|.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetPopup()->popup_move(options)"],"popup_notification":["\\t\\tShow the {what} for 3 seconds at the top of the Vim window.","\\t\\tThis works like: >","\\t\\t\\tcall popup_create({what}, #{","\\t\\t\\t\\t\\\\ line: 1,","\\t\\t\\t\\t\\\\ col: 10,","\\t\\t\\t\\t\\\\ minwidth: 20,","\\t\\t\\t\\t\\\\ time: 3000,","\\t\\t\\t\\t\\\\ tabpage: -1,","\\t\\t\\t\\t\\\\ zindex: 300,","\\t\\t\\t\\t\\\\ drag: 1,","\\t\\t\\t\\t\\\\ highlight: \'WarningMsg\',","\\t\\t\\t\\t\\\\ border: [],","\\t\\t\\t\\t\\\\ close: \'click\',","\\t\\t\\t\\t\\\\ padding: [0,1,0,1],","\\t\\t\\t\\t\\\\ })","<\\t\\tThe PopupNotification highlight group is used instead of","\\t\\tWarningMsg if it is defined.","","\\t\\tWithout the |+timers| feature the popup will not disappear","\\t\\tautomatically, the user has to click in it.","","\\t\\tThe position will be adjusted to avoid overlap with other","\\t\\tnotifications.","\\t\\tUse {options} to change the properties.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetText()->popup_notification({})"],"popup_show":["\\t\\tIf {id} is a hidden popup, show it now.","\\t\\tFor {id} see `popup_hide()`.","\\t\\tIf {id} is the info popup it will be positioned next to the","\\t\\tcurrent popup menu item.",""],"popup_setoptions":["\\t\\tOverride options in popup {id} with entries in {options}.","\\t\\tThese options can be set:","\\t\\t\\tborder","\\t\\t\\tborderchars","\\t\\t\\tborderhighlight","\\t\\t\\tcallback","\\t\\t\\tclose","\\t\\t\\tcursorline","\\t\\t\\tdrag","\\t\\t\\tfilter","\\t\\t\\tfirstline","\\t\\t\\tflip","\\t\\t\\thighlight","\\t\\t\\tmapping","\\t\\t\\tmask","\\t\\t\\tmoved","\\t\\t\\tpadding","\\t\\t\\tresize","\\t\\t\\tscrollbar","\\t\\t\\tscrollbarhighlight","\\t\\t\\tthumbhighlight","\\t\\t\\ttime","\\t\\t\\ttitle","\\t\\t\\twrap","\\t\\t\\tzindex","\\t\\tThe options from |popup_move()| can also be used.","\\t\\tFor \\"hidden\\" use |popup_hide()| and |popup_show()|.","\\t\\t\\"tabpage\\" cannot be changed.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetPopup()->popup_setoptions(options)"],"popup_settext":["\\t\\tSet the text of the buffer in popup win {id}. {text} is the","\\t\\tsame as supplied to |popup_create()|, except that a buffer","\\t\\tnumber is not allowed.","\\t\\tDoes not change the window size or position, other than caused","\\t\\tby the different text.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetPopup()->popup_settext(\'hello\')"],"prop_add":["\\t\\tAttach a text property at position {lnum}, {col}.  {col} is","\\t\\tcounted in bytes, use one for the first column.","\\t\\tIf {lnum} is invalid an error is given. *E966*","\\t\\tIf {col} is invalid an error is given. *E964*","","\\t\\t{props} is a dictionary with these fields:","\\t\\t   length\\tlength of text in bytes, can only be used","\\t\\t\\t\\tfor a property that does not continue in","\\t\\t\\t\\tanother line; can be zero","\\t\\t   end_lnum\\tline number for the end of text","\\t\\t   end_col\\tcolumn just after the text; not used when","\\t\\t\\t\\t\\"length\\" is present; when {col} and \\"end_col\\"","\\t\\t\\t\\tare equal, and \\"end_lnum\\" is omitted or equal","\\t\\t\\t\\tto {lnum}, this is a zero-width text property","\\t\\t   bufnr\\tbuffer to add the property to; when omitted","\\t\\t\\t\\tthe current buffer is used","\\t\\t   id\\t\\tuser defined ID for the property; when omitted","\\t\\t\\t\\tzero is used","\\t\\t   type\\t\\tname of the text property type","\\t\\tAll fields except \\"type\\" are optional.","","\\t\\tIt is an error when both \\"length\\" and \\"end_lnum\\" or \\"end_col\\"","\\t\\tare given.  Either use \\"length\\" or \\"end_col\\" for a property","\\t\\twithin one line, or use \\"end_lnum\\" and \\"end_col\\" for a","\\t\\tproperty that spans more than one line.","\\t\\tWhen neither \\"length\\" nor \\"end_col\\" are given the property","\\t\\twill be zero-width.  That means it will not be highlighted but","\\t\\twill move with the text, as a kind of mark.","\\t\\tThe property can end exactly at the last character of the","\\t\\ttext, or just after it.  In the last case, if text is appended","\\t\\tto the line, the text property size will increase, also when","\\t\\tthe property type does not have \\"end_incl\\" set.","","\\t\\t\\"type\\" will first be looked up in the buffer the property is","\\t\\tadded to. When not found, the global property types are used.","\\t\\tIf not found an error is given.","","\\t\\tSee |text-properties| for information about text properties.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetLnum()->prop_add(col, props)",""],"prop_clear":["\\t\\tRemove all text properties from line {lnum}.","\\t\\tWhen {lnum-end} is given, remove all text properties from line","\\t\\t{lnum} to {lnum-end} (inclusive).","","\\t\\tWhen {props} contains a \\"bufnr\\" item use this buffer,","\\t\\totherwise use the current buffer.","","\\t\\tSee |text-properties| for information about text properties.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetLnum()->prop_clear()","<"],"prop_find":["\\t\\t{not implemented yet}","\\t\\tSearch for a text property as specified with {props}:","\\t\\t   id\\t\\tproperty with this ID","\\t\\t   type\\t\\tproperty with this type name","\\t\\t   bufnr\\tbuffer to search in; when present a","\\t\\t\\t\\tstart position with \\"lnum\\" and \\"col\\"","\\t\\t\\t\\tmust be given; when omitted the","\\t\\t\\t\\tcurrent buffer is used","\\t\\t   lnum\\t\\tstart in this line (when omitted start","\\t\\t\\t\\tat the cursor)","\\t\\t   col\\t\\tstart at this column (when omitted","\\t\\t\\t\\tand \\"lnum\\" is given: use column 1,","\\t\\t\\t\\totherwise start at the cursor)","\\t\\t   skipstart\\tdo not look for a match at the start","\\t\\t\\t\\tposition","","\\t\\t{direction} can be \\"f\\" for forward and \\"b\\" for backward.  When","\\t\\tomitted forward search is performed.","","\\t\\tIf a match is found then a Dict is returned with the entries","\\t\\tas with prop_list(), and additionally an \\"lnum\\" entry.","\\t\\tIf no match is found then an empty Dict is returned.","","\\t\\tSee |text-properties| for information about text properties.",""],"prop_list":["\\t\\tReturn a List with all text properties in line {lnum}.","","\\t\\tWhen {props} contains a \\"bufnr\\" item, use this buffer instead","\\t\\tof the current buffer.","","\\t\\tThe properties are ordered by starting column and priority.","\\t\\tEach property is a Dict with these entries:","\\t\\t   col\\t\\tstarting column","\\t\\t   length\\tlength in bytes, one more if line break is","\\t\\t\\t\\tincluded","\\t\\t   id\\t\\tproperty ID","\\t\\t   type\\t\\tname of the property type, omitted if","\\t\\t\\t\\tthe type was deleted","\\t\\t   start\\twhen TRUE property starts in this line","\\t\\t   end\\t\\twhen TRUE property ends in this line","","\\t\\tWhen \\"start\\" is zero the property started in a previous line,","\\t\\tthe current one is a continuation.","\\t\\tWhen \\"end\\" is zero the property continues in the next line.","\\t\\tThe line break after this line is included.","","\\t\\tSee |text-properties| for information about text properties.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetLnum()->prop_list()","<"],"prop_remove":["\\t\\tRemove a matching text property from line {lnum}.  When","\\t\\t{lnum-end} is given, remove matching text properties from line","\\t\\t{lnum} to {lnum-end} (inclusive).","\\t\\tWhen {lnum} is omitted remove matching text properties from","\\t\\tall lines.","","\\t\\t{props} is a dictionary with these fields:","\\t\\t   id\\t\\tremove text properties with this ID","\\t\\t   type\\t\\tremove text properties with this type name","\\t\\t   bufnr\\tuse this buffer instead of the current one","\\t\\t   all\\t\\twhen TRUE remove all matching text properties,","\\t\\t\\t\\tnot just the first one","\\t\\tA property matches when either \\"id\\" or \\"type\\" matches.","\\t\\tIf buffer \\"bufnr\\" does not exist you get an error message.","\\t\\tIf buffer \\"bufnr\\" is not loaded then nothing happens.","","\\t\\tReturns the number of properties that were removed.","","\\t\\tSee |text-properties| for information about text properties.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetProps()->prop_remove()",""],"prop_type_add":["\\t\\tAdd a text property type {name}.  If a property type with this","\\t\\tname already exists an error is given.  Nothing is returned.","\\t\\t{props} is a dictionary with these optional fields:","\\t\\t   bufnr\\tdefine the property only for this buffer; this","\\t\\t\\t\\tavoids name collisions and automatically","\\t\\t\\t\\tclears the property types when the buffer is","\\t\\t\\t\\tdeleted.","\\t\\t   highlight\\tname of highlight group to use","\\t\\t   priority\\twhen a character has multiple text","\\t\\t\\t\\tproperties the one with the highest priority","\\t\\t\\t\\twill be used; negative values can be used, the","\\t\\t\\t\\tdefault priority is zero","\\t\\t   combine\\twhen TRUE combine the highlight with any","\\t\\t\\t\\tsyntax highlight; when omitted or FALSE syntax","\\t\\t\\t\\thighlight will not be used","\\t\\t   start_incl\\twhen TRUE inserts at the start position will","\\t\\t\\t\\tbe included in the text property","\\t\\t   end_incl\\twhen TRUE inserts at the end position will be","\\t\\t\\t\\tincluded in the text property","","\\t\\tSee |text-properties| for information about text properties.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetPropName()->prop_type_add(props)"],"prop_type_change":["\\t\\tChange properties of an existing text property type.  If a","\\t\\tproperty with this name does not exist an error is given.","\\t\\tThe {props} argument is just like |prop_type_add()|.","","\\t\\tSee |text-properties| for information about text properties.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetPropName()->prop_type_change(props)"],"prop_type_delete":["\\t\\tRemove the text property type {name}.  When text properties","\\t\\tusing the type {name} are still in place, they will not have","\\t\\tan effect and can no longer be removed by name.","","\\t\\t{props} can contain a \\"bufnr\\" item.  When it is given, delete","\\t\\ta property type from this buffer instead of from the global","\\t\\tproperty types.","","\\t\\tWhen text property type {name} is not found there is no error.","","\\t\\tSee |text-properties| for information about text properties.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetPropName()->prop_type_delete()"],"prop_type_get":["\\t\\tReturns the properties of property type {name}.  This is a","\\t\\tdictionary with the same fields as was given to","\\t\\tprop_type_add().","\\t\\tWhen the property type {name} does not exist, an empty","\\t\\tdictionary is returned.","","\\t\\t{props} can contain a \\"bufnr\\" item.  When it is given, use","\\t\\tthis buffer instead of the global property types.","","\\t\\tSee |text-properties| for information about text properties.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetPropName()->prop_type_get()"],"prop_type_list":["\\t\\tReturns a list with all property type names.","","\\t\\t{props} can contain a \\"bufnr\\" item.  When it is given, use","\\t\\tthis buffer instead of the global property types.","","\\t\\tSee |text-properties| for information about text properties.",""],"rand":["\\t\\tReturn a pseudo-random Number generated with an xoshiro128**","\\t\\talgorithm using seed {expr}.  The returned number is 32 bits,","\\t\\talso on 64 bits systems, for consistency.","\\t\\t{expr} can be initialized by |srand()| and will be updated by","\\t\\trand().  If {expr} is omitted, an internal seed value is used","\\t\\tand updated.","","\\t\\tExamples: >","\\t\\t\\t:echo rand()","\\t\\t\\t:let seed = srand()","\\t\\t\\t:echo rand(seed)","\\t\\t\\t:echo rand(seed) % 16  \\" random number 0 - 15","<"],"rubyeval":["\\t\\tEvaluate Ruby expression {expr} and return its result","\\t\\tconverted to Vim data structures.","\\t\\tNumbers, floats and strings are returned as they are (strings","\\t\\tare copied though).","\\t\\tArrays are represented as Vim |List| type.","\\t\\tHashes are represented as Vim |Dictionary| type.","\\t\\tOther objects are represented as strings resulted from their","\\t\\t\\"Object#to_s\\" method.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetRubyExpr()->rubyeval()","","<\\t\\t{only available when compiled with the |+ruby| feature}"],"screenchars":["\\t\\tThe result is a List of Numbers.  The first number is the same","\\t\\tas what |screenchar()| returns.  Further numbers are","\\t\\tcomposing characters on top of the base character.","\\t\\tThis is mainly to be used for testing.","\\t\\tReturns an empty List when row or col is out of range.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetRow()->screenchars(col)"],"screenstring":["\\t\\tThe result is a String that contains the base character and","\\t\\tany composing characters at position [row, col] on the screen.","\\t\\tThis is like |screenchars()| but returning a String with the","\\t\\tcharacters.","\\t\\tThis is mainly to be used for testing.","\\t\\tReturns an empty String when row or col is out of range.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetRow()->screenstring(col)"],"sound_clear":["\\t\\tStop playing all sounds.","\\t\\t{only available when compiled with the |+sound| feature}",""],"sound_playevent":["\\t\\tPlay a sound identified by {name}.  Which event names are","\\t\\tsupported depends on the system.  Often the XDG sound names","\\t\\tare used.  On Ubuntu they may be found in","\\t\\t/usr/share/sounds/freedesktop/stereo.  Example: >","\\t\\t\\tcall sound_playevent(\'bell\')","<\\t\\tOn MS-Windows, {name} can be SystemAsterisk, SystemDefault,","\\t\\tSystemExclamation, SystemExit, SystemHand, SystemQuestion,","\\t\\tSystemStart, SystemWelcome, etc.","","\\t\\tWhen {callback} is specified it is invoked when the sound is","\\t\\tfinished.  The first argument is the sound ID, the second","\\t\\targument is the status:","\\t\\t\\t0\\tsound was played to the end","\\t\\t\\t1\\tsound was interrupted","\\t\\t\\t2\\terror occurred after sound started","\\t\\tExample: >","\\t\\t   func Callback(id, status)","\\t\\t     echomsg \\"sound \\" .. a:id .. \\" finished with \\" .. a:status","\\t\\t   endfunc","\\t\\t   call sound_playevent(\'bell\', \'Callback\')","","<\\t\\tMS-Windows: {callback} doesn\'t work for this function.","","\\t\\tReturns the sound ID, which can be passed to `sound_stop()`.","\\t\\tReturns zero if the sound could not be played.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetSoundName()->sound_playevent()","","<\\t\\t{only available when compiled with the |+sound| feature}",""],"sound_playfile":["\\t\\tLike `sound_playevent()` but play sound file {path}.  {path}","\\t\\tmust be a full path.  On Ubuntu you may find files to play","\\t\\twith this command: >","\\t\\t    :!find /usr/share/sounds -type f | grep -v index.theme","","<\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetSoundPath()->sound_playfile()","","<\\t\\t{only available when compiled with the |+sound| feature}",""],"sound_stop":["\\t\\tStop playing sound {id}.  {id} must be previously returned by","\\t\\t`sound_playevent()` or `sound_playfile()`.","","\\t\\tOn MS-Windows, this does not work for event sound started by","\\t\\t`sound_playevent()`. To stop event sounds, use `sound_clear()`.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tsoundid->sound_stop()","","<\\t\\t{only available when compiled with the |+sound| feature}",""],"srand":["\\t\\tInitialize seed used by |rand()|:","\\t\\t- If {expr} is not given, seed values are initialized by","\\t\\t  reading from /dev/urandom, if possible, or using time(NULL)","\\t\\t  a.k.a. epoch time otherwise; this only has second accuracy.","\\t\\t- If {expr} is given it must be a Number.  It is used to","\\t\\t  initialize the seed values.  This is useful for testing or","\\t\\t  when a predictable sequence is intended.","","\\t\\tExamples: >","\\t\\t\\t:let seed = srand()","\\t\\t\\t:let seed = srand(userinput)","\\t\\t\\t:echo rand(seed)"],"state":["\\t\\tReturn a string which contains characters indicating the","\\t\\tcurrent state.  Mostly useful in callbacks that want to do","\\t\\twork that may not always be safe.  Roughly this works like:","\\t\\t- callback uses state() to check if work is safe to do.","\\t\\t  Yes: then do it right away.","\\t\\t  No:  add to work queue and add a |SafeState| and/or","\\t\\t       |SafeStateAgain| autocommand (|SafeState| triggers at","\\t\\t       toplevel, |SafeStateAgain| triggers after handling","\\t\\t       messages and callbacks).","\\t\\t- When SafeState or SafeStateAgain is triggered and executes","\\t\\t  your autocommand, check with `state()` if the work can be","\\t\\t  done now, and if yes remove it from the queue and execute.","\\t\\t  Remove the autocommand if the queue is now empty.","\\t\\tAlso see |mode()|.","","\\t\\tWhen {what} is given only characters in this string will be","\\t\\tadded.  E.g, this checks if the screen has scrolled: >","\\t\\t\\tif state(\'s\') == \'\'","\\t\\t\\t   \\" screen has not scrolled","<","\\t\\tThese characters indicate the state, generally indicating that","\\t\\tsomething is busy:","\\t\\t    m\\thalfway a mapping, :normal command, feedkeys() or","\\t\\t\\tstuffed command","\\t\\t    o\\toperator pending or waiting for a command argument,","\\t\\t        e.g. after |f|","\\t\\t    a\\tInsert mode autocomplete active","\\t\\t    x\\texecuting an autocommand","\\t\\t    w\\tblocked on waiting, e.g. ch_evalexpr(), ch_read() and","\\t\\t\\tch_readraw() when reading json.","\\t\\t    S\\tnot triggering SafeState or SafeStateAgain","\\t\\t    c\\tcallback invoked, including timer (repeats for","\\t\\t\\trecursiveness up to \\"ccc\\")","\\t\\t    s\\tscreen has scrolled for messages"],"strptime":["\\t\\tThe result is a Number, which is a unix timestamp representing","\\t\\tthe date and time in {timestring}, which is expected to match","\\t\\tthe format specified in {format}.","","\\t\\tThe accepted {format} depends on your system, thus this is not","\\t\\tportable!  See the manual page of the C function strptime()","\\t\\tfor the format.  Especially avoid \\"%c\\".  The value of $TZ also","\\t\\tmatters.","","\\t\\tIf the {timestring} cannot be parsed with {format} zero is","\\t\\treturned.  If you do not know the format of {timestring} you","\\t\\tcan try different {format} values until you get a non-zero","\\t\\tresult.","","\\t\\tSee also |strftime()|.","\\t\\tExamples: >","\\t\\t  :echo strptime(\\"%Y %b %d %X\\", \\"1997 Apr 27 11:49:23\\")","<\\t\\t  862156163 >","\\t\\t  :echo strftime(\\"%c\\", strptime(\\"%y%m%d %T\\", \\"970427 11:53:55\\"))","<\\t\\t  Sun Apr 27 11:53:55 1997 >","\\t\\t  :echo strftime(\\"%c\\", strptime(\\"%Y%m%d%H%M%S\\", \\"19970427115355\\") + 3600)","<\\t\\t  Sun Apr 27 12:53:55 1997","","\\t\\tNot available on all systems.  To check use: >","\\t\\t\\t:if exists(\\"*strptime\\")",""],"term_dumpdiff":["\\t\\tOpen a new window displaying the difference between the two","\\t\\tfiles.  The files must have been created with","\\t\\t|term_dumpwrite()|.","\\t\\tReturns the buffer number or zero when the diff fails.","\\t\\tAlso see |terminal-diff|.","\\t\\tNOTE: this does not work with double-width characters yet.","","\\t\\tThe top part of the buffer contains the contents of the first","\\t\\tfile, the bottom part of the buffer contains the contents of","\\t\\tthe second file.  The middle part shows the differences.","\\t\\tThe parts are separated by a line of equals.","","\\t\\tIf the {options} argument is present, it must be a Dict with","\\t\\tthese possible members:","\\t\\t   \\"term_name\\"\\t     name to use for the buffer name, instead","\\t\\t\\t\\t     of the first file name.","\\t\\t   \\"term_rows\\"\\t     vertical size to use for the terminal,","\\t\\t\\t\\t     instead of using \'termwinsize\'","\\t\\t   \\"term_cols\\"\\t     horizontal size to use for the terminal,","\\t\\t\\t\\t     instead of using \'termwinsize\'","\\t\\t   \\"vertical\\"\\t     split the window vertically","\\t\\t   \\"curwin\\"\\t     use the current window, do not split the","\\t\\t\\t\\t     window; fails if the current buffer","\\t\\t\\t\\t     cannot be |abandon|ed","\\t\\t   \\"bufnr\\"\\t     do not create a new buffer, use the","\\t\\t\\t\\t     existing buffer \\"bufnr\\".  This buffer","\\t\\t\\t\\t     must have been previously created with","\\t\\t\\t\\t     term_dumpdiff() or term_dumpload() and","\\t\\t\\t\\t     visible in a window.","\\t\\t   \\"norestore\\"\\t     do not add the terminal window to a","\\t\\t\\t\\t     session file","","\\t\\tEach character in the middle part indicates a difference. If","\\t\\tthere are multiple differences only the first in this list is","\\t\\tused:","\\t\\t\\tX\\tdifferent character","\\t\\t\\tw\\tdifferent width","\\t\\t\\tf\\tdifferent foreground color","\\t\\t\\tb\\tdifferent background color","\\t\\t\\ta\\tdifferent attribute","\\t\\t\\t+\\tmissing position in first file","\\t\\t\\t-\\tmissing position in second file","","\\t\\tUsing the \\"s\\" key the top and bottom parts are swapped.  This","\\t\\tmakes it easy to spot a difference.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetFilename()->term_dumpdiff(otherfile)","<"],"term_dumpload":["\\t\\tOpen a new window displaying the contents of {filename}","\\t\\tThe file must have been created with |term_dumpwrite()|.","\\t\\tReturns the buffer number or zero when it fails.","\\t\\tAlso see |terminal-diff|.","","\\t\\tFor {options} see |term_dumpdiff()|.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetFilename()->term_dumpload()","<"],"term_dumpwrite":["\\t\\tDump the contents of the terminal screen of {buf} in the file","\\t\\t{filename}.  This uses a format that can be used with","\\t\\t|term_dumpload()| and |term_dumpdiff()|.","\\t\\tIf the job in the terminal already finished an error is given:","\\t\\t*E958*","\\t\\tIf {filename} already exists an error is given:\\t*E953*","\\t\\tAlso see |terminal-diff|.","","\\t\\t{options} is a dictionary with these optional entries:","\\t\\t\\t\\"rows\\"\\t\\tmaximum number of rows to dump","\\t\\t\\t\\"columns\\"\\tmaximum number of columns to dump","","\\t\\tCan also be used as a |method|, the base is used for the file","\\t\\tname: >","\\t\\t\\tGetFilename()->term_dumpwrite(bufnr)"],"term_getaltscreen":["\\t\\tReturns 1 if the terminal of {buf} is using the alternate","\\t\\tscreen.","\\t\\t{buf} is used as with |term_getsize()|.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetBufnr()->term_getaltscreen()",""],"term_getansicolors":["\\t\\tGet the ANSI color palette in use by terminal {buf}.","\\t\\tReturns a List of length 16 where each element is a String","\\t\\trepresenting a color in hexadecimal \\"#rrggbb\\" format.","\\t\\tAlso see |term_setansicolors()| and |g:terminal_ansi_colors|.","\\t\\tIf neither was used returns the default colors.","","\\t\\t{buf} is used as with |term_getsize()|.  If the buffer does not","\\t\\texist or is not a terminal window, an empty list is returned.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetBufnr()->term_getansicolors()","","<\\t\\t{only available when compiled with GUI enabled and/or the","\\t\\t|+termguicolors| feature}"],"term_getattr":["\\t\\tGiven {attr}, a value returned by term_scrape() in the \\"attr\\"","\\t\\titem, return whether {what} is on.  {what} can be one of:","\\t\\t\\tbold","\\t\\t\\titalic","\\t\\t\\tunderline","\\t\\t\\tstrike","\\t\\t\\treverse","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetAttr()->term_getattr()",""],"term_getcursor":["\\t\\tGet the cursor position of terminal {buf}. Returns a list with","\\t\\ttwo numbers and a dictionary: [row, col, dict].","","\\t\\t\\"row\\" and \\"col\\" are one based, the first screen cell is row","\\t\\t1, column 1.  This is the cursor position of the terminal","\\t\\titself, not of the Vim window.","","\\t\\t\\"dict\\" can have these members:","\\t\\t   \\"visible\\"\\tone when the cursor is visible, zero when it","\\t\\t\\t\\tis hidden.","\\t\\t   \\"blink\\"\\tone when the cursor is blinking, zero when it","\\t\\t\\t\\tis not blinking.","\\t\\t   \\"shape\\"\\t1 for a block cursor, 2 for underline and 3","\\t\\t\\t\\tfor a vertical bar.","\\t\\t   \\"color\\"\\tcolor of the cursor, e.g. \\"green\\"","","\\t\\t{buf} must be the buffer number of a terminal window. If the","\\t\\tbuffer does not exist or is not a terminal window, an empty","\\t\\tlist is returned.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetBufnr()->term_getcursor()"],"term_getjob":["\\t\\tGet the Job associated with terminal window {buf}.","\\t\\t{buf} is used as with |term_getsize()|.","\\t\\tReturns |v:null| when there is no job.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetBufnr()->term_getjob()",""],"term_getline":["\\t\\tGet a line of text from the terminal window of {buf}.","\\t\\t{buf} is used as with |term_getsize()|.","","\\t\\tThe first line has {row} one.  When {row} is \\".\\" the cursor","\\t\\tline is used.  When {row} is invalid an empty string is","\\t\\treturned.","","\\t\\tTo get attributes of each character use |term_scrape()|.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetBufnr()->term_getline(row)",""],"term_getscrolled":["\\t\\tReturn the number of lines that scrolled to above the top of","\\t\\tterminal {buf}.  This is the offset between the row number","\\t\\tused for |term_getline()| and |getline()|, so that: >","\\t\\t\\tterm_getline(buf, N)","<\\t\\tis equal to: >","\\t\\t\\tgetline(N + term_getscrolled(buf))","<\\t\\t(if that line exists).","","\\t\\t{buf} is used as with |term_getsize()|.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetBufnr()->term_getscrolled()",""],"term_getsize":["\\t\\tGet the size of terminal {buf}. Returns a list with two","\\t\\tnumbers: [rows, cols].  This is the size of the terminal, not","\\t\\tthe window containing the terminal.","","\\t\\t{buf} must be the buffer number of a terminal window.  Use an","\\t\\tempty string for the current buffer.  If the buffer does not","\\t\\texist or is not a terminal window, an empty list is returned.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetBufnr()->term_getsize()",""],"term_getstatus":["\\t\\tGet the status of terminal {buf}. This returns a comma","\\t\\tseparated list of these items:","\\t\\t\\trunning\\t\\tjob is running","\\t\\t\\tfinished\\tjob has finished","\\t\\t\\tnormal\\t\\tin Terminal-Normal mode","\\t\\tOne of \\"running\\" or \\"finished\\" is always present.","","\\t\\t{buf} must be the buffer number of a terminal window. If the","\\t\\tbuffer does not exist or is not a terminal window, an empty","\\t\\tstring is returned.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetBufnr()->term_getstatus()",""],"term_gettitle":["\\t\\tGet the title of terminal {buf}. This is the title that the","\\t\\tjob in the terminal has set.","","\\t\\t{buf} must be the buffer number of a terminal window. If the","\\t\\tbuffer does not exist or is not a terminal window, an empty","\\t\\tstring is returned.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetBufnr()->term_gettitle()",""],"term_gettty":["\\t\\tGet the name of the controlling terminal associated with","\\t\\tterminal window {buf}.  {buf} is used as with |term_getsize()|.","","\\t\\tWhen {input} is omitted or 0, return the name for writing","\\t\\t(stdout). When {input} is 1 return the name for reading","\\t\\t(stdin). On UNIX, both return same name.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetBufnr()->term_gettty()",""],"term_list":["\\t\\tReturn a list with the buffer numbers of all buffers for","\\t\\tterminal windows.",""],"term_scrape":["\\t\\tGet the contents of {row} of terminal screen of {buf}.","\\t\\tFor {buf} see |term_getsize()|.","","\\t\\tThe first line has {row} one.  When {row} is \\".\\" the cursor","\\t\\tline is used.  When {row} is invalid an empty string is","\\t\\treturned.","","\\t\\tReturn a List containing a Dict for each screen cell:","\\t\\t    \\"chars\\"\\tcharacter(s) at the cell","\\t\\t    \\"fg\\"\\tforeground color as #rrggbb","\\t\\t    \\"bg\\"\\tbackground color as #rrggbb","\\t\\t    \\"attr\\"\\tattributes of the cell, use |term_getattr()|","\\t\\t\\t\\tto get the individual flags","\\t\\t    \\"width\\"\\tcell width: 1 or 2","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetBufnr()->term_scrape(row)",""],"term_sendkeys":["\\t\\tSend keystrokes {keys} to terminal {buf}.","\\t\\t{buf} is used as with |term_getsize()|.","","\\t\\t{keys} are translated as key sequences. For example, \\"\\\\<c-x>\\"","\\t\\tmeans the character CTRL-X.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetBufnr()->term_sendkeys(keys)",""],"term_setapi":["\\t\\tSet the function name prefix to be used for the |terminal-api|","\\t\\tfunction in terminal {buf}.  For example: >","\\t\\t    :call term_setapi(buf, \\"Myapi_\\")","\\t\\t    :call term_setapi(buf, \\"\\")","<","\\t\\tThe default is \\"Tapi_\\".  When {expr} is an empty string then","\\t\\tno |terminal-api| function can be used for {buf}."],"term_setansicolors":["\\t\\tSet the ANSI color palette used by terminal {buf}.","\\t\\t{colors} must be a List of 16 valid color names or hexadecimal","\\t\\tcolor codes, like those accepted by |highlight-guifg|.","\\t\\tAlso see |term_getansicolors()| and |g:terminal_ansi_colors|.","","\\t\\tThe colors normally are:","\\t\\t\\t0    black","\\t\\t\\t1    dark red","\\t\\t\\t2    dark green","\\t\\t\\t3    brown","\\t\\t\\t4    dark blue","\\t\\t\\t5    dark magenta","\\t\\t\\t6    dark cyan","\\t\\t\\t7    light grey","\\t\\t\\t8    dark grey","\\t\\t\\t9    red","\\t\\t\\t10   green","\\t\\t\\t11   yellow","\\t\\t\\t12   blue","\\t\\t\\t13   magenta","\\t\\t\\t14   cyan","\\t\\t\\t15   white","","\\t\\tThese colors are used in the GUI and in the terminal when","\\t\\t\'termguicolors\' is set.  When not using GUI colors (GUI mode","\\t\\tor \'termguicolors\'), the terminal window always uses the 16","\\t\\tANSI colors of the underlying terminal.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetBufnr()->term_setansicolors(colors)","","<\\t\\t{only available with GUI enabled and/or the |+termguicolors|","\\t\\tfeature}"],"term_setkill":["\\t\\tWhen exiting Vim or trying to close the terminal window in","\\t\\tanother way, {how} defines whether the job in the terminal can","\\t\\tbe stopped.","\\t\\tWhen {how} is empty (the default), the job will not be","\\t\\tstopped, trying to exit will result in |E947|.","\\t\\tOtherwise, {how} specifies what signal to send to the job.","\\t\\tSee |job_stop()| for the values.","","\\t\\tAfter sending the signal Vim will wait for up to a second to","\\t\\tcheck that the job actually stopped.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetBufnr()->term_setkill(how)",""],"term_setrestore":["\\t\\tSet the command to write in a session file to restore the job","\\t\\tin this terminal.  The line written in the session file is: >","\\t\\t\\tterminal ++curwin ++cols=%d ++rows=%d {command}","<\\t\\tMake sure to escape the command properly.","","\\t\\tUse an empty {command} to run \'shell\'.","\\t\\tUse \\"NONE\\" to not restore this window.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetBufnr()->term_setrestore(command)",""],"term_setsize":["\\t\\tSet the size of terminal {buf}. The size of the window","\\t\\tcontaining the terminal will also be adjusted, if possible.","\\t\\tIf {rows} or {cols} is zero or negative, that dimension is not","\\t\\tchanged.","","\\t\\t{buf} must be the buffer number of a terminal window.  Use an","\\t\\tempty string for the current buffer.  If the buffer does not","\\t\\texist or is not a terminal window, an error is given.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetBufnr()->term_setsize(rows, cols)",""],"term_start":["\\t\\tOpen a terminal window and run {cmd} in it.","","\\t\\t{cmd} can be a string or a List, like with |job_start()|. The","\\t\\tstring \\"NONE\\" can be used to open a terminal window without","\\t\\tstarting a job, the pty of the terminal can be used by a","\\t\\tcommand like gdb.","","\\t\\tReturns the buffer number of the terminal window.  If {cmd}","\\t\\tcannot be executed the window does open and shows an error","\\t\\tmessage.","\\t\\tIf opening the window fails zero is returned.","","\\t\\t{options} are similar to what is used for |job_start()|, see","\\t\\t|job-options|.  However, not all options can be used.  These","\\t\\tare supported:","\\t\\t   all timeout options","\\t\\t   \\"stoponexit\\", \\"cwd\\", \\"env\\"","\\t\\t   \\"callback\\", \\"out_cb\\", \\"err_cb\\", \\"exit_cb\\", \\"close_cb\\"","\\t\\t   \\"in_io\\", \\"in_top\\", \\"in_bot\\", \\"in_name\\", \\"in_buf\\"","\\t\\t   \\"out_io\\", \\"out_name\\", \\"out_buf\\", \\"out_modifiable\\", \\"out_msg\\"","\\t\\t   \\"err_io\\", \\"err_name\\", \\"err_buf\\", \\"err_modifiable\\", \\"err_msg\\"","\\t\\tHowever, at least one of stdin, stdout or stderr must be","\\t\\tconnected to the terminal.  When I/O is connected to the","\\t\\tterminal then the callback function for that part is not used.","","\\t\\tThere are extra options:","\\t\\t   \\"term_name\\"\\t     name to use for the buffer name, instead","\\t\\t\\t\\t     of the command name.","\\t\\t   \\"term_rows\\"\\t     vertical size to use for the terminal,","\\t\\t\\t\\t     instead of using \'termwinsize\'","\\t\\t   \\"term_cols\\"\\t     horizontal size to use for the terminal,","\\t\\t\\t\\t     instead of using \'termwinsize\'","\\t\\t   \\"vertical\\"\\t     split the window vertically; note that","\\t\\t\\t\\t     other window position can be defined with","\\t\\t\\t\\t     command modifiers, such as |:belowright|.","\\t\\t   \\"curwin\\"\\t     use the current window, do not split the","\\t\\t\\t\\t     window; fails if the current buffer","\\t\\t\\t\\t     cannot be |abandon|ed","\\t\\t   \\"hidden\\"\\t     do not open a window","\\t\\t   \\"norestore\\"\\t     do not add the terminal window to a","\\t\\t\\t\\t     session file","\\t\\t   \\"term_kill\\"\\t     what to do when trying to close the","\\t\\t\\t\\t     terminal window, see |term_setkill()|","\\t\\t   \\"term_finish\\"     What to do when the job is finished:","\\t\\t\\t\\t\\t\\"close\\": close any windows","\\t\\t\\t\\t\\t\\"open\\": open window if needed","\\t\\t\\t\\t     Note that \\"open\\" can be interruptive.","\\t\\t\\t\\t     See |term++close| and |term++open|.","\\t\\t   \\"term_opencmd\\"    command to use for opening the window when","\\t\\t\\t\\t     \\"open\\" is used for \\"term_finish\\"; must","\\t\\t\\t\\t     have \\"%d\\" where the buffer number goes,","\\t\\t\\t\\t     e.g. \\"10split|buffer %d\\"; when not","\\t\\t\\t\\t     specified \\"botright sbuf %d\\" is used","\\t\\t   \\"eof_chars\\"\\t     Text to send after all buffer lines were","\\t\\t\\t\\t     written to the terminal.  When not set","\\t\\t\\t\\t     CTRL-D is used on MS-Windows. For Python","\\t\\t\\t\\t     use CTRL-Z or \\"exit()\\". For a shell use","\\t\\t\\t\\t     \\"exit\\".  A CR is always added.","\\t\\t   \\"ansi_colors\\"     A list of 16 color names or hex codes","\\t\\t\\t\\t     defining the ANSI palette used in GUI","\\t\\t\\t\\t     color modes.  See |g:terminal_ansi_colors|.","\\t\\t   \\"tty_type\\"\\t     (MS-Windows only): Specify which pty to","\\t\\t\\t\\t     use.  See \'termwintype\' for the values.","\\t\\t   \\"term_api\\"\\t     function name prefix for the","\\t\\t\\t\\t     |terminal-api| function.  See","\\t\\t\\t\\t     |term_setapi()|.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetCommand()->term_start()",""],"term_wait":["\\t\\tWait for pending updates of {buf} to be handled.","\\t\\t{buf} is used as with |term_getsize()|.","\\t\\t{time} is how long to wait for updates to arrive in msec.  If","\\t\\tnot set then 10 msec will be used.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetBufnr()->term_wait()"],"test_alloc_fail":["\\t\\tThis is for testing: If the memory allocation with {id} is","\\t\\tcalled, then decrement {countdown}, and when it reaches zero","\\t\\tlet memory allocation fail {repeat} times.  When {repeat} is","\\t\\tsmaller than one it fails one time.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetAllocId()->test_alloc_fail()"],"test_autochdir":["\\t\\tSet a flag to enable the effect of \'autochdir\' before Vim","\\t\\tstartup has finished.",""],"test_feedinput":["\\t\\tCharacters in {string} are queued for processing as if they","\\t\\twere typed by the user. This uses a low level input buffer.","\\t\\tThis function works only when with |+unix| or GUI is running.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetText()->test_feedinput()"],"test_garbagecollect_soon":["\\t\\tSet the flag to call the garbagecollector as if in the main","\\t\\tloop.  Only to be used in tests.",""],"test_getvalue":["\\t\\tGet the value of an internal variable.  These values for","\\t\\t{name} are supported:","\\t\\t\\tneed_fileinfo","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetName()->test_getvalue()"],"test_ignore_error":["\\t\\tIgnore any error containing {expr}.  A normal message is given","\\t\\tinstead.","\\t\\tThis is only meant to be used in tests, where catching the","\\t\\terror with try/catch cannot be used (because it skips over","\\t\\tfollowing code).","\\t\\t{expr} is used literally, not as a pattern.","\\t\\tWhen the {expr} is the string \\"RESET\\" then the list of ignored","\\t\\terrors is made empty.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetErrorText()->test_ignore_error()"],"test_null_blob":["\\t\\tReturn a |Blob| that is null. Only useful for testing.",""],"test_null_channel":["\\t\\tReturn a |Channel| that is null. Only useful for testing.","\\t\\t{only available when compiled with the +channel feature}",""],"test_null_dict":["\\t\\tReturn a |Dict| that is null. Only useful for testing.",""],"test_null_job":["\\t\\tReturn a |Job| that is null. Only useful for testing.","\\t\\t{only available when compiled with the +job feature}",""],"test_null_list":["\\t\\tReturn a |List| that is null. Only useful for testing.",""],"test_null_partial":["\\t\\tReturn a |Partial| that is null. Only useful for testing.",""],"test_null_string":["\\t\\tReturn a |String| that is null. Only useful for testing.",""],"test_option_not_set":["\\t\\tReset the flag that indicates option {name} was set.  Thus it","\\t\\tlooks like it still has the default value. Use like this: >","\\t\\t\\tset ambiwidth=double","\\t\\t\\tcall test_option_not_set(\'ambiwidth\')","<\\t\\tNow the \'ambiwidth\' option behaves like it was never changed,","\\t\\teven though the value is \\"double\\".","\\t\\tOnly to be used for testing!","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetOptionName()->test_option_not_set()",""],"test_override":["\\t\\tOverrides certain parts of Vim\'s internal processing to be able","\\t\\tto run tests. Only to be used for testing Vim!","\\t\\tThe override is enabled when {val} is non-zero and removed","\\t\\twhen {val} is zero.","\\t\\tCurrent supported values for name are:","","\\t\\tname\\t     effect when {val} is non-zero ~","\\t\\tredraw       disable the redrawing() function","\\t\\tredraw_flag  ignore the RedrawingDisabled flag","\\t\\tchar_avail   disable the char_avail() function","\\t\\tstarting     reset the \\"starting\\" variable, see below","\\t\\tnfa_fail     makes the NFA regexp engine fail to force a","\\t\\t\\t     fallback to the old engine","\\t\\tno_query_mouse  do not query the mouse position for \\"dec\\"","\\t\\t\\t\\tterminals","\\t\\tno_wait_return\\tset the \\"no_wait_return\\" flag.  Not restored","\\t\\t\\t\\twith \\"ALL\\".","\\t\\tALL\\t     clear all overrides ({val} is not used)","","\\t\\t\\"starting\\" is to be used when a test should behave like","\\t\\tstartup was done.  Since the tests are run by sourcing a","\\t\\tscript the \\"starting\\" variable is non-zero. This is usually a","\\t\\tgood thing (tests run faster), but sometimes changes behavior","\\t\\tin a way that the test doesn\'t work properly.","\\t\\tWhen using: >","\\t\\t\\tcall test_override(\'starting\', 1)","<\\t\\tThe value of \\"starting\\" is saved.  It is restored by: >","\\t\\t\\tcall test_override(\'starting\', 0)","","<\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetOverrideVal()-> test_override(\'starting\')"],"test_refcount":["\\t\\tReturn the reference count of {expr}.  When {expr} is of a","\\t\\ttype that does not have a reference count, returns -1.  Only","\\t\\tto be used for testing.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetVarname()->test_refcount()",""],"test_scrollbar":["\\t\\tPretend using scrollbar {which} to move it to position","\\t\\t{value}.  {which} can be:","\\t\\t\\tleft\\tLeft scrollbar of the current window","\\t\\t\\tright\\tRight scrollbar of the current window","\\t\\t\\thor\\tHorizontal scrollbar","","\\t\\tFor the vertical scrollbars {value} can be 1 to the","\\t\\tline-count of the buffer.  For the horizontal scrollbar the","\\t\\t{value} can be between 1 and the maximum line length, assuming","\\t\\t\'wrap\' is not set.","","\\t\\tWhen {dragging} is non-zero it\'s like dragging the scrollbar,","\\t\\totherwise it\'s like clicking in the scrollbar.","\\t\\tOnly works when the {which} scrollbar actually exists,","\\t\\tobviously only when using the GUI.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetValue()->test_scrollbar(\'right\', 0)"],"test_setmouse":["\\t\\tSet the mouse position to be used for the next mouse action.","\\t\\t{row} and {col} are one based.","\\t\\tFor example: >","\\t\\t\\tcall test_setmouse(4, 20)","\\t\\t\\tcall feedkeys(\\"\\\\<LeftMouse>\\", \\"xt\\")",""],"test_settime":["\\t\\tSet the time Vim uses internally.  Currently only used for","\\t\\ttimestamps in the history, as they are used in viminfo, and","\\t\\tfor undo.","\\t\\tUsing a value of 1 makes Vim not sleep after a warning or","\\t\\terror message.","\\t\\t{expr} must evaluate to a number.  When the value is zero the","\\t\\tnormal behavior is restored.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetTime()->test_settime()"],"win_execute":["\\t\\tLike `execute()` but in the context of window {id}.","\\t\\tThe window will temporarily be made the current window,","\\t\\twithout triggering autocommands.  When executing {command}","\\t\\tautocommands will be triggered, this may have unexpected side","\\t\\teffects.  Use |:noautocmd| if needed.","\\t\\tExample: >","\\t\\t\\tcall win_execute(winid, \'set syntax=python\')","<\\t\\tDoing the same with `setwinvar()` would not trigger","\\t\\tautocommands and not actually show syntax highlighting.","\\t\\t\\t\\t\\t\\t\\t*E994*","\\t\\tNot all commands are allowed in popup windows.","\\t\\tWhen window {id} does not exist then no error is given.","","\\t\\tCan also be used as a |method|, the base is passed as the","\\t\\tsecond argument: >","\\t\\t\\tGetCommand()->win_execute(winid)"],"win_splitmove":["\\t        Move the window {nr} to a new split of the window {target}.","\\t\\tThis is similar to moving to {target}, creating a new window","\\t\\tusing |:split| but having the same contents as window {nr}, and","\\t\\tthen closing {nr}.","","\\t\\tBoth {nr} and {target} can be window numbers or |window-ID|s.","","\\t\\tReturns zero for success, non-zero for failure.","","\\t\\t{options} is a Dictionary with the following optional entries:","\\t\\t  \\"vertical\\"\\tWhen TRUE, the split is created vertically,","\\t\\t\\t\\tlike with |:vsplit|.","\\t\\t  \\"rightbelow\\"\\tWhen TRUE, the split is made below or to the","\\t\\t\\t\\tright (if vertical).  When FALSE, it is done","\\t\\t\\t\\tabove or to the left (if vertical).  When not","\\t\\t\\t\\tpresent, the values of \'splitbelow\' and","\\t\\t\\t\\t\'splitright\' are used.","","\\t\\tCan also be used as a |method|: >","\\t\\t\\tGetWinid()->win_splitmove(target)","<"]},"variables":{"v:beval_col":["The number of the column, over which the mouse pointer is.","\\t\\tThis is the byte index in the |v:beval_lnum| line.","\\t\\tOnly valid while evaluating the \'balloonexpr\' option."],"v:beval_bufnr":["The number of the buffer, over which the mouse pointer is. Only","\\t\\tvalid while evaluating the \'balloonexpr\' option."],"v:beval_lnum":["The number of the line, over which the mouse pointer is. Only","\\t\\tvalid while evaluating the \'balloonexpr\' option."],"v:beval_text":["The text under or after the mouse pointer.  Usually a word as","\\t\\tit is useful for debugging a C program.  \'iskeyword\' applies,","\\t\\tbut a dot and \\"->\\" before the position is included.  When on a","\\t\\t\']\' the text before it is used, including the matching \'[\' and","\\t\\tword before it.  When on a Visual area within one line the","\\t\\thighlighted text is used.  Also see |<cexpr>|.","\\t\\tOnly valid while evaluating the \'balloonexpr\' option."],"v:beval_winnr":["The number of the window, over which the mouse pointer is. Only","\\t\\tvalid while evaluating the \'balloonexpr\' option.  The first","\\t\\twindow has number zero (unlike most other places where a","\\t\\twindow gets a number)."],"v:beval_winid":["The |window-ID| of the window, over which the mouse pointer","\\t\\tis.  Otherwise like v:beval_winnr."],"v:char":["Argument for evaluating \'formatexpr\' and used for the typed","\\t\\tcharacter when using <expr> in an abbreviation |:map-<expr>|.","\\t\\tIt is also used by the |InsertCharPre| and |InsertEnter| events."],"v:cmdarg":["This variable is used for two purposes:","\\t\\t1. The extra arguments given to a file read/write command.","\\t\\t   Currently these are \\"++enc=\\" and \\"++ff=\\".  This variable is","\\t\\t   set before an autocommand event for a file read/write","\\t\\t   command is triggered.  There is a leading space to make it","\\t\\t   possible to append this variable directly after the","\\t\\t   read/write command.  Note: The \\"+cmd\\" argument isn\'t","\\t\\t   included here, because it will be executed anyway.","\\t\\t2. When printing a PostScript file with \\":hardcopy\\" this is","\\t\\t   the argument for the \\":hardcopy\\" command.  This can be used","\\t\\t   in \'printexpr\'."],"v:cmdbang":["Set like v:cmdarg for a file read/write command.  When a \\"!\\"","\\t\\twas used the value is 1, otherwise it is 0.  Note that this","\\t\\tcan only be used in autocommands.  For user commands |<bang>|","\\t\\tcan be used."],"v:count":["The count given for the last Normal mode command.  Can be used","\\t\\tto get the count before a mapping.  Read-only.  Example: >","\\t:map _x :<C-U>echo \\"the count is \\" . v:count<CR>","<\\t\\tNote: The <C-U> is required to remove the line range that you","\\t\\tget when typing \':\' after a count.","\\t\\tWhen there are two counts, as in \\"3d2w\\", they are multiplied,","\\t\\tjust like what happens in the command, \\"d6w\\" for the example.","\\t\\tAlso used for evaluating the \'formatexpr\' option."],"v:count1":["Just like \\"v:count\\", but defaults to one when no count is","\\t\\tused."],"v:ctype":["The current locale setting for characters of the runtime","\\t\\tenvironment.  This allows Vim scripts to be aware of the","\\t\\tcurrent locale encoding.  Technical: it\'s the value of","\\t\\tLC_CTYPE.  When not using a locale the value is \\"C\\".","\\t\\tThis variable can not be set directly, use the |:language|","\\t\\tcommand.","\\t\\tSee |multi-lang|."],"v:dying":["Normally zero.  When a deadly signal is caught it\'s set to","\\t\\tone.  When multiple signals are caught the number increases.","\\t\\tCan be used in an autocommand to check if Vim didn\'t","\\t\\tterminate normally. {only works on Unix}","\\t\\tExample: >","\\t:au VimLeave * if v:dying | echo \\"\\\\nAAAAaaaarrrggghhhh!!!\\\\n\\" | endif","<\\t\\tNote: if another deadly signal is caught when v:dying is one,","\\t\\tVimLeave autocommands will not be executed."],"v:exiting":["Exit code, or |v:null| if not exiting. |VimLeave|"],"v:echospace":["Number of screen cells that can be used for an `:echo` message","\\t\\tin the last screen line before causing the |hit-enter-prompt|.","\\t\\tDepends on \'showcmd\', \'ruler\' and \'columns\'.  You need to","\\t\\tcheck \'cmdheight\' for whether there are full-width lines","\\t\\tavailable above the last line."],"v:errmsg":["Last given error message.","\\t\\tModifiable (can be set).","\\t\\tExample: >","\\t:let v:errmsg = \\"\\"","\\t:silent! next","\\t:if v:errmsg != \\"\\"","\\t:  ... handle error","<"],"v:errors":["Errors found by assert functions, such as |assert_true()|.","\\t\\tThis is a list of strings.","\\t\\tThe assert functions append an item when an assert fails.","\\t\\tThe return value indicates this: a one is returned if an item","\\t\\twas added to v:errors, otherwise zero is returned.","\\t\\tTo remove old results make it empty: >","\\t:let v:errors = []","<\\t\\tIf v:errors is set to anything but a list it is made an empty","\\t\\tlist by the assert function."],"v:event":["Dictionary of event data for the current |autocommand|.  Valid","\\t\\tonly during the event lifetime; storing or passing v:event is","\\t\\tinvalid!  Copy it instead: >","\\t\\t\\tau TextYankPost * let g:foo = deepcopy(v:event)","<\\t\\tKeys vary by event; see the documentation for the specific","\\t\\tevent, e.g. |DirChanged| or |TextYankPost|.","\\t\\t\\tKEY\\t\\tDESCRIPTION ~","\\t\\t\\tabort\\t\\tWhether the event triggered during","\\t\\t\\t\\t\\tan aborting condition (e.g. |c_Esc| or","\\t\\t\\t\\t\\t|c_CTRL-C| for |CmdlineLeave|).","\\t\\t\\tchan\\t\\t|channel-id| or 0 for \\"internal\\".","\\t\\t\\tcmdlevel\\tLevel of cmdline.","\\t\\t\\tcmdtype\\t\\tType of cmdline, |cmdline-char|.","\\t\\t\\tcwd\\t\\tCurrent working directory.","\\t\\t\\tinclusive\\tMotion is |inclusive|, else exclusive.","\\t\\t\\tscope\\t\\tEvent-specific scope name.","\\t\\t\\toperator\\tCurrent |operator|.  Also set for Ex","\\t\\t\\t\\t\\tcommands (unlike |v:operator|). For","\\t\\t\\t\\t\\texample if |TextYankPost| is triggered","\\t\\t\\t\\t\\tby the |:yank| Ex command then","\\t\\t\\t\\t\\t`v:event.operator` is \\"y\\".","\\t\\t\\tregcontents\\tText stored in the register as a","\\t\\t\\t\\t\\t|readfile()|-style list of lines.","\\t\\t\\tregname\\t\\tRequested register (e.g \\"x\\" for \\"xyy)","\\t\\t\\t\\t\\tor the empty string for an unnamed","\\t\\t\\t\\t\\toperation.","\\t\\t\\tregtype\\t\\tType of register as returned by","\\t\\t\\t\\t\\t|getregtype()|.","\\t\\t\\tcompleted_item    Current selected complete item on","\\t\\t\\t\\t\\t|CompleteChanged|, Is `{}` when no complete","\\t\\t\\t\\t\\titem selected.","\\t\\t\\theight \\t\\tHeight of popup menu on |CompleteChanged|","\\t\\t\\twidth   \\twidth of popup menu on |CompleteChanged|","\\t\\t\\trow  \\t \\tRow count of popup menu on |CompleteChanged|,","\\t\\t\\t\\t\\trelative to screen.","\\t\\t\\tcol  \\t \\tCol count of popup menu on |CompleteChanged|,","\\t\\t\\t\\t\\trelative to screen.","\\t\\t\\tsize \\t\\tTotal number of completion items on","\\t\\t\\t\\t\\t|CompleteChanged|.","\\t\\t\\tscrollbar \\tIs |v:true| if popup menu have scrollbar, or","\\t\\t\\t\\t\\t|v:false| if not."],"v:exception":["The value of the exception most recently caught and not","\\t\\tfinished.  See also |v:throwpoint| and |throw-variables|.","\\t\\tExample: >","\\t:try","\\t:  throw \\"oops\\"","\\t:catch /.*/","\\t:  echo \\"caught \\" .. v:exception","\\t:endtry","<\\t\\tOutput: \\"caught oops\\"."],"v:false":["Special value used to put \\"false\\" in JSON and msgpack.  See","\\t\\t|json_encode()|.  This value is converted to \\"v:false\\" when used","\\t\\tas a String (e.g. in |expr5| with string concatenation","\\t\\toperator) and to zero when used as a Number (e.g. in |expr5|","\\t\\tor |expr7| when used with numeric operators). Read-only."],"v:fcs_reason":["The reason why the |FileChangedShell| event was triggered.","\\t\\tCan be used in an autocommand to decide what to do and/or what","\\t\\tto set v:fcs_choice to.  Possible values:","\\t\\t\\tdeleted\\t\\tfile no longer exists","\\t\\t\\tconflict\\tfile contents, mode or timestamp was","\\t\\t\\t\\t\\tchanged and buffer is modified","\\t\\t\\tchanged\\t\\tfile contents has changed","\\t\\t\\tmode\\t\\tmode of file changed","\\t\\t\\ttime\\t\\tonly file timestamp changed"],"v:fcs_choice":["What should happen after a |FileChangedShell| event was","\\t\\ttriggered.  Can be used in an autocommand to tell Vim what to","\\t\\tdo with the affected buffer:","\\t\\t\\treload\\t\\tReload the buffer (does not work if","\\t\\t\\t\\t\\tthe file was deleted).","\\t\\t\\task\\t\\tAsk the user what to do, as if there","\\t\\t\\t\\t\\twas no autocommand.  Except that when","\\t\\t\\t\\t\\tonly the timestamp changed nothing","\\t\\t\\t\\t\\twill happen.","\\t\\t\\t<empty>\\t\\tNothing, the autocommand should do","\\t\\t\\t\\t\\teverything that needs to be done.","\\t\\tThe default is empty.  If another (invalid) value is used then","\\t\\tVim behaves like it is empty, there is no warning message."],"v:fname_in":["The name of the input file.  Valid while evaluating:","\\t\\t\\toption\\t\\tused for ~","\\t\\t\\t\'charconvert\'\\tfile to be converted","\\t\\t\\t\'diffexpr\'\\toriginal file","\\t\\t\\t\'patchexpr\'\\toriginal file","\\t\\t\\t\'printexpr\'\\tfile to be printed","\\t\\tAnd set to the swap file name for |SwapExists|."],"v:fname_out":["The name of the output file.  Only valid while","\\t\\tevaluating:","\\t\\t\\toption\\t\\tused for ~","\\t\\t\\t\'charconvert\'\\tresulting converted file (*)","\\t\\t\\t\'diffexpr\'\\toutput of diff","\\t\\t\\t\'patchexpr\'\\tresulting patched file","\\t\\t(*) When doing conversion for a write command (e.g., \\":w","\\t\\tfile\\") it will be equal to v:fname_in.  When doing conversion","\\t\\tfor a read command (e.g., \\":e file\\") it will be a temporary","\\t\\tfile and different from v:fname_in."],"v:fname_new":["The name of the new version of the file.  Only valid while","\\t\\tevaluating \'diffexpr\'."],"v:fname_diff":["The name of the diff (patch) file.  Only valid while","\\t\\tevaluating \'patchexpr\'."],"v:folddashes":["Used for \'foldtext\': dashes representing foldlevel of a closed","\\t\\tfold.","\\t\\tRead-only in the |sandbox|. |fold-foldtext|"],"v:foldlevel":["Used for \'foldtext\': foldlevel of closed fold.","\\t\\tRead-only in the |sandbox|. |fold-foldtext|"],"v:foldend":["Used for \'foldtext\': last line of closed fold.","\\t\\tRead-only in the |sandbox|. |fold-foldtext|"],"v:foldstart":["Used for \'foldtext\': first line of closed fold.","\\t\\tRead-only in the |sandbox|. |fold-foldtext|"],"v:hlsearch":["Variable that indicates whether search highlighting is on.","\\t\\tSetting it makes sense only if \'hlsearch\' is enabled. Setting","\\t\\tthis variable to zero acts like the |:nohlsearch| command,","\\t\\tsetting it to one acts like >","\\t\\t\\tlet &hlsearch = &hlsearch","<\\t\\tNote that the value is restored when returning from a","\\t\\tfunction. |function-search-undo|."],"v:insertmode":["Used for the |InsertEnter| and |InsertChange| autocommand","\\t\\tevents.  Values:","\\t\\t\\ti\\tInsert mode","\\t\\t\\tr\\tReplace mode","\\t\\t\\tv\\tVirtual Replace mode"],"v:key":["Key of the current item of a |Dictionary|.  Only valid while","\\t\\tevaluating the expression used with |map()| and |filter()|.","\\t\\tRead-only."],"v:lang":["The current locale setting for messages of the runtime","\\t\\tenvironment.  This allows Vim scripts to be aware of the","\\t\\tcurrent language.  Technical: it\'s the value of LC_MESSAGES.","\\t\\tThe value is system dependent.","\\t\\tThis variable can not be set directly, use the |:language|","\\t\\tcommand.","\\t\\tIt can be different from |v:ctype| when messages are desired","\\t\\tin a different language than what is used for character","\\t\\tencoding.  See |multi-lang|."],"v:lc_time":["The current locale setting for time messages of the runtime","\\t\\tenvironment.  This allows Vim scripts to be aware of the","\\t\\tcurrent language.  Technical: it\'s the value of LC_TIME.","\\t\\tThis variable can not be set directly, use the |:language|","\\t\\tcommand.  See |multi-lang|."],"v:lnum":["Line number for the \'foldexpr\' |fold-expr|, \'formatexpr\' and","\\t\\t\'indentexpr\' expressions, tab page number for \'guitablabel\'","\\t\\tand \'guitabtooltip\'.  Only valid while one of these","\\t\\texpressions is being evaluated.  Read-only when in the","\\t\\t|sandbox|."],"v:lua":["Prefix for calling Lua functions from expressions.","\\t\\tSee |v:lua-call| for more information."],"v:mouse_win":["Window number for a mouse click obtained with |getchar()|.","\\t\\tFirst window has number 1, like with |winnr()|.  The value is","\\t\\tzero when there was no mouse button click."],"v:mouse_winid":["|window-ID| for a mouse click obtained with |getchar()|.","\\t\\tThe value is zero when there was no mouse button click."],"v:mouse_lnum":["Line number for a mouse click obtained with |getchar()|.","\\t\\tThis is the text line number, not the screen line number.  The","\\t\\tvalue is zero when there was no mouse button click."],"v:mouse_col":["Column number for a mouse click obtained with |getchar()|.","\\t\\tThis is the screen column number, like with |virtcol()|.  The","\\t\\tvalue is zero when there was no mouse button click."],"v:msgpack_types":["Dictionary containing msgpack types used by |msgpackparse()|","\\t\\tand |msgpackdump()|. All types inside dictionary are fixed","\\t\\t(not editable) empty lists. To check whether some list is one","\\t\\tof msgpack types, use |is| operator."],"v:null":["Special value used to put \\"null\\" in JSON and NIL in msgpack. ","\\t\\tSee |json_encode()|.  This value is converted to \\"v:null\\" when","\\t\\tused as a String (e.g. in |expr5| with string concatenation","\\t\\toperator) and to zero when used as a Number (e.g. in |expr5|","\\t\\tor |expr7| when used with numeric operators). Read-only."],"v:oldfiles":["List of file names that is loaded from the |shada| file on","\\t\\tstartup.  These are the files that Vim remembers marks for.","\\t\\tThe length of the List is limited by the \' argument of the","\\t\\t\'shada\' option (default is 100).","\\t\\tWhen the |shada| file is not used the List is empty.","\\t\\tAlso see |:oldfiles| and |c_#<|.","\\t\\tThe List can be modified, but this has no effect on what is","\\t\\tstored in the |shada| file later.  If you use values other","\\t\\tthan String this will cause trouble."],"v:option_new":["New value of the option. Valid while executing an |OptionSet|","\\t\\tautocommand."],"v:option_old":["Old value of the option. Valid while executing an |OptionSet|","\\t\\tautocommand."],"v:option_type":["Scope of the set command. Valid while executing an","\\t\\t|OptionSet| autocommand. Can be either \\"global\\" or \\"local\\""],"v:operator":["The last operator given in Normal mode.  This is a single","\\t\\tcharacter except for commands starting with <g> or <z>,","\\t\\tin which case it is two characters.  Best used alongside","\\t\\t|v:prevcount| and |v:register|.  Useful if you want to cancel","\\t\\tOperator-pending mode and then use the operator, e.g.: >","\\t\\t\\t:omap O <Esc>:call MyMotion(v:operator)<CR>","<\\t\\tThe value remains set until another operator is entered, thus","\\t\\tdon\'t expect it to be empty.","\\t\\tv:operator is not set for |:delete|, |:yank| or other Ex","\\t\\tcommands.","\\t\\tRead-only."],"v:prevcount":["The count given for the last but one Normal mode command.","\\t\\tThis is the v:count value of the previous command.  Useful if","\\t\\tyou want to cancel Visual or Operator-pending mode and then","\\t\\tuse the count, e.g.: >","\\t\\t\\t:vmap % <Esc>:call MyFilter(v:prevcount)<CR>","<\\t\\tRead-only."],"v:profiling":["Normally zero.  Set to one after using \\":profile start\\".","\\t\\tSee |profiling|."],"v:progname":["The name by which Nvim was invoked (with path removed).","\\t\\tRead-only."],"v:progpath":["Absolute path to the current running Nvim.","\\t\\tRead-only."],"v:register":["The name of the register in effect for the current normal mode","\\t\\tcommand (regardless of whether that command actually used a","\\t\\tregister).  Or for the currently executing normal mode mapping","\\t\\t(use this in custom commands that take a register).","\\t\\tIf none is supplied it is the default register \'\\"\', unless","\\t\\t\'clipboard\' contains \\"unnamed\\" or \\"unnamedplus\\", then it is","\\t\\t\'*\' or \'+\'.","\\t\\tAlso see |getreg()| and |setreg()|"],"v:scrollstart":["String describing the script or function that caused the","\\t\\tscreen to scroll up.  It\'s only set when it is empty, thus the","\\t\\tfirst reason is remembered.  It is set to \\"Unknown\\" for a","\\t\\ttyped command.","\\t\\tThis can be used to find out why your script causes the","\\t\\thit-enter prompt."],"v:servername":["Primary listen-address of the current Nvim instance, the first","\\t\\titem returned by |serverlist()|.  Can be set by |--listen| or","\\t\\t|$NVIM_LISTEN_ADDRESS| at startup. |serverstart()| |serverstop()|","\\t\\tRead-only."],"v:searchforward":["*v:searchforward* *searchforward-variable*","\\t\\tSearch direction:  1 after a forward search, 0 after a","\\t\\tbackward search.  It is reset to forward when directly setting","\\t\\tthe last search pattern, see |quote/|.","\\t\\tNote that the value is restored when returning from a","\\t\\tfunction. |function-search-undo|.","\\t\\tRead-write."],"v:shell_error":["Result of the last shell command.  When non-zero, the last","\\t\\tshell command had an error.  When zero, there was no problem.","\\t\\tThis only works when the shell returns the error code to Vim.","\\t\\tThe value -1 is often used when the command could not be","\\t\\texecuted.  Read-only.","\\t\\tExample: >","\\t:!mv foo bar","\\t:if v:shell_error","\\t:  echo \'could not rename \\"foo\\" to \\"bar\\"!\'","\\t:endif","<"],"v:statusmsg":["Last given status message.","\\t\\tModifiable (can be set)."],"v:stderr":["|channel-id| corresponding to stderr. The value is always 2;","\\t\\tuse this variable to make your code more descriptive.","\\t\\tUnlike stdin and stdout (see |stdioopen()|), stderr is always","\\t\\topen for writing. Example: >","\\t\\t\\t:call chansend(v:stderr, \\"error: toaster empty\\\\n\\")","<"],"v:swapname":["Only valid when executing |SwapExists| autocommands: Name of","\\t\\tthe swap file found.  Read-only."],"v:swapchoice":["|SwapExists| autocommands can set this to the selected choice","\\t\\tfor handling an existing swap file:","\\t\\t\\t\'o\'\\tOpen read-only","\\t\\t\\t\'e\'\\tEdit anyway","\\t\\t\\t\'r\'\\tRecover","\\t\\t\\t\'d\'\\tDelete swapfile","\\t\\t\\t\'q\'\\tQuit","\\t\\t\\t\'a\'\\tAbort","\\t\\tThe value should be a single-character string.  An empty value","\\t\\tresults in the user being asked, as would happen when there is","\\t\\tno SwapExists autocommand.  The default is empty."],"v:swapcommand":["Normal mode command to be executed after a file has been","\\t\\topened.  Can be used for a |SwapExists| autocommand to have","\\t\\tanother Vim open the file and jump to the right place.  For","\\t\\texample, when jumping to a tag the value is \\":tag tagname\\\\r\\".","\\t\\tFor \\":edit +cmd file\\" the value is \\":cmd\\\\r\\"."],"v:t_bool":["Value of Boolean type.  Read-only.  See: |type()|"],"v:t_dict":["Value of Dictionary type.  Read-only.  See: |type()|"],"v:t_float":["Value of Float type.  Read-only.  See: |type()|"],"v:t_func":["Value of Funcref type.  Read-only.  See: |type()|"],"v:t_list":["Value of List type.  Read-only.  See: |type()|"],"v:t_number":["Value of Number type.  Read-only.  See: |type()|"],"v:t_string":["Value of String type.  Read-only.  See: |type()|"],"v:termresponse":["The escape sequence returned by the terminal for the DA","\\t\\t(request primary device attributes) control sequence.  It is","\\t\\tset when Vim receives an escape sequence that starts with ESC","\\t\\t[ or CSI and ends in a \'c\', with only digits, \';\' and \'.\' in","\\t\\tbetween.","\\t\\tWhen this option is set, the TermResponse autocommand event is","\\t\\tfired, so that you can react to the response from the","\\t\\tterminal.","\\t\\tThe response from a new xterm is: \\"<Esc>[ Pp ; Pv ; Pc c\\".  Pp","\\t\\tis the terminal type: 0 for vt100 and 1 for vt220.  Pv is the","\\t\\tpatch level (since this was introduced in patch 95, it\'s","\\t\\talways 95 or bigger).  Pc is always zero."],"v:testing":["Must be set before using `test_garbagecollect_now()`."],"v:this_session":["Full filename of the last loaded or saved session file.","\\t\\tEmpty when no session file has been saved.  See |:mksession|.","\\t\\tModifiable (can be set)."],"v:throwpoint":["The point where the exception most recently caught and not","\\t\\tfinished was thrown.  Not set when commands are typed.  See","\\t\\talso |v:exception| and |throw-variables|.","\\t\\tExample: >","\\t:try","\\t:  throw \\"oops\\"","\\t:catch /.*/","\\t:  echo \\"Exception from\\" v:throwpoint","\\t:endtry","<\\t\\tOutput: \\"Exception from test.vim, line 2\\""],"v:true":["Special value used to put \\"true\\" in JSON and msgpack.  See","\\t\\t|json_encode()|.  This value is converted to \\"v:true\\" when used","\\t\\tas a String (e.g. in |expr5| with string concatenation","\\t\\toperator) and to one when used as a Number (e.g. in |expr5| or","\\t\\t|expr7| when used with numeric operators). Read-only."],"v:val":["Value of the current item of a |List| or |Dictionary|.  Only","\\t\\tvalid while evaluating the expression used with |map()| and","\\t\\t|filter()|.  Read-only."],"v:version":["Vim version number: major version times 100 plus minor","\\t\\tversion.  Vim 5.0 is 500, Vim 5.1 is 501.","\\t\\tRead-only.","\\t\\tUse |has()| to check the Nvim (not Vim) version: >","\\t\\t\\t:if has(\\"nvim-0.2.1\\")","<"],"v:vim_did_enter":["0 during startup, 1 just before |VimEnter|.","\\t\\tRead-only."],"v:warningmsg":["Last given warning message.","\\t\\tModifiable (can be set)."],"v:windowid":["Application-specific window \\"handle\\" which may be set by any","\\t\\tattached UI. Defaults to zero.","\\t\\tNote: For Nvim |windows| use |winnr()| or |win_getid()|, see","\\t\\t|window-ID|."],"v:argv":["The command line arguments Vim was invoked with.  This is a","\\t\\tlist of strings.  The first item is the Vim command."],"v:none":["An empty String. Used to put an empty item in JSON.  See","\\t\\t|json_encode()|.","\\t\\tWhen used as a number this evaluates to zero.","\\t\\tWhen used as a string this evaluates to \\"v:none\\". >","\\t\\t\\techo v:none","<\\t\\t\\tv:none ~","\\t\\tThat is so that eval() can parse the string back to the same","\\t\\tvalue.  Read-only."],"v:t_channel":["Value of |Channel| type.  Read-only.  See: |type()|"],"v:t_job":["Value of |Job| type.  Read-only.  See: |type()|"],"v:t_none":["Value of |None| type.  Read-only.  See: |type()|"],"v:t_blob":["Value of |Blob| type.  Read-only.  See: |type()|"],"v:termblinkresp":["The escape sequence returned by the terminal for the |t_RC|","\\t\\ttermcap entry.  This is used to find out whether the terminal","\\t\\tcursor is blinking. This is used by |term_getcursor()|."],"v:termstyleresp":["The escape sequence returned by the terminal for the |t_RS|","\\t\\ttermcap entry.  This is used to find out what the shape of the","\\t\\tcursor is.  This is used by |term_getcursor()|."],"v:termrbgresp":["The escape sequence returned by the terminal for the |t_RB|","\\t\\ttermcap entry.  This is used to find out what the terminal","\\t\\tbackground color is, see \'background\'."],"v:termrfgresp":["The escape sequence returned by the terminal for the |t_RF|","\\t\\ttermcap entry.  This is used to find out what the terminal","\\t\\tforeground color is."],"v:termu7resp":["The escape sequence returned by the terminal for the |t_u7|","\\t\\ttermcap entry.  This is used to find out what the terminal","\\t\\tdoes with ambiguous width characters, see \'ambiwidth\'."],"v:versionlong":["Like v:version, but also including the patchlevel in the last","\\t\\tfour digits.  Version 8.1 with patch 123 has value 8010123.","\\t\\tThis can be used like this: >","\\t\\t\\tif v:versionlong >= 8010123","<\\t\\tHowever, if there are gaps in the list of patches included","\\t\\tthis will not work well.  This can happen if a recent patch","\\t\\twas included into an older version, e.g. for a security fix.","\\t\\tUse the has() function to make sure the patch is actually","\\t\\tincluded."]},"options":{"aleph":["number\\t(default 224)","\\t\\t\\tglobal","\\tThe ASCII code for the first letter of the Hebrew alphabet.  The","\\troutine that maps the keyboard in Hebrew mode, both in Insert mode","\\t(when hkmap is set) and on the command-line (when hitting CTRL-_)","\\toutputs the Hebrew characters in the range [aleph..aleph+26].","\\taleph=128 applies to PC code, and aleph=224 applies to ISO 8859-8.","\\tSee |rileft.txt|."],"allowrevins":["boolean\\t(default off)","\\t\\t\\tglobal","\\tAllow CTRL-_ in Insert and Command-line mode.  This is default off, to","\\tavoid that users that accidentally type CTRL-_ instead of SHIFT-_ get","\\tinto reverse Insert mode, and don\'t know how to get out.  See","\\t\'revins\'."],"ambiwidth":["string (default: \\"single\\")","\\t\\t\\tglobal","\\tTells Vim what to do with characters with East Asian Width Class","\\tAmbiguous (such as Euro, Registered Sign, Copyright Sign, Greek","\\tletters, Cyrillic letters)."],"autochdir":["boolean (default off)","\\t\\t\\tglobal","\\tWhen on, Vim will change the current working directory whenever you","\\topen a file, switch buffers, delete a buffer or open/close a window.","\\tIt will change to the directory containing the file which was opened","\\tor selected.","\\tNote: When this option is on some plugins may not work."],"arabic":["boolean (default off)","\\t\\t\\tlocal to window","\\tThis option can be set to start editing Arabic text.","\\tSetting this option will:","\\t- Set the \'rightleft\' option, unless \'termbidi\' is set.","\\t- Set the \'arabicshape\' option, unless \'termbidi\' is set.","\\t- Set the \'keymap\' option to \\"arabic\\"; in Insert mode CTRL-^ toggles","\\t  between typing English and Arabic key mapping.","\\t- Set the \'delcombine\' option"],"arabicshape":["boolean (default on)","\\t\\t\\tglobal","\\tWhen on and \'termbidi\' is off, the required visual character","\\tcorrections that need to take place for displaying the Arabic language","\\ttake effect.  Shaping, in essence, gets enabled; the term is a broad","\\tone which encompasses:","\\t  a) the changing/morphing of characters based on their location","\\t     within a word (initial, medial, final and stand-alone).","\\t  b) the enabling of the ability to compose characters","\\t  c) the enabling of the required combining of some characters","\\tWhen disabled the display shows each character\'s true stand-alone","\\tform.","\\tArabic is a complex language which requires other settings, for","\\tfurther details see |arabic.txt|."],"autoindent":["boolean\\t(default on)","\\t\\t\\tlocal to buffer","\\tCopy indent from current line when starting a new line (typing <CR>","\\tin Insert mode or when using the \\"o\\" or \\"O\\" command).  If you do not","\\ttype anything on the new line except <BS> or CTRL-D and then type","\\t<Esc>, CTRL-O or <CR>, the indent is deleted again.  Moving the cursor","\\tto another line has the same effect, unless the \'I\' flag is included","\\tin \'cpoptions\'.","\\tWhen autoindent is on, formatting (with the \\"gq\\" command or when you","\\treach \'textwidth\' in Insert mode) uses the indentation of the first","\\tline.","\\tWhen \'smartindent\' or \'cindent\' is on the indent is changed in","\\ta different way.","\\tThe \'autoindent\' option is reset when the \'paste\' option is set and","\\trestored when \'paste\' is reset.","\\t{small difference from Vi: After the indent is deleted when typing","\\t<Esc> or <CR>, the cursor position when moving up or down is after the","\\tdeleted indent; Vi puts the cursor somewhere in the deleted indent}."],"autoread":["boolean\\t(default on)","\\t\\t\\tglobal or local to buffer |global-local|","\\tWhen a file has been detected to have been changed outside of Vim and","\\tit has not been changed inside of Vim, automatically read it again.","\\tWhen the file has been deleted this is not done, so you have the text","\\tfrom before it was deleted.  When it appears again then it is read.","\\t|timestamp|","\\tIf this option has a local value, use this command to switch back to","\\tusing the global value: >","\\t\\t:set autoread<","<","\\t\\t\\t\\t *\'autowrite\'* *\'aw\'* *\'noautowrite\'* *\'noaw\'*"],"autowrite":["boolean\\t(default off)","\\t\\t\\tglobal","\\tWrite the contents of the file, if it has been modified, on each","\\t:next, :rewind, :last, :first, :previous, :stop, :suspend, :tag, :!,","\\t:make, CTRL-] and CTRL-^ command; and when a :buffer, CTRL-O, CTRL-I,","\\t\'{A-Z0-9}, or `{A-Z0-9} command takes one to another file.","\\tNote that for some commands the \'autowrite\' option is not used, see","\\t\'autowriteall\' for that.","\\tSome buffers will not be written, specifically when \'buftype\' is","\\t\\"nowrite\\", \\"nofile\\", \\"terminal\\" or \\"prompt\\"."],"autowriteall":["boolean\\t(default off)","\\t\\t\\tglobal","\\tLike \'autowrite\', but also used for commands \\":edit\\", \\":enew\\", \\":quit\\",","\\t\\":qall\\", \\":exit\\", \\":xit\\", \\":recover\\" and closing the Vim window.","\\tSetting this option also implies that Vim behaves like \'autowrite\' has","\\tbeen set."],"background":["string\\t(default \\"dark\\")","\\t\\t\\tglobal","\\tWhen set to \\"dark\\" or \\"light\\", adjusts the default color groups for","\\tthat background type.  The |TUI| or other UI sets this on startup","\\t(triggering |OptionSet|) if it can detect the background color."],"backspace":["string\\t(default \\"indent,eol,start\\")","\\t\\t\\tglobal","\\tInfluences the working of <BS>, <Del>, CTRL-W and CTRL-U in Insert","\\tmode.  This is a list of items, separated by commas.  Each item allows","\\ta way to backspace over something:","\\tvalue\\teffect\\t~","\\tindent\\tallow backspacing over autoindent","\\teol\\tallow backspacing over line breaks (join lines)","\\tstart\\tallow backspacing over the start of insert; CTRL-W and CTRL-U","\\t\\tstop once at the start of insert."],"backup":["boolean\\t(default off)","\\t\\t\\tglobal","\\tMake a backup before overwriting a file.  Leave it around after the","\\tfile has been successfully written.  If you do not want to keep the","\\tbackup file, but you do want a backup while the file is being","\\twritten, reset this option and set the \'writebackup\' option (this is","\\tthe default).  If you do not want a backup file at all reset both","\\toptions (use this if your file system is almost full).  See the","\\t|backup-table| for more explanations.","\\tWhen the \'backupskip\' pattern matches, a backup is not made anyway.","\\tWhen \'patchmode\' is set, the backup may be renamed to become the","\\toldest version of a file."],"backupcopy":["string\\t(Vi default for Unix: \\"yes\\", otherwise: \\"auto\\")","\\t\\t\\tglobal or local to buffer |global-local|","\\tWhen writing a file and a backup is made, this option tells how it\'s","\\tdone.  This is a comma separated list of words."],"backupdir":["string\\t(default \\".,$XDG_DATA_HOME/nvim/backup\\")","\\t\\t\\tglobal","\\tList of directories for the backup file, separated with commas.","\\t- The backup file will be created in the first directory in the list","\\t  where this is possible.  The directory must exist, Vim will not","\\t  create it for you.","\\t- Empty means that no backup file will be created (\'patchmode\' is","\\t  impossible!).  Writing may fail because of this.","\\t- A directory \\".\\" means to put the backup file in the same directory","\\t  as the edited file.","\\t- A directory starting with \\"./\\" (or \\".\\\\\\" for Windows) means to","\\t  put the backup file relative to where the edited file is.  The","\\t  leading \\".\\" is replaced with the path name of the edited file.","\\t  (\\".\\" inside a directory name has no special meaning).","\\t- Spaces after the comma are ignored, other spaces are considered part","\\t  of the directory name.  To have a space at the start of a directory","\\t  name, precede it with a backslash.","\\t- To include a comma in a directory name precede it with a backslash.","\\t- A directory name may end in an \'/\'.","\\t- For Unix and Win32, if a directory ends in two path separators \\"//\\",","\\t  the swap file name will be built from the complete path to the file","\\t  with all path separators changed to percent \'%\' signs. This will","\\t  ensure file name uniqueness in the backup directory.","\\t  On Win32, it is also possible to end with \\"\\\\\\\\\\".  However, When a","\\t  separating comma is following, you must use \\"//\\", since \\"\\\\\\\\\\" will","\\t  include the comma in the file name. Therefore it is recommended to","\\t  use \'//\', instead of \'\\\\\\\\\'.","\\t- Environment variables are expanded |:set_env|.","\\t- Careful with \'\\\\\' characters, type one before a space, type two to","\\t  get one in the option (see |option-backslash|), for example: >","\\t    :set bdir=c:\\\\\\\\tmp,\\\\ dir\\\\\\\\,with\\\\\\\\,commas,\\\\\\\\\\\\ dir\\\\ with\\\\ spaces","<\\t- For backwards compatibility with Vim version 3.0 a \'>\' at the start","\\t  of the option is removed.","\\tSee also \'backup\' and \'writebackup\' options.","\\tIf you want to hide your backup files on Unix, consider this value: >","\\t\\t:set backupdir=./.backup,~/.backup,.,/tmp","<\\tYou must create a \\".backup\\" directory in each directory and in your","\\thome directory for this to work properly.","\\tThe use of |:set+=| and |:set-=| is preferred when adding or removing","\\tdirectories from the list.  This avoids problems when a future version","\\tuses another default.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"backupext":["string\\t(default \\"~\\")","\\t\\t\\tglobal","\\tString which is appended to a file name to make the name of the","\\tbackup file.  The default is quite unusual, because this avoids","\\taccidentally overwriting existing files with a backup file.  You might","\\tprefer using \\".bak\\", but make sure that you don\'t have files with","\\t\\".bak\\" that you want to keep.","\\tOnly normal file name characters can be used, \\"/\\\\*?[|<>\\" are illegal."],"backupskip":["string\\t(default: \\"$TMPDIR/*,$TMP/*,$TEMP/*\\"","\\t\\t\\t\\t Unix: \\"/tmp/*,$TMPDIR/*,$TMP/*,$TEMP/*\\"","\\t\\t\\t\\t Mac: \\"/private/tmp/*,$TMPDIR/*,$TMP/*,$TEMP/*\\")","\\t\\t\\tglobal","\\tA list of file patterns.  When one of the patterns matches with the","\\tname of the file which is written, no backup file is created.  Both","\\tthe specified file name and the full path name of the file are used.","\\tThe pattern is used like with |:autocmd|, see |autocmd-pattern|.","\\tWatch out for special characters, see |option-backslash|.","\\tWhen $TMPDIR, $TMP or $TEMP is not defined, it is not used for the","\\tdefault value.  \\"/tmp/*\\" is only used for Unix."],"balloondelay":["Removed."],"ballooneval":["Removed."],"balloonexpr":["Removed."],"belloff":["string\\t(default \\"all\\")","\\t\\t\\tglobal","\\tSpecifies for which events the bell will not be rung. It is a comma","\\tseparated list of items. For each item that is present, the bell","\\twill be silenced. This is most useful to specify specific events in","\\tinsert mode to be silenced."],"binary":["boolean\\t(default off)","\\t\\t\\tlocal to buffer","\\tThis option should be set before editing a binary file.  You can also","\\tuse the |-b| Vim argument.  When this option is switched on a few","\\toptions will be changed (also when it already was on):","\\t\\t\'textwidth\'  will be set to 0","\\t\\t\'wrapmargin\' will be set to 0","\\t\\t\'modeline\'   will be off","\\t\\t\'expandtab\'  will be off","\\tAlso, \'fileformat\' and \'fileformats\' options will not be used, the","\\tfile is read and written like \'fileformat\' was \\"unix\\" (a single <NL>","\\tseparates lines).","\\tThe \'fileencoding\' and \'fileencodings\' options will not be used, the","\\tfile is read without conversion.","\\tNOTE: When you start editing a(nother) file while the \'bin\' option is","\\ton, settings from autocommands may change the settings again (e.g.,","\\t\'textwidth\'), causing trouble when editing.  You might want to set","\\t\'bin\' again when the file has been loaded.","\\tThe previous values of these options are remembered and restored when","\\t\'bin\' is switched from on to off.  Each buffer has its own set of","\\tsaved option values.","\\tTo edit a file with \'binary\' set you can use the |++bin| argument.","\\tThis avoids you have to do \\":set bin\\", which would have effect for all","\\tfiles you edit.","\\tWhen writing a file the <EOL> for the last line is only written if","\\tthere was one in the original file (normally Vim appends an <EOL> to","\\tthe last line if there is none; this would make the file longer).  See","\\tthe \'endofline\' option."],"bomb":["boolean\\t(default off)","\\t\\t\\tlocal to buffer","\\tWhen writing a file and the following conditions are met, a BOM (Byte","\\tOrder Mark) is prepended to the file:","\\t- this option is on","\\t- the \'binary\' option is off","\\t- \'fileencoding\' is \\"utf-8\\", \\"ucs-2\\", \\"ucs-4\\" or one of the little/big","\\t  endian variants.","\\tSome applications use the BOM to recognize the encoding of the file.","\\tOften used for UCS-2 files on MS-Windows.  For other applications it","\\tcauses trouble, for example: \\"cat file1 file2\\" makes the BOM of file2","\\tappear halfway through the resulting file.  Gcc doesn\'t accept a BOM.","\\tWhen Vim reads a file and \'fileencodings\' starts with \\"ucs-bom\\", a","\\tcheck for the presence of the BOM is done and \'bomb\' set accordingly.","\\tUnless \'binary\' is set, it is removed from the first line, so that you","\\tdon\'t see it when editing.  When you don\'t change the options, the BOM","\\twill be restored when writing the file."],"breakat":["string\\t(default \\" ^I!@*-+;:,./?\\")","\\t\\t\\tglobal","\\tThis option lets you choose which characters might cause a line","\\tbreak if \'linebreak\' is on.  Only works for ASCII characters."],"breakindent":["boolean (default off)","\\t\\t\\tlocal to window","\\tEvery wrapped line will continue visually indented (same amount of","\\tspace as the beginning of that line), thus preserving horizontal blocks","\\tof text."],"breakindentopt":["string (default empty)","\\t\\t\\tlocal to window","\\tSettings for \'breakindent\'. It can consist of the following optional","\\titems and must be separated by a comma:","\\t\\tmin:{n}\\t    Minimum text width that will be kept after","\\t\\t\\t    applying \'breakindent\', even if the resulting","\\t\\t\\t    text should normally be narrower. This prevents","\\t\\t\\t    text indented almost to the right window border","\\t\\t\\t    occupying lot of vertical space when broken.","\\t\\tshift:{n}   After applying \'breakindent\', the wrapped line\'s","\\t\\t\\t    beginning will be shifted by the given number of","\\t\\t\\t    characters.  It permits dynamic French paragraph","\\t\\t\\t    indentation (negative) or emphasizing the line","\\t\\t\\t    continuation (positive).","\\t\\tsbr\\t    Display the \'showbreak\' value before applying the","\\t\\t\\t    additional indent.","\\tThe default value for min is 20 and shift is 0."],"browsedir":["string\\t(default: \\"last\\")","\\t\\t\\tglobal","\\tWhich directory to use for the file browser:","\\t   last\\t\\tUse same directory as with last file browser, where a","\\t\\t\\tfile was opened or saved.","\\t   buffer\\tUse the directory of the related buffer.","\\t   current\\tUse the current directory.","\\t   {path}\\tUse the specified directory"],"bufhidden":["string (default: \\"\\")","\\t\\t\\tlocal to buffer","\\tThis option specifies what happens when a buffer is no longer","\\tdisplayed in a window:","\\t  <empty>\\tfollow the global \'hidden\' option","\\t  hide\\t\\thide the buffer (don\'t unload it), also when \'hidden\'","\\t\\t\\tis not set","\\t  unload\\tunload the buffer, also when \'hidden\' is set or using","\\t\\t\\t|:hide|","\\t  delete\\tdelete the buffer from the buffer list, also when","\\t\\t\\t\'hidden\' is set or using |:hide|, like using","\\t\\t\\t|:bdelete|","\\t  wipe\\t\\twipe out the buffer from the buffer list, also when","\\t\\t\\t\'hidden\' is set or using |:hide|, like using","\\t\\t\\t|:bwipeout|"],"buflisted":["boolean (default: on)","\\t\\t\\tlocal to buffer","\\tWhen this option is set, the buffer shows up in the buffer list.  If","\\tit is reset it is not used for \\":bnext\\", \\"ls\\", the Buffers menu, etc.","\\tThis option is reset by Vim for buffers that are only used to remember","\\ta file name or marks.  Vim sets it when starting to edit a buffer.","\\tBut not when moving to a buffer with \\":buffer\\"."],"buftype":["string (default: \\"\\")","\\t\\t\\tlocal to buffer","\\tThe value of this option specifies the type of a buffer:","\\t  <empty>\\tnormal buffer","\\t  acwrite\\tbuffer will always be written with |BufWriteCmd|s","\\t  help\\t\\thelp buffer (do not set this manually)","\\t  nofile\\tbuffer is not related to a file, will not be written","\\t  nowrite\\tbuffer will not be written","\\t  quickfix\\tlist of errors |:cwindow| or locations |:lwindow|","\\t  terminal\\t|terminal-emulator| buffer","\\t  prompt\\tbuffer where only the last line can be edited, meant","\\t\\t\\tto be used by a plugin, see |prompt-buffer|"],"casemap":["string\\t(default: \\"internal,keepascii\\")","\\t\\t\\tglobal","\\tSpecifies details about changing the case of letters.  It may contain","\\tthese words, separated by a comma:","\\tinternal\\tUse internal case mapping functions, the current","\\t\\t\\tlocale does not change the case mapping. When","\\t\\t\\t\\"internal\\" is omitted, the towupper() and towlower()","\\t\\t\\tsystem library functions are used when available.","\\tkeepascii\\tFor the ASCII characters (0x00 to 0x7f) use the US","\\t\\t\\tcase mapping, the current locale is not effective.","\\t\\t\\tThis probably only matters for Turkish."],"cdpath":["string\\t(default: equivalent to $CDPATH or \\",,\\")","\\t\\t\\tglobal","\\tThis is a list of directories which will be searched when using the","\\t|:cd| and |:lcd| commands, provided that the directory being searched","\\tfor has a relative path, not an absolute part starting with \\"/\\", \\"./\\"","\\tor \\"../\\", the \'cdpath\' option is not used then.","\\tThe \'cdpath\' option\'s value has the same form and semantics as","\\t|\'path\'|.  Also see |file-searching|.","\\tThe default value is taken from $CDPATH, with a \\",\\" prepended to look","\\tin the current directory first.","\\tIf the default value taken from $CDPATH is not what you want, include","\\ta modified version of the following command in your vimrc file to","\\toverride it: >","\\t  :let &cdpath = \',\' . substitute(substitute($CDPATH, \'[, ]\', \'\\\\\\\\\\\\0\', \'g\'), \':\', \',\', \'g\')","<\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons.","\\t(parts of \'cdpath\' can be passed to the shell to expand file names)."],"cedit":["string\\t(Vim default: CTRL-F, Vi default: \\"\\")","\\t\\t\\tglobal","\\tThe key used in Command-line Mode to open the command-line window.","\\tOnly non-printable keys are allowed.","\\tThe key can be specified as a single character, but it is difficult to","\\ttype.  The preferred way is to use the <> notation.  Examples: >","\\t\\t:exe \\"set cedit=\\\\<C-Y>\\"","\\t\\t:exe \\"set cedit=\\\\<Esc>\\"","<\\t|Nvi| also has this option, but it only uses the first character.","\\tSee |cmdwin|."],"channel":["number (default: 0)","\\t\\t\\tlocal to buffer","\\t|channel| connected to the buffer, or 0 if no channel is connected.","\\tIn a |:terminal| buffer this is the terminal channel.","\\tRead-only."],"charconvert":["string (default \\"\\")","\\t\\t\\tglobal","\\tAn expression that is used for character encoding conversion.  It is","\\tevaluated when a file that is to be read or has been written has a","\\tdifferent encoding from what is desired.","\\t\'charconvert\' is not used when the internal iconv() function is","\\tsupported and is able to do the conversion.  Using iconv() is","\\tpreferred, because it is much faster.","\\t\'charconvert\' is not used when reading stdin |--|, because there is no","\\tfile to convert from.  You will have to save the text in a file first.","\\tThe expression must return zero or an empty string for success,","\\tnon-zero for failure.","\\tSee |encoding-names| for possible encoding names.","\\tAdditionally, names given in \'fileencodings\' and \'fileencoding\' are","\\tused.","\\tConversion between \\"latin1\\", \\"unicode\\", \\"ucs-2\\", \\"ucs-4\\" and \\"utf-8\\"","\\tis done internally by Vim, \'charconvert\' is not used for this.","\\tAlso used for Unicode conversion.","\\tExample: >","\\t\\tset charconvert=CharConvert()","\\t\\tfun CharConvert()","\\t\\t  system(\\"recode \\"","\\t\\t\\t\\\\ . v:charconvert_from . \\"..\\" . v:charconvert_to","\\t\\t\\t\\\\ . \\" <\\" . v:fname_in . \\" >\\" v:fname_out)","\\t\\t  return v:shell_error","\\t\\tendfun","<\\tThe related Vim variables are:","\\t\\tv:charconvert_from\\tname of the current encoding","\\t\\tv:charconvert_to\\tname of the desired encoding","\\t\\tv:fname_in\\t\\tname of the input file","\\t\\tv:fname_out\\t\\tname of the output file","\\tNote that v:fname_in and v:fname_out will never be the same.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"cindent":["boolean\\t(default off)","\\t\\t\\tlocal to buffer","\\tEnables automatic C program indenting.  See \'cinkeys\' to set the keys","\\tthat trigger reindenting in insert mode and \'cinoptions\' to set your","\\tpreferred indent style.","\\tIf \'indentexpr\' is not empty, it overrules \'cindent\'.","\\tIf \'lisp\' is not on and both \'indentexpr\' and \'equalprg\' are empty,","\\tthe \\"=\\" operator indents using this algorithm rather than calling an","\\texternal program.","\\tSee |C-indenting|.","\\tWhen you don\'t like the way \'cindent\' works, try the \'smartindent\'","\\toption or \'indentexpr\'.","\\tThis option is not used when \'paste\' is set."],"cinkeys":["string\\t(default \\"0{,0},0),0],:,0#,!^F,o,O,e\\")","\\t\\t\\tlocal to buffer","\\tA list of keys that, when typed in Insert mode, cause reindenting of","\\tthe current line.  Only used if \'cindent\' is on and \'indentexpr\' is","\\tempty.","\\tFor the format of this option see |cinkeys-format|.","\\tSee |C-indenting|."],"cinoptions":["string\\t(default \\"\\")","\\t\\t\\tlocal to buffer","\\tThe \'cinoptions\' affect the way \'cindent\' reindents lines in a C","\\tprogram.  See |cinoptions-values| for the values of this option, and","\\t|C-indenting| for info on C indenting in general."],"cinwords":["string\\t(default \\"if,else,while,do,for,switch\\")","\\t\\t\\tlocal to buffer","\\tThese keywords start an extra indent in the next line when","\\t\'smartindent\' or \'cindent\' is set.  For \'cindent\' this is only done at","\\tan appropriate place (inside {}).","\\tNote that \'ignorecase\' isn\'t used for \'cinwords\'.  If case doesn\'t","\\tmatter, include the keyword both the uppercase and lowercase:","\\t\\"if,If,IF\\"."],"clipboard":["string\\t(default \\"\\")","\\t\\t\\tglobal","\\tThis option is a list of comma separated names.","\\tThese names are recognized:"],"cmdheight":["number\\t(default 1)","\\t\\t\\tglobal","\\tNumber of screen lines to use for the command-line.  Helps avoiding","\\t|hit-enter| prompts.","\\tThe value of this option is stored with the tab page, so that each tab","\\tpage can have a different value."],"cmdwinheight":["number\\t(default 7)","\\t\\t\\tglobal","\\tNumber of screen lines to use for the command-line window. |cmdwin|"],"colorcolumn":["string\\t(default \\"\\")","\\t\\t\\tlocal to window","\\t\'colorcolumn\' is a comma separated list of screen columns that are","\\thighlighted with ColorColumn |hl-ColorColumn|.  Useful to align","\\ttext.  Will make screen redrawing slower.","\\tThe screen column can be an absolute number, or a number preceded with","\\t\'+\' or \'-\', which is added to or subtracted from \'textwidth\'. >"],"columns":["number\\t(default 80 or terminal width)","\\t\\t\\tglobal","\\tNumber of columns of the screen.  Normally this is set by the terminal","\\tinitialization and does not have to be set by hand.","\\tWhen Vim is running in the GUI or in a resizable window, setting this","\\toption will cause the window size to be changed.  When you only want","\\tto use the size for the GUI, put the command in your |ginit.vim| file.","\\tWhen you set this option and Vim is unable to change the physical","\\tnumber of columns of the display, the display may be messed up.  For","\\tthe GUI it is always possible and Vim limits the number of columns to","\\twhat fits on the screen.  You can use this command to get the widest","\\twindow possible: >","\\t\\t:set columns=9999","<\\tMinimum value is 12, maximum value is 10000."],"comments":["string\\t(default","\\t\\t\\t\\t\\"s1:/*,mb:*,ex:*/,://,b:#,:%,:XCOMM,n:>,fb:-\\")","\\t\\t\\tlocal to buffer","\\tA comma separated list of strings that can start a comment line.  See","\\t|format-comments|.  See |option-backslash| about using backslashes to","\\tinsert a space."],"commentstring":["string\\t(default \\"/*%s*/\\")","\\t\\t\\tlocal to buffer","\\tA template for a comment.  The \\"%s\\" in the value is replaced with the","\\tcomment text.  Currently only used to add markers for folding, see","\\t|fold-marker|."],"complete":["string\\t(default: \\".,w,b,u,t\\")","\\t\\t\\tlocal to buffer","\\tThis option specifies how keyword completion |ins-completion| works","\\twhen CTRL-P or CTRL-N are used.  It is also used for whole-line","\\tcompletion |i_CTRL-X_CTRL-L|.  It indicates the type of completion","\\tand the places to scan.  It is a comma separated list of flags:","\\t.\\tscan the current buffer (\'wrapscan\' is ignored)","\\tw\\tscan buffers from other windows","\\tb\\tscan other loaded buffers that are in the buffer list","\\tu\\tscan the unloaded buffers that are in the buffer list","\\tU\\tscan the buffers that are not in the buffer list","\\tk\\tscan the files given with the \'dictionary\' option","\\tkspell  use the currently active spell checking |spell|","\\tk{dict}\\tscan the file {dict}.  Several \\"k\\" flags can be given,","\\t\\tpatterns are valid too.  For example: >","\\t\\t\\t:set cpt=k/usr/dict/*,k~/spanish","<\\ts\\tscan the files given with the \'thesaurus\' option","\\ts{tsr}\\tscan the file {tsr}.  Several \\"s\\" flags can be given, patterns","\\t\\tare valid too.","\\ti\\tscan current and included files","\\td\\tscan current and included files for defined name or macro","\\t\\t|i_CTRL-X_CTRL-D|","\\t]\\ttag completion","\\tt\\tsame as \\"]\\""],"completefunc":["string\\t(default: empty)","\\t\\t\\tlocal to buffer","\\tThis option specifies a function to be used for Insert mode completion","\\twith CTRL-X CTRL-U. |i_CTRL-X_CTRL-U|","\\tSee |complete-functions| for an explanation of how the function is","\\tinvoked and what it should return.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"completeopt":["string\\t(default: \\"menu,preview\\")","\\t\\t\\tglobal","\\tA comma separated list of options for Insert mode completion","\\t|ins-completion|.  The supported values are:"],"concealcursor":["string (default: \\"\\")","\\t\\t\\tlocal to window","\\tSets the modes in which text in the cursor line can also be concealed.","\\tWhen the current mode is listed then concealing happens just like in","\\tother lines.","\\t  n\\t\\tNormal mode","\\t  v\\t\\tVisual mode","\\t  i\\t\\tInsert mode","\\t  c\\t\\tCommand line editing, for \'incsearch\'"],"conceallevel":["number (default 0)","\\t\\t\\tlocal to window","\\tDetermine how text with the \\"conceal\\" syntax attribute |:syn-conceal|","\\tis shown:"],"confirm":["boolean (default off)","\\t\\t\\tglobal","\\tWhen \'confirm\' is on, certain operations that would normally","\\tfail because of unsaved changes to a buffer, e.g. \\":q\\" and \\":e\\",","\\tinstead raise a dialog asking if you wish to save the current","\\tfile(s).  You can still use a ! to unconditionally |abandon| a buffer.","\\tIf \'confirm\' is off you can still activate confirmation for one","\\tcommand only (this is most useful in mappings) with the |:confirm|","\\tcommand.","\\tAlso see the |confirm()| function and the \'v\' flag in \'guioptions\'."],"copyindent":["boolean\\t(default off)","\\t\\t\\tlocal to buffer","\\tCopy the structure of the existing lines indent when autoindenting a","\\tnew line.  Normally the new indent is reconstructed by a series of","\\ttabs followed by spaces as required (unless |\'expandtab\'| is enabled,","\\tin which case only spaces are used).  Enabling this option makes the","\\tnew line copy whatever characters were used for indenting on the","\\texisting line.  \'expandtab\' has no effect on these characters, a Tab","\\tremains a Tab.  If the new indent is greater than on the existing","\\tline, the remaining space is filled in the normal manner.","\\tSee \'preserveindent\'."],"cpoptions":["string\\t(Vim default: \\"aABceFs_\\",","\\t\\t\\t\\t Vi default: all flags)","\\t\\t\\tglobal","\\tA sequence of single character flags.  When a character is present","\\tthis indicates Vi-compatible behavior.  This is used for things where","\\tnot being Vi-compatible is mostly or sometimes preferred.","\\t\'cpoptions\' stands for \\"compatible-options\\".","\\tCommas can be added for readability.","\\tTo avoid problems with flags that are added in the future, use the","\\t\\"+=\\" and \\"-=\\" feature of \\":set\\" |add-option-flags|."],"cscopepathcomp":["number\\t(default 0)","\\t\\t\\tglobal","\\tDetermines how many components of the path to show in a list of tags.","\\tSee |cscopepathcomp|."],"cscopeprg":["string\\t(default \\"cscope\\")","\\t\\t\\tglobal","\\tSpecifies the command to execute cscope.  See |cscopeprg|.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"cscopequickfix":["string\\t(default \\"\\")","\\t\\t\\tglobal","\\tSpecifies whether to use quickfix window to show cscope results.","\\tSee |cscopequickfix|."],"cscoperelative":["boolean (default off)","\\t\\t\\tglobal","\\tIn the absence of a prefix (-P) for cscope. setting this option enables","\\tto use the basename of cscope.out path as the prefix.","\\tSee |cscoperelative|."],"cscopetag":["boolean (default off)","\\t\\t\\tglobal","\\tUse cscope for tag commands.  See |cscope-options|."],"cscopetagorder":["number\\t(default 0)","\\t\\t\\tglobal","\\tDetermines the order in which \\":cstag\\" performs a search.  See","\\t|cscopetagorder|."],"cursorbind":["boolean  (default off)","\\t\\t\\tlocal to window","\\tWhen this option is set, as the cursor in the current","\\twindow moves other cursorbound windows (windows that also have","\\tthis option set) move their cursors to the corresponding line and","\\tcolumn.  This option is useful for viewing the","\\tdifferences between two versions of a file (see \'diff\'); in diff mode,","\\tinserted and deleted lines (though not characters within a line) are","\\ttaken into account."],"cursorcolumn":["boolean\\t(default off)","\\t\\t\\tlocal to window","\\tHighlight the screen column of the cursor with CursorColumn","\\t|hl-CursorColumn|.  Useful to align text.  Will make screen redrawing","\\tslower.","\\tIf you only want the highlighting in the current window you can use","\\tthese autocommands: >","\\t\\tau WinLeave * set nocursorline nocursorcolumn","\\t\\tau WinEnter * set cursorline cursorcolumn","<"],"cursorline":["boolean\\t(default off)","\\t\\t\\tlocal to window","\\tHighlight the screen line of the cursor with CursorLine","\\t|hl-CursorLine|.  Useful to easily spot the cursor.  Will make screen","\\tredrawing slower.","\\tWhen Visual mode is active the highlighting isn\'t used to make it","\\teasier to see the selected text."],"debug":["string\\t(default \\"\\")","\\t\\t\\tglobal","\\tThese values can be used:","\\tmsg\\tError messages that would otherwise be omitted will be given","\\t\\tanyway.","\\tthrow\\tError messages that would otherwise be omitted will be given","\\t\\tanyway and also throw an exception and set |v:errmsg|.","\\tbeep\\tA message will be given when otherwise only a beep would be","\\t\\tproduced.","\\tThe values can be combined, separated by a comma.","\\t\\"msg\\" and \\"throw\\" are useful for debugging \'foldexpr\', \'formatexpr\' or","\\t\'indentexpr\'."],"define":["string\\t(default \\"^\\\\s*#\\\\s*define\\")","\\t\\t\\tglobal or local to buffer |global-local|","\\tPattern to be used to find a macro definition.  It is a search","\\tpattern, just like for the \\"/\\" command.  This option is used for the","\\tcommands like \\"[i\\" and \\"[d\\" |include-search|.  The \'isident\' option is","\\tused to recognize the defined name after the match:","\\t\\t{match with \'define\'}{non-ID chars}{defined name}{non-ID char}","\\tSee |option-backslash| about inserting backslashes to include a space","\\tor backslash.","\\tThe default value is for C programs.  For C++ this value would be","\\tuseful, to include const type declarations: >","\\t\\t^\\\\(#\\\\s*define\\\\|[a-z]*\\\\s*const\\\\s*[a-z]*\\\\)","<\\tYou can also use \\"\\\\ze\\" just before the name and continue the pattern","\\tto check what is following.  E.g. for Javascript, if a function is","\\tdefined with \\"func_name = function(args)\\": >","\\t\\t^\\\\s*\\\\ze\\\\i\\\\+\\\\s*=\\\\s*function(","<\\tIf the function is defined with \\"func_name : function() {...\\": >","\\t        ^\\\\s*\\\\ze\\\\i\\\\+\\\\s*[:]\\\\s*(*function\\\\s*(","<\\tWhen using the \\":set\\" command, you need to double the backslashes!","\\tTo avoid that use `:let` with a single quote string: >","\\t\\tlet &l:define = \'^\\\\s*\\\\ze\\\\k\\\\+\\\\s*=\\\\s*function(\'","<"],"delcombine":["boolean (default off)","\\t\\t\\tglobal","\\tIf editing Unicode and this option is set, backspace and Normal mode","\\t\\"x\\" delete each combining character on its own.  When it is off (the","\\tdefault) the character along with its combining characters are","\\tdeleted.","\\tNote: When \'delcombine\' is set \\"xx\\" may work different from \\"2x\\"!"],"dictionary":["string\\t(default \\"\\")","\\t\\t\\tglobal or local to buffer |global-local|","\\tList of file names, separated by commas, that are used to lookup words","\\tfor keyword completion commands |i_CTRL-X_CTRL-K|.  Each file should","\\tcontain a list of words.  This can be one word per line, or several","\\twords per line, separated by non-keyword characters (white space is","\\tpreferred).  Maximum line length is 510 bytes."],"diff":["boolean\\t(default off)","\\t\\t\\tlocal to window","\\tJoin the current window in the group of windows that shows differences","\\tbetween files.  See |diff-mode|."],"diffexpr":["string\\t(default \\"\\")","\\t\\t\\tglobal","\\tExpression which is evaluated to obtain a diff file (either ed-style","\\tor unified-style) from two versions of a file.  See |diff-diffexpr|.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"diffopt":["string\\t(default \\"internal,filler,closeoff\\")","\\t\\t\\tglobal","\\tOption settings for diff mode.  It can consist of the following items.","\\tAll are optional.  Items must be separated by a comma."],"digraph":["boolean\\t(default off)","\\t\\t\\tglobal","\\tEnable the entering of digraphs in Insert mode with {char1} <BS>","\\t{char2}.  See |digraphs|."],"directory":["string\\t(default \\"$XDG_DATA_HOME/nvim/swap//\\")","\\t\\t\\tglobal","\\tList of directory names for the swap file, separated with commas.","\\t- The swap file will be created in the first directory where this is","\\t  possible.  If it is not possible in any directory, but last ","\\t  directory listed in the option does not exist, it is created.","\\t- Empty means that no swap file will be used (recovery is","\\t  impossible!) and no |E303| error will be given.","\\t- A directory \\".\\" means to put the swap file in the same directory as","\\t  the edited file.  On Unix, a dot is prepended to the file name, so","\\t  it doesn\'t show in a directory listing.  On MS-Windows the \\"hidden\\"","\\t  attribute is set and a dot prepended if possible.","\\t- A directory starting with \\"./\\" (or \\".\\\\\\" for Windows) means to","\\t  put the swap file relative to where the edited file is.  The leading","\\t  \\".\\" is replaced with the path name of the edited file.","\\t- For Unix and Win32, if a directory ends in two path separators \\"//\\",","\\t  the swap file name will be built from the complete path to the file","\\t  with all path separators substituted to percent \'%\' signs. This will","\\t  ensure file name uniqueness in the preserve directory.","\\t  On Win32, it is also possible to end with \\"\\\\\\\\\\".  However, When a","\\t  separating comma is following, you must use \\"//\\", since \\"\\\\\\\\\\" will","\\t  include the comma in the file name. Therefore it is recommended to","\\t  use \'//\', instead of \'\\\\\\\\\'.","\\t- Spaces after the comma are ignored, other spaces are considered part","\\t  of the directory name.  To have a space at the start of a directory","\\t  name, precede it with a backslash.","\\t- To include a comma in a directory name precede it with a backslash.","\\t- A directory name may end in an \':\' or \'/\'.","\\t- Environment variables are expanded |:set_env|.","\\t- Careful with \'\\\\\' characters, type one before a space, type two to","\\t  get one in the option (see |option-backslash|), for example: >","\\t    :set dir=c:\\\\\\\\tmp,\\\\ dir\\\\\\\\,with\\\\\\\\,commas,\\\\\\\\\\\\ dir\\\\ with\\\\ spaces","<\\t- For backwards compatibility with Vim version 3.0 a \'>\' at the start","\\t  of the option is removed.","\\tUsing \\".\\" first in the list is recommended.  This means that editing","\\tthe same file twice will result in a warning.  Using \\"/tmp\\" on Unix is","\\tdiscouraged: When the system crashes you lose the swap file.","\\t\\"/var/tmp\\" is often not cleared when rebooting, thus is a better","\\tchoice than \\"/tmp\\".  But it can contain a lot of files, your swap","\\tfiles get lost in the crowd.  That is why a \\"tmp\\" directory in your","\\thome directory is tried first.","\\tThe use of |:set+=| and |:set-=| is preferred when adding or removing","\\tdirectories from the list.  This avoids problems when a future version","\\tuses another default.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"display":["string\\t(default \\"lastline,msgsep\\", Vi default: \\"\\")","\\t\\t\\tglobal","\\tChange the way text is displayed.  This is comma separated list of","\\tflags:","\\tlastline\\tWhen included, as much as possible of the last line","\\t\\t\\tin a window will be displayed.  \\"@@@\\" is put in the","\\t\\t\\tlast columns of the last screen line to indicate the","\\t\\t\\trest of the line is not displayed.","\\ttruncate\\tLike \\"lastline\\", but \\"@@@\\" is displayed in the first","\\t\\t\\tcolumn of the last screen line.  Overrules \\"lastline\\".","\\tuhex\\t\\tShow unprintable characters hexadecimal as <xx>","\\t\\t\\tinstead of using ^C and ~C.","\\tmsgsep\\t\\tWhen showing messages longer than \'cmdheight\', only","\\t\\t\\tscroll the message lines, not the entire screen. The","\\t\\t\\tseparator line is decorated by |hl-MsgSeparator| and","\\t\\t\\tthe \\"msgsep\\" flag of \'fillchars\'."],"eadirection":["string\\t(default \\"both\\")","\\t\\t\\tglobal","\\tTells when the \'equalalways\' option applies:","\\t\\tver\\tvertically, width of windows is not affected","\\t\\thor\\thorizontally, height of windows is not affected","\\t\\tboth\\twidth and height of windows is affected"],"emoji":["boolean (default: on)","\\t\\t\\tglobal","\\tWhen on all Unicode emoji characters are considered to be full width."],"endofline":["boolean\\t(default on)","\\t\\t\\tlocal to buffer","\\tWhen writing a file and this option is off and the \'binary\' option","\\tis on, or \'fixeol\' option is off, no <EOL> will be written for the","\\tlast line in the file.  This option is automatically set or reset when","\\tstarting to edit a new file, depending on whether file has an <EOL>","\\tfor the last line in the file.  Normally you don\'t have to set or","\\treset this option.","\\tWhen \'binary\' is off and \'fixeol\' is on the value is not used when","\\twriting the file.  When \'binary\' is on or \'fixeol\' is off it is used","\\tto remember the presence of a <EOL> for the last line in the file, so","\\tthat when you write the file the situation from the original file can","\\tbe kept.  But you can change it if you want to."],"equalalways":["boolean\\t(default on)","\\t\\t\\tglobal","\\tWhen on, all the windows are automatically made the same size after","\\tsplitting or closing a window.  This also happens the moment the","\\toption is switched on.  When off, splitting a window will reduce the","\\tsize of the current window and leave the other windows the same.  When","\\tclosing a window the extra lines are given to the window next to it","\\t(depending on \'splitbelow\' and \'splitright\').","\\tWhen mixing vertically and horizontally split windows, a minimal size","\\tis computed and some windows may be larger if there is room.  The","\\t\'eadirection\' option tells in which direction the size is affected.","\\tChanging the height and width of a window can be avoided by setting","\\t\'winfixheight\' and \'winfixwidth\', respectively.","\\tIf a window size is specified when creating a new window sizes are","\\tcurrently not equalized (it\'s complicated, but may be implemented in","\\tthe future)."],"equalprg":["string\\t(default \\"\\")","\\t\\t\\tglobal or local to buffer |global-local|","\\tExternal program to use for \\"=\\" command.  When this option is empty","\\tthe internal formatting functions are used; either \'lisp\', \'cindent\'","\\tor \'indentexpr\'.  When Vim was compiled without internal formatting,","\\tthe \\"indent\\" program is used.","\\tEnvironment variables are expanded |:set_env|.  See |option-backslash|","\\tabout including spaces and backslashes.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"errorbells":["boolean\\t(default off)","\\t\\t\\tglobal","\\tRing the bell (beep or screen flash) for error messages.  This only","\\tmakes a difference for error messages, the bell will be used always","\\tfor a lot of errors without a message (e.g., hitting <Esc> in Normal","\\tmode).  See \'visualbell\' to make the bell behave like a screen flash","\\tor do nothing. See \'belloff\' to finetune when to ring the bell."],"errorfile":["string\\t(default: \\"errors.err\\")","\\t\\t\\tglobal","\\tName of the errorfile for the QuickFix mode (see |:cf|).","\\tWhen the \\"-q\\" command-line argument is used, \'errorfile\' is set to the","\\tfollowing argument.  See |-q|.","\\tNOT used for the \\":make\\" command.  See \'makeef\' for that.","\\tEnvironment variables are expanded |:set_env|.","\\tSee |option-backslash| about including spaces and backslashes.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"errorformat":["string\\t(default is very long)","\\t\\t\\tglobal or local to buffer |global-local|","\\tScanf-like description of the format for the lines in the error file","\\t(see |errorformat|)."],"eventignore":["string\\t(default \\"\\")","\\t\\t\\tglobal","\\tA list of autocommand event names, which are to be ignored.","\\tWhen set to \\"all\\" or when \\"all\\" is one of the items, all autocommand","\\tevents are ignored, autocommands will not be executed.","\\tOtherwise this is a comma separated list of event names.  Example: >","\\t    :set ei=WinEnter,WinLeave","<","\\t\\t\\t\\t *\'expandtab\'* *\'et\'* *\'noexpandtab\'* *\'noet\'*"],"expandtab":["boolean\\t(default off)","\\t\\t\\tlocal to buffer","\\tIn Insert mode: Use the appropriate number of spaces to insert a","\\t<Tab>.  Spaces are used in indents with the \'>\' and \'<\' commands and","\\twhen \'autoindent\' is on.  To insert a real tab when \'expandtab\' is","\\ton, use CTRL-V<Tab>.  See also |:retab| and |ins-expandtab|.","\\tThis option is reset when the \'paste\' option is set and restored when","\\tthe \'paste\' option is reset."],"fileencoding":["string (default: \\"\\")","\\t\\t\\tlocal to buffer","\\tFile-content encoding for the current buffer. Conversion is done with","\\ticonv() or as specified with \'charconvert\'."],"fileencodings":["string (default: \\"ucs-bom,utf-8,default,latin1\\")","\\t\\t\\tglobal","\\tThis is a list of character encodings considered when starting to edit","\\tan existing file.  When a file is read, Vim tries to use the first","\\tmentioned character encoding.  If an error is detected, the next one","\\tin the list is tried.  When an encoding is found that works,","\\t\'fileencoding\' is set to it.  If all fail, \'fileencoding\' is set to","\\tan empty string, which means that UTF-8 is used.","\\t\\tWARNING: Conversion can cause loss of information! You can use","\\t\\tthe |++bad| argument to specify what is done with characters","\\t\\tthat can\'t be converted.","\\tFor an empty file or a file with only ASCII characters most encodings","\\twill work and the first entry of \'fileencodings\' will be used (except","\\t\\"ucs-bom\\", which requires the BOM to be present).  If you prefer","\\tanother encoding use an BufReadPost autocommand event to test if your","\\tpreferred encoding is to be used.  Example: >","\\t\\tau BufReadPost * if search(\'\\\\S\', \'w\') == 0 |","\\t\\t\\t\\\\ set fenc=iso-2022-jp | endif","<\\tThis sets \'fileencoding\' to \\"iso-2022-jp\\" if the file does not contain","\\tnon-blank characters.","\\tWhen the |++enc| argument is used then the value of \'fileencodings\' is","\\tnot used.","\\tNote that \'fileencodings\' is not used for a new file, the global value","\\tof \'fileencoding\' is used instead.  You can set it with: >","\\t\\t:setglobal fenc=iso-8859-2","<\\tThis means that a non-existing file may get a different encoding than","\\tan empty file.","\\tThe special value \\"ucs-bom\\" can be used to check for a Unicode BOM","\\t(Byte Order Mark) at the start of the file.  It must not be preceded","\\tby \\"utf-8\\" or another Unicode encoding for this to work properly.","\\tAn entry for an 8-bit encoding (e.g., \\"latin1\\") should be the last,","\\tbecause Vim cannot detect an error, thus the encoding is always","\\taccepted.","\\tThe special value \\"default\\" can be used for the encoding from the","\\tenvironment.  It is useful when your environment uses a non-latin1","\\tencoding, such as Russian.","\\tWhen a file contains an illegal UTF-8 byte sequence it won\'t be","\\trecognized as \\"utf-8\\".  You can use the |8g8| command to find the","\\tillegal byte sequence.","\\tWRONG VALUES:\\t\\t\\tWHAT\'S WRONG:","\\t\\tlatin1,utf-8\\t\\t\\"latin1\\" will always be used","\\t\\tutf-8,ucs-bom,latin1\\tBOM won\'t be recognized in an utf-8","\\t\\t\\t\\t\\tfile","\\t\\tcp1250,latin1\\t\\t\\"cp1250\\" will always be used","\\tIf \'fileencodings\' is empty, \'fileencoding\' is not modified.","\\tSee \'fileencoding\' for the possible values.","\\tSetting this option does not have an effect until the next time a file","\\tis read."],"fileformat":["string (Windows default: \\"dos\\",","\\t\\t\\t\\tUnix default: \\"unix\\")","\\t\\t\\tlocal to buffer","\\tThis gives the <EOL> of the current buffer, which is used for","\\treading/writing the buffer from/to a file:","\\t    dos\\t    <CR> <NL>","\\t    unix    <NL>","\\t    mac\\t    <CR>","\\tWhen \\"dos\\" is used, CTRL-Z at the end of a file is ignored.","\\tSee |file-formats| and |file-read|.","\\tFor the character encoding of the file see \'fileencoding\'.","\\tWhen \'binary\' is set, the value of \'fileformat\' is ignored, file I/O","\\tworks like it was set to \\"unix\\".","\\tThis option is set automatically when starting to edit a file and","\\t\'fileformats\' is not empty and \'binary\' is off.","\\tWhen this option is set, after starting to edit a file, the \'modified\'","\\toption is set, because the file would be different when written.","\\tThis option cannot be changed when \'modifiable\' is off."],"fileformats":["string (default:","\\t\\t\\t\\tVim+Vi\\tWin32: \\"dos,unix\\",","\\t\\t\\t\\tVim\\tUnix: \\"unix,dos\\",","\\t\\t\\t\\tVi\\tothers: \\"\\")","\\t\\t\\tglobal","\\tThis gives the end-of-line (<EOL>) formats that will be tried when","\\tstarting to edit a new buffer and when reading a file into an existing","\\tbuffer:","\\t- When empty, the format defined with \'fileformat\' will be used","\\t  always.  It is not set automatically.","\\t- When set to one name, that format will be used whenever a new buffer","\\t  is opened.  \'fileformat\' is set accordingly for that buffer.  The","\\t  \'fileformats\' name will be used when a file is read into an existing","\\t  buffer, no matter what \'fileformat\' for that buffer is set to.","\\t- When more than one name is present, separated by commas, automatic","\\t  <EOL> detection will be done when reading a file.  When starting to","\\t  edit a file, a check is done for the <EOL>:","\\t  1. If all lines end in <CR><NL>, and \'fileformats\' includes \\"dos\\",","\\t     \'fileformat\' is set to \\"dos\\".","\\t  2. If a <NL> is found and \'fileformats\' includes \\"unix\\", \'fileformat\'","\\t     is set to \\"unix\\".  Note that when a <NL> is found without a","\\t     preceding <CR>, \\"unix\\" is preferred over \\"dos\\".","\\t  3. If \'fileformat\' has not yet been set, and if a <CR> is found, and","\\t     if \'fileformats\' includes \\"mac\\", \'fileformat\' is set to \\"mac\\".","\\t     This means that \\"mac\\" is only chosen when:","\\t      \\"unix\\" is not present or no <NL> is found in the file, and","\\t      \\"dos\\" is not present or no <CR><NL> is found in the file.","\\t     Except: if \\"unix\\" was chosen, but there is a <CR> before","\\t     the first <NL>, and there appear to be more <CR>s than <NL>s in","\\t     the first few lines, \\"mac\\" is used.","\\t  4. If \'fileformat\' is still not set, the first name from","\\t     \'fileformats\' is used.","\\t  When reading a file into an existing buffer, the same is done, but","\\t  this happens like \'fileformat\' has been set appropriately for that","\\t  file only, the option is not changed.","\\tWhen \'binary\' is set, the value of \'fileformats\' is not used."],"fileignorecase":["boolean\\t(default on for systems where case in file","\\t\\t\\t\\t names is normally ignored)","\\t\\t\\tglobal","\\tWhen set case is ignored when using file names and directories.","\\tSee \'wildignorecase\' for only ignoring case when doing completion."],"filetype":["string (default: \\"\\")","\\t\\t\\tlocal to buffer","\\tWhen this option is set, the FileType autocommand event is triggered.","\\tAll autocommands that match with the value of this option will be","\\texecuted.  Thus the value of \'filetype\' is used in place of the file","\\tname.","\\tOtherwise this option does not always reflect the current file type.","\\tThis option is normally set when the file type is detected.  To enable","\\tthis use the \\":filetype on\\" command. |:filetype|","\\tSetting this option to a different value is most useful in a modeline,","\\tfor a file for which the file type is not automatically recognized.","\\tExample, for in an IDL file:","\\t\\t/* vim: set filetype=idl : */ ~","\\t|FileType| |filetypes|","\\tWhen a dot appears in the value then this separates two filetype","\\tnames.  Example:","\\t\\t/* vim: set filetype=c.doxygen : */ ~","\\tThis will use the \\"c\\" filetype first, then the \\"doxygen\\" filetype.","\\tThis works both for filetype plugins and for syntax files.  More than","\\tone dot may appear.","\\tThis option is not copied to another buffer, independent of the \'s\' or","\\t\'S\' flag in \'cpoptions\'.","\\tOnly normal file name characters can be used, \\"/\\\\*?[|<>\\" are illegal."],"fillchars":["string\\t(default \\"\\")","\\t\\t\\tglobal or local to window |global-local|","\\tCharacters to fill the statuslines and vertical separators.","\\tIt is a comma separated list of items:"],"fixendofline":["boolean\\t(default on)","\\t\\t\\tlocal to buffer","\\tWhen writing a file and this option is on, <EOL> at the end of file","\\twill be restored if missing. Turn this option off if you want to","\\tpreserve the situation from the original file.","\\tWhen the \'binary\' option is set the value of this option doesn\'t","\\tmatter.","\\tSee the \'endofline\' option."],"foldclose":["string (default \\"\\")","\\t\\t\\tglobal","\\tWhen set to \\"all\\", a fold is closed when the cursor isn\'t in it and","\\tits level is higher than \'foldlevel\'.  Useful if you want folds to","\\tautomatically close when moving out of them."],"foldcolumn":["string (default \\"0\\")","\\t\\t\\tlocal to window","\\tWhen and how to draw the foldcolumn. Valid values are:","\\t    \\"auto\\":       resize to the maximum amount of folds to display.","\\t    \\"auto:[1-9]\\": resize to accommodate multiple folds up to the","\\t\\t\\t  selected level","            0:            to disable foldcolumn","\\t    \\"[1-9]\\":      to display a fixed number of columns","\\tSee |folding|."],"foldenable":["boolean (default on)","\\t\\t\\tlocal to window","\\tWhen off, all folds are open.  This option can be used to quickly","\\tswitch between showing all text unfolded and viewing the text with","\\tfolds (including manually opened or closed folds).  It can be toggled","\\twith the |zi| command.  The \'foldcolumn\' will remain blank when","\\t\'foldenable\' is off.","\\tThis option is set by commands that create a new fold or close a fold.","\\tSee |folding|."],"foldexpr":["string (default: \\"0\\")","\\t\\t\\tlocal to window","\\tThe expression used for when \'foldmethod\' is \\"expr\\".  It is evaluated","\\tfor each line to obtain its fold level.  See |fold-expr|."],"foldignore":["string (default: \\"#\\")","\\t\\t\\tlocal to window","\\tUsed only when \'foldmethod\' is \\"indent\\".  Lines starting with","\\tcharacters in \'foldignore\' will get their fold level from surrounding","\\tlines.  White space is skipped before checking for this character.","\\tThe default \\"#\\" works well for C programs.  See |fold-indent|."],"foldlevel":["number (default: 0)","\\t\\t\\tlocal to window","\\tSets the fold level: Folds with a higher level will be closed.","\\tSetting this option to zero will close all folds.  Higher numbers will","\\tclose fewer folds.","\\tThis option is set by commands like |zm|, |zM| and |zR|.","\\tSee |fold-foldlevel|."],"foldlevelstart":["number (default: -1)","\\t\\t\\tglobal","\\tSets \'foldlevel\' when starting to edit another buffer in a window.","\\tUseful to always start editing with all folds closed (value zero),","\\tsome folds closed (one) or no folds closed (99).","\\tThis is done before reading any modeline, thus a setting in a modeline","\\toverrules this option.  Starting to edit a file for |diff-mode| also","\\tignores this option and closes all folds.","\\tIt is also done before BufReadPre autocommands, to allow an autocmd to","\\toverrule the \'foldlevel\' value for specific files.","\\tWhen the value is negative, it is not used."],"foldmarker":["string (default: \\"{{{,}}}\\")","\\t\\t\\tlocal to window","\\tThe start and end marker used when \'foldmethod\' is \\"marker\\".  There","\\tmust be one comma, which separates the start and end marker.  The","\\tmarker is a literal string (a regular expression would be too slow).","\\tSee |fold-marker|."],"foldmethod":["string (default: \\"manual\\")","\\t\\t\\tlocal to window","\\tThe kind of folding used for the current window.  Possible values:","\\t|fold-manual|\\tmanual\\t    Folds are created manually.","\\t|fold-indent|\\tindent\\t    Lines with equal indent form a fold.","\\t|fold-expr|\\texpr\\t    \'foldexpr\' gives the fold level of a line.","\\t|fold-marker|\\tmarker\\t    Markers are used to specify folds.","\\t|fold-syntax|\\tsyntax\\t    Syntax highlighting items specify folds.","\\t|fold-diff|\\tdiff\\t    Fold text that is not changed."],"foldminlines":["number (default: 1)","\\t\\t\\tlocal to window","\\tSets the number of screen lines above which a fold can be displayed","\\tclosed.  Also for manually closed folds.  With the default value of","\\tone a fold can only be closed if it takes up two or more screen lines.","\\tSet to zero to be able to close folds of just one screen line.","\\tNote that this only has an effect on what is displayed.  After using","\\t\\"zc\\" to close a fold, which is displayed open because it\'s smaller","\\tthan \'foldminlines\', a following \\"zc\\" may close a containing fold."],"foldnestmax":["number (default: 20)","\\t\\t\\tlocal to window","\\tSets the maximum nesting of folds for the \\"indent\\" and \\"syntax\\"","\\tmethods.  This avoids that too many folds will be created.  Using more","\\tthan 20 doesn\'t work, because the internal limit is 20."],"foldopen":["string (default: \\"block,hor,mark,percent,quickfix,","\\t\\t\\t\\t\\t\\t\\t     search,tag,undo\\")","\\t\\t\\tglobal","\\tSpecifies for which type of commands folds will be opened, if the","\\tcommand moves the cursor into a closed fold.  It is a comma separated","\\tlist of items.","\\tNOTE: When the command is part of a mapping this option is not used.","\\tAdd the |zv| command to the mapping to get the same effect.","\\t(rationale: the mapping may want to control opening folds itself)"],"foldtext":["string (default: \\"foldtext()\\")","\\t\\t\\tlocal to window","\\tAn expression which is used to specify the text displayed for a closed","\\tfold.  See |fold-foldtext|."],"formatexpr":["string (default \\"\\")","\\t\\t\\tlocal to buffer","\\tExpression which is evaluated to format a range of lines for the |gq|","\\toperator or automatic formatting (see \'formatoptions\').  When this","\\toption is empty \'formatprg\' is used."],"formatlistpat":["string (default: \\"^\\\\s*\\\\d\\\\+[\\\\]:.)}\\\\t ]\\\\s*\\")","\\t\\t\\tlocal to buffer","\\tA pattern that is used to recognize a list header.  This is used for","\\tthe \\"n\\" flag in \'formatoptions\'.","\\tThe pattern must match exactly the text that will be the indent for","\\tthe line below it.  You can use |/\\\\ze| to mark the end of the match","\\twhile still checking more characters.  There must be a character","\\tfollowing the pattern, when it matches the whole line it is handled","\\tlike there is no match.","\\tThe default recognizes a number, followed by an optional punctuation","\\tcharacter and white space."],"formatoptions":["string (default: \\"tcqj\\", Vi default: \\"vt\\")","\\t\\t\\tlocal to buffer","\\tThis is a sequence of letters which describes how automatic","\\tformatting is to be done.  See |fo-table|.  When the \'paste\' option is","\\ton, no formatting is done (like \'formatoptions\' is empty).  Commas can","\\tbe inserted for readability.","\\tTo avoid problems with flags that are added in the future, use the","\\t\\"+=\\" and \\"-=\\" feature of \\":set\\" |add-option-flags|."],"formatprg":["string (default \\"\\")","\\t\\t\\tglobal or local to buffer |global-local|","\\tThe name of an external program that will be used to format the lines","\\tselected with the |gq| operator.  The program must take the input on","\\tstdin and produce the output on stdout.  The Unix program \\"fmt\\" is","\\tsuch a program.","\\tIf the \'formatexpr\' option is not empty it will be used instead.","\\tOtherwise, if \'formatprg\' option is an empty string, the internal","\\tformat function will be used |C-indenting|.","\\tEnvironment variables are expanded |:set_env|.  See |option-backslash|","\\tabout including spaces and backslashes.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"fsync":["boolean\\t(default off)","\\t\\t\\tglobal","\\tWhen on, the OS function fsync() will be called after saving a file","\\t(|:write|, |writefile()|, …), |swap-file| and |shada-file|. This","\\tflushes the file to disk, ensuring that it is safely written.","\\tSlow on some systems: writing buffers, quitting Nvim, and other","\\toperations may sometimes take a few seconds."],"gdefault":["boolean\\t(default off)","\\t\\t\\tglobal","\\tWhen on, the \\":substitute\\" flag \'g\' is default on.  This means that","\\tall matches in a line are substituted instead of one.  When a \'g\' flag","\\tis given to a \\":substitute\\" command, this will toggle the substitution","\\tof all or one match.  See |complex-change|."],"grepformat":["string\\t(default \\"%f:%l:%m,%f:%l%m,%f  %l%m\\")","\\t\\t\\tglobal","\\tFormat to recognize for the \\":grep\\" command output.","\\tThis is a scanf-like string that uses the same format as the","\\t\'errorformat\' option: see |errorformat|."],"grepprg":["string\\t(default \\"grep -n \\",","\\t\\t\\t\\t Unix: \\"grep -n $* /dev/null\\")","\\t\\t\\tglobal or local to buffer |global-local|","\\tProgram to use for the |:grep| command.  This option may contain \'%\'","\\tand \'#\' characters, which are expanded like when used in a command-","\\tline.  The placeholder \\"$*\\" is allowed to specify where the arguments","\\twill be included.  Environment variables are expanded |:set_env|.  See","\\t|option-backslash| about including spaces and backslashes.","\\tWhen your \\"grep\\" accepts the \\"-H\\" argument, use this to make \\":grep\\"","\\talso work well with a single file: >","\\t\\t:set grepprg=grep\\\\ -nH","<\\tSpecial value: When \'grepprg\' is set to \\"internal\\" the |:grep| command","\\tworks like |:vimgrep|, |:lgrep| like |:lvimgrep|, |:grepadd| like","\\t|:vimgrepadd| and |:lgrepadd| like |:lvimgrepadd|.","\\tSee also the section |:make_makeprg|, since most of the comments there","\\tapply equally to \'grepprg\'.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"guicursor":["string\\t(default \\"n-v-c-sm:block,i-ci-ve:ver25,r-cr-o:hor20\\")","\\t\\t\\tglobal","\\tConfigures the cursor style for each mode. Works in the GUI and many","\\tterminals.  See |tui-cursor-shape|."],"guifont":["string\\t(default \\"\\")","\\t\\t\\tglobal","\\tThis is a list of fonts which will be used for the GUI version of Vim.","\\tIn its simplest form the value is just one font name.  When","\\tthe font cannot be found you will get an error message.  To try other","\\tfont names a list can be specified, font names separated with commas.","\\tThe first valid font is used."],"guifontset":["string\\t(default \\"\\")","\\t\\t\\tglobal","\\tWhen not empty, specifies two (or more) fonts to be used.  The first","\\tone for normal English, the second one for your special language.  See","\\t|xfontset|.","\\tSetting this option also means that all font names will be handled as","\\ta fontset name.  Also the ones used for the \\"font\\" argument of the","\\t|:highlight| command.","\\tThe fonts must match with the current locale.  If fonts for the","\\tcharacter sets that the current locale uses are not included, setting","\\t\'guifontset\' will fail.","\\tNote the difference between \'guifont\' and \'guifontset\': In \'guifont\'","\\tthe comma-separated names are alternative names, one of which will be","\\tused.  In \'guifontset\' the whole string is one fontset name,","\\tincluding the commas.  It is not possible to specify alternative","\\tfontset names.","\\tThis example works on many X11 systems: >","\\t\\t:set guifontset=-*-*-medium-r-normal--16-*-*-*-c-*-*-*","<","\\t\\t\\t\\t*\'guifontwide\'* *\'gfw\'* *E231* *E533* *E534*"],"guifontwide":["string\\t(default \\"\\")","\\t\\t\\tglobal","\\tWhen not empty, specifies a comma-separated list of fonts to be used","\\tfor double-width characters.  The first font that can be loaded is","\\tused.","\\tNote: The size of these fonts must be exactly twice as wide as the one","\\tspecified with \'guifont\' and the same height."],"guioptions":["string\\t(default \\"egmrLT\\"   (MS-Windows))","\\t\\t\\tglobal","\\tThis option only has an effect in the GUI version of Vim.  It is a","\\tsequence of letters which describes what components and options of the","\\tGUI should be used.","\\tTo avoid problems with flags that are added in the future, use the","\\t\\"+=\\" and \\"-=\\" feature of \\":set\\" |add-option-flags|."],"guitablabel":["string\\t(default empty)","\\t\\t\\tglobal","\\tWhen nonempty describes the text to use in a label of the GUI tab","\\tpages line.  When empty and when the result is empty Vim will use a","\\tdefault label.  See |setting-guitablabel| for more info."],"guitabtooltip":["string\\t(default empty)","\\t\\t\\tglobal","\\tWhen nonempty describes the text to use in a tooltip for the GUI tab","\\tpages line.  When empty Vim will use a default tooltip.","\\tThis option is otherwise just like \'guitablabel\' above.","\\tYou can include a line break.  Simplest method is to use |:let|: >","\\t\\t:let &guitabtooltip = \\"line one\\\\nline two\\"","<"],"helpfile":["string\\t(default (MSDOS)  \\"$VIMRUNTIME\\\\doc\\\\help.txt\\"","\\t\\t\\t\\t\\t (others) \\"$VIMRUNTIME/doc/help.txt\\")","\\t\\t\\tglobal","\\tName of the main help file.  All distributed help files should be","\\tplaced together in one directory.  Additionally, all \\"doc\\" directories","\\tin \'runtimepath\' will be used.","\\tEnvironment variables are expanded |:set_env|.  For example:","\\t\\"$VIMRUNTIME/doc/help.txt\\".  If $VIMRUNTIME is not set, $VIM is also","\\ttried.  Also see |$VIMRUNTIME| and |option-backslash| about including","\\tspaces and backslashes.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"helpheight":["number\\t(default 20)","\\t\\t\\tglobal","\\tMinimal initial height of the help window when it is opened with the","\\t\\":help\\" command.  The initial height of the help window is half of the","\\tcurrent window, or (when the \'ea\' option is on) the same as other","\\twindows.  When the height is less than \'helpheight\', the height is","\\tset to \'helpheight\'.  Set to zero to disable."],"helplang":["string\\t(default: messages language or empty)","\\t\\t\\tglobal","\\tComma separated list of languages.  Vim will use the first language","\\tfor which the desired help can be found.  The English help will always","\\tbe used as a last resort.  You can add \\"en\\" to prefer English over","\\tanother language, but that will only find tags that exist in that","\\tlanguage and not in the English help.","\\tExample: >","\\t\\t:set helplang=de,it","<\\tThis will first search German, then Italian and finally English help","\\tfiles.","\\tWhen using |CTRL-]| and \\":help!\\" in a non-English help file Vim will","\\ttry to find the tag in the current language before using this option.","\\tSee |help-translated|."],"hidden":["boolean\\t(default off)","\\t\\t\\tglobal","\\tWhen off a buffer is unloaded when it is |abandon|ed.  When on a","\\tbuffer becomes hidden when it is |abandon|ed.  If the buffer is still","\\tdisplayed in another window, it does not become hidden, of course.","\\tThe commands that move through the buffer list sometimes make a buffer","\\thidden although the \'hidden\' option is off: When the buffer is","\\tmodified, \'autowrite\' is off or writing is not possible, and the \'!\'","\\tflag was used.  See also |windows.txt|.","\\tTo only make one buffer hidden use the \'bufhidden\' option.","\\tThis option is set for one command with \\":hide {command}\\" |:hide|.","\\tWARNING: It\'s easy to forget that you have changes in hidden buffers.","\\tThink twice when using \\":q!\\" or \\":qa!\\"."],"history":["number\\t(Vim default: 10000, Vi default: 0)","\\t\\t\\tglobal","\\tA history of \\":\\" commands, and a history of previous search patterns","\\tis remembered.  This option decides how many entries may be stored in","\\teach of these histories (see |cmdline-editing|).","\\tThe maximum value is 10000."],"hkmap":["boolean (default off)","\\t\\t\\tglobal","\\tWhen on, the keyboard is mapped for the Hebrew character set.","\\tNormally you would set \'allowrevins\' and use CTRL-_ in insert mode to","\\ttoggle this option.  See |rileft.txt|."],"hkmapp":["boolean (default off)","\\t\\t\\tglobal","\\tWhen on, phonetic keyboard mapping is used.  \'hkmap\' must also be on.","\\tThis is useful if you have a non-Hebrew keyboard.","\\tSee |rileft.txt|."],"hlsearch":["boolean\\t(default on)","\\t\\t\\tglobal","\\tWhen there is a previous search pattern, highlight all its matches.","\\tThe |hl-Search| highlight group determines the highlighting. Note that","\\tonly the matching text is highlighted, any offsets are not applied.","\\tSee also: \'incsearch\' and |:match|.","\\tWhen you get bored looking at the highlighted matches, you can turn it","\\toff with |:nohlsearch|.  This does not change the option value, as","\\tsoon as you use a search command, the highlighting comes back.","\\t\'redrawtime\' specifies the maximum time spent on finding matches.","\\tWhen the search pattern can match an end-of-line, Vim will try to","\\thighlight all of the matched text.  However, this depends on where the","\\tsearch starts.  This will be the first line in the window or the first","\\tline below a closed fold.  A match in a previous line which is not","\\tdrawn may not continue in a newly drawn line.","\\tYou can specify whether the highlight status is restored on startup","\\twith the \'h\' flag in \'shada\' |shada-h|."],"icon":["boolean\\t(default off, on when title can be restored)","\\t\\t\\tglobal","\\tWhen on, the icon text of the window will be set to the value of","\\t\'iconstring\' (if it is not empty), or to the name of the file","\\tcurrently being edited.  Only the last part of the name is used.","\\tOverridden by the \'iconstring\' option.","\\tOnly works if the terminal supports setting window icons."],"iconstring":["string\\t(default \\"\\")","\\t\\t\\tglobal","\\tWhen this option is not empty, it will be used for the icon text of","\\tthe window.  This happens only when the \'icon\' option is on.","\\tOnly works if the terminal supports setting window icon text","\\tWhen this option contains printf-style \'%\' items, they will be","\\texpanded according to the rules used for \'statusline\'.  See","\\t\'titlestring\' for example settings.","\\tThis option cannot be set in a modeline when \'modelineexpr\' is off."],"ignorecase":["boolean\\t(default off)","\\t\\t\\tglobal","\\tIgnore case in search patterns.  Also used when searching in the tags","\\tfile.","\\tAlso see \'smartcase\' and \'tagcase\'.","\\tCan be overruled by using \\"\\\\c\\" or \\"\\\\C\\" in the pattern, see","\\t|/ignorecase|."],"imcmdline":["boolean (default off)","\\t\\t\\tglobal","\\tWhen set the Input Method is always on when starting to edit a command","\\tline, unless entering a search pattern (see \'imsearch\' for that).","\\tSetting this option is useful when your input method allows entering","\\tEnglish characters directly, e.g., when it\'s used to type accented","\\tcharacters with dead keys."],"imdisable":["boolean (default off, on for some systems (SGI))","\\t\\t\\tglobal","\\tWhen set the Input Method is never used.  This is useful to disable","\\tthe IM when it doesn\'t work properly.","\\tCurrently this option is on by default for SGI/IRIX machines.  This","\\tmay change in later releases."],"iminsert":["number (default 0)","\\t\\t\\tlocal to buffer","\\tSpecifies whether :lmap or an Input Method (IM) is to be used in","\\tInsert mode.  Valid values:","\\t\\t0\\t:lmap is off and IM is off","\\t\\t1\\t:lmap is ON and IM is off","\\t\\t2\\t:lmap is off and IM is ON","\\tTo always reset the option to zero when leaving Insert mode with <Esc>","\\tthis can be used: >","\\t\\t:inoremap <ESC> <ESC>:set iminsert=0<CR>","<\\tThis makes :lmap and IM turn off automatically when leaving Insert","\\tmode.","\\tNote that this option changes when using CTRL-^ in Insert mode","\\t|i_CTRL-^|.","\\tThe value is set to 1 when setting \'keymap\' to a valid keymap name.","\\tIt is also used for the argument of commands like \\"r\\" and \\"f\\"."],"imsearch":["number (default -1)","\\t\\t\\tlocal to buffer","\\tSpecifies whether :lmap or an Input Method (IM) is to be used when","\\tentering a search pattern.  Valid values:","\\t\\t-1\\tthe value of \'iminsert\' is used, makes it look like","\\t\\t\\t\'iminsert\' is also used when typing a search pattern","\\t\\t0\\t:lmap is off and IM is off","\\t\\t1\\t:lmap is ON and IM is off","\\t\\t2\\t:lmap is off and IM is ON","\\tNote that this option changes when using CTRL-^ in Command-line mode","\\t|c_CTRL-^|.","\\tThe value is set to 1 when it is not -1 and setting the \'keymap\'","\\toption to a valid keymap name."],"inccommand":["string\\t(default \\"\\")","\\t\\t\\tglobal"],"include":["string\\t(default \\"^\\\\s*#\\\\s*include\\")","\\t\\t\\tglobal or local to buffer |global-local|","\\tPattern to be used to find an include command.  It is a search","\\tpattern, just like for the \\"/\\" command (See |pattern|).  The default","\\tvalue is for C programs.  This option is used for the commands \\"[i\\",","\\t\\"]I\\", \\"[d\\", etc.","\\tNormally the \'isfname\' option is used to recognize the file name that","\\tcomes after the matched pattern.  But if \\"\\\\zs\\" appears in the pattern","\\tthen the text matched from \\"\\\\zs\\" to the end, or until \\"\\\\ze\\" if it","\\tappears, is used as the file name.  Use this to include characters","\\tthat are not in \'isfname\', such as a space.  You can then use","\\t\'includeexpr\' to process the matched text.","\\tSee |option-backslash| about including spaces and backslashes."],"includeexpr":["string\\t(default \\"\\")","\\t\\t\\tlocal to buffer","\\tExpression to be used to transform the string found with the \'include\'","\\toption to a file name.  Mostly useful to change \\".\\" to \\"/\\" for Java: >","\\t\\t:set includeexpr=substitute(v:fname,\'\\\\\\\\.\',\'/\',\'g\')","<\\tThe \\"v:fname\\" variable will be set to the file name that was detected."],"incsearch":["boolean\\t(default on)","\\t\\t\\tglobal","\\tWhile typing a search command, show where the pattern, as it was typed","\\tso far, matches.  The matched string is highlighted.  If the pattern","\\tis invalid or not found, nothing is shown.  The screen will be updated","\\toften, this is only useful on fast terminals.","\\tNote that the match will be shown, but the cursor will return to its","\\toriginal position when no match is found and when pressing <Esc>.  You","\\tstill need to finish the search command with <Enter> to move the","\\tcursor to the match.","\\tYou can use the CTRL-G and CTRL-T keys to move to the next and","\\tprevious match. |c_CTRL-G| |c_CTRL-T|","\\tVim only searches for about half a second.  With a complicated","\\tpattern and/or a lot of text the match may not be found.  This is to","\\tavoid that Vim hangs while you are typing the pattern.","\\tThe |hl-IncSearch| highlight group determines the highlighting.","\\tWhen \'hlsearch\' is on, all matched strings are highlighted too while","\\ttyping a search command. See also: \'hlsearch\'.","\\tIf you don\'t want to turn \'hlsearch\' on, but want to highlight all","\\tmatches while searching, you can turn on and off \'hlsearch\' with","\\tautocmd.  Example: >","\\t\\taugroup vimrc-incsearch-highlight","\\t\\t  autocmd!","\\t\\t  autocmd CmdlineEnter /,\\\\? :set hlsearch","\\t\\t  autocmd CmdlineLeave /,\\\\? :set nohlsearch","\\t\\taugroup END","<","\\tCTRL-L can be used to add one character from after the current match","\\tto the command line.  If \'ignorecase\' and \'smartcase\' are set and the","\\tcommand line has no uppercase characters, the added character is","\\tconverted to lowercase.","\\tCTRL-R CTRL-W can be used to add the word at the end of the current","\\tmatch, excluding the characters that were already typed."],"indentexpr":["string\\t(default \\"\\")","\\t\\t\\tlocal to buffer","\\tExpression which is evaluated to obtain the proper indent for a line.","\\tIt is used when a new line is created, for the |=| operator and","\\tin Insert mode as specified with the \'indentkeys\' option.","\\tWhen this option is not empty, it overrules the \'cindent\' and","\\t\'smartindent\' indenting.  When \'lisp\' is set, this option is","\\toverridden by the Lisp indentation algorithm.","\\tWhen \'paste\' is set this option is not used for indenting.","\\tThe expression is evaluated with |v:lnum| set to the line number for","\\twhich the indent is to be computed.  The cursor is also in this line","\\twhen the expression is evaluated (but it may be moved around).","\\tThe expression must return the number of spaces worth of indent.  It","\\tcan return \\"-1\\" to keep the current indent (this means \'autoindent\' is","\\tused for the indent).","\\tFunctions useful for computing the indent are |indent()|, |cindent()|","\\tand |lispindent()|.","\\tThe evaluation of the expression must not have side effects!  It must","\\tnot change the text, jump to another window, etc.  Afterwards the","\\tcursor position is always restored, thus the cursor may be moved.","\\tNormally this option would be set to call a function: >","\\t\\t:set indentexpr=GetMyIndent()","<\\tError messages will be suppressed, unless the \'debug\' option contains","\\t\\"msg\\".","\\tSee |indent-expression|."],"indentkeys":["string\\t(default \\"0{,0},0),0],:,0#,!^F,o,O,e\\")","\\t\\t\\tlocal to buffer","\\tA list of keys that, when typed in Insert mode, cause reindenting of","\\tthe current line.  Only happens if \'indentexpr\' isn\'t empty.","\\tThe format is identical to \'cinkeys\', see |indentkeys-format|.","\\tSee |C-indenting| and |indent-expression|."],"infercase":["boolean\\t(default off)","\\t\\t\\tlocal to buffer","\\tWhen doing keyword completion in insert mode |ins-completion|, and","\\t\'ignorecase\' is also on, the case of the match is adjusted depending","\\ton the typed text.  If the typed text contains a lowercase letter","\\twhere the match has an upper case letter, the completed part is made","\\tlowercase.  If the typed text has no lowercase letters and the match","\\thas a lowercase letter where the typed text has an uppercase letter,","\\tand there is a letter before it, the completed part is made uppercase.","\\tWith \'noinfercase\' the match is used as-is."],"insertmode":["boolean\\t(default off)","\\t\\t\\tglobal","\\tMakes Vim work in a way that Insert mode is the default mode.  Useful","\\tif you want to use Vim as a modeless editor.","\\tThese Insert mode commands will be useful:","\\t- Use the cursor keys to move around.","\\t- Use CTRL-O to execute one Normal mode command |i_CTRL-O|.  When","\\t  this is a mapping, it is executed as if \'insertmode\' was off.","\\t  Normal mode remains active until the mapping is finished.","\\t- Use CTRL-L to execute a number of Normal mode commands, then use","\\t  <Esc> to get back to Insert mode.  Note that CTRL-L moves the cursor","\\t  left, like <Esc> does when \'insertmode\' isn\'t set.  |i_CTRL-L|"],"isfname":["string\\t(default for Windows:","\\t\\t\\t     \\"@,48-57,/,\\\\,.,-,_,+,,,#,$,%,{,},[,],:,@-@,!,~,=\\"","\\t\\t\\t    otherwise: \\"@,48-57,/,.,-,_,+,,,#,$,%,~,=\\")","\\t\\t\\tglobal","\\tThe characters specified by this option are included in file names and","\\tpath names.  Filenames are used for commands like \\"gf\\", \\"[i\\" and in","\\tthe tags file.  It is also used for \\"\\\\f\\" in a |pattern|.","\\tMulti-byte characters 256 and above are always included, only the","\\tcharacters up to 255 are specified with this option.","\\tFor UTF-8 the characters 0xa0 to 0xff are included as well.","\\tThink twice before adding white space to this option.  Although a","\\tspace may appear inside a file name, the effect will be that Vim","\\tdoesn\'t know where a file name starts or ends when doing completion.","\\tIt most likely works better without a space in \'isfname\'."],"isident":["string\\t(default for Windows:","\\t\\t\\t\\t\\t   \\"@,48-57,_,128-167,224-235\\"","\\t\\t\\t\\totherwise: \\"@,48-57,_,192-255\\")","\\t\\t\\tglobal","\\tThe characters given by this option are included in identifiers.","\\tIdentifiers are used in recognizing environment variables and after a","\\tmatch of the \'define\' option.  It is also used for \\"\\\\i\\" in a","\\t|pattern|.  See \'isfname\' for a description of the format of this","\\toption.  For \'@\' only characters up to 255 are used.","\\tCareful: If you change this option, it might break expanding","\\tenvironment variables.  E.g., when \'/\' is included and Vim tries to","\\texpand \\"$HOME/.local/share/nvim/shada/main.shada\\".  Maybe you should ","\\tchange \'iskeyword\' instead."],"iskeyword":["string (default: @,48-57,_,192-255","\\t\\t\\t\\tVi default: @,48-57,_)","\\t\\t\\tlocal to buffer","\\tKeywords are used in searching and recognizing with many commands:","\\t\\"w\\", \\"*\\", \\"[i\\", etc.  It is also used for \\"\\\\k\\" in a |pattern|.  See","\\t\'isfname\' for a description of the format of this option.  For \'@\'","\\tcharacters above 255 check the \\"word\\" character class.","\\tFor C programs you could use \\"a-z,A-Z,48-57,_,.,-,>\\".","\\tFor a help file it is set to all non-blank printable characters except","\\t\'*\', \'\\"\' and \'|\' (so that CTRL-] on a command finds the help for that","\\tcommand).","\\tWhen the \'lisp\' option is on the \'-\' character is always included.","\\tThis option also influences syntax highlighting, unless the syntax","\\tuses |:syn-iskeyword|."],"isprint":["string\\t(default: \\"@,161-255\\")","\\t\\t\\tglobal","\\tThe characters given by this option are displayed directly on the","\\tscreen.  It is also used for \\"\\\\p\\" in a |pattern|.  The characters from","\\tspace (ASCII 32) to \'~\' (ASCII 126) are always displayed directly,","\\teven when they are not included in \'isprint\' or excluded.  See","\\t\'isfname\' for a description of the format of this option."],"jumpoptions":["string\\t(default \\"\\")","\\t\\t\\tglobal","\\tList of words that change the behavior of the |jumplist|.","\\t  stack         Make the jumplist behave like the tagstack or like a","\\t                web browser.  Relative location of entries in the","\\t\\t\\tjumplist is preserved at the cost of discarding","\\t\\t\\tsubsequent entries when navigating backwards in the","\\t\\t\\tjumplist and then jumping to a location.","\\t\\t\\t|jumplist-stack|"],"joinspaces":["boolean\\t(default on)","\\t\\t\\tglobal","\\tInsert two spaces after a \'.\', \'?\' and \'!\' with a join command.","\\tOtherwise only one space is inserted."],"keymap":["string\\t(default \\"\\")","\\t\\t\\tlocal to buffer","\\tName of a keyboard mapping.  See |mbyte-keymap|.","\\tSetting this option to a valid keymap name has the side effect of","\\tsetting \'iminsert\' to one, so that the keymap becomes effective.","\\t\'imsearch\' is also set to one, unless it was -1","\\tOnly normal file name characters can be used, \\"/\\\\*?[|<>\\" are illegal."],"keymodel":["string\\t(default \\"\\")","\\t\\t\\tglobal","\\tList of comma separated words, which enable special things that keys","\\tcan do.  These values can be used:","\\t   startsel\\tUsing a shifted special key starts selection (either","\\t\\t\\tSelect mode or Visual mode, depending on \\"key\\" being","\\t\\t\\tpresent in \'selectmode\').","\\t   stopsel\\tUsing a not-shifted special key stops selection.","\\tSpecial keys in this context are the cursor keys, <End>, <Home>,","\\t<PageUp> and <PageDown>.","\\tThe \'keymodel\' option is set by the |:behave| command."],"keywordprg":["string\\t(default \\":Man\\", Windows: \\":help\\")","\\t\\t\\tglobal or local to buffer |global-local|","\\tProgram to use for the |K| command.  Environment variables are","\\texpanded |:set_env|.  \\":help\\" may be used to access the Vim internal","\\thelp.  (Note that previously setting the global option to the empty","\\tvalue did this, which is now deprecated.)","\\tWhen the first character is \\":\\", the command is invoked as a Vim","\\tcommand prefixed with [count].","\\tWhen \\"man\\" or \\"man -s\\" is used, Vim will automatically translate","\\ta [count] for the \\"K\\" command to a section number.","\\tSee |option-backslash| about including spaces and backslashes.","\\tExample: >","\\t\\t:set keywordprg=man\\\\ -s","\\t\\t:set keywordprg=:Man","<\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"langmap":["string\\t(default \\"\\")","\\t\\t\\tglobal","\\tThis option allows switching your keyboard into a special language","\\tmode.  When you are typing text in Insert mode the characters are","\\tinserted directly.  When in Normal mode the \'langmap\' option takes","\\tcare of translating these special characters to the original meaning","\\tof the key.  This means you don\'t have to change the keyboard mode to","\\tbe able to execute Normal mode commands.","\\tThis is the opposite of the \'keymap\' option, where characters are","\\tmapped in Insert mode.","\\tAlso consider resetting \'langremap\' to avoid \'langmap\' applies to","\\tcharacters resulting from a mapping.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"langmenu":["string\\t(default \\"\\")","\\t\\t\\tglobal","\\tLanguage to use for menu translation.  Tells which file is loaded","\\tfrom the \\"lang\\" directory in \'runtimepath\': >","\\t\\t\\"lang/menu_\\" . &langmenu . \\".vim\\"","<\\t(without the spaces).  For example, to always use the Dutch menus, no","\\tmatter what $LANG is set to: >","\\t\\t:set langmenu=nl_NL.ISO_8859-1","<\\tWhen \'langmenu\' is empty, |v:lang| is used.","\\tOnly normal file name characters can be used, \\"/\\\\*?[|<>\\" are illegal.","\\tIf your $LANG is set to a non-English language but you do want to use","\\tthe English menus: >","\\t\\t:set langmenu=none","<\\tThis option must be set before loading menus, switching on filetype","\\tdetection or syntax highlighting.  Once the menus are defined setting","\\tthis option has no effect.  But you could do this: >","\\t\\t:source $VIMRUNTIME/delmenu.vim","\\t\\t:set langmenu=de_DE.ISO_8859-1","\\t\\t:source $VIMRUNTIME/menu.vim","<\\tWarning: This deletes all menus that you defined yourself!"],"langremap":["boolean (default off)","\\t\\t\\tglobal","\\tWhen off, setting \'langmap\' does not apply to characters resulting from","\\ta mapping.  If setting \'langmap\' disables some of your mappings, make","\\tsure this option is off."],"laststatus":["number\\t(default 2)","\\t\\t\\tglobal","\\tThe value of this option influences when the last window will have a","\\tstatus line:","\\t\\t0: never","\\t\\t1: only if there are at least two windows","\\t\\t2: always","\\tThe screen looks nicer with a status line if you have several","\\twindows, but it takes another screen line. |status-line|"],"lazyredraw":["boolean\\t(default off)","\\t\\t\\tglobal","\\tWhen this option is set, the screen will not be redrawn while","\\texecuting macros, registers and other commands that have not been","\\ttyped.  Also, updating the window title is postponed.  To force an","\\tupdate use |:redraw|."],"linebreak":["boolean\\t(default off)","\\t\\t\\tlocal to window","\\tIf on, Vim will wrap long lines at a character in \'breakat\' rather","\\tthan at the last character that fits on the screen.  Unlike","\\t\'wrapmargin\' and \'textwidth\', this does not insert <EOL>s in the file,","\\tit only affects the way the file is displayed, not its contents.","\\tIf \'breakindent\' is set, line is visually indented. Then, the value","\\tof \'showbreak\' is used to put in front of wrapped lines. This option","\\tis not used when the \'wrap\' option is off.","\\tNote that <Tab> characters after an <EOL> are mostly not displayed","\\twith the right amount of white space."],"lines":["number\\t(default 24 or terminal height)","\\t\\t\\tglobal","\\tNumber of lines of the Vim window.","\\tNormally you don\'t need to set this.  It is done automatically by the","\\tterminal initialization code.","\\tWhen Vim is running in the GUI or in a resizable window, setting this","\\toption will cause the window size to be changed.  When you only want","\\tto use the size for the GUI, put the command in your |gvimrc| file.","\\tVim limits the number of lines to what fits on the screen.  You can","\\tuse this command to get the tallest window possible: >","\\t\\t:set lines=999","<\\tMinimum value is 2, maximum value is 1000."],"linespace":["number\\t(default 0)","\\t\\t\\tglobal","\\t\\t\\t{only in the GUI}","\\tNumber of pixel lines inserted between characters.  Useful if the font","\\tuses the full character cell height, making lines touch each other.","\\tWhen non-zero there is room for underlining.","\\tWith some fonts there can be too much room between lines (to have","\\tspace for ascents and descents).  Then it makes sense to set","\\t\'linespace\' to a negative value.  This may cause display problems","\\tthough!"],"lisp":["boolean\\t(default off)","\\t\\t\\tlocal to buffer","\\tLisp mode: When <Enter> is typed in insert mode set the indent for","\\tthe next line to Lisp standards (well, sort of).  Also happens with","\\t\\"cc\\" or \\"S\\".  \'autoindent\' must also be on for this to work.  The \'p\'","\\tflag in \'cpoptions\' changes the method of indenting: Vi compatible or","\\tbetter.  Also see \'lispwords\'.","\\tThe \'-\' character is included in keyword characters.  Redefines the","\\t\\"=\\" operator to use this same indentation algorithm rather than","\\tcalling an external program if \'equalprg\' is empty.","\\tThis option is not used when \'paste\' is set."],"lispwords":["string\\t(default is very long)","\\t\\t\\tglobal or local to buffer |global-local|","\\tComma separated list of words that influence the Lisp indenting.","\\t|\'lisp\'|"],"list":["boolean\\t(default off)","\\t\\t\\tlocal to window","\\tList mode: Show tabs as CTRL-I is displayed, display $ after end of","\\tline.  Useful to see the difference between tabs and spaces and for","\\ttrailing blanks.  Further changed by the \'listchars\' option."],"listchars":["string\\t(default: \\"tab:> ,trail:-,nbsp:+\\"","\\t\\t\\t\\t Vi default: \\"eol:$\\")","\\t\\t\\tglobal or local to window |global-local|","\\tStrings to use in \'list\' mode and for the |:list| command.  It is a","\\tcomma separated list of string settings."],"loadplugins":["boolean\\t(default on)","\\t\\t\\tglobal","\\tWhen on the plugin scripts are loaded when starting up |load-plugins|.","\\tThis option can be reset in your |vimrc| file to disable the loading","\\tof plugins.","\\tNote that using the \\"-u NONE\\" and \\"--noplugin\\" command line arguments","\\treset this option. |-u| |--noplugin|"],"magic":["boolean\\t(default on)","\\t\\t\\tglobal","\\tChanges the special characters that can be used in search patterns.","\\tSee |pattern|.","\\tWARNING: Switching this option off most likely breaks plugins!  That","\\tis because many patterns assume it\'s on and will fail when it\'s off.","\\tOnly switch it off when working with old Vi scripts.  In any other","\\tsituation write patterns that work when \'magic\' is on.  Include \\"\\\\M\\"","\\twhen you want to |/\\\\M|."],"makeef":["string\\t(default: \\"\\")","\\t\\t\\tglobal","\\tName of the errorfile for the |:make| command (see |:make_makeprg|)","\\tand the |:grep| command.","\\tWhen it is empty, an internally generated temp file will be used.","\\tWhen \\"##\\" is included, it is replaced by a number to make the name","\\tunique.  This makes sure that the \\":make\\" command doesn\'t overwrite an","\\texisting file.","\\tNOT used for the \\":cf\\" command.  See \'errorfile\' for that.","\\tEnvironment variables are expanded |:set_env|.","\\tSee |option-backslash| about including spaces and backslashes.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"makeencoding":["string\\t(default \\"\\")","\\t\\t\\tglobal or local to buffer |global-local|","\\tEncoding used for reading the output of external commands.  When empty,","\\tencoding is not converted.","\\tThis is used for `:make`, `:lmake`, `:grep`, `:lgrep`, `:grepadd`,","\\t`:lgrepadd`, `:cfile`, `:cgetfile`, `:caddfile`, `:lfile`, `:lgetfile`,","\\tand `:laddfile`."],"makeprg":["string\\t(default \\"make\\")","\\t\\t\\tglobal or local to buffer |global-local|","\\tProgram to use for the \\":make\\" command.  See |:make_makeprg|.","\\tThis option may contain \'%\' and \'#\' characters (see  |:_%| and |:_#|),","\\twhich are expanded to the current and alternate file name.  Use |::S|","\\tto escape file names in case they contain special characters.","\\tEnvironment variables are expanded |:set_env|.  See |option-backslash|","\\tabout including spaces and backslashes.","\\tNote that a \'|\' must be escaped twice: once for \\":set\\" and once for","\\tthe interpretation of a command.  When you use a filter called","\\t\\"myfilter\\" do it like this: >","\\t    :set makeprg=gmake\\\\ \\\\\\\\\\\\|\\\\ myfilter","<\\tThe placeholder \\"$*\\" can be given (even multiple times) to specify","\\twhere the arguments will be included, for example: >","\\t    :set makeprg=latex\\\\ \\\\\\\\\\\\\\\\nonstopmode\\\\ \\\\\\\\\\\\\\\\input\\\\\\\\{$*}","<\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"matchpairs":["string\\t(default \\"(:),{:},[:]\\")","\\t\\t\\tlocal to buffer","\\tCharacters that form pairs.  The |%| command jumps from one to the","\\tother.","\\tOnly character pairs are allowed that are different, thus you cannot","\\tjump between two double quotes.","\\tThe characters must be separated by a colon.","\\tThe pairs must be separated by a comma.  Example for including \'<\' and","\\t\'>\' (HTML): >","\\t\\t:set mps+=<:>"],"matchtime":["number\\t(default 5)","\\t\\t\\tglobal","\\tTenths of a second to show the matching paren, when \'showmatch\' is","\\tset.  Note that this is not in milliseconds, like other options that","\\tset a time.  This is to be compatible with Nvi."],"maxcombine":["Removed. |vim-differences|","\\tNvim always displays up to 6 combining characters.  You can still edit","    text with more than 6 combining characters, you just can\'t see them.","    Use |g8| or |ga|.  See |mbyte-combining|."],"maxfuncdepth":["number\\t(default 100)","\\t\\t\\tglobal","\\tMaximum depth of function calls for user functions.  This normally","\\tcatches endless recursion.  When using a recursive function with","\\tmore depth, set \'maxfuncdepth\' to a bigger number.  But this will use","\\tmore memory, there is the danger of failing when memory is exhausted.","\\tIncreasing this limit above 200 also changes the maximum for Ex","\\tcommand recursion, see |E169|.","\\tSee also |:function|."],"maxmapdepth":["number\\t(default 1000)","\\t\\t\\tglobal","\\tMaximum number of times a mapping is done without resulting in a","\\tcharacter to be used.  This normally catches endless mappings, like","\\t\\":map x y\\" with \\":map y x\\".  It still does not catch \\":map g wg\\",","\\tbecause the \'w\' is used before the next mapping is done.  See also","\\t|key-mapping|."],"maxmempattern":["number\\t(default 1000)","\\t\\t\\tglobal","\\tMaximum amount of memory (in Kbyte) to use for pattern matching.","\\tThe maximum value is about 2000000.  Use this to work without a limit.","\\t\\t\\t\\t\\t\\t\\t*E363*","\\tWhen Vim runs into the limit it gives an error message and mostly","\\tbehaves like CTRL-C was typed.","\\tRunning into the limit often means that the pattern is very","\\tinefficient or too complex.  This may already happen with the pattern","\\t\\"\\\\(.\\\\)*\\" on a very long line.  \\".*\\" works much better.","\\tMight also happen on redraw, when syntax rules try to match a complex","\\ttext structure.","\\tVim may run out of memory before hitting the \'maxmempattern\' limit, in","\\twhich case you get an \\"Out of memory\\" error instead."],"menuitems":["number\\t(default 25)","\\t\\t\\tglobal","\\tMaximum number of items to use in a menu.  Used for menus that are","\\tgenerated from a list of items, e.g., the Buffers menu.  Changing this","\\toption has no direct effect, the menu must be refreshed first."],"mkspellmem":["string\\t(default \\"460000,2000,500\\")","\\t\\t\\tglobal","\\tParameters for |:mkspell|.  This tunes when to start compressing the","\\tword tree.  Compression can be slow when there are many words, but","\\tit\'s needed to avoid running out of memory.  The amount of memory used","\\tper word depends very much on how similar the words are, that\'s why","\\tthis tuning is complicated."],"modeline":["boolean\\t(Vim default: on (off for root),","\\t\\t\\t\\t Vi default: off)","\\t\\t\\tlocal to buffer","\\tIf \'modeline\' is on \'modelines\' gives the number of lines that is","\\tchecked for set commands.  If \'modeline\' is off or \'modelines\' is zero","\\tno lines are checked.  See |modeline|."],"modelineexpr":["boolean (default: off)","\\t\\t\\tglobal","\\tWhen on allow some options that are an expression to be set in the","\\tmodeline.  Check the option for whether it is affected by","\\t\'modelineexpr\'.  Also see |modeline|."],"modelines":["number\\t(default 5)","\\t\\t\\tglobal","\\tIf \'modeline\' is on \'modelines\' gives the number of lines that is","\\tchecked for set commands.  If \'modeline\' is off or \'modelines\' is zero","\\tno lines are checked.  See |modeline|."],"modifiable":["boolean\\t(default on)","\\t\\t\\tlocal to buffer","\\tWhen off the buffer contents cannot be changed.  The \'fileformat\' and","\\t\'fileencoding\' options also can\'t be changed.","\\tCan be reset on startup with the |-M| command line argument."],"modified":["boolean\\t(default off)","\\t\\t\\tlocal to buffer","\\tWhen on, the buffer is considered to be modified.  This option is set","\\twhen:","\\t1. A change was made to the text since it was last written.  Using the","\\t   |undo| command to go back to the original text will reset the","\\t   option.  But undoing changes that were made before writing the","\\t   buffer will set the option again, since the text is different from","\\t   when it was written.","\\t2. \'fileformat\' or \'fileencoding\' is different from its original","\\t   value.  The original value is set when the buffer is read or","\\t   written.  A \\":set nomodified\\" command also resets the original","\\t   values to the current values and the \'modified\' option will be","\\t   reset.","\\t   Similarly for \'eol\' and \'bomb\'.","\\tThis option is not set when a change is made to the buffer as the","\\tresult of a BufNewFile, BufRead/BufReadPost, BufWritePost,","\\tFileAppendPost or VimLeave autocommand event.  See |gzip-example| for","\\tan explanation.","\\tWhen \'buftype\' is \\"nowrite\\" or \\"nofile\\" this option may be set, but","\\twill be ignored.","\\tNote that the text may actually be the same, e.g. \'modified\' is set","\\twhen using \\"rA\\" on an \\"A\\"."],"more":["boolean\\t(Vim default: on, Vi default: off)","\\t\\t\\tglobal","\\tWhen on, listings pause when the whole screen is filled.  You will get","\\tthe |more-prompt|.  When this option is off there are no pauses, the","\\tlisting continues until finished."],"mouse":["string\\t(default \\"\\")","\\t\\t\\tglobal"],"mousefocus":["boolean\\t(default off)","\\t\\t\\tglobal","\\t\\t\\t{only works in the GUI}","\\tThe window that the mouse pointer is on is automatically activated.","\\tWhen changing the window layout or window focus in another way, the","\\tmouse pointer is moved to the window with keyboard focus.  Off is the","\\tdefault because it makes using the pull down menus a little goofy, as","\\ta pointer transit may activate a window unintentionally."],"mousehide":["boolean\\t(default on)","\\t\\t\\tglobal","\\t\\t\\t{only works in the GUI}","\\tWhen on, the mouse pointer is hidden when characters are typed.","\\tThe mouse pointer is restored when the mouse is moved."],"mousemodel":["string\\t(default \\"extend\\")","\\t\\t\\tglobal","\\tSets the model to use for the mouse.  The name mostly specifies what","\\tthe right mouse button is used for:","\\t   extend\\tRight mouse button extends a selection.  This works","\\t\\t\\tlike in an xterm.","\\t   popup\\tRight mouse button pops up a menu.  The shifted left","\\t\\t\\tmouse button extends a selection.  This works like","\\t\\t\\twith Microsoft Windows.","\\t   popup_setpos Like \\"popup\\", but the cursor will be moved to the","\\t\\t\\tposition where the mouse was clicked, and thus the","\\t\\t\\tselected operation will act upon the clicked object.","\\t\\t\\tIf clicking inside a selection, that selection will","\\t\\t\\tbe acted upon, i.e. no cursor move.  This implies of","\\t\\t\\tcourse, that right clicking outside a selection will","\\t\\t\\tend Visual mode.","\\tOverview of what button does what for each model:","\\tmouse\\t\\t    extend\\t\\tpopup(_setpos) ~","\\tleft click\\t    place cursor\\tplace cursor","\\tleft drag\\t    start selection\\tstart selection","\\tshift-left\\t    search word\\t\\textend selection","\\tright click\\t    extend selection\\tpopup menu (place cursor)","\\tright drag\\t    extend selection\\t-","\\tmiddle click\\t    paste\\t\\tpaste"],"mouseshape":["string\\t(default \\"i:beam,r:beam,s:updown,sd:cross,","\\t\\t\\t\\t\\tm:no,ml:up-arrow,v:rightup-arrow\\")","\\t\\t\\tglobal","\\tThis option tells Vim what the mouse pointer should look like in","\\tdifferent modes.  The option is a comma separated list of parts, much","\\tlike used for \'guicursor\'.  Each part consist of a mode/location-list","\\tand an argument-list:","\\t\\tmode-list:shape,mode-list:shape,..","\\tThe mode-list is a dash separated list of these modes/locations:","\\t\\t\\tIn a normal window: ~","\\t\\tn\\tNormal mode","\\t\\tv\\tVisual mode","\\t\\tve\\tVisual mode with \'selection\' \\"exclusive\\" (same as \'v\',","\\t\\t\\tif not specified)","\\t\\to\\tOperator-pending mode","\\t\\ti\\tInsert mode","\\t\\tr\\tReplace mode"],"mousetime":["number\\t(default 500)","\\t\\t\\tglobal","\\tDefines the maximum time in msec between two mouse clicks for the","\\tsecond click to be recognized as a multi click."],"nrformats":["string\\t(default \\"bin,hex\\")","\\t\\t\\tlocal to buffer","\\tThis defines what bases Vim will consider for numbers when using the","\\tCTRL-A and CTRL-X commands for adding to and subtracting from a number","\\trespectively; see |CTRL-A| for more info on these commands.","\\talpha\\tIf included, single alphabetical characters will be","\\t\\tincremented or decremented.  This is useful for a list with a","\\t\\tletter index a), b), etc.\\t\\t*octal-nrformats*","\\toctal\\tIf included, numbers that start with a zero will be considered","\\t\\tto be octal.  Example: Using CTRL-A on \\"007\\" results in \\"010\\".","\\thex\\tIf included, numbers starting with \\"0x\\" or \\"0X\\" will be","\\t\\tconsidered to be hexadecimal.  Example: Using CTRL-X on","\\t\\t\\"0x100\\" results in \\"0x0ff\\".","\\tbin\\tIf included, numbers starting with \\"0b\\" or \\"0B\\" will be","\\t\\tconsidered to be binary.  Example: Using CTRL-X on","\\t\\t\\"0b1000\\" subtracts one, resulting in \\"0b0111\\".","\\tNumbers which simply begin with a digit in the range 1-9 are always","\\tconsidered decimal.  This also happens for numbers that are not","\\trecognized as octal or hex."],"number":["boolean\\t(default off)","\\t\\t\\tlocal to window","\\tPrint the line number in front of each line.  When the \'n\' option is","\\texcluded from \'cpoptions\' a wrapped line will not use the column of","\\tline numbers.","\\tUse the \'numberwidth\' option to adjust the room for the line number.","\\tWhen a long, wrapped line doesn\'t start with the first character, \'-\'","\\tcharacters are put before the number.","\\tFor highlighting see |hl-LineNr|, |hl-CursorLineNr|, and the","\\t|:sign-define| \\"numhl\\" argument.","\\t\\t\\t\\t\\t\\t*number_relativenumber*","\\tThe \'relativenumber\' option changes the displayed number to be","\\trelative to the cursor.  Together with \'number\' there are these","\\tfour combinations (cursor in line 3):"],"numberwidth":["number\\t(Vim default: 4  Vi default: 8)","\\t\\t\\tlocal to window","\\tMinimal number of columns to use for the line number.  Only relevant","\\twhen the \'number\' or \'relativenumber\' option is set or printing lines","\\twith a line number. Since one space is always between the number and","\\tthe text, there is one less character for the number itself.","\\tThe value is the minimum width.  A bigger width is used when needed to","\\tfit the highest line number in the buffer respectively the number of","\\trows in the window, depending on whether \'number\' or \'relativenumber\'","\\tis set. Thus with the Vim default of 4 there is room for a line number","\\tup to 999. When the buffer has 1000 lines five columns will be used.","\\tThe minimum value is 1, the maximum value is 20."],"omnifunc":["string\\t(default: empty)","\\t\\t\\tlocal to buffer","\\tThis option specifies a function to be used for Insert mode omni","\\tcompletion with CTRL-X CTRL-O. |i_CTRL-X_CTRL-O|","\\tSee |complete-functions| for an explanation of how the function is","\\tinvoked and what it should return.","\\tThis option is usually set by a filetype plugin:","\\t|:filetype-plugin-on|","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"opendevice":["boolean\\t(default off)","\\t\\t\\tglobal","\\t\\t\\t{only for Windows}","\\tEnable reading and writing from devices.  This may get Vim stuck on a","\\tdevice that can be opened but doesn\'t actually do the I/O.  Therefore","\\tit is off by default.","\\tNote that on Windows editing \\"aux.h\\", \\"lpt1.txt\\" and the like also","\\tresult in editing a device."],"operatorfunc":["string\\t(default: empty)","\\t\\t\\tglobal","\\tThis option specifies a function to be called by the |g@| operator.","\\tSee |:map-operator| for more info and an example."],"packpath":["string\\t(default: see \'runtimepath\')","\\tDirectories used to find packages.  See |packages|."],"paragraphs":["string\\t(default \\"IPLPPPQPP TPHPLIPpLpItpplpipbp\\")","\\t\\t\\tglobal","\\tSpecifies the nroff macros that separate paragraphs.  These are pairs","\\tof two letters (see |object-motions|)."],"paste":["boolean\\t(default off)","\\t\\t\\tglobal","\\tThis option is obsolete; |bracketed-paste-mode| is built-in."],"pastetoggle":["string\\t(default \\"\\")","\\t\\t\\tglobal","\\tWhen non-empty, specifies the key sequence that toggles the \'paste\'","\\toption.  This is like specifying a mapping: >","\\t    :map {keys} :set invpaste<CR>","<\\tWhere {keys} is the value of \'pastetoggle\'.","\\tThe difference is that it will work even when \'paste\' is set.","\\t\'pastetoggle\' works in Insert mode and Normal mode, but not in","\\tCommand-line mode.","\\tMappings are checked first, thus overrule \'pastetoggle\'.  However,","\\twhen \'paste\' is on mappings are ignored in Insert mode, thus you can do","\\tthis: >","\\t    :map <F10> :set paste<CR>","\\t    :map <F11> :set nopaste<CR>","\\t    :imap <F10> <C-O>:set paste<CR>","\\t    :imap <F11> <nop>","\\t    :set pastetoggle=<F11>","<\\tThis will make <F10> start paste mode and <F11> stop paste mode.","\\tNote that typing <F10> in paste mode inserts \\"<F10>\\", since in paste","\\tmode everything is inserted literally, except the \'pastetoggle\' key","\\tsequence.","\\tNo timeout is used, this means that a multi-key \'pastetoggle\' can not","\\tbe triggered manually."],"patchexpr":["string\\t(default \\"\\")","\\t\\t\\tglobal","\\tExpression which is evaluated to apply a patch to a file and generate","\\tthe resulting new version of the file.  See |diff-patchexpr|."],"patchmode":["string\\t(default \\"\\")","\\t\\t\\tglobal","\\tWhen non-empty the oldest version of a file is kept.  This can be used","\\tto keep the original version of a file if you are changing files in a","\\tsource distribution.  Only the first time that a file is written a","\\tcopy of the original file will be kept.  The name of the copy is the","\\tname of the original file with the string in the \'patchmode\' option","\\tappended.  This option should start with a dot.  Use a string like","\\t\\".orig\\" or \\".org\\".  \'backupdir\' must not be empty for this to work","\\t(Detail: The backup file is renamed to the patchmode file after the","\\tnew file has been successfully written, that\'s why it must be possible","\\tto write a backup file).  If there was no file to be backed up, an","\\tempty file is created.","\\tWhen the \'backupskip\' pattern matches, a patchmode file is not made.","\\tUsing \'patchmode\' for compressed files appends the extension at the","\\tend (e.g., \\"file.gz.orig\\"), thus the resulting name isn\'t always","\\trecognized as a compressed file.","\\tOnly normal file name characters can be used, \\"/\\\\*?[|<>\\" are illegal."],"path":["string\\t(default on Unix: \\".,/usr/include,,\\"","\\t\\t\\t\\t   other systems: \\".,,\\")","\\t\\t\\tglobal or local to buffer |global-local|","\\tThis is a list of directories which will be searched when using the","\\t|gf|, [f, ]f, ^Wf, |:find|, |:sfind|, |:tabfind| and other commands,","\\tprovided that the file being searched for has a relative path (not","\\tstarting with \\"/\\", \\"./\\" or \\"../\\").  The directories in the \'path\'","\\toption may be relative or absolute.","\\t- Use commas to separate directory names: >","\\t\\t:set path=.,/usr/local/include,/usr/include","<\\t- Spaces can also be used to separate directory names (for backwards","\\t  compatibility with version 3.0).  To have a space in a directory","\\t  name, precede it with an extra backslash, and escape the space: >","\\t\\t:set path=.,/dir/with\\\\\\\\\\\\ space","<\\t- To include a comma in a directory name precede it with an extra","\\t  backslash: >","\\t\\t:set path=.,/dir/with\\\\\\\\,comma","<\\t- To search relative to the directory of the current file, use: >","\\t\\t:set path=.","<\\t- To search in the current directory use an empty string between two","\\t  commas: >","\\t\\t:set path=,,","<\\t- A directory name may end in a \':\' or \'/\'.","\\t- Environment variables are expanded |:set_env|.","\\t- When using |netrw.vim| URLs can be used.  For example, adding","\\t  \\"http://www.vim.org\\" will make \\":find index.html\\" work.","\\t- Search upwards and downwards in a directory tree using \\"*\\", \\"**\\" and","\\t  \\";\\".  See |file-searching| for info and syntax.","\\t- Careful with \'\\\\\' characters, type two to get one in the option: >","\\t\\t:set path=.,c:\\\\\\\\include","<\\t  Or just use \'/\' instead: >","\\t\\t:set path=.,c:/include","<\\tDon\'t forget \\".\\" or files won\'t even be found in the same directory as","\\tthe file!","\\tThe maximum length is limited.  How much depends on the system, mostly","\\tit is something like 256 or 1024 characters.","\\tYou can check if all the include files are found, using the value of","\\t\'path\', see |:checkpath|.","\\tThe use of |:set+=| and |:set-=| is preferred when adding or removing","\\tdirectories from the list.  This avoids problems when a future version","\\tuses another default.  To remove the current directory use: >","\\t\\t:set path-=","<\\tTo add the current directory use: >","\\t\\t:set path+=","<\\tTo use an environment variable, you probably need to replace the","\\tseparator.  Here is an example to append $INCL, in which directory","\\tnames are separated with a semi-colon: >","\\t\\t:let &path = &path . \\",\\" . substitute($INCL, \';\', \',\', \'g\')","<\\tReplace the \';\' with a \':\' or whatever separator is used.  Note that","\\tthis doesn\'t work when $INCL contains a comma or white space."],"preserveindent":["boolean\\t(default off)","\\t\\t\\tlocal to buffer","\\tWhen changing the indent of the current line, preserve as much of the","\\tindent structure as possible.  Normally the indent is replaced by a","\\tseries of tabs followed by spaces as required (unless |\'expandtab\'| is","\\tenabled, in which case only spaces are used).  Enabling this option","\\tmeans the indent will preserve as many existing characters as possible","\\tfor indenting, and only add additional tabs or spaces as required.","\\t\'expandtab\' does not apply to the preserved white space, a Tab remains","\\ta Tab.","\\tNOTE: When using \\">>\\" multiple times the resulting indent is a mix of","\\ttabs and spaces.  You might not like this.","\\tAlso see \'copyindent\'.","\\tUse |:retab| to clean up white space."],"previewheight":["number (default 12)","\\t\\t\\tglobal","\\tDefault height for a preview window.  Used for |:ptag| and associated","\\tcommands.  Used for |CTRL-W_}| when no count is given."],"previewwindow":["boolean (default off)","\\t\\t\\tlocal to window","\\tIdentifies the preview window.  Only one window can have this option","\\tset.  It\'s normally not set directly, but by using one of the commands","\\t|:ptag|, |:pedit|, etc."],"printdevice":["string\\t(default empty)","\\t\\t\\tglobal","\\tThe name of the printer to be used for |:hardcopy|.","\\tSee |pdev-option|.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"printencoding":["string\\t(default empty, except for some systems)","\\t\\t\\tglobal","\\tSets the character encoding used when printing.","\\tSee |penc-option|."],"printexpr":["string\\t(default: see below)","\\t\\t\\tglobal","\\tExpression used to print the PostScript produced with |:hardcopy|.","\\tSee |pexpr-option|.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"printfont":["string\\t(default \\"courier\\")","\\t\\t\\tglobal","\\tThe name of the font that will be used for |:hardcopy|.","\\tSee |pfn-option|."],"printheader":["string  (default \\"%<%f%h%m%=Page %N\\")","\\t\\t\\tglobal","\\tThe format of the header produced in |:hardcopy| output.","\\tSee |pheader-option|."],"printmbcharset":["string (default \\"\\")","\\t\\t\\tglobal","\\tThe CJK character set to be used for CJK output from |:hardcopy|.","\\tSee |pmbcs-option|."],"printmbfont":["string (default \\"\\")","\\t\\t\\tglobal","\\tList of font names to be used for CJK output from |:hardcopy|.","\\tSee |pmbfn-option|."],"printoptions":["string (default \\"\\")","\\t\\t\\tglobal","\\tList of items that control the format of the output of |:hardcopy|.","\\tSee |popt-option|."],"prompt":["boolean\\t(default on)","\\t\\t\\tglobal","\\tWhen on a \\":\\" prompt is used in Ex mode."],"pumblend":["number\\t(default 0)","\\t\\t\\tglobal","\\tEnables pseudo-transparency for the |popup-menu|. Valid values are in","\\tthe range of 0 for fully opaque popupmenu (disabled) to 100 for fully","\\ttransparent background. Values between 0-30 are typically most useful."],"pumheight":["number\\t(default 0)","\\t\\t\\tglobal","\\tMaximum number of items to show in the popup menu","\\t(|ins-completion-menu|). Zero means \\"use available screen space\\"."],"pumwidth":["number\\t(default 15)","\\t\\t\\tglobal","\\tMinimum width for the popup menu (|ins-completion-menu|).  If the","\\tcursor column + \'pumwidth\' exceeds screen width, the popup menu is","\\tnudged to fit on the screen."],"pyxversion":["number\\t(default depends on the build)","\\t\\t\\tglobal","\\tSpecifies the python version used for pyx* functions and commands","\\t|python_x|.  The default value is as follows:"],"quoteescape":["string\\t(default \\"\\\\\\")","\\t\\t\\tlocal to buffer","\\tThe characters that are used to escape quotes in a string.  Used for","\\tobjects like a\', a\\" and a` |a\'|.","\\tWhen one of the characters in this option is found inside a string,","\\tthe following character will be skipped.  The default value makes the","\\ttext \\"foo\\\\\\"bar\\\\\\\\\\" considered to be one string."],"readonly":["boolean\\t(default off)","\\t\\t\\tlocal to buffer","\\tIf on, writes fail unless you use a \'!\'.  Protects you from","\\taccidentally overwriting a file.  Default on when Vim is started","\\tin read-only mode (\\"vim -R\\") or when the executable is called \\"view\\".","\\tWhen using \\":w!\\" the \'readonly\' option is reset for the current","\\tbuffer, unless the \'Z\' flag is in \'cpoptions\'.","\\tWhen using the \\":view\\" command the \'readonly\' option is","\\tset for the newly edited buffer.","\\tSee \'modifiable\' for disallowing changes to the buffer."],"redrawdebug":["string\\t(default \'\')","\\t\\t\\tglobal","\\tFlags to change the way redrawing works, for debugging purposes.","\\tMost useful with \'writedelay\' set to some reasonable value.","\\tSupports the following flags:","\\t    compositor\\tIndicate what redraws come from the compositor","\\t\\t\\tby briefly flashing the redrawn regions in colors","\\t\\t\\tindicating the redraw type. These are the highlight","\\t\\t\\tgroups used (and their default colors):","\\t\\tRedrawDebugNormal   gui=reverse   normal redraw passed through","\\t\\tRedrawDebugClear    guibg=Yellow  clear event passed through","\\t\\tRedrawDebugComposed guibg=Green   redraw event modified by the","\\t\\t\\t\\t\\t\\t  compositor (due to","\\t\\t\\t\\t\\t\\t  overlapping grids, etc)","\\t\\tRedrawDebugRecompose guibg=Red    redraw generated by the","\\t\\t\\t\\t\\t\\t  compositor itself, due to a","\\t\\t\\t\\t\\t\\t  grid being moved or deleted.","\\t    nothrottle\\tTurn off throttling of the message grid. This is an","\\t\\t\\toptimization that joins many small scrolls to one","\\t\\t\\tlarger scroll when drawing the message area (with","\\t\\t\\t\'display\' msgsep flag active).","\\t    invalid\\tEnable stricter checking (abort) of inconsistencies","\\t\\t\\tof the internal screen state. This is mostly","\\t\\t\\tuseful when running nvim inside a debugger (and","\\t\\t\\tthe test suite).","\\t    nodelta\\tSend all internally redrawn cells to the UI, even if","\\t                they are unchanged from the already displayed state."],"redrawtime":["number\\t(default 2000)","\\t\\t\\tglobal","\\tTime in milliseconds for redrawing the display.  Applies to","\\t\'hlsearch\', \'inccommand\', |:match| highlighting and syntax","\\thighlighting.","\\tWhen redrawing takes more than this many milliseconds no further","\\tmatches will be highlighted.","\\tFor syntax highlighting the time applies per window.  When over the","\\tlimit syntax highlighting is disabled until |CTRL-L| is used.","\\tThis is used to avoid that Vim hangs when using a very complicated","\\tpattern."],"regexpengine":["number\\t(default 0)","\\t\\t\\tglobal","\\tThis selects the default regexp engine. |two-engines|","\\tThe possible values are:","\\t\\t0\\tautomatic selection","\\t\\t1\\told engine","\\t\\t2\\tNFA engine","\\tNote that when using the NFA engine and the pattern contains something","\\tthat is not supported the pattern will not match.  This is only useful","\\tfor debugging the regexp engine.","\\tUsing automatic selection enables Vim to switch the engine, if the","\\tdefault engine becomes too costly.  E.g., when the NFA engine uses too","\\tmany states.  This should prevent Vim from hanging on a combination of","\\ta complex pattern with long text."],"relativenumber":["boolean\\t(default off)","\\t\\t\\tlocal to window","\\tShow the line number relative to the line with the cursor in front of","\\teach line. Relative line numbers help you use the |count| you can","\\tprecede some vertical motion commands (e.g. j k + -) with, without","\\thaving to calculate it yourself. Especially useful in combination with","\\tother commands (e.g. y d c < > gq gw =).","\\tWhen the \'n\' option is excluded from \'cpoptions\' a wrapped","\\tline will not use the column of line numbers.","\\tThe \'numberwidth\' option can be used to set the room used for the line","\\tnumber.","\\tWhen a long, wrapped line doesn\'t start with the first character, \'-\'","\\tcharacters are put before the number.","\\tSee |hl-LineNr|  and |hl-CursorLineNr| for the highlighting used for","\\tthe number."],"remap":["boolean\\t(default on)","\\t\\t\\tglobal","\\tAllows for mappings to work recursively.  If you do not want this for","\\ta single entry, use the :noremap[!] command.","\\tNOTE: To avoid portability problems with Vim scripts, always keep","\\tthis option at the default \\"on\\".  Only switch it off when working with","\\told Vi scripts."],"report":["number\\t(default 2)","\\t\\t\\tglobal","\\tThreshold for reporting number of lines changed.  When the number of","\\tchanged lines is more than \'report\' a message will be given for most","\\t\\":\\" commands.  If you want it always, set \'report\' to 0.","\\tFor the \\":substitute\\" command the number of substitutions is used","\\tinstead of the number of lines."],"revins":["boolean\\t(default off)","\\t\\t\\tglobal","\\tInserting characters in Insert mode will work backwards.  See \\"typing","\\tbackwards\\" |ins-reverse|.  This option can be toggled with the CTRL-_","\\tcommand in Insert mode, when \'allowrevins\' is set.","\\tThis option is reset when \'paste\' is set and restored when \'paste\' is","\\treset."],"rightleft":["boolean\\t(default off)","\\t\\t\\tlocal to window","\\tWhen on, display orientation becomes right-to-left, i.e., characters","\\tthat are stored in the file appear from the right to the left.","\\tUsing this option, it is possible to edit files for languages that","\\tare written from the right to the left such as Hebrew and Arabic.","\\tThis option is per window, so it is possible to edit mixed files","\\tsimultaneously, or to view the same file in both ways (this is","\\tuseful whenever you have a mixed text file with both right-to-left","\\tand left-to-right strings so that both sets are displayed properly","\\tin different windows).  Also see |rileft.txt|."],"rightleftcmd":["string\\t(default \\"search\\")","\\t\\t\\tlocal to window","\\tEach word in this option enables the command line editing to work in","\\tright-to-left mode for a group of commands:"],"ruler":["boolean\\t(default on)","\\t\\t\\tglobal","\\tShow the line and column number of the cursor position, separated by a","\\tcomma.  When there is room, the relative position of the displayed","\\ttext in the file is shown on the far right:","\\t\\tTop\\tfirst line is visible","\\t\\tBot\\tlast line is visible","\\t\\tAll\\tfirst and last line are visible","\\t\\t45%\\trelative position in the file","\\tIf \'rulerformat\' is set, it will determine the contents of the ruler.","\\tEach window has its own ruler.  If a window has a status line, the","\\truler is shown there.  Otherwise it is shown in the last line of the","\\tscreen.  If the statusline is given by \'statusline\' (i.e. not empty),","\\tthis option takes precedence over \'ruler\' and \'rulerformat\'","\\tIf the number of characters displayed is different from the number of","\\tbytes in the text (e.g., for a TAB or a multi-byte character), both","\\tthe text column (byte number) and the screen column are shown,","\\tseparated with a dash.","\\tFor an empty line \\"0-1\\" is shown.","\\tFor an empty buffer the line number will also be zero: \\"0,0-1\\".","\\tThis option is reset when \'paste\' is set and restored when \'paste\' is","\\treset.","\\tIf you don\'t want to see the ruler all the time but want to know where","\\tyou are, use \\"g CTRL-G\\" |g_CTRL-G|."],"rulerformat":["string\\t(default empty)","\\t\\t\\tglobal","\\tWhen this option is not empty, it determines the content of the ruler","\\tstring, as displayed for the \'ruler\' option.","\\tThe format of this option is like that of \'statusline\'.","\\tThis option cannot be set in a modeline when \'modelineexpr\' is off."],"runtimepath":["string\\t(default:     \\"$XDG_CONFIG_HOME/nvim,","\\t\\t\\t\\t\\t       $XDG_CONFIG_DIRS[1]/nvim,","\\t\\t\\t\\t\\t       $XDG_CONFIG_DIRS[2]/nvim,","\\t\\t\\t\\t\\t       …","\\t\\t\\t\\t\\t       $XDG_DATA_HOME/nvim[-data]/site,","\\t\\t\\t\\t\\t       $XDG_DATA_DIRS[1]/nvim/site,","\\t\\t\\t\\t\\t       $XDG_DATA_DIRS[2]/nvim/site,","\\t\\t\\t\\t\\t       …","\\t\\t\\t\\t\\t       $VIMRUNTIME,","\\t\\t\\t\\t\\t       …","\\t\\t\\t\\t\\t       $XDG_DATA_DIRS[2]/nvim/site/after,","\\t\\t\\t\\t\\t       $XDG_DATA_DIRS[1]/nvim/site/after,","\\t\\t\\t\\t\\t       $XDG_DATA_HOME/nvim[-data]/site/after,","\\t\\t\\t\\t\\t       …","\\t\\t\\t\\t\\t       $XDG_CONFIG_DIRS[2]/nvim/after,","\\t\\t\\t\\t\\t       $XDG_CONFIG_DIRS[1]/nvim/after,","\\t\\t\\t\\t\\t       $XDG_CONFIG_HOME/nvim/after\\")","\\t\\t\\tglobal","\\tList of directories to be searched for these runtime files:","\\t  filetype.vim\\tfiletypes by file name |new-filetype|","\\t  scripts.vim\\tfiletypes by file contents |new-filetype-scripts|","\\t  autoload/\\tautomatically loaded scripts |autoload-functions|","\\t  colors/\\tcolor scheme files |:colorscheme|","\\t  compiler/\\tcompiler files |:compiler|","\\t  doc/\\t\\tdocumentation |write-local-help|","\\t  ftplugin/\\tfiletype plugins |write-filetype-plugin|","\\t  indent/\\tindent scripts |indent-expression|","\\t  keymap/\\tkey mapping files |mbyte-keymap|","\\t  lang/\\t\\tmenu translations |:menutrans|","\\t  menu.vim\\tGUI menus |menu.vim|","\\t  pack/\\t\\tpackages |:packadd|","\\t  plugin/\\tplugin scripts |write-plugin|","\\t  print/\\tfiles for printing |postscript-print-encoding|","\\t  rplugin/\\t|remote-plugin| scripts","\\t  spell/\\tspell checking files |spell|","\\t  syntax/\\tsyntax files |mysyntaxfile|","\\t  tutor/\\ttutorial files |:Tutor|"],"scroll":["number\\t(default: half the window height)","\\t\\t\\tlocal to window","\\tNumber of lines to scroll with CTRL-U and CTRL-D commands.  Will be","\\tset to half the number of lines in the window when the window size","\\tchanges.  If you give a count to the CTRL-U or CTRL-D command it will","\\tbe used as the new value for \'scroll\'.  Reset to half the window","\\theight with \\":set scroll=0\\"."],"scrollback":["number\\t(default: 10000)","\\t\\t\\tlocal to buffer","\\tMaximum number of lines kept beyond the visible screen. Lines at the","\\ttop are deleted if new lines exceed this limit.","\\tMinimum is 1, maximum is 100000.","\\tOnly in |terminal| buffers."],"scrollbind":["boolean  (default off)","\\t\\t\\tlocal to window","\\tSee also |scroll-binding|.  When this option is set, the current","\\twindow scrolls as other scrollbind windows (windows that also have","\\tthis option set) scroll.  This option is useful for viewing the","\\tdifferences between two versions of a file, see \'diff\'.","\\tSee |\'scrollopt\'| for options that determine how this option should be","\\tinterpreted.","\\tThis option is mostly reset when splitting a window to edit another","\\tfile.  This means that \\":split | edit file\\" results in two windows","\\twith scroll-binding, but \\":split file\\" does not."],"scrolljump":["number\\t(default 1)","\\t\\t\\tglobal","\\tMinimal number of lines to scroll when the cursor gets off the","\\tscreen (e.g., with \\"j\\").  Not used for scroll commands (e.g., CTRL-E,","\\tCTRL-D).  Useful if your terminal scrolls very slowly.","\\tWhen set to a negative number from -1 to -100 this is used as the","\\tpercentage of the window height.  Thus -50 scrolls half the window","\\theight."],"scrolloff":["number\\t(default 0)","\\t\\t\\tglobal or local to window |global-local|","\\tMinimal number of screen lines to keep above and below the cursor.","\\tThis will make some context visible around where you are working.  If","\\tyou set it to a very large value (999) the cursor line will always be","\\tin the middle of the window (except at the start or end of the file or","\\twhen long lines wrap).","\\tAfter using the local value, go back the global value with one of","\\tthese two: >","\\t\\tsetlocal scrolloff<","\\t\\tsetlocal scrolloff=-1","<\\tFor scrolling horizontally see \'sidescrolloff\'."],"scrollopt":["string\\t(default \\"ver,jump\\")","\\t\\t\\tglobal","\\tThis is a comma-separated list of words that specifies how","\\t\'scrollbind\' windows should behave.  \'sbo\' stands for ScrollBind","\\tOptions.","\\tThe following words are available:","\\t    ver\\t\\tBind vertical scrolling for \'scrollbind\' windows","\\t    hor\\t\\tBind horizontal scrolling for \'scrollbind\' windows","\\t    jump\\tApplies to the offset between two windows for vertical","\\t\\t\\tscrolling.  This offset is the difference in the first","\\t\\t\\tdisplayed line of the bound windows.  When moving","\\t\\t\\taround in a window, another \'scrollbind\' window may","\\t\\t\\treach a position before the start or after the end of","\\t\\t\\tthe buffer.  The offset is not changed though, when","\\t\\t\\tmoving back the \'scrollbind\' window will try to scroll","\\t\\t\\tto the desired position when possible.","\\t\\t\\tWhen now making that window the current one, two","\\t\\t\\tthings can be done with the relative offset:","\\t\\t\\t1. When \\"jump\\" is not included, the relative offset is","\\t\\t\\t   adjusted for the scroll position in the new current","\\t\\t\\t   window.  When going back to the other window, the","\\t\\t\\t   new relative offset will be used.","\\t\\t\\t2. When \\"jump\\" is included, the other windows are","\\t\\t\\t   scrolled to keep the same relative offset.  When","\\t\\t\\t   going back to the other window, it still uses the","\\t\\t\\t   same relative offset.","\\tAlso see |scroll-binding|.","\\tWhen \'diff\' mode is active there always is vertical scroll binding,","\\teven when \\"ver\\" isn\'t there."],"sections":["string\\t(default \\"SHNHH HUnhsh\\")","\\t\\t\\tglobal","\\tSpecifies the nroff macros that separate sections.  These are pairs of","\\ttwo letters (See |object-motions|).  The default makes a section start","\\tat the nroff macros \\".SH\\", \\".NH\\", \\".H\\", \\".HU\\", \\".nh\\" and \\".sh\\"."],"secure":["boolean\\t(default off)","\\t\\t\\tglobal","\\tWhen on, \\":autocmd\\", shell and write commands are not allowed in","\\t\\".nvimrc\\" and \\".exrc\\" in the current directory and map commands are","\\tdisplayed.  Switch it off only if you know that you will not run into","\\tproblems, or when the \'exrc\' option is off.  On Unix this option is","\\tonly used if the \\".nvimrc\\" or \\".exrc\\" is not owned by you.  This can be","\\tdangerous if the systems allows users to do a \\"chown\\".  You better set","\\t\'secure\' at the end of your |init.vim| then.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"selection":["string\\t(default \\"inclusive\\")","\\t\\t\\tglobal","\\tThis option defines the behavior of the selection.  It is only used","\\tin Visual and Select mode.","\\tPossible values:","\\t   value\\tpast line     inclusive ~","\\t   old\\t\\t   no\\t\\tyes","\\t   inclusive\\t   yes\\t\\tyes","\\t   exclusive\\t   yes\\t\\tno","\\t\\"past line\\" means that the cursor is allowed to be positioned one","\\tcharacter past the line.","\\t\\"inclusive\\" means that the last character of the selection is included","\\tin an operation.  For example, when \\"x\\" is used to delete the","\\tselection.","\\tWhen \\"old\\" is used and \'virtualedit\' allows the cursor to move past","\\tthe end of line the line break still isn\'t included.","\\tNote that when \\"exclusive\\" is used and selecting from the end","\\tbackwards, you cannot include the last character of a line, when","\\tstarting in Normal mode and \'virtualedit\' empty."],"selectmode":["string\\t(default \\"\\")","\\t\\t\\tglobal","\\tThis is a comma separated list of words, which specifies when to start","\\tSelect mode instead of Visual mode, when a selection is started.","\\tPossible values:","\\t   mouse\\twhen using the mouse","\\t   key\\t\\twhen using shifted special keys","\\t   cmd\\t\\twhen using \\"v\\", \\"V\\" or CTRL-V","\\tSee |Select-mode|.","\\tThe \'selectmode\' option is set by the |:behave| command."],"sessionoptions":["string\\t(default: \\"blank,buffers,curdir,folds,","\\t\\t\\t\\t\\t       help,tabpages,winsize\\"","\\t\\t\\t\\t Vi default: \\"blank,buffers,curdir,folds,","\\t\\t\\t\\t\\t       help,options,tabpages,winsize\\")","\\t\\t\\tglobal","\\tChanges the effect of the |:mksession| command.  It is a comma","\\tseparated list of words.  Each word enables saving and restoring","\\tsomething:","\\t   word\\t\\tsave and restore ~","\\t   blank\\tempty windows","\\t   buffers\\thidden and unloaded buffers, not just those in windows","\\t   curdir\\tthe current directory","\\t   folds\\tmanually created folds, opened/closed folds and local","\\t\\t\\tfold options","\\t   globals\\tglobal variables that start with an uppercase letter","\\t\\t\\tand contain at least one lowercase letter.  Only","\\t\\t\\tString and Number types are stored.","\\t   help\\t\\tthe help window","\\t   localoptions\\toptions and mappings local to a window or buffer (not","\\t\\t\\tglobal values for local options)","\\t   options\\tall options and mappings (also global values for local","\\t\\t\\toptions)","\\t   resize\\tsize of the Vim window: \'lines\' and \'columns\'","\\t   sesdir\\tthe directory in which the session file is located","\\t\\t\\twill become the current directory (useful with","\\t\\t\\tprojects accessed over a network from different","\\t\\t\\tsystems)","\\t   slash\\tbackslashes in file names replaced with forward","\\t\\t\\tslashes","\\t   tabpages\\tall tab pages; without this only the current tab page","\\t\\t\\tis restored, so that you can make a session for each","\\t\\t\\ttab page separately","\\t   terminal\\tinclude terminal windows where the command can be","\\t\\t\\trestored","\\t   unix\\t\\twith Unix end-of-line format (single <NL>), even when","\\t\\t\\ton Windows or DOS","\\t   winpos\\tposition of the whole Vim window","\\t   winsize\\twindow sizes"],"shada":["string\\t(Vim default for","\\t\\t\\t\\t   Win32:  !,\'100,<50,s10,h,rA:,rB:","\\t\\t\\t\\t   others: !,\'100,<50,s10,h","\\t\\t\\t\\t Vi default: \\"\\")","\\t\\t\\tglobal","\\tWhen non-empty, the shada file is read upon startup and written","\\twhen exiting Vim (see |shada-file|).  The string should be a comma","\\tseparated list of parameters, each consisting of a single character","\\tidentifying the particular parameter, followed by a number or string","\\twhich specifies the value of that parameter.  If a particular","\\tcharacter is left out, then the default value is used for that","\\tparameter.  The following is a list of the identifying characters and","\\tthe effect of their value.","\\tCHAR\\tVALUE\\t~","\\t\\t\\t\\t\\t\\t\\t*shada-!*","\\t!\\tWhen included, save and restore global variables that start","\\t\\twith an uppercase letter, and don\'t contain a lowercase","\\t\\tletter.  Thus \\"KEEPTHIS and \\"K_L_M\\" are stored, but \\"KeepThis\\"","\\t\\tand \\"_K_L_M\\" are not.  Nested List and Dict items may not be","\\t\\tread back correctly, you end up with an empty item.","\\t\\t\\t\\t\\t\\t\\t*shada-quote*","\\t\\"\\tMaximum number of lines saved for each register.  Old name of","\\t\\tthe \'<\' item, with the disadvantage that you need to put a","\\t\\tbackslash before the \\", otherwise it will be recognized as the","\\t\\tstart of a comment!","\\t\\t\\t\\t\\t\\t\\t*shada-%*","\\t%\\tWhen included, save and restore the buffer list.  If Vim is","\\t\\tstarted with a file name argument, the buffer list is not","\\t\\trestored.  If Vim is started without a file name argument, the","\\t\\tbuffer list is restored from the shada file.  Quickfix ","\\t\\t(\'buftype\'), unlisted (\'buflisted\'), unnamed and buffers on ","\\t\\tremovable media (|shada-r|) are not saved.","\\t\\tWhen followed by a number, the number specifies the maximum","\\t\\tnumber of buffers that are stored.  Without a number all","\\t\\tbuffers are stored.","\\t\\t\\t\\t\\t\\t\\t*shada-\'*","\\t\'\\tMaximum number of previously edited files for which the marks","\\t\\tare remembered.  This parameter must always be included when","\\t\\t\'shada\' is non-empty.","\\t\\tIncluding this item also means that the |jumplist| and the","\\t\\t|changelist| are stored in the shada file.","\\t\\t\\t\\t\\t\\t\\t*shada-/*","\\t/\\tMaximum number of items in the search pattern history to be","\\t\\tsaved.  If non-zero, then the previous search and substitute","\\t\\tpatterns are also saved.  When not included, the value of","\\t\\t\'history\' is used.","\\t\\t\\t\\t\\t\\t\\t*shada-:*","\\t:\\tMaximum number of items in the command-line history to be","\\t\\tsaved.  When not included, the value of \'history\' is used.","\\t\\t\\t\\t\\t\\t\\t*shada-<*","\\t<\\tMaximum number of lines saved for each register.  If zero then","\\t\\tregisters are not saved.  When not included, all lines are","\\t\\tsaved.  \'\\"\' is the old name for this item.","\\t\\tAlso see the \'s\' item below: limit specified in KiB.","\\t\\t\\t\\t\\t\\t\\t*shada-@*","\\t@\\tMaximum number of items in the input-line history to be","\\t\\tsaved.  When not included, the value of \'history\' is used.","\\t\\t\\t\\t\\t\\t\\t*shada-c*","\\tc\\tDummy option, kept for compatibility reasons.  Has no actual ","\\t\\teffect: ShaDa always uses UTF-8 and \'encoding\' value is fixed ","\\t\\tto UTF-8 as well.","\\t\\t\\t\\t\\t\\t\\t*shada-f*","\\tf\\tWhether file marks need to be stored.  If zero, file marks (\'0","\\t\\tto \'9, \'A to \'Z) are not stored.  When not present or when","\\t\\tnon-zero, they are all stored.  \'0 is used for the current","\\t\\tcursor position (when exiting or when doing |:wshada|).","\\t\\t\\t\\t\\t\\t\\t*shada-h*","\\th\\tDisable the effect of \'hlsearch\' when loading the shada","\\t\\tfile.  When not included, it depends on whether \\":nohlsearch\\"","\\t\\thas been used since the last search command.","\\t\\t\\t\\t\\t\\t\\t*shada-n*","\\tn\\tName of the shada file.  The name must immediately follow","\\t\\tthe \'n\'.  Must be at the end of the option!  If the","\\t\\t\'shadafile\' option is set, that file name overrides the one","\\t\\tgiven here with \'shada\'.  Environment variables are","\\t\\texpanded when opening the file, not when setting the option.","\\t\\t\\t\\t\\t\\t\\t*shada-r*","\\tr\\tRemovable media.  The argument is a string (up to the next","\\t\\t\',\').  This parameter can be given several times.  Each","\\t\\tspecifies the start of a path for which no marks will be","\\t\\tstored.  This is to avoid removable media.  For Windows you","\\t\\tcould use \\"ra:,rb:\\".  You can also use it for temp files,","\\t\\te.g., for Unix: \\"r/tmp\\".  Case is ignored.","\\t\\t\\t\\t\\t\\t\\t*shada-s*","\\ts\\tMaximum size of an item contents in KiB.  If zero then nothing ","\\t\\tis saved.  Unlike Vim this applies to all items, except for ","\\t\\tthe buffer list and header.  Full item size is off by three ","\\t\\tunsigned integers: with `s10` maximum item size may be 1 byte ","\\t\\t(type: 7-bit integer) + 9 bytes (timestamp: up to 64-bit ","\\t\\tinteger) + 3 bytes (item size: up to 16-bit integer because ","\\t\\t2^8 < 10240 < 2^16) + 10240 bytes (requested maximum item ","\\t\\tcontents size) = 10253 bytes."],"shadafile":["string\\t(default: \\"\\")","\\t\\t\\tglobal","\\tWhen non-empty, overrides the file name used for |shada| (viminfo).","\\tWhen equal to \\"NONE\\" no shada file will be read or written.","\\tThis option can be set with the |-i| command line flag.  The |--clean|","\\tcommand line flag sets it to \\"NONE\\".","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"shell":["string\\t(default $SHELL or \\"sh\\",","\\t\\t\\t\\t\\tWindows: \\"cmd.exe\\")","\\t\\t\\tglobal","\\tName of the shell to use for ! and :! commands.  When changing the","\\tvalue also check these options: \'shellpipe\', \'shellslash\'","\\t\'shellredir\', \'shellquote\', \'shellxquote\' and \'shellcmdflag\'.","\\tIt is allowed to give an argument to the command, e.g.  \\"csh -f\\".","\\tSee |option-backslash| about including spaces and backslashes.","\\tEnvironment variables are expanded |:set_env|.","\\tIf the name of the shell contains a space, you might need to enclose","\\tit in quotes.  Example: >","\\t\\t:set shell=\\\\\\"c:\\\\program\\\\ files\\\\unix\\\\sh.exe\\\\\\"\\\\ -f","<\\tNote the backslash before each quote (to avoid starting a comment) and ","\\teach space (to avoid ending the option value), so better use |:let-&| ","\\tlike this: >","\\t\\t:let &shell=\'\\"C:\\\\Program Files\\\\unix\\\\sh.exe\\" -f\'","<\\tAlso note that the \\"-f\\" is not inside the quotes, because it is not ","\\tpart of the command name.","\\t\\t\\t\\t\\t\\t\\t*shell-unquoting*","\\tRules regarding quotes:","\\t1. Option is split on space and tab characters that are not inside ","\\t   quotes: \\"abc def\\" runs shell named \\"abc\\" with additional argument ","\\t   \\"def\\", \'\\"abc def\\"\' runs shell named \\"abc def\\" with no additional ","\\t   arguments (here and below: additional means “additional to ","\\t   \'shellcmdflag\'”).","\\t2. Quotes in option may be present in any position and any number: ","\\t   \'\\"abc\\"\', \'\\"a\\"bc\', \'a\\"b\\"c\', \'ab\\"c\\"\' and \'\\"a\\"b\\"c\\"\' are all equivalent ","\\t   to just \\"abc\\".","\\t3. Inside quotes backslash preceding backslash means one backslash.  ","\\t   Backslash preceding quote means one quote. Backslash preceding ","\\t   anything else means backslash and next character literally: ","\\t   \'\\"a\\\\\\\\b\\"\' is the same as \\"a\\\\b\\", \'\\"a\\\\\\\\\\"b\\"\' runs shell named literally ","\\t   \'a\\"b\', \'\\"a\\\\b\\"\' is the same as \\"a\\\\b\\" again.","\\t4. Outside of quotes backslash always means itself, it cannot be used ","\\t   to escape quote: \'a\\\\\\"b\\"\' is the same as \\"a\\\\b\\".","\\tNote that such processing is done after |:set| did its own round of ","\\tunescaping, so to keep yourself sane use |:let-&| like shown above.","\\t\\t\\t\\t\\t\\t\\t*shell-powershell*","\\tTo use powershell: >","\\t\\tlet &shell = has(\'win32\') ? \'powershell\' : \'pwsh\'","\\t\\tset shellquote= shellpipe=\\\\| shellxquote=","\\t\\tset shellcmdflag=-NoLogo\\\\ -NoProfile\\\\ -ExecutionPolicy\\\\ RemoteSigned\\\\ -Command","\\t\\tset shellredir=\\\\|\\\\ Out-File\\\\ -Encoding\\\\ UTF8"],"shellcmdflag":["string\\t(default: \\"-c\\"; Windows: \\"/s /c\\")","\\t\\t\\tglobal","\\tFlag passed to the shell to execute \\"!\\" and \\":!\\" commands; e.g.,","\\t`bash.exe -c ls` or `cmd.exe /s /c \\"dir\\"`.  For Windows","\\tsystems, the default is set according to the value of \'shell\', to","\\treduce the need to set this option by the user.","\\tOn Unix it can have more than one flag.  Each white space separated","\\tpart is passed as an argument to the shell command.","\\tSee |option-backslash| about including spaces and backslashes.","\\tSee |shell-unquoting| which talks about separating this option into ","\\tmultiple arguments.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"shellpipe":["string\\t(default \\">\\", \\"| tee\\", \\"|& tee\\" or \\"2>&1| tee\\")","\\t\\t\\tglobal","\\tString to be used to put the output of the \\":make\\" command in the","\\terror file.  See also |:make_makeprg|.  See |option-backslash| about","\\tincluding spaces and backslashes.","\\tThe name of the temporary file can be represented by \\"%s\\" if necessary","\\t(the file name is appended automatically if no %s appears in the value","\\tof this option).","\\tFor Windows the default is \\">\\".  The output is directly saved in a file","\\tand not echoed to the screen.","\\tFor Unix the default it \\"| tee\\".  The stdout of the compiler is saved","\\tin a file and echoed to the screen.  If the \'shell\' option is \\"csh\\" or","\\t\\"tcsh\\" after initializations, the default becomes \\"|& tee\\".  If the","\\t\'shell\' option is \\"sh\\", \\"ksh\\", \\"mksh\\", \\"pdksh\\", \\"zsh\\" or \\"bash\\" the","\\tdefault becomes \\"2>&1| tee\\".  This means that stderr is also included.","\\tBefore using the \'shell\' option a path is removed, thus \\"/bin/sh\\" uses","\\t\\"sh\\".","\\tThe initialization of this option is done after reading the vimrc","\\tand the other initializations, so that when the \'shell\' option is set","\\tthere, the \'shellpipe\' option changes automatically, unless it was","\\texplicitly set before.","\\tWhen \'shellpipe\' is set to an empty string, no redirection of the","\\t\\":make\\" output will be done.  This is useful if you use a \'makeprg\'","\\tthat writes to \'makeef\' by itself.  If you want no piping, but do","\\twant to include the \'makeef\', set \'shellpipe\' to a single space.","\\tDon\'t forget to precede the space with a backslash: \\":set sp=\\\\ \\".","\\tIn the future pipes may be used for filtering and this option will","\\tbecome obsolete (at least for Unix).","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"shellquote":["string\\t(default: \\"\\"; Windows, when \'shell\'","\\t\\t\\t\\t\\tcontains \\"sh\\" somewhere: \\"\\\\\\"\\")","\\t\\t\\tglobal","\\tQuoting character(s), put around the command passed to the shell, for","\\tthe \\"!\\" and \\":!\\" commands.  The redirection is kept outside of the","\\tquoting.  See \'shellxquote\' to include the redirection.  It\'s","\\tprobably not useful to set both options.","\\tThis is an empty string by default.  Only known to be useful for","\\tthird-party shells on Windows systems, such as the MKS Korn Shell","\\tor bash, where it should be \\"\\\\\\"\\".  The default is adjusted according","\\tthe value of \'shell\', to reduce the need to set this option by the","\\tuser.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"shellredir":["string\\t(default \\">\\", \\">&\\" or \\">%s 2>&1\\")","\\t\\t\\tglobal","\\tString to be used to put the output of a filter command in a temporary","\\tfile.  See also |:!|.  See |option-backslash| about including spaces","\\tand backslashes.","\\tThe name of the temporary file can be represented by \\"%s\\" if necessary","\\t(the file name is appended automatically if no %s appears in the value","\\tof this option).","\\tThe default is \\">\\".  For Unix, if the \'shell\' option is \\"csh\\", \\"tcsh\\"","\\tor \\"zsh\\" during initializations, the default becomes \\">&\\".  If the","\\t\'shell\' option is \\"sh\\", \\"ksh\\" or \\"bash\\" the default becomes","\\t\\">%s 2>&1\\".  This means that stderr is also included.","\\tFor Win32, the Unix checks are done and additionally \\"cmd\\" is checked","\\tfor, which makes the default \\">%s 2>&1\\".  Also, the same names with","\\t\\".exe\\" appended are checked for.","\\tThe initialization of this option is done after reading the vimrc","\\tand the other initializations, so that when the \'shell\' option is set","\\tthere, the \'shellredir\' option changes automatically unless it was","\\texplicitly set before.","\\tIn the future pipes may be used for filtering and this option will","\\tbecome obsolete (at least for Unix).","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"shellslash":["boolean\\t(default off)","\\t\\t\\tglobal","\\t\\t\\t{only for Windows}","\\tWhen set, a forward slash is used when expanding file names.  This is","\\tuseful when a Unix-like shell is used instead of command.com or","\\tcmd.exe.  Backward slashes can still be typed, but they are changed to","\\tforward slashes by Vim.","\\tNote that setting or resetting this option has no effect for some","\\texisting file names, thus this option needs to be set before opening","\\tany file for best results.  This might change in the future.","\\t\'shellslash\' only works when a backslash can be used as a path","\\tseparator.  To test if this is so use: >","\\t\\tif exists(\'+shellslash\')","<","\\t\\t\\t*\'shelltemp\'* *\'stmp\'* *\'noshelltemp\'* *\'nostmp\'*"],"shelltemp":["boolean\\t(Vim default on, Vi default off)","\\t\\t\\tglobal","\\tWhen on, use temp files for shell commands.  When off use a pipe.","\\tWhen using a pipe is not possible temp files are used anyway.","\\tThe advantage of using a pipe is that nobody can read the temp file","\\tand the \'shell\' command does not need to support redirection.","\\tThe advantage of using a temp file is that the file type and encoding","\\tcan be detected.","\\tThe |FilterReadPre|, |FilterReadPost| and |FilterWritePre|,","\\t|FilterWritePost| autocommands event are not triggered when","\\t\'shelltemp\' is off.","\\t|system()| does not respect this option, it always uses pipes."],"shellxescape":["string\\t(default: \\"\\")","\\t\\t\\tglobal","\\tWhen \'shellxquote\' is set to \\"(\\" then the characters listed in this","\\toption will be escaped with a \'^\' character.  This makes it possible","\\tto execute most external commands with cmd.exe."],"shellxquote":["string\\t(default: \\"\\", Windows: \\"\\\\\\"\\")","\\t\\t\\tglobal","\\tQuoting character(s), put around the command passed to the shell, for","\\tthe \\"!\\" and \\":!\\" commands.  Includes the redirection.  See","\\t\'shellquote\' to exclude the redirection.  It\'s probably not useful","\\tto set both options.","\\tWhen the value is \'(\' then \')\' is appended. When the value is \'\\"(\'","\\tthen \')\\"\' is appended.","\\tWhen the value is \'(\' then also see \'shellxescape\'.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"shiftround":["boolean\\t(default off)","\\t\\t\\tglobal","\\tRound indent to multiple of \'shiftwidth\'.  Applies to > and <","\\tcommands.  CTRL-T and CTRL-D in Insert mode always round the indent to","\\ta multiple of \'shiftwidth\' (this is Vi compatible)."],"shiftwidth":["number\\t(default 8)","\\t\\t\\tlocal to buffer","\\tNumber of spaces to use for each step of (auto)indent.  Used for","\\t|\'cindent\'|, |>>|, |<<|, etc.","\\tWhen zero the \'ts\' value will be used.  Use the |shiftwidth()|","\\tfunction to get the effective shiftwidth value."],"shortmess":["string\\t(Vim default \\"filnxtToOF\\", Vi default: \\"S\\")","\\t\\t\\tglobal","\\tThis option helps to avoid all the |hit-enter| prompts caused by file","\\tmessages, for example  with CTRL-G, and to avoid some other messages.","\\tIt is a list of flags:","\\t flag\\tmeaning when present\\t~","\\t  f\\tuse \\"(3 of 5)\\" instead of \\"(file 3 of 5)\\"","\\t  i\\tuse \\"[noeol]\\" instead of \\"[Incomplete last line]\\"","\\t  l\\tuse \\"999L, 888C\\" instead of \\"999 lines, 888 characters\\"","\\t  m\\tuse \\"[+]\\" instead of \\"[Modified]\\"","\\t  n\\tuse \\"[New]\\" instead of \\"[New File]\\"","\\t  r\\tuse \\"[RO]\\" instead of \\"[readonly]\\"","\\t  w\\tuse \\"[w]\\" instead of \\"written\\" for file write message","\\t\\tand \\"[a]\\" instead of \\"appended\\" for \':w >> file\' command","\\t  x\\tuse \\"[dos]\\" instead of \\"[dos format]\\", \\"[unix]\\" instead of","\\t\\t\\"[unix format]\\" and \\"[mac]\\" instead of \\"[mac format]\\".","\\t  a\\tall of the above abbreviations"],"showbreak":["string\\t(default \\"\\")","\\t\\t\\tglobal","\\tString to put at the start of lines that have been wrapped.  Useful","\\tvalues are \\"> \\" or \\"+++ \\": >","\\t\\t:set showbreak=>\\\\ ","<\\tNote the backslash to escape the trailing space.  It\'s easier like","\\tthis: >","\\t\\t:let &showbreak = \'+++ \'","<\\tOnly printable single-cell characters are allowed, excluding <Tab> and","\\tcomma (in a future version the comma might be used to separate the","\\tpart that is shown at the end and at the start of a line).","\\tThe |hl-NonText| highlight group determines the highlighting.","\\tNote that tabs after the showbreak will be displayed differently.","\\tIf you want the \'showbreak\' to appear in between line numbers, add the","\\t\\"n\\" flag to \'cpoptions\'."],"showcmd":["boolean\\t(Vim default: on, Vi default: off)","\\t\\t\\tglobal","\\tShow (partial) command in the last line of the screen.  Set this","\\toption off if your terminal is slow.","\\tIn Visual mode the size of the selected area is shown:","\\t- When selecting characters within a line, the number of characters.","\\t  If the number of bytes is different it is also displayed: \\"2-6\\"","\\t  means two characters and six bytes.","\\t- When selecting more than one line, the number of lines.","\\t- When selecting a block, the size in screen characters:","\\t  {lines}x{columns}."],"showfulltag":["boolean (default off)","\\t\\t\\tglobal","\\tWhen completing a word in insert mode (see |ins-completion|) from the","\\ttags file, show both the tag name and a tidied-up form of the search","\\tpattern (if there is one) as possible matches.  Thus, if you have","\\tmatched a C function, you can see a template for what arguments are","\\trequired (coding style permitting).","\\tNote that this doesn\'t work well together with having \\"longest\\" in","\\t\'completeopt\', because the completion from the search pattern may not","\\tmatch the typed text."],"showmatch":["boolean\\t(default off)","\\t\\t\\tglobal","\\tWhen a bracket is inserted, briefly jump to the matching one.  The","\\tjump is only done if the match can be seen on the screen.  The time to","\\tshow the match can be set with \'matchtime\'.","\\tA Beep is given if there is no match (no matter if the match can be","\\tseen or not).","\\tThis option is reset when \'paste\' is set and restored when \'paste\' is","\\treset.","\\tWhen the \'m\' flag is not included in \'cpoptions\', typing a character","\\twill immediately move the cursor back to where it belongs.","\\tSee the \\"sm\\" field in \'guicursor\' for setting the cursor shape and","\\tblinking when showing the match.","\\tThe \'matchpairs\' option can be used to specify the characters to show","\\tmatches for.  \'rightleft\' and \'revins\' are used to look for opposite","\\tmatches.","\\tAlso see the matchparen plugin for highlighting the match when moving","\\taround |pi_paren.txt|.","\\tNote: Use of the short form is rated PG."],"showmode":["boolean\\t(Vim default: on, Vi default: off)","\\t\\t\\tglobal","\\tIf in Insert, Replace or Visual mode put a message on the last line.","\\tThe |hl-ModeMsg| highlight group determines the highlighting."],"showtabline":["number\\t(default 1)","\\t\\t\\tglobal","\\tThe value of this option specifies when the line with tab page labels","\\twill be displayed:","\\t\\t0: never","\\t\\t1: only if there are at least two tab pages","\\t\\t2: always","\\tThis is both for the GUI and non-GUI implementation of the tab pages","\\tline.","\\tSee |tab-page| for more information about tab pages."],"sidescroll":["number\\t(default 1)","\\t\\t\\tglobal","\\tThe minimal number of columns to scroll horizontally.  Used only when","\\tthe \'wrap\' option is off and the cursor is moved off of the screen.","\\tWhen it is zero the cursor will be put in the middle of the screen.","\\tWhen using a slow terminal set it to a large number or 0.  Not used","\\tfor \\"zh\\" and \\"zl\\" commands."],"sidescrolloff":["number (default 0)","\\t\\t\\tglobal or local to window |global-local|","\\tThe minimal number of screen columns to keep to the left and to the","\\tright of the cursor if \'nowrap\' is set.  Setting this option to a","\\tvalue greater than 0 while having |\'sidescroll\'| also at a non-zero","\\tvalue makes some context visible in the line you are scrolling in","\\thorizontally (except at beginning of the line).  Setting this option","\\tto a large value (like 999) has the effect of keeping the cursor","\\thorizontally centered in the window, as long as one does not come too","\\tclose to the beginning of the line.","\\tAfter using the local value, go back the global value with one of","\\tthese two: >","\\t\\tsetlocal sidescrolloff<","\\t\\tsetlocal sidescrolloff=-1","<","\\tExample: Try this together with \'sidescroll\' and \'listchars\' as","\\t\\t in the following example to never allow the cursor to move","\\t\\t onto the \\"extends\\" character: >"],"signcolumn":["string\\t(default \\"auto\\")","\\t\\t\\tlocal to window","\\tWhen and how to draw the signcolumn. Valid values are:","\\t   \\"auto\\"   \\tonly when there is a sign to display","\\t   \\"auto:[1-9]\\" resize to accommodate multiple signs up to the","\\t                given number (maximum 9), e.g. \\"auto:4\\"","\\t   \\"no\\"\\t    \\tnever","\\t   \\"yes\\"    \\talways","\\t   \\"yes:[1-9]\\"  always, with fixed space for signs up to the given","\\t                number (maximum 9), e.g. \\"yes:3\\""],"smartcase":["boolean\\t(default off)","\\t\\t\\tglobal","\\tOverride the \'ignorecase\' option if the search pattern contains upper","\\tcase characters.  Only used when the search pattern is typed and","\\t\'ignorecase\' option is on.  Used for the commands \\"/\\", \\"?\\", \\"n\\", \\"N\\",","\\t\\":g\\" and \\":s\\".  Not used for \\"*\\", \\"#\\", \\"gd\\", tag search, etc.  After","\\t\\"*\\" and \\"#\\" you can make \'smartcase\' used by doing a \\"/\\" command,","\\trecalling the search pattern from history and hitting <Enter>."],"smartindent":["boolean\\t(default off)","\\t\\t\\tlocal to buffer","\\tDo smart autoindenting when starting a new line.  Works for C-like","\\tprograms, but can also be used for other languages.  \'cindent\' does","\\tsomething like this, works better in most cases, but is more strict,","\\tsee |C-indenting|.  When \'cindent\' is on or \'indentexpr\' is set,","\\tsetting \'si\' has no effect.  \'indentexpr\' is a more advanced","\\talternative.","\\tNormally \'autoindent\' should also be on when using \'smartindent\'.","\\tAn indent is automatically inserted:","\\t- After a line ending in \'{\'.","\\t- After a line starting with a keyword from \'cinwords\'.","\\t- Before a line starting with \'}\' (only with the \\"O\\" command).","\\tWhen typing \'}\' as the first character in a new line, that line is","\\tgiven the same indent as the matching \'{\'.","\\tWhen typing \'#\' as the first character in a new line, the indent for","\\tthat line is removed, the \'#\' is put in the first column.  The indent","\\tis restored for the next line.  If you don\'t want this, use this","\\tmapping: \\":inoremap # X^H#\\", where ^H is entered with CTRL-V CTRL-H.","\\tWhen using the \\">>\\" command, lines starting with \'#\' are not shifted","\\tright.","\\tThis option is reset when \'paste\' is set and restored when \'paste\' is","\\treset."],"smarttab":["boolean\\t(default on)","\\t\\t\\tglobal","\\tWhen on, a <Tab> in front of a line inserts blanks according to","\\t\'shiftwidth\'.  \'tabstop\' or \'softtabstop\' is used in other places.  A","\\t<BS> will delete a \'shiftwidth\' worth of space at the start of the","\\tline.","\\tWhen off, a <Tab> always inserts blanks according to \'tabstop\' or","\\t\'softtabstop\'.  \'shiftwidth\' is only used for shifting text left or","\\tright |shift-left-right|.","\\tWhat gets inserted (a <Tab> or spaces) depends on the \'expandtab\'","\\toption.  Also see |ins-expandtab|.  When \'expandtab\' is not set, the","\\tnumber of spaces is minimized by using <Tab>s.","\\tThis option is reset when \'paste\' is set and restored when \'paste\' is","\\treset."],"softtabstop":["number\\t(default 0)","\\t\\t\\tlocal to buffer","\\tNumber of spaces that a <Tab> counts for while performing editing","\\toperations, like inserting a <Tab> or using <BS>.  It \\"feels\\" like","\\t<Tab>s are being inserted, while in fact a mix of spaces and <Tab>s is","\\tused.  This is useful to keep the \'ts\' setting at its standard value","\\tof 8, while being able to edit like it is set to \'sts\'.  However,","\\tcommands like \\"x\\" still work on the actual characters.","\\tWhen \'sts\' is zero, this feature is off.","\\tWhen \'sts\' is negative, the value of \'shiftwidth\' is used.","\\t\'softtabstop\' is set to 0 when the \'paste\' option is set and restored","\\twhen \'paste\' is reset.","\\tSee also |ins-expandtab|.  When \'expandtab\' is not set, the number of","\\tspaces is minimized by using <Tab>s.","\\tThe \'L\' flag in \'cpoptions\' changes how tabs are used when \'list\' is","\\tset."],"spell":["boolean\\t(default off)","\\t\\t\\tlocal to window","\\tWhen on spell checking will be done.  See |spell|.","\\tThe languages are specified with \'spelllang\'."],"spellcapcheck":["string\\t(default \\"[.?!]\\\\_[\\\\])\'\\" \\\\t]\\\\+\\")","\\t\\t\\tlocal to buffer","\\tPattern to locate the end of a sentence.  The following word will be","\\tchecked to start with a capital letter.  If not then it is highlighted","\\twith SpellCap |hl-SpellCap| (unless the word is also badly spelled).","\\tWhen this check is not wanted make this option empty.","\\tOnly used when \'spell\' is set.","\\tBe careful with special characters, see |option-backslash| about","\\tincluding spaces and backslashes.","\\tTo set this option automatically depending on the language, see","\\t|set-spc-auto|."],"spellfile":["string\\t(default empty)","\\t\\t\\tlocal to buffer","\\tName of the word list file where words are added for the |zg| and |zw|","\\tcommands.  It must end in \\".{encoding}.add\\".  You need to include the","\\tpath, otherwise the file is placed in the current directory.","\\t\\t\\t\\t\\t\\t\\t\\t*E765*","\\tIt may also be a comma separated list of names.  A count before the","\\t|zg| and |zw| commands can be used to access each.  This allows using","\\ta personal word list file and a project word list file.","\\tWhen a word is added while this option is empty Vim will set it for","\\tyou: Using the first directory in \'runtimepath\' that is writable.  If","\\tthere is no \\"spell\\" directory yet it will be created.  For the file","\\tname the first language name that appears in \'spelllang\' is used,","\\tignoring the region.","\\tThe resulting \\".spl\\" file will be used for spell checking, it does not","\\thave to appear in \'spelllang\'.","\\tNormally one file is used for all regions, but you can add the region","\\tname if you want to.  However, it will then only be used when","\\t\'spellfile\' is set to it, for entries in \'spelllang\' only files","\\twithout region name will be found.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"spelllang":["string\\t(default \\"en\\")","\\t\\t\\tlocal to buffer","\\tA comma separated list of word list names.  When the \'spell\' option is","\\ton spellchecking will be done for these languages.  Example: >","\\t\\tset spelllang=en_us,nl,medical","<\\tThis means US English, Dutch and medical words are recognized.  Words","\\tthat are not recognized will be highlighted.","\\tThe word list name must consist of alphanumeric characters, a dash or","\\tan underscore.  It should not include a comma or dot.  Using a dash is","\\trecommended to separate the two letter language name from a","\\tspecification.  Thus \\"en-rare\\" is used for rare English words.","\\tA region name must come last and have the form \\"_xx\\", where \\"xx\\" is","\\tthe two-letter, lower case region name.  You can use more than one","\\tregion by listing them: \\"en_us,en_ca\\" supports both US and Canadian","\\tEnglish, but not words specific for Australia, New Zealand or Great","\\tBritain. (Note: currently en_au and en_nz dictionaries are older than","\\ten_ca, en_gb and en_us).","\\tIf the name \\"cjk\\" is included East Asian characters are excluded from","\\tspell checking.  This is useful when editing text that also has Asian","\\twords.","\\t\\t\\t\\t\\t\\t\\t*E757*","\\tAs a special case the name of a .spl file can be given as-is.  The","\\tfirst \\"_xx\\" in the name is removed and used as the region name","\\t(_xx is an underscore, two letters and followed by a non-letter).","\\tThis is mainly for testing purposes.  You must make sure the correct","\\tencoding is used, Vim doesn\'t check it.","\\tHow the related spell files are found is explained here: |spell-load|."],"spellsuggest":["string\\t(default \\"best\\")","\\t\\t\\tglobal","\\tMethods used for spelling suggestions.  Both for the |z=| command and","\\tthe |spellsuggest()| function.  This is a comma-separated list of","\\titems:"],"splitbelow":["boolean\\t(default off)","\\t\\t\\tglobal","\\tWhen on, splitting a window will put the new window below the current","\\tone. |:split|"],"splitright":["boolean\\t(default off)","\\t\\t\\tglobal","\\tWhen on, splitting a window will put the new window right of the","\\tcurrent one. |:vsplit|"],"startofline":["boolean\\t(default off)","\\t\\t\\tglobal","\\tWhen \\"on\\" the commands listed below move the cursor to the first","\\tnon-blank of the line.  When off the cursor is kept in the same column","\\t(if possible).  This applies to the commands: CTRL-D, CTRL-U, CTRL-B,","\\tCTRL-F, \\"G\\", \\"H\\", \\"M\\", \\"L\\", gg, and to the commands \\"d\\", \\"<<\\" and \\">>\\"","\\twith a linewise operator, with \\"%\\" with a count and to buffer changing","\\tcommands (CTRL-^, :bnext, :bNext, etc.).  Also for an Ex command that","\\tonly has a line number, e.g., \\":25\\" or \\":+\\".","\\tIn case of buffer changing commands the cursor is placed at the column","\\twhere it was the last time the buffer was edited."],"statusline":["string\\t(default empty)","\\t\\t\\tglobal or local to window |global-local|","\\tWhen nonempty, this option determines the content of the status line.","\\tAlso see |status-line|."],"suffixes":["string\\t(default \\".bak,~,.o,.h,.info,.swp,.obj\\")","\\t\\t\\tglobal","\\tFiles with these suffixes get a lower priority when multiple files","\\tmatch a wildcard.  See |suffixes|.  Commas can be used to separate the","\\tsuffixes.  Spaces after the comma are ignored.  A dot is also seen as","\\tthe start of a suffix.  To avoid a dot or comma being recognized as a","\\tseparator, precede it with a backslash (see |option-backslash| about","\\tincluding spaces and backslashes).","\\tSee \'wildignore\' for completely ignoring files.","\\tThe use of |:set+=| and |:set-=| is preferred when adding or removing","\\tsuffixes from the list.  This avoids problems when a future version","\\tuses another default."],"suffixesadd":["string\\t(default \\"\\")","\\t\\t\\tlocal to buffer","\\tComma separated list of suffixes, which are used when searching for a","\\tfile for the \\"gf\\", \\"[I\\", etc. commands.  Example: >","\\t\\t:set suffixesadd=.java","<","\\t\\t\\t\\t*\'swapfile\'* *\'swf\'* *\'noswapfile\'* *\'noswf\'*"],"swapfile":["boolean (default on)","\\t\\t\\tlocal to buffer","\\tUse a swapfile for the buffer.  This option can be reset when a","\\tswapfile is not wanted for a specific buffer.  For example, with","\\tconfidential information that even root must not be able to access.","\\tCareful: All text will be in memory:","\\t\\t- Don\'t use this for big files.","\\t\\t- Recovery will be impossible!","\\tA swapfile will only be present when |\'updatecount\'| is non-zero and","\\t\'swapfile\' is set.","\\tWhen \'swapfile\' is reset, the swap file for the current buffer is","\\timmediately deleted.  When \'swapfile\' is set, and \'updatecount\' is","\\tnon-zero, a swap file is immediately created.","\\tAlso see |swap-file|.","\\tIf you want to open a new buffer without creating a swap file for it,","\\tuse the |:noswapfile| modifier.","\\tSee \'directory\' for where the swap file is created."],"switchbuf":["string\\t(default \\"\\")","\\t\\t\\tglobal","\\tThis option controls the behavior when switching between buffers.","\\tPossible values (comma separated list):","\\t   useopen\\tIf included, jump to the first open window that","\\t\\t\\tcontains the specified buffer (if there is one).","\\t\\t\\tOtherwise: Do not examine other windows.","\\t\\t\\tThis setting is checked with |quickfix| commands, when","\\t\\t\\tjumping to errors (\\":cc\\", \\":cn\\", \\"cp\\", etc.).  It is","\\t\\t\\talso used in all buffer related split commands, for","\\t\\t\\texample \\":sbuffer\\", \\":sbnext\\", or \\":sbrewind\\".","\\t   usetab\\tLike \\"useopen\\", but also consider windows in other tab","\\t\\t\\tpages.","\\t   split\\tIf included, split the current window before loading","\\t\\t\\ta buffer for a |quickfix| command that display errors.","\\t\\t\\tOtherwise: do not split, use current window (when used","\\t\\t\\tin the quickfix window: the previously used window or","\\t\\t\\tsplit if there is no other window).","\\t   vsplit\\tJust like \\"split\\" but split vertically.","\\t   newtab\\tLike \\"split\\", but open a new tab page.  Overrules","\\t\\t\\t\\"split\\" when both are present.","\\t   uselast\\tIf included, jump to the previously used window when","\\t\\t\\tjumping to errors with |quickfix| commands."],"synmaxcol":["number\\t(default 3000)","\\t\\t\\tlocal to buffer","\\tMaximum column in which to search for syntax items.  In long lines the","\\ttext after this column is not highlighted and following lines may not","\\tbe highlighted correctly, because the syntax state is cleared.","\\tThis helps to avoid very slow redrawing for an XML file that is one","\\tlong line.","\\tSet to zero to remove the limit."],"syntax":["string\\t(default empty)","\\t\\t\\tlocal to buffer","\\tWhen this option is set, the syntax with this name is loaded, unless","\\tsyntax highlighting has been switched off with \\":syntax off\\".","\\tOtherwise this option does not always reflect the current syntax (the","\\tb:current_syntax variable does).","\\tThis option is most useful in a modeline, for a file which syntax is","\\tnot automatically recognized.  Example, in an IDL file:","\\t\\t/* vim: set syntax=idl : */ ~","\\tWhen a dot appears in the value then this separates two filetype","\\tnames.  Example:","\\t\\t/* vim: set syntax=c.doxygen : */ ~","\\tThis will use the \\"c\\" syntax first, then the \\"doxygen\\" syntax.","\\tNote that the second one must be prepared to be loaded as an addition,","\\totherwise it will be skipped.  More than one dot may appear.","\\tTo switch off syntax highlighting for the current file, use: >","\\t\\t:set syntax=OFF","<\\tTo switch syntax highlighting on according to the current value of the","\\t\'filetype\' option: >","\\t\\t:set syntax=ON","<\\tWhat actually happens when setting the \'syntax\' option is that the","\\tSyntax autocommand event is triggered with the value as argument.","\\tThis option is not copied to another buffer, independent of the \'s\' or","\\t\'S\' flag in \'cpoptions\'.","\\tOnly normal file name characters can be used, \\"/\\\\*?[|<>\\" are illegal."],"tabline":["string\\t(default empty)","\\t\\t\\tglobal","\\tWhen nonempty, this option determines the content of the tab pages","\\tline at the top of the Vim window.  When empty Vim will use a default","\\ttab pages line.  See |setting-tabline| for more info."],"tabpagemax":["number\\t(default 50)","\\t\\t\\tglobal","\\tMaximum number of tab pages to be opened by the |-p| command line","\\targument or the \\":tab all\\" command. |tabpage|"],"tabstop":["number\\t(default 8)","\\t\\t\\tlocal to buffer","\\tNumber of spaces that a <Tab> in the file counts for.  Also see","\\t|:retab| command, and \'softtabstop\' option."],"tagbsearch":["boolean\\t(default on)","\\t\\t\\tglobal","\\tWhen searching for a tag (e.g., for the |:ta| command), Vim can either","\\tuse a binary search or a linear search in a tags file.  Binary","\\tsearching makes searching for a tag a LOT faster, but a linear search","\\twill find more tags if the tags file wasn\'t properly sorted.","\\tVim normally assumes that your tags files are sorted, or indicate that","\\tthey are not sorted.  Only when this is not the case does the","\\t\'tagbsearch\' option need to be switched off."],"tagcase":["string\\t(default \\"followic\\")","\\t\\t\\tglobal or local to buffer |global-local|","\\tThis option specifies how case is handled when searching the tags","\\tfile:","\\t   followic\\tFollow the \'ignorecase\' option","\\t   followscs    Follow the \'smartcase\' and \'ignorecase\' options","\\t   ignore\\tIgnore case","\\t   match\\tMatch case","\\t   smart\\tIgnore case unless an upper case letter is used"],"tagfunc":["string\\t(default: empty)","\\t\\t\\tlocal to buffer","\\tThis option specifies a function to be used to perform tag searches.","\\tThe function gets the tag pattern and should return a List of matching","\\ttags.  See |tag-function| for an explanation of how to write the","\\tfunction and an example."],"taglength":["number\\t(default 0)","\\t\\t\\tglobal","\\tIf non-zero, tags are significant up to this number of characters."],"tagrelative":["boolean\\t(Vim default: on, Vi default: off)","\\t\\t\\tglobal","\\tIf on and using a tags file in another directory, file names in that","\\ttags file are relative to the directory where the tags file is."],"tags":["string\\t(default \\"./tags;,tags\\")","\\t\\t\\tglobal or local to buffer |global-local|","\\tFilenames for the tag command, separated by spaces or commas.  To","\\tinclude a space or comma in a file name, precede it with a backslash","\\t(see |option-backslash| about including spaces and backslashes).","\\tWhen a file name starts with \\"./\\", the \'.\' is replaced with the path","\\tof the current file.  But only when the \'d\' flag is not included in","\\t\'cpoptions\'.  Environment variables are expanded |:set_env|.  Also see","\\t|tags-option|.","\\t\\"*\\", \\"**\\" and other wildcards can be used to search for tags files in","\\ta directory tree.  See |file-searching|.  E.g., \\"/lib/**/tags\\" will","\\tfind all files named \\"tags\\" below \\"/lib\\".  The filename itself cannot","\\tcontain wildcards, it is used as-is.  E.g., \\"/lib/**/tags?\\" will find","\\tfiles called \\"tags?\\".","\\tThe |tagfiles()| function can be used to get a list of the file names","\\tactually used.","\\tThe use of |:set+=| and |:set-=| is preferred when adding or removing","\\tfile names from the list.  This avoids problems when a future version","\\tuses another default."],"tagstack":["boolean\\t(default on)","\\t\\t\\tglobal","\\tWhen on, the |tagstack| is used normally.  When off, a \\":tag\\" or","\\t\\":tselect\\" command with an argument will not push the tag onto the","\\ttagstack.  A following \\":tag\\" without an argument, a \\":pop\\" command or","\\tany other command that uses the tagstack will use the unmodified","\\ttagstack, but does change the pointer to the active entry.","\\tResetting this option is useful when using a \\":tag\\" command in a","\\tmapping which should not change the tagstack."],"termbidi":["boolean (default off)","\\t\\t\\tglobal","\\tThe terminal is in charge of Bi-directionality of text (as specified","\\tby Unicode).  The terminal is also expected to do the required shaping","\\tthat some languages (such as Arabic) require.","\\tSetting this option implies that \'rightleft\' will not be set when","\\t\'arabic\' is set and the value of \'arabicshape\' will be ignored.","\\tNote that setting \'termbidi\' has the immediate effect that","\\t\'arabicshape\' is ignored, but \'rightleft\' isn\'t changed automatically.","\\tFor further details see |arabic.txt|."],"termguicolors":["boolean (default off)","\\t\\t\\tglobal","\\tEnables 24-bit RGB color in the |TUI|.  Uses \\"gui\\" |:highlight|","\\tattributes instead of \\"cterm\\" attributes. |highlight-guifg|","\\tRequires an ISO-8613-3 compatible terminal."],"terse":["boolean\\t(default off)","\\t\\t\\tglobal","\\tWhen set: Add \'s\' flag to \'shortmess\' option (this makes the message","\\tfor a search that hits the start or end of the file not being","\\tdisplayed).  When reset: Remove \'s\' flag from \'shortmess\' option."],"textwidth":["number\\t(default 0)","\\t\\t\\tlocal to buffer","\\tMaximum width of text that is being inserted.  A longer line will be","\\tbroken after white space to get this width.  A zero value disables","\\tthis.","\\t\'textwidth\' is set to 0 when the \'paste\' option is set and restored","\\twhen \'paste\' is reset.","\\tWhen \'textwidth\' is zero, \'wrapmargin\' may be used.  See also","\\t\'formatoptions\' and |ins-textwidth|.","\\tWhen \'formatexpr\' is set it will be used to break the line."],"thesaurus":["string\\t(default \\"\\")","\\t\\t\\tglobal or local to buffer |global-local|","\\tList of file names, separated by commas, that are used to lookup words","\\tfor thesaurus completion commands |i_CTRL-X_CTRL-T|."],"tildeop":["boolean\\t(default off)","\\t\\t\\tglobal","\\tWhen on: The tilde command \\"~\\" behaves like an operator."],"timeout":["boolean (default on)","\\t\\t\\tglobal","\\tThis option and \'timeoutlen\' determine the behavior when part of a","\\tmapped key sequence has been received. For example, if <c-f> is","\\tpressed and \'timeout\' is set, Nvim will wait \'timeoutlen\' milliseconds","\\tfor any key that can follow <c-f> in a mapping."],"ttimeout":["boolean (default on)","\\t\\t\\tglobal","\\tThis option and \'ttimeoutlen\' determine the behavior when part of a","\\tkey code sequence has been received by the |TUI|."],"timeoutlen":["number\\t(default 1000)","\\t\\t\\tglobal","\\tTime in milliseconds to wait for a mapped sequence to complete."],"ttimeoutlen":["number\\t(default 50)","\\t\\t\\tglobal","\\tTime in milliseconds to wait for a key code sequence to complete. Also","\\tused for CTRL-\\\\ CTRL-N and CTRL-\\\\ CTRL-G when part of a command has","\\tbeen typed."],"title":["boolean\\t(default off)","\\t\\t\\tglobal","\\tWhen on, the title of the window will be set to the value of","\\t\'titlestring\' (if it is not empty), or to:","\\t\\tfilename [+=-] (path) - NVIM","\\tWhere:","\\t\\tfilename\\tthe name of the file being edited","\\t\\t-\\t\\tindicates the file cannot be modified, \'ma\' off","\\t\\t+\\t\\tindicates the file was modified","\\t\\t=\\t\\tindicates the file is read-only","\\t\\t=+\\t\\tindicates the file is read-only and modified","\\t\\t(path)\\t\\tis the path of the file being edited","\\t\\t- NVIM\\t\\tthe server name |v:servername| or \\"NVIM\\""],"titlelen":["number\\t(default 85)","\\t\\t\\tglobal","\\tGives the percentage of \'columns\' to use for the length of the window","\\ttitle.  When the title is longer, only the end of the path name is","\\tshown.  A \'<\' character before the path name is used to indicate this.","\\tUsing a percentage makes this adapt to the width of the window.  But","\\tit won\'t work perfectly, because the actual number of characters","\\tavailable also depends on the font used and other things in the title","\\tbar.  When \'titlelen\' is zero the full path is used.  Otherwise,","\\tvalues from 1 to 30000 percent can be used.","\\t\'titlelen\' is also used for the \'titlestring\' option."],"titleold":["string\\t(default \\"\\")","\\t\\t\\tglobal","\\tIf not empty, this option will be used to set the window title when","\\texiting.  Only if \'title\' is enabled.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons.","\\t\\t\\t\\t\\t\\t*\'titlestring\'*"],"titlestring":["string\\t(default \\"\\")","\\t\\t\\tglobal","\\tWhen this option is not empty, it will be used for the title of the","\\twindow.  This happens only when the \'title\' option is on."],"ttyfast":["Removed. |vim-differences|"],"undodir":["string\\t(default \\"$XDG_DATA_HOME/nvim/undo\\")","\\t\\t\\tglobal","\\tList of directory names for undo files, separated with commas.","\\tSee |\'backupdir\'| for details of the format.","\\t\\".\\" means using the directory of the file.  The undo file name for","\\t\\"file.txt\\" is \\".file.txt.un~\\".","\\tFor other directories the file name is the full path of the edited","\\tfile, with path separators replaced with \\"%\\".","\\tWhen writing: The first directory that exists is used.  \\".\\" always","\\tworks, no directories after \\".\\" will be used for writing.  If none of ","\\tthe directories exist Neovim will attempt to create last directory in ","\\tthe list.","\\tWhen reading all entries are tried to find an undo file.  The first","\\tundo file that exists is used.  When it cannot be read an error is","\\tgiven, no further entry is used.","\\tSee |undo-persistence|.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"undofile":["boolean\\t(default off)","\\t\\t\\tlocal to buffer","\\tWhen on, Vim automatically saves undo history to an undo file when","\\twriting a buffer to a file, and restores undo history from the same","\\tfile on buffer read.","\\tThe directory where the undo file is stored is specified by \'undodir\'.","\\tFor more information about this feature see |undo-persistence|.","\\tThe undo file is not read when \'undoreload\' causes the buffer from","\\tbefore a reload to be saved for undo.","\\tWhen \'undofile\' is turned off the undo file is NOT deleted."],"undolevels":["number\\t(default 1000)","\\t\\t\\tglobal or local to buffer |global-local|","\\tMaximum number of changes that can be undone.  Since undo information","\\tis kept in memory, higher numbers will cause more memory to be used","\\t(nevertheless, a single change can use an unlimited amount of memory).","\\tSet to 0 for Vi compatibility: One level of undo and \\"u\\" undoes","\\titself: >","\\t\\tset ul=0","<\\tBut you can also get Vi compatibility by including the \'u\' flag in","\\t\'cpoptions\', and still be able to use CTRL-R to repeat undo.","\\tAlso see |undo-two-ways|.","\\tSet to -1 for no undo at all.  You might want to do this only for the","\\tcurrent buffer: >","\\t\\tsetlocal ul=-1","<\\tThis helps when you run out of memory for a single change."],"undoreload":["number\\t(default 10000)","\\t\\t\\tglobal","\\tSave the whole buffer for undo when reloading it.  This applies to the","\\t\\":e!\\" command and reloading for when the buffer changed outside of","\\tVim. |FileChangedShell|","\\tThe save only happens when this option is negative or when the number","\\tof lines is smaller than the value of this option.","\\tSet this option to zero to disable undo for a reload."],"updatecount":["number\\t(default: 200)","\\t\\t\\tglobal","\\tAfter typing this many characters the swap file will be written to","\\tdisk.  When zero, no swap file will be created at all (see chapter on","\\trecovery |crash-recovery|).  \'updatecount\' is set to zero by starting","\\tVim with the \\"-n\\" option, see |startup|.  When editing in readonly","\\tmode this option will be initialized to 10000.","\\tThe swapfile can be disabled per buffer with |\'swapfile\'|.","\\tWhen \'updatecount\' is set from zero to non-zero, swap files are","\\tcreated for all buffers that have \'swapfile\' set.  When \'updatecount\'","\\tis set to zero, existing swap files are not deleted.","\\tThis option has no meaning in buffers where |\'buftype\'| is \\"nofile\\"","\\tor \\"nowrite\\"."],"updatetime":["number\\t(default 4000)","\\t\\t\\tglobal","\\tIf this many milliseconds nothing is typed the swap file will be","\\twritten to disk (see |crash-recovery|).  Also used for the","\\t|CursorHold| autocommand event."],"verbose":["number\\t(default 0)","\\t\\t\\tglobal","\\tWhen bigger than zero, Vim will give messages about what it is doing.","\\tCurrently, these messages are given:","\\t>= 1\\tWhen the shada file is read or written.","\\t>= 2\\tWhen a file is \\":source\\"\'ed.","\\t>= 3\\tUI info, terminal capabilities","\\t>= 5\\tEvery searched tags file and include file.","\\t>= 8\\tFiles for which a group of autocommands is executed.","\\t>= 9\\tEvery executed autocommand.","\\t>= 12\\tEvery executed function.","\\t>= 13\\tWhen an exception is thrown, caught, finished, or discarded.","\\t>= 14\\tAnything pending in a \\":finally\\" clause.","\\t>= 15\\tEvery executed Ex command (truncated at 200 characters)."],"verbosefile":["string\\t(default empty)","\\t\\t\\tglobal","\\tWhen not empty all messages are written in a file with this name.","\\tWhen the file exists messages are appended.","\\tWriting to the file ends when Vim exits or when \'verbosefile\' is made","\\tempty.  Writes are buffered, thus may not show up for some time.","\\tSetting \'verbosefile\' to a new value is like making it empty first.","\\tThe difference with |:redir| is that verbose messages are not","\\tdisplayed when \'verbosefile\' is set."],"viewdir":["string\\t(default: \\"$XDG_DATA_HOME/nvim/view\\")","\\t\\t\\tglobal","\\tName of the directory where to store files for |:mkview|.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"viewoptions":["string\\t(default: \\"folds,options,cursor,curdir\\")","\\t\\t\\tglobal","\\tChanges the effect of the |:mkview| command.  It is a comma separated","\\tlist of words.  Each word enables saving and restoring something:","\\t   word\\t\\tsave and restore ~","\\t   cursor\\tcursor position in file and in window","\\t   curdir\\tlocal current directory, if set with |:lcd|","\\t   folds\\tmanually created folds, opened/closed folds and local","\\t\\t\\tfold options","\\t   options\\toptions and mappings local to a window or buffer (not","\\t\\t\\tglobal values for local options)","\\t   localoptions same as \\"options\\"","\\t   slash\\tbackslashes in file names replaced with forward","\\t\\t\\tslashes","\\t   unix\\t\\twith Unix end-of-line format (single <NL>), even when","\\t\\t\\ton Windows or DOS"],"virtualedit":["string\\t(default \\"\\")","\\t\\t\\tglobal","\\tA comma separated list of these words:","\\t    block\\tAllow virtual editing in Visual block mode.","\\t    insert\\tAllow virtual editing in Insert mode.","\\t    all\\t\\tAllow virtual editing in all modes.","\\t    onemore\\tAllow the cursor to move just past the end of the line"],"visualbell":["boolean\\t(default off)","\\t\\t\\tglobal","\\tUse visual bell instead of beeping.  Also see \'errorbells\'."],"warn":["boolean\\t(default on)","\\t\\t\\tglobal","\\tGive a warning message when a shell command is used while the buffer","\\thas been changed."],"whichwrap":["string\\t(Vim default: \\"b,s\\", Vi default: \\"\\")","\\t\\t\\tglobal","\\tAllow specified keys that move the cursor left/right to move to the","\\tprevious/next line when the cursor is on the first/last character in","\\tthe line.  Concatenate characters to allow this for these keys:","\\t\\tchar   key\\t  mode\\t~","\\t\\t b    <BS>\\t Normal and Visual","\\t\\t s    <Space>\\t Normal and Visual","\\t\\t h    \\"h\\"\\t Normal and Visual (not recommended)","\\t\\t l    \\"l\\"\\t Normal and Visual (not recommended)","\\t\\t <    <Left>\\t Normal and Visual","\\t\\t >    <Right>\\t Normal and Visual","\\t\\t ~    \\"~\\"\\t Normal","\\t\\t [    <Left>\\t Insert and Replace","\\t\\t ]    <Right>\\t Insert and Replace","\\tFor example: >","\\t\\t:set ww=<,>,[,]","<\\tallows wrap only when cursor keys are used.","\\tWhen the movement keys are used in combination with a delete or change","\\toperator, the <EOL> also counts for a character.  This makes \\"3h\\"","\\tdifferent from \\"3dh\\" when the cursor crosses the end of a line.  This","\\tis also true for \\"x\\" and \\"X\\", because they do the same as \\"dl\\" and","\\t\\"dh\\".  If you use this, you may also want to use the mapping","\\t\\":map <BS> X\\" to make backspace delete the character in front of the","\\tcursor.","\\tWhen \'l\' is included and it is used after an operator at the end of a","\\tline then it will not move to the next line.  This makes \\"dl\\", \\"cl\\",","\\t\\"yl\\" etc. work normally."],"wildchar":["number\\t(Vim default: <Tab>, Vi default: CTRL-E)","\\t\\t\\tglobal","\\tCharacter you have to type to start wildcard expansion in the","\\tcommand-line, as specified with \'wildmode\'.","\\tMore info here: |cmdline-completion|.","\\tThe character is not recognized when used inside a macro.  See","\\t\'wildcharm\' for that.","\\tAlthough \'wc\' is a number option, you can set it to a special key: >","\\t\\t:set wc=<Esc>","<"],"wildcharm":["number\\t(default: none (0))","\\t\\t\\tglobal","\\t\'wildcharm\' works exactly like \'wildchar\', except that it is","\\trecognized when used inside a macro.  You can find \\"spare\\" command-line","\\tkeys suitable for this option by looking at |ex-edit-index|.  Normally","\\tyou\'ll never actually type \'wildcharm\', just use it in mappings that","\\tautomatically invoke completion mode, e.g.: >","\\t\\t:set wcm=<C-Z>","\\t\\t:cnoremap ss so $vim/sessions/*.vim<C-Z>","<\\tThen after typing :ss you can use CTRL-P & CTRL-N."],"wildignore":["string\\t(default \\"\\")","\\t\\t\\tglobal","\\tA list of file patterns.  A file that matches with one of these","\\tpatterns is ignored when expanding |wildcards|, completing file or","\\tdirectory names, and influences the result of |expand()|, |glob()| and","\\t|globpath()| unless a flag is passed to disable this.","\\tThe pattern is used like with |:autocmd|, see |autocmd-pattern|.","\\tAlso see \'suffixes\'.","\\tExample: >","\\t\\t:set wildignore=*.o,*.obj","<\\tThe use of |:set+=| and |:set-=| is preferred when adding or removing","\\ta pattern from the list.  This avoids problems when a future version","\\tuses another default."],"wildignorecase":["boolean\\t(default off)","\\t\\t\\tglobal","\\tWhen set case is ignored when completing file names and directories.","\\tHas no effect when \'fileignorecase\' is set.","\\tDoes not apply when the shell is used to expand wildcards, which","\\thappens when there are special characters."],"wildmenu":["boolean\\t(default on)","\\t\\t\\tglobal","\\tEnables \\"enhanced mode\\" of command-line completion. When user hits","\\t<Tab> (or \'wildchar\') to invoke completion, the possible matches are","\\tshown in a menu just above the command-line (see \'wildoptions\'), with","\\tthe first match highlighted (overwriting the statusline).  Keys that","\\tshow the previous/next match (<Tab>/CTRL-P/CTRL-N) highlight the","\\tmatch.","\\t\'wildmode\' must specify \\"full\\": \\"longest\\" and \\"list\\" do not start","\\t\'wildmenu\' mode. You can check the current mode with |wildmenumode()|.","\\tThe menu is canceled when a key is hit that is not used for selecting","\\ta completion."],"wildmode":["string\\t(default: \\"full\\")","\\t\\t\\tglobal","\\tCompletion mode that is used for the character specified with","\\t\'wildchar\'.  It is a comma separated list of up to four parts.  Each","\\tpart specifies what to do for each consecutive use of \'wildchar\'.  The","\\tfirst part specifies the behavior for the first use of \'wildchar\',","\\tThe second part for the second use, etc.","\\tThese are the possible values for each part:","\\t\\"\\"\\t\\tComplete only the first match.","\\t\\"full\\"\\t\\tComplete the next full match.  After the last match,","\\t\\t\\tthe original string is used and then the first match","\\t\\t\\tagain.","\\t\\"longest\\"\\tComplete till longest common string.  If this doesn\'t","\\t\\t\\tresult in a longer string, use the next part.","\\t\\"longest:full\\"\\tLike \\"longest\\", but also start \'wildmenu\' if it is","\\t\\t\\tenabled.","\\t\\"list\\"\\t\\tWhen more than one match, list all matches.","\\t\\"list:full\\"\\tWhen more than one match, list all matches and","\\t\\t\\tcomplete first match.","\\t\\"list:longest\\"\\tWhen more than one match, list all matches and","\\t\\t\\tcomplete till longest common string.","\\tWhen there is only a single match, it is fully completed in all cases."],"wildoptions":["string\\t(default \\"pum,tagfile\\")","\\t\\t\\tglobal","\\tList of words that change how |cmdline-completion| is done.","\\t  pum\\t\\tDisplay the completion matches using the popupmenu","\\t\\t\\tin the same style as the |ins-completion-menu|.","\\t  tagfile\\tWhen using CTRL-D to list matching tags, the kind of","\\t\\t\\ttag and the file of the tag is listed.\\tOnly one match","\\t\\t\\tis displayed per line.  Often used tag kinds are:","\\t\\t\\t\\td\\t#define","\\t\\t\\t\\tf\\tfunction"],"winaltkeys":["string\\t(default \\"menu\\")","\\t\\t\\tglobal","\\t\\t\\t{only used in Win32}","\\tSome GUI versions allow the access to menu entries by using the ALT","\\tkey in combination with a character that appears underlined in the","\\tmenu.  This conflicts with the use of the ALT key for mappings and","\\tentering special characters.  This option tells what to do:","\\t  no\\tDon\'t use ALT keys for menus.  ALT key combinations can be","\\t\\tmapped, but there is no automatic handling.","\\t  yes\\tALT key handling is done by the windowing system.  ALT key","\\t\\tcombinations cannot be mapped.","\\t  menu\\tUsing ALT in combination with a character that is a menu","\\t\\tshortcut key, will be handled by the windowing system.  Other","\\t\\tkeys can be mapped.","\\tIf the menu is disabled by excluding \'m\' from \'guioptions\', the ALT","\\tkey is never used for the menu.","\\tThis option is not used for <F10>; on Win32."],"winblend":["number\\t(default 0)","\\t\\t\\tlocal to window","\\tEnables pseudo-transparency for a floating window. Valid values are in","\\tthe range of 0 for fully opaque window (disabled) to 100 for fully","\\ttransparent background. Values between 0-30 are typically most useful."],"window":["number  (default screen height - 1)","\\t\\t\\tglobal","\\tWindow height.  Do not confuse this with the height of the Vim window,","\\tuse \'lines\' for that.","\\tUsed for |CTRL-F| and |CTRL-B| when there is only one window and the","\\tvalue is smaller than \'lines\' minus one.  The screen will scroll","\\t\'window\' minus two lines, with a minimum of one.","\\tWhen \'window\' is equal to \'lines\' minus one CTRL-F and CTRL-B scroll","\\tin a much smarter way, taking care of wrapping lines.","\\tWhen resizing the Vim window, the value is smaller than 1 or more than","\\tor equal to \'lines\' it will be set to \'lines\' minus 1."],"winheight":["number\\t(default 1)","\\t\\t\\tglobal","\\tMinimal number of lines for the current window.  This is not a hard","\\tminimum, Vim will use fewer lines if there is not enough room.  If the","\\tfocus goes to a window that is smaller, its size is increased, at the","\\tcost of the height of other windows.","\\tSet \'winheight\' to a small number for normal editing.","\\tSet it to 999 to make the current window fill most of the screen.","\\tOther windows will be only \'winminheight\' high.  This has the drawback","\\tthat \\":all\\" will create only two windows.  To avoid \\"vim -o 1 2 3 4\\"","\\tto create only two windows, set the option after startup is done,","\\tusing the |VimEnter| event: >","\\t\\tau VimEnter * set winheight=999","<\\tMinimum value is 1.","\\tThe height is not adjusted after one of the commands that change the","\\theight of the current window.","\\t\'winheight\' applies to the current window.  Use \'winminheight\' to set","\\tthe minimal height for other windows."],"winhighlight":["string (default empty)","\\t\\t\\tlocal to window","\\tWindow-local highlights.  Comma-delimited list of highlight","\\t|group-name| pairs \\"{hl-builtin}:{hl},...\\" where each {hl-builtin} is","\\ta built-in |highlight-groups| item to be overridden by {hl} group in","\\tthe window.  Only built-in |highlight-groups| are supported, not","\\tsyntax highlighting (use |:ownsyntax| for that)."],"winfixheight":["boolean\\t(default off)","\\t\\t\\tlocal to window","\\tKeep the window height when windows are opened or closed and","\\t\'equalalways\' is set.  Also for |CTRL-W_=|.  Set by default for the","\\t|preview-window| and |quickfix-window|.","\\tThe height may be changed anyway when running out of room."],"winfixwidth":["boolean\\t(default off)","\\t\\t\\tlocal to window","\\tKeep the window width when windows are opened or closed and","\\t\'equalalways\' is set.  Also for |CTRL-W_=|.","\\tThe width may be changed anyway when running out of room."],"winminheight":["number\\t(default 1)","\\t\\t\\tglobal","\\tThe minimal height of a window, when it\'s not the current window.","\\tThis is a hard minimum, windows will never become smaller.","\\tWhen set to zero, windows may be \\"squashed\\" to zero lines (i.e. just a","\\tstatus bar) if necessary.  They will return to at least one line when","\\tthey become active (since the cursor has to have somewhere to go.)","\\tUse \'winheight\' to set the minimal height of the current window.","\\tThis option is only checked when making a window smaller.  Don\'t use a","\\tlarge number, it will cause errors when opening more than a few","\\twindows.  A value of 0 to 3 is reasonable."],"winminwidth":["number\\t(default 1)","\\t\\t\\tglobal","\\tThe minimal width of a window, when it\'s not the current window.","\\tThis is a hard minimum, windows will never become smaller.","\\tWhen set to zero, windows may be \\"squashed\\" to zero columns (i.e. just","\\ta vertical separator) if necessary.  They will return to at least one","\\tline when they become active (since the cursor has to have somewhere","\\tto go.)","\\tUse \'winwidth\' to set the minimal width of the current window.","\\tThis option is only checked when making a window smaller.  Don\'t use a","\\tlarge number, it will cause errors when opening more than a few","\\twindows.  A value of 0 to 12 is reasonable."],"winwidth":["number\\t(default 20)","\\t\\t\\tglobal","\\tMinimal number of columns for the current window.  This is not a hard","\\tminimum, Vim will use fewer columns if there is not enough room.  If","\\tthe current window is smaller, its size is increased, at the cost of","\\tthe width of other windows.  Set it to 999 to make the current window","\\talways fill the screen.  Set it to a small number for normal editing.","\\tThe width is not adjusted after one of the commands to change the","\\twidth of the current window.","\\t\'winwidth\' applies to the current window.  Use \'winminwidth\' to set","\\tthe minimal width for other windows."],"wrap":["boolean\\t(default on)","\\t\\t\\tlocal to window","\\tThis option changes how text is displayed.  It doesn\'t change the text","\\tin the buffer, see \'textwidth\' for that.","\\tWhen on, lines longer than the width of the window will wrap and","\\tdisplaying continues on the next line.  When off lines will not wrap","\\tand only part of long lines will be displayed.  When the cursor is","\\tmoved to a part that is not shown, the screen will scroll","\\thorizontally.","\\tThe line will be broken in the middle of a word if necessary.  See","\\t\'linebreak\' to get the break at a word boundary.","\\tTo make scrolling horizontally a bit more useful, try this: >","\\t\\t:set sidescroll=5","\\t\\t:set listchars+=precedes:<,extends:>","<\\tSee \'sidescroll\', \'listchars\' and |wrap-off|.","\\tThis option can\'t be set from a |modeline| when the \'diff\' option is","\\ton."],"wrapmargin":["number\\t(default 0)","\\t\\t\\tlocal to buffer","\\tNumber of characters from the right window border where wrapping","\\tstarts.  When typing text beyond this limit, an <EOL> will be inserted","\\tand inserting continues on the next line.","\\tOptions that add a margin, such as \'number\' and \'foldcolumn\', cause","\\tthe text width to be further reduced.  This is Vi compatible.","\\tWhen \'textwidth\' is non-zero, this option is not used.","\\tSee also \'formatoptions\' and |ins-textwidth|."],"wrapscan":["boolean\\t(default on)\\t\\t\\t*E384* *E385*","\\t\\t\\tglobal","\\tSearches wrap around the end of the file.  Also applies to |]s| and","\\t|[s|, searching for spelling mistakes."],"write":["boolean\\t(default on)","\\t\\t\\tglobal","\\tAllows writing files.  When not set, writing a file is not allowed.","\\tCan be used for a view-only mode, where modifications to the text are","\\tstill allowed.  Can be reset with the |-m| or |-M| command line","\\targument.  Filtering text is still possible, even though this requires","\\twriting a temporary file."],"writeany":["boolean\\t(default off)","\\t\\t\\tglobal","\\tAllows writing to any file with no need for \\"!\\" override."],"writebackup":["boolean\\t(default on with |+writebackup| feature, off","\\t\\t\\t\\t\\totherwise)","\\t\\t\\tglobal","\\tMake a backup before overwriting a file.  The backup is removed after","\\tthe file was successfully written, unless the \'backup\' option is","\\talso on.","\\tWARNING: Switching this option off means that when Vim fails to write","\\tyour buffer correctly and then, for whatever reason, Vim exits, you","\\tlose both the original file and what you were writing.  Only reset","\\tthis option if your file system is almost full and it makes the write","\\tfail (and make sure not to exit Vim until the write was successful).","\\tSee |backup-table| for another explanation.","\\tWhen the \'backupskip\' pattern matches, a backup is not made anyway."],"writedelay":["number\\t(default 0)","\\t\\t\\tglobal","\\tThe number of milliseconds to wait for each character sent to the","\\tscreen.  When positive, characters are sent to the UI one by one.","\\tSee \'redrawdebug\' for more options.  For debugging purposes."],"altkeymap":["boolean (default off)","\\t\\t\\tglobal","\\t\\t\\t{only available when compiled with the |+farsi|","\\t\\t\\tfeature}","\\tThis option was for using Farsi, which has been removed.  See","\\t|farsi.txt|."],"antialias":["boolean (default: off)","\\t\\t\\tglobal","\\t\\t\\t{only available when compiled with GUI enabled","\\t\\t\\ton Mac OS X}","\\tThis option only has an effect in the GUI version of Vim on Mac OS X","\\tv10.2 or later.  When on, Vim will use smooth (\\"antialiased\\") fonts,","\\twhich can be easier to read at certain sizes on certain displays.","\\tSetting this option can sometimes cause problems if \'guifont\' is set","\\tto its default (empty string).","\\tNOTE: This option is reset when \'compatible\' is set."],"balloonevalterm":["boolean\\t(default off)","\\t\\t\\tglobal","\\t\\t\\t{only available when compiled with the","\\t\\t\\t|+balloon_eval_term| feature}","\\tSwitch on the |balloon-eval| functionality for the terminal."],"bioskey":["boolean\\t(default on)","\\t\\t\\tglobal","\\t\\t\\t{only for MS-DOS}","\\tThis was for MS-DOS and is no longer supported."],"compatible":["boolean\\t(default on, off when a |vimrc| or |gvimrc|","\\t\\t\\t\\t\\tfile is found, reset in |defaults.vim|)","\\t\\t\\tglobal","\\tThis option has the effect of making Vim either more Vi-compatible, or","\\tmake Vim behave in a more useful way."],"completeslash":["string\\t(default: \\"\\")","\\t\\t\\tlocal to buffer","\\t\\t\\t{only for MS-Windows}","\\tWhen this option is set it overrules \'shellslash\' for completion:","\\t- When this option is set to \\"slash\\", a forward slash is used for path","\\t  completion in insert mode. This is useful when editing HTML tag, or","\\t  Makefile with \'noshellslash\' on Windows.","\\t- When this option is set to \\"backslash\\", backslash is used. This is","\\t  useful when editing a batch file with \'shellslash\' set on Windows.","\\t- When this option is empty, same character is used as for","\\t  \'shellslash\'.","\\tFor Insert mode completion the buffer-local value is used.  For","\\tcommand line completion the global value is used."],"completepopup":["string (default empty)","\\t\\t\\tglobal","\\t\\t\\t{not available when compiled without the |+textprop|","\\t\\t\\tor |+quickfix| feature}","\\tWhen \'completeopt\' contains \\"popup\\" then this option is used for the","\\tproperties of the info popup when it is created.  You can also use","\\t|popup_findinfo()| and then set properties for an existing info popup","\\twith |popup_setoptions()|.  See |complete-popup|."],"conskey":["boolean\\t(default off)","\\t\\t\\tglobal","\\tThis was for MS-DOS and is no longer supported."],"cryptmethod":["string\\t(default \\"blowfish2\\")","\\t\\t\\tglobal or local to buffer |global-local|","\\tMethod used for encryption when the buffer is written to a file:","\\t\\t\\t\\t\\t\\t\\t*pkzip*","\\t   zip\\t\\tPkZip compatible method.  A weak kind of encryption.","\\t\\t\\tBackwards compatible with Vim 7.2 and older.","\\t\\t\\t\\t\\t\\t\\t*blowfish*","\\t   blowfish\\tBlowfish method.  Medium strong encryption but it has","\\t\\t\\tan implementation flaw.  Requires Vim 7.3 or later,","\\t\\t\\tfiles can NOT be read by Vim 7.2 and older.  This adds","\\t\\t\\ta \\"seed\\" to the file, every time you write the file","\\t\\t\\tthe encrypted bytes will be different.","\\t\\t\\t\\t\\t\\t\\t*blowfish2*","\\t   blowfish2\\tBlowfish method.  Medium strong encryption.  Requires","\\t\\t\\tVim 7.4.401 or later, files can NOT be read by Vim 7.3","\\t\\t\\tand older.  This adds a \\"seed\\" to the file, every time","\\t\\t\\tyou write the file the encrypted bytes will be","\\t\\t\\tdifferent.  The whole undo file is encrypted, not just","\\t\\t\\tthe pieces of text."],"cscopeverbose":["boolean (default off)","\\t\\t\\tglobal","\\t\\t\\t{not available when compiled without the |+cscope|","\\t\\t\\tfeature}","\\tGive messages when adding a cscope database.  See |cscopeverbose|.","\\tNOTE: This option is reset when \'compatible\' is set."],"cursorlineopt":["string (default: \\"number,line\\")","\\t\\t\\tlocal to window","\\t\\t\\t{not available when compiled without the |+syntax|","\\t\\t\\tfeature}","\\tComma separated list of settings for how \'cursorline\' is displayed.","\\tValid values:","\\t\\"line\\"\\t\\tHighlight the text line of the cursor with","\\t\\t\\tCursorLine |hl-CursorLine|.","\\t\\"screenline\\"\\tHighlight only the screen line of the cursor with","\\t\\t\\tCursorLine |hl-CursorLine|.","\\t\\"number\\"\\tHighlight the line number of the cursor with","\\t\\t\\tCursorLineNr |hl-CursorLineNr|."],"edcompatible":["boolean\\t(default off)","\\t\\t\\tglobal","\\tMakes the \'g\' and \'c\' flags of the \\":substitute\\" command to be","\\ttoggled each time the flag is given.  See |complex-change|.  See","\\talso \'gdefault\' option.","\\tSwitching this option on may break plugins!"],"encoding":["string (default: \\"latin1\\" or value from $LANG)","\\t\\t\\tglobal","\\tSets the character encoding used inside Vim.  It applies to text in","\\tthe buffers, registers, Strings in expressions, text stored in the","\\tviminfo file, etc.  It sets the kind of characters which Vim can work","\\twith.  See |encoding-names| for the possible values."],"esckeys":["boolean\\t(Vim default: on, Vi default: off)","\\t\\t\\tglobal","\\tFunction keys that start with an <Esc> are recognized in Insert","\\tmode.  When this option is off, the cursor and function keys cannot be","\\tused in Insert mode if they start with an <Esc>.  The advantage of","\\tthis is that the single <Esc> is recognized immediately, instead of","\\tafter one second.  Instead of resetting this option, you might want to","\\ttry changing the values for \'timeoutlen\' and \'ttimeoutlen\'.  Note that","\\twhen \'esckeys\' is off, you can still map anything, but the cursor keys","\\twon\'t work by default.","\\tNOTE: This option is set to the Vi default value when \'compatible\' is","\\tset and to the Vim default value when \'compatible\' is reset.","\\tNOTE: when this option is off then the |modifyOtherKeys| functionality","\\tis disabled while in Insert mode to avoid ending Insert mode with any","\\tkey that has a modifier."],"exrc":["boolean (default off)","\\t\\t\\tglobal","\\tEnables the reading of .vimrc, .exrc and .gvimrc in the current","\\tdirectory."],"fkmap":["boolean (default off)\\t\\t\\t*E198*","\\t\\t\\tglobal","\\t\\t\\t{only available when compiled with the |+rightleft|","\\t\\t\\tfeature}","\\tThis option was for using Farsi, which has been removed.  See","\\t|farsi.txt|."],"guiheadroom":["number\\t(default 50)","\\t\\t\\tglobal","\\t\\t\\t{only for GTK and X11 GUI}","\\tThe number of pixels subtracted from the screen height when fitting","\\tthe GUI window on the screen.  Set this before the GUI is started,","\\te.g., in your |gvimrc| file.  When zero, the whole screen height will","\\tbe used by the window.  When positive, the specified number of pixel","\\tlines will be left for window decorations and other items on the","\\tscreen.  Set it to a negative value to allow windows taller than the","\\tscreen."],"guipty":["boolean\\t(default on)","\\t\\t\\tglobal","\\t\\t\\t{only available when compiled with GUI enabled}","\\tOnly in the GUI: If on, an attempt is made to open a pseudo-tty for","\\tI/O to/from shell commands.  See |gui-pty|."],"highlight":["string\\t(default (as a single string):","\\t\\t\\t\\t     \\"8:SpecialKey,~:EndOfBuffer,@:NonText,","\\t\\t\\t\\t     d:Directory,e:ErrorMsg,i:IncSearch,","\\t\\t\\t\\t     l:Search,m:MoreMsg,M:ModeMsg,n:LineNr,","\\t\\t\\t\\t     a:LineNrAbove,b:LineNrBelow,","\\t\\t\\t\\t     N:CursorLineNr,r:Question,s:StatusLine,","\\t\\t\\t\\t     S:StatusLineNC,c:VertSplit,t:Title,","\\t\\t\\t\\t     v:Visual,V:VisualNOS,w:WarningMsg,","\\t\\t\\t\\t     W:WildMenu,f:Folded,F:FoldColumn,","\\t\\t\\t\\t     A:DiffAdd,C:DiffChange,D:DiffDelete,","\\t\\t\\t\\t     T:DiffText,>:SignColumn,-:Conceal,","\\t\\t\\t\\t     B:SpellBad,P:SpellCap,R:SpellRare,","\\t\\t\\t\\t     L:SpellLocal,+:Pmenu,=:PmenuSel,","\\t\\t\\t\\t     x:PmenuSbar,X:PmenuThumb,*:TabLine,","\\t\\t\\t\\t     #:TabLineSel,_:TabLineFill,!:CursorColumn,","\\t\\t\\t\\t     .:CursorLine,o:ColorColumn,q:QuickFixLine,","\\t\\t\\t\\t     z:StatusLineTerm,Z:StatusLineTermNC\\")","\\t\\t\\tglobal","\\tThis option can be used to set highlighting mode for various","\\toccasions.  It is a comma separated list of character pairs.  The","\\tfirst character in a pair gives the occasion, the second the mode to","\\tuse for that occasion.  The occasions are:","\\t|hl-SpecialKey|\\t 8  Meta and special keys listed with \\":map\\"","\\t|hl-EndOfBuffer|   ~  lines after the last line in the buffer","\\t|hl-NonText|\\t @  \'@\' at the end of the window and","\\t\\t\\t    characters from \'showbreak\'","\\t|hl-Directory|\\t d  directories in CTRL-D listing and other special","\\t\\t\\t    things in listings","\\t|hl-ErrorMsg|\\t e  error messages","\\t\\t\\t h  (obsolete, ignored)","\\t|hl-IncSearch|\\t i  \'incsearch\' highlighting","\\t|hl-Search|\\t l  last search pattern highlighting (see \'hlsearch\')","\\t|hl-MoreMsg|\\t m  |more-prompt|","\\t|hl-ModeMsg|\\t M  Mode (e.g., \\"-- INSERT --\\")","\\t|hl-LineNr|\\t n  line number for \\":number\\" and \\":#\\" commands, and","\\t\\t\\t    when \'number\' or \'relativenumber\' option is set.","\\t|hl-LineNrAbove|   a  line number above the cursor for when the","\\t\\t\\t    \'relativenumber\' option is set.","\\t|hl-LineNrBelow|   b  line number below the cursor for when the","\\t\\t\\t    \'relativenumber\' option is set.","\\t|hl-CursorLineNr|  N like n for when \'cursorline\' or \'relativenumber\' is","\\t\\t\\t    set.","\\t|hl-Question|\\t r  |hit-enter| prompt and yes/no questions","\\t|hl-StatusLine|\\t s  status line of current window |status-line|","\\t|hl-StatusLineNC|  S  status lines of not-current windows","\\t|hl-Title|\\t t  Titles for output from \\":set all\\", \\":autocmd\\" etc.","\\t|hl-VertSplit|\\t c  column used to separate vertically split windows","\\t|hl-Visual|\\t v  Visual mode","\\t|hl-VisualNOS|\\t V  Visual mode when Vim does is \\"Not Owning the","\\t\\t\\t    Selection\\" Only X11 Gui\'s |gui-x11| and","\\t\\t\\t    |xterm-clipboard|.","\\t|hl-WarningMsg|\\t w  warning messages","\\t|hl-WildMenu|\\t W  wildcard matches displayed for \'wildmenu\'","\\t|hl-Folded|\\t f  line used for closed folds","\\t|hl-FoldColumn|\\t F  \'foldcolumn\'","\\t|hl-DiffAdd|\\t A  added line in diff mode","\\t|hl-DiffChange|\\t C  changed line in diff mode","\\t|hl-DiffDelete|\\t D  deleted line in diff mode","\\t|hl-DiffText|\\t T  inserted text in diff mode","\\t|hl-SignColumn|\\t >  column used for |signs|","\\t|hl-Conceal|\\t -  the placeholders used for concealed characters","\\t\\t\\t    (see \'conceallevel\')","\\t|hl-SpellBad|\\t B  misspelled word |spell|","\\t|hl-SpellCap|\\t P  word that should start with capital |spell|","\\t|hl-SpellRare|\\t R  rare word |spell|","\\t|hl-SpellLocal|\\t L  word from other region |spell|","\\t|hl-Pmenu|\\t +  popup menu normal line","\\t|hl-PmenuSel|\\t =  popup menu selected line","\\t|hl-PmenuSbar|\\t x  popup menu scrollbar","\\t|hl-PmenuThumb|\\t X  popup menu scrollbar thumb"],"imactivatefunc":["string (default \\"\\")","\\t\\t\\tglobal","\\tThis option specifies a function that will be called to","\\tactivate or deactivate the Input Method.","\\tIt is not used in the GUI.","\\tThe expression will be evaluated in the |sandbox| when set from a","\\tmodeline, see |sandbox-option|."],"imactivatekey":["string (default \\"\\")","\\t\\t\\tglobal","\\t\\t\\t{only available when compiled with |+xim| and","\\t\\t\\t|+GUI_GTK|}\\t\\t\\t\\t*E599*","\\tSpecifies the key that your Input Method in X-Windows uses for","\\tactivation.  When this is specified correctly, vim can fully control","\\tIM with \'imcmdline\', \'iminsert\' and \'imsearch\'.","\\tYou can\'t use this option to change the activation key, the option","\\ttells Vim what the key is.","\\tFormat:","\\t\\t[MODIFIER_FLAG-]KEY_STRING"],"imstatusfunc":["string (default \\"\\")","\\t\\t\\tglobal","\\tThis option specifies a function that is called to obtain the status","\\tof Input Method.  It must return a positive number when IME is active.","\\tIt is not used in the GUI."],"imstyle":["number (default 1)","\\t\\t\\tglobal","\\t\\t\\t{only available when compiled with |+xim| and","\\t\\t\\t|+GUI_GTK|}","\\tThis option specifies the input style of Input Method:","\\t0   use on-the-spot style","\\t1   over-the-spot style","\\tSee: |xim-input-style|"],"key":["string\\t(default \\"\\")","\\t\\t\\tlocal to buffer","\\t\\t\\t{only available when compiled with the |+cryptv|","\\t\\t\\tfeature}","\\tThe key that is used for encrypting and decrypting the current buffer.","\\tSee |encryption| and \'cryptmethod\'.","\\tCareful: Do not set the key value by hand, someone might see the typed","\\tkey.  Use the |:X| command.  But you can make \'key\' empty: >","\\t\\t:set key=","<\\tIt is not possible to get the value of this option with \\":set key\\" or","\\t\\"echo &key\\".  This is to avoid showing it to someone who shouldn\'t","\\tknow.  It also means you cannot see it yourself once you have set it,","\\tbe careful not to make a typing error!","\\tYou can use \\"&key\\" in an expression to detect whether encryption is","\\tenabled.  When \'key\' is set it returns \\"*****\\" (five stars)."],"langnoremap":["boolean (default off, set in |defaults.vim|)","\\t\\t\\tglobal","\\t\\t\\t{only available when compiled with the |+langmap|","\\t\\t\\tfeature}","\\tThis is just like \'langremap\' but with the value inverted.  It only","\\texists for backwards compatibility.  When setting \'langremap\' then","\\t\'langnoremap\' is set to the inverted value, and the other way around."],"luadll":["string\\t(default depends on the build)","\\t\\t\\tglobal","\\t\\t\\t{only available when compiled with the |+lua/dyn|","\\t\\t\\tfeature}","\\tSpecifies the name of the Lua shared library. The default is","\\tDYNAMIC_LUA_DLL, which was specified at compile time.","\\tEnvironment variables are expanded |:set_env|.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"macatsui":["boolean\\t(default on)","\\t\\t\\tglobal","\\t\\t\\t{only available in Mac GUI version}","\\tThis is a workaround for when drawing doesn\'t work properly.  When set","\\tand compiled with multi-byte support ATSUI text drawing is used.  When","\\tnot set ATSUI text drawing is not used.  Switch this option off when","\\tyou experience drawing problems.  In a future version the problems may","\\tbe solved and this option becomes obsolete.  Therefore use this method","\\tto unset it: >","\\t\\tif exists(\'&macatsui\')","\\t\\t   set nomacatsui","\\t\\tendif","<\\tAnother option to check if you have drawing problems is","\\t\'termencoding\'."],"maxmem":["number\\t(default between 256 to 5120 (system","\\t\\t\\t\\t dependent) or half the amount of memory","\\t\\t\\t\\t available)","\\t\\t\\tglobal","\\tMaximum amount of memory (in Kbyte) to use for one buffer.  When this","\\tlimit is reached allocating extra memory for a buffer will cause","\\tother memory to be freed.","\\tThe maximum usable value is about 2000000.  Use this to work without a","\\tlimit.","\\tThe value is ignored when \'swapfile\' is off.","\\tAlso see \'maxmemtot\'."],"maxmemtot":["number\\t(default between 2048 and 10240 (system","\\t\\t\\t\\t dependent) or half the amount of memory","\\t\\t\\t\\t available)","\\t\\t\\tglobal","\\tMaximum amount of memory in Kbyte to use for all buffers together.","\\tThe maximum usable value is about 2000000 (2 Gbyte).  Use this to work","\\twithout a limit.","\\tOn 64 bit machines higher values might work.  But hey, do you really","\\tneed more than 2 Gbyte for text editing?  Keep in mind that text is","\\tstored in the swap file, one can edit files > 2 Gbyte anyway.  We do","\\tneed the memory to store undo info.","\\tBuffers with \'swapfile\' off still count to the total amount of memory","\\tused.","\\tAlso see \'maxmem\'."],"mzschemedll":["string\\t(default depends on the build)","\\t\\t\\tglobal","\\t\\t\\t{only available when compiled with the |+mzscheme/dyn|","\\t\\t\\tfeature}","\\tSpecifies the name of the MzScheme shared library. The default is","\\tDYNAMIC_MZSCH_DLL which was specified at compile time.","\\tEnvironment variables are expanded |:set_env|.","\\tThe value must be set in the |vimrc| script or earlier.  In the","\\tstartup, before the |load-plugins| step.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"mzschemegcdll":["string\\t(default depends on the build)","\\t\\t\\tglobal","\\t\\t\\t{only available when compiled with the |+mzscheme/dyn|","\\t\\t\\tfeature}","\\tSpecifies the name of the MzScheme GC shared library. The default is","\\tDYNAMIC_MZGC_DLL which was specified at compile time.","\\tThe value can be equal to \'mzschemedll\' if it includes the GC code.","\\tEnvironment variables are expanded |:set_env|.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"mzquantum":["number\\t(default 100)","\\t\\t\\tglobal","\\t\\t\\t{not available when compiled without the |+mzscheme|","\\t\\t\\tfeature}","\\tThe number of milliseconds between polls for MzScheme threads.","\\tNegative or zero value means no thread scheduling.","\\tNOTE: This option is set to the Vim default value when \'compatible\'","\\tis reset."],"osfiletype":["string (default: \\"\\")","\\t\\t\\tlocal to buffer","\\tThis option was supported on RISC OS, which has been removed."],"perldll":["string\\t(default depends on the build)","\\t\\t\\tglobal","\\t\\t\\t{only available when compiled with the |+perl/dyn|","\\t\\t\\tfeature}","\\tSpecifies the name of the Perl shared library. The default is","\\tDYNAMIC_PERL_DLL, which was specified at compile time.","\\tEnvironment variables are expanded |:set_env|.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"previewpopup":["string (default empty)","\\t\\t\\tglobal","\\t\\t\\t{not available when compiled without the |+textprop|","\\t\\t\\tor |+quickfix| feature}","\\tWhen not empty a popup window is used for commands that would open a","\\tpreview window.  See |preview-popup|.","\\tNot used for the insert completion info, add \\"popup\\" to","\\t\'completeopt\' for that."],"pythondll":["string\\t(default depends on the build)","\\t\\t\\tglobal","\\t\\t\\t{only available when compiled with the |+python/dyn|","\\t\\t\\tfeature}","\\tSpecifies the name of the Python 2.x shared library. The default is","\\tDYNAMIC_PYTHON_DLL, which was specified at compile time.","\\tEnvironment variables are expanded |:set_env|.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"pythonhome":["string\\t(default \\"\\")","\\t\\t\\tglobal","\\t\\t\\t{only available when compiled with the |+python/dyn|","\\t\\t\\tfeature}","\\tSpecifies the name of the Python 2.x home directory. When \'pythonhome\'","\\tand the PYTHONHOME environment variable are not set, PYTHON_HOME,","\\twhich was specified at compile time, will be used for the Python 2.x","\\thome directory.","\\tEnvironment variables are expanded |:set_env|.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"renderoptions":["string  (default: empty)","\\t\\t\\tglobal","\\t\\t\\t{only available when compiled with GUI and DIRECTX on","\\t\\t\\tMS-Windows}","\\tSelect a text renderer and set its options.  The options depend on the","\\trenderer."],"restorescreen":["boolean\\t(default on)","\\t\\t\\tglobal","\\t\\t\\t{only in Windows 95/NT console version}","\\tWhen set, the screen contents is restored when exiting Vim.  This also","\\thappens when executing external commands."],"rubydll":["string\\t(default: depends on the build)","\\t\\t\\tglobal","\\t\\t\\t{only available when compiled with the |+ruby/dyn|","\\t\\t\\tfeature}","\\tSpecifies the name of the Ruby shared library. The default is","\\tDYNAMIC_RUBY_DLL, which was specified at compile time.","\\tEnvironment variables are expanded |:set_env|.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"scrollfocus":["boolean  (default off)","\\t\\t\\tglobal","\\t\\t\\t{only for MS-Windows GUI}","\\tWhen using the scroll wheel and this option is set, the window under","\\tthe mouse pointer is scrolled.  With this option off the current","\\twindow is scrolled.","\\tSystems other than MS-Windows always behave like this option is on."],"shelltype":["number\\t(default 0)","\\t\\t\\tglobal","\\t\\t\\t{only for the Amiga}","\\tOn the Amiga this option influences the way how the commands work","\\twhich use a shell.","\\t0 and 1: always use the shell","\\t2 and 3: use the shell only to filter lines","\\t4 and 5: use shell only for \':sh\' command","\\tWhen not using the shell, the command is executed directly."],"shortname":["boolean\\t(default off)","\\t\\t\\tlocal to buffer","\\tFilenames are assumed to be 8 characters plus one extension of 3","\\tcharacters.  Multiple dots in file names are not allowed.  When this","\\toption is on, dots in file names are replaced with underscores when","\\tadding an extension (\\".~\\" or \\".swp\\").  This option is not available","\\tfor MS-DOS, because then it would always be on.  This option is useful","\\twhen editing files on an MS-DOS compatible filesystem, e.g., messydos","\\tor crossdos.  When running the Win32 GUI version under Win32s, this","\\toption is always on by default."],"swapsync":["string\\t(default \\"fsync\\")","\\t\\t\\tglobal","\\tWhen this option is not empty a swap file is synced to disk after","\\twriting to it.  This takes some time, especially on busy unix systems.","\\tWhen this option is empty parts of the swap file may be in memory and","\\tnot written to disk.  When the system crashes you may lose more work.","\\tOn Unix the system does a sync now and then without Vim asking for it,","\\tso the disadvantage of setting this option off is small.  On some","\\tsystems the swap file will not be written at all.  For a unix system","\\tsetting it to \\"sync\\" will use the sync() call instead of the default","\\tfsync(), which may work better on some systems.","\\tThe \'fsync\' option is used for the actual file."],"tcldll":["string\\t(default depends on the build)","\\t\\t\\tglobal","\\t\\t\\t{only available when compiled with the |+tcl/dyn|","\\t\\t\\tfeature}","\\tSpecifies the name of the Tcl shared library. The default is","\\tDYNAMIC_TCL_DLL, which was specified at compile time.","\\tEnvironment variables are expanded |:set_env|.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"term":["string\\t(default is $TERM, if that fails:","\\t\\t\\t\\t      in the GUI: \\"builtin_gui\\"","\\t\\t\\t\\t\\ton Amiga: \\"amiga\\"","\\t\\t\\t\\t\\t on BeOS: \\"beos-ansi\\"","\\t\\t\\t\\t\\t  on Mac: \\"mac-ansi\\"","\\t\\t\\t\\t\\t on MiNT: \\"vt52\\"","\\t\\t\\t\\t       on MS-DOS: \\"pcterm\\"","\\t\\t\\t\\t\\t on OS/2: \\"os2ansi\\"","\\t\\t\\t\\t\\t on Unix: \\"ansi\\"","\\t\\t\\t\\t\\t  on VMS: \\"ansi\\"","\\t\\t\\t\\t       on Win 32: \\"win32\\")","\\t\\t\\tglobal","\\tName of the terminal.  Used for choosing the terminal control","\\tcharacters.  Environment variables are expanded |:set_env|.","\\tFor example: >","\\t\\t:set term=$TERM","<\\tSee |termcap|."],"termencoding":["string\\t(default \\"\\"; with GTK+ GUI: \\"utf-8\\"; with","\\t\\t\\t\\t\\t\\t    Macintosh GUI: \\"macroman\\")","\\t\\t\\tglobal","\\tEncoding used for the terminal.  This specifies what character","\\tencoding the keyboard produces and the display will understand.  For","\\tthe GUI it only applies to the keyboard (\'encoding\' is used for the","\\tdisplay).  Except for the Mac when \'macatsui\' is off, then","\\t\'termencoding\' should be \\"macroman\\".","\\t\\t\\t\\t\\t\\t\\t\\t*E617*","\\tNote: This does not apply to the GTK+ GUI.  After the GUI has been","\\tsuccessfully initialized, \'termencoding\' is forcibly set to \\"utf-8\\".","\\tAny attempts to set a different value will be rejected, and an error","\\tmessage is shown.","\\tFor the Win32 GUI and console versions \'termencoding\' is not used,","\\tbecause the Win32 system always passes Unicode characters.","\\tWhen empty, the same encoding is used as for the \'encoding\' option.","\\tThis is the normal value.","\\tNot all combinations for \'termencoding\' and \'encoding\' are valid.  See","\\t|encoding-table|.","\\tThe value for this option must be supported by internal conversions or","\\ticonv().  When this is not possible no conversion will be done and you","\\twill probably experience problems with non-ASCII characters.","\\tExample: You are working with the locale set to euc-jp (Japanese) and","\\twant to edit a UTF-8 file: >","\\t\\t:let &termencoding = &encoding","\\t\\t:set encoding=utf-8","<\\tYou need to do this when your system has no locale support for UTF-8."],"termwinkey":["string\\t(default \\"\\")","\\t\\t\\tlocal to window","\\tThe key that starts a CTRL-W command in a terminal window.  Other keys","\\tare sent to the job running in the window.","\\tThe <> notation can be used, e.g.: >","\\t\\t:set termwinkey=<C-L>","<\\tThe string must be one key stroke but can be multiple bytes.","\\tWhen not set CTRL-W is used, so that CTRL-W : gets you to the command","\\tline.  If \'termwinkey\' is set to CTRL-L then CTRL-L : gets you to the","\\tcommand line."],"termwinscroll":["number\\t(default 10000)","\\t\\t\\tlocal to buffer","\\t\\t\\t{not available when compiled without the","\\t\\t\\t|+terminal| feature}","\\tNumber of scrollback lines to keep.  When going over this limit the","\\tfirst 10% of the scrollback lines are deleted.  This is just to reduce","\\tthe memory usage.  See |Terminal-Normal|."],"termwinsize":["string\\t(default \\"\\")","\\t\\t\\tlocal to window","\\tSize of the |terminal| window.  Format: {rows}x{columns} or","\\t{rows}*{columns}.","\\t- When empty the terminal gets the size from the window.","\\t- When set with a \\"x\\" (e.g., \\"24x80\\") the terminal size is not","\\t  adjusted to the window size.  If the window is smaller only the","\\t  top-left part is displayed.","\\t- When set with a \\"*\\" (e.g., \\"10*50\\") the terminal size follows the","\\t  window size, but will not be smaller than the specified rows and/or","\\t  columns.","\\t- When rows is zero then use the height of the window.","\\t- When columns is zero then use the width of the window.","\\t- Using \\"0x0\\" or \\"0*0\\" is the same as empty."],"termwintype":["string  (default \\"\\")","\\t\\t\\tglobal","\\t\\t\\t{only available when compiled with the |terminal|","\\t\\t\\tfeature on MS-Windows}","\\tSpecify the virtual console (pty) used when opening the terminal","\\twindow."],"textauto":["boolean\\t(Vim default: on, Vi default: off)","\\t\\t\\tglobal","\\tThis option is obsolete.  Use \'fileformats\'.","\\tFor backwards compatibility, when \'textauto\' is set, \'fileformats\' is","\\tset to the default value for the current system.  When \'textauto\' is","\\treset, \'fileformats\' is made empty.","\\tNOTE: This option is set to the Vi default value when \'compatible\' is","\\tset and to the Vim default value when \'compatible\' is reset."],"textmode":["boolean\\t(MS-DOS, Win32 and OS/2: default on,","\\t\\t\\t\\t others: default off)","\\t\\t\\tlocal to buffer","\\tThis option is obsolete.  Use \'fileformat\'.","\\tFor backwards compatibility, when \'textmode\' is set, \'fileformat\' is","\\tset to \\"dos\\".  When \'textmode\' is reset, \'fileformat\' is set to","\\t\\"unix\\"."],"toolbar":["string\\t(default \\"icons,tooltips\\")","\\t\\t\\tglobal","\\t\\t\\t{only for |+GUI_GTK|, |+GUI_Athena|, |+GUI_Motif| and","\\t\\t\\t|+GUI_Photon|}","\\tThe contents of this option controls various toolbar settings.  The","\\tpossible values are:","\\t\\ticons\\t\\tToolbar buttons are shown with icons.","\\t\\ttext\\t\\tToolbar buttons shown with text.","\\t\\thoriz\\t\\tIcon and text of a toolbar button are","\\t\\t\\t\\thorizontally arranged.  {only in GTK+ 2 GUI}","\\t\\ttooltips\\tTooltips are active for toolbar buttons.","\\tTooltips refer to the popup help text which appears after the mouse","\\tcursor is placed over a toolbar button for a brief moment."],"toolbariconsize":["string\\t(default \\"small\\")","\\t\\t\\t\\tglobal","\\t\\t\\t\\t{only in the GTK+ GUI}","\\tControls the size of toolbar icons.  The possible values are:","\\t\\ttiny\\t\\tUse tiny icons.","\\t\\tsmall\\t\\tUse small icons (default).","\\t\\tmedium\\t\\tUse medium-sized icons.","\\t\\tlarge\\t\\tUse large icons.","\\t\\thuge\\t\\tUse even larger icons.","\\t\\tgiant\\t\\tUse very big icons.","\\tThe exact dimensions in pixels of the various icon sizes depend on","\\tthe current theme.  Common dimensions are giant=48x48, huge=32x32,","\\tlarge=24x24, medium=24x24, small=20x20 and tiny=16x16."],"ttybuiltin":["boolean\\t(default on)","\\t\\t\\tglobal","\\tWhen on, the builtin termcaps are searched before the external ones.","\\tWhen off the builtin termcaps are searched after the external ones.","\\tWhen this option is changed, you should set the \'term\' option next for","\\tthe change to take effect, for example: >","\\t\\t:set notbi term=$TERM","<\\tSee also |termcap|.","\\tRationale: The default for this option is \\"on\\", because the builtin","\\ttermcap entries are generally better (many systems contain faulty","\\txterm entries...)."],"ttymouse":["string\\t(default depends on \'term\')","\\t\\t\\tglobal","\\t\\t\\t{only in Unix and VMS, doesn\'t work in the GUI; not","\\t\\t\\tavailable when compiled without |+mouse|}","\\tName of the terminal type for which mouse codes are to be recognized.","\\tCurrently these strings are valid:","\\t\\t\\t\\t\\t\\t\\t*xterm-mouse*","\\t   xterm\\txterm-like mouse handling.  The mouse generates","\\t\\t\\t\\"<Esc>[Mscr\\", where \\"scr\\" is three bytes:","\\t\\t\\t\\t\\"s\\"  = button state","\\t\\t\\t\\t\\"c\\"  = column plus 33","\\t\\t\\t\\t\\"r\\"  = row plus 33","\\t\\t\\tThis only works up to 223 columns!  See \\"dec\\",","\\t\\t\\t\\"urxvt\\", and \\"sgr\\" for solutions.","\\t   xterm2\\tWorks like \\"xterm\\", but with the xterm reporting the","\\t\\t\\tmouse position while the mouse is dragged.  This works","\\t\\t\\tmuch faster and more precise.  Your xterm must at","\\t\\t\\tleast at patchlevel 88 / XFree 3.3.3 for this to","\\t\\t\\twork.  See below for how Vim detects this","\\t\\t\\tautomatically.","\\t\\t\\t\\t\\t\\t\\t*netterm-mouse*","\\t   netterm\\tNetTerm mouse handling.  A left mouse click generates","\\t\\t\\t\\"<Esc>}r,c<CR>\\", where \\"r,c\\" are two decimal numbers","\\t\\t\\tfor the row and column.  No other mouse events are","\\t\\t\\tsupported.","\\t\\t\\t\\t\\t\\t\\t*dec-mouse*","\\t   dec\\t\\tDEC terminal mouse handling.  The mouse generates a","\\t\\t\\trather complex sequence, starting with \\"<Esc>[\\".","\\t\\t\\tThis is also available for an Xterm, if it was","\\t\\t\\tconfigured with \\"--enable-dec-locator\\".","\\t\\t\\t\\t\\t\\t\\t*jsbterm-mouse*","\\t   jsbterm\\tJSB term mouse handling.","\\t\\t\\t\\t\\t\\t\\t*pterm-mouse*","\\t   pterm\\tQNX pterm mouse handling.","\\t\\t\\t\\t\\t\\t\\t*urxvt-mouse*","\\t   urxvt\\tMouse handling for the urxvt (rxvt-unicode) terminal.","\\t\\t\\tThe mouse works only if the terminal supports this","\\t\\t\\tencoding style, but it does not have 223 columns limit","\\t\\t\\tunlike \\"xterm\\" or \\"xterm2\\".","\\t\\t\\t\\t\\t\\t\\t*sgr-mouse*","\\t   sgr\\t\\tMouse handling for the terminal that emits SGR-styled","\\t\\t\\tmouse reporting.  The mouse works even in columns","\\t\\t\\tbeyond 223.  This option is backward compatible with","\\t\\t\\t\\"xterm2\\" because it can also decode \\"xterm2\\" style","\\t\\t\\tmouse codes."],"ttyscroll":["number\\t(default 999)","\\t\\t\\tglobal","\\tMaximum number of lines to scroll the screen.  If there are more lines","\\tto scroll the window is redrawn.  For terminals where scrolling is","\\tvery slow and redrawing is not slow this can be set to a small number,","\\te.g., 3, to speed up displaying."],"ttytype":["string\\t(default from $TERM)","\\t\\t\\tglobal","\\tAlias for \'term\', see above."],"varsofttabstop":["string\\t(default \\"\\")","\\t\\t\\tlocal to buffer","\\t\\t\\t{only available when compiled with the |+vartabs|","\\t\\t\\tfeature}","\\tA list of the number of spaces that a <Tab> counts for while editing,","\\tsuch as inserting a <Tab> or using <BS>.  It \\"feels\\" like variable-","\\twidth <Tab>s are being inserted, while in fact a mixture of spaces","\\tand <Tab>s is used.  Tab widths are separated with commas, with the","\\tfinal value applying to all subsequent tabs."],"vartabstop":["string\\t(default \\"\\")","\\t\\t\\tlocal to buffer","\\t\\t\\t{only available when compiled with the |+vartabs|","\\t\\t\\tfeature}","\\tA list of the number of spaces that a <Tab> in the file counts for,","\\tseparated by commas.  Each value corresponds to one tab, with the","\\tfinal value applying to all subsequent tabs. For example: >","\\t\\t:set vartabstop=4,20,10,8","<\\tThis will make the first tab 4 spaces wide, the second 20 spaces,","\\tthe third 10 spaces, and all following tabs 8 spaces."],"viminfo":["string\\t(Vi default: \\"\\", Vim default for MS-DOS,","\\t\\t\\t\\t   Windows and OS/2: \'100,<50,s10,h,rA:,rB:,","\\t\\t\\t\\t   for Amiga: \'100,<50,s10,h,rdf0:,rdf1:,rdf2:","\\t\\t\\t\\t   for others: \'100,<50,s10,h)","\\t\\t\\tglobal","\\t\\t\\t{not available when compiled without the |+viminfo|","\\t\\t\\tfeature}","\\tWhen non-empty, the viminfo file is read upon startup and written","\\twhen exiting Vim (see |viminfo-file|). Except when \'viminfofile\' is","\\t\\"NONE\\".","\\tThe string should be a comma separated list of parameters, each","\\tconsisting of a single character identifying the particular parameter,","\\tfollowed by a number or string which specifies the value of that","\\tparameter.  If a particular character is left out, then the default","\\tvalue is used for that parameter.  The following is a list of the","\\tidentifying characters and the effect of their value.","\\tCHAR\\tVALUE\\t~","\\t\\t\\t\\t\\t\\t\\t*viminfo-!*","\\t!\\tWhen included, save and restore global variables that start","\\t\\twith an uppercase letter, and don\'t contain a lowercase","\\t\\tletter.  Thus \\"KEEPTHIS and \\"K_L_M\\" are stored, but \\"KeepThis\\"","\\t\\tand \\"_K_L_M\\" are not.  Nested List and Dict items may not be","\\t\\tread back correctly, you end up with an empty item.","\\t\\t\\t\\t\\t\\t\\t*viminfo-quote*","\\t\\"\\tMaximum number of lines saved for each register.  Old name of","\\t\\tthe \'<\' item, with the disadvantage that you need to put a","\\t\\tbackslash before the \\", otherwise it will be recognized as the","\\t\\tstart of a comment!","\\t\\t\\t\\t\\t\\t\\t*viminfo-%*","\\t%\\tWhen included, save and restore the buffer list.  If Vim is","\\t\\tstarted with a file name argument, the buffer list is not","\\t\\trestored.  If Vim is started without a file name argument, the","\\t\\tbuffer list is restored from the viminfo file.  Quickfix","\\t\\t(\'buftype\'), unlisted (\'buflisted\'), unnamed and buffers on","\\t\\tremovable media (|viminfo-r|) are not saved.","\\t\\tWhen followed by a number, the number specifies the maximum","\\t\\tnumber of buffers that are stored.  Without a number all","\\t\\tbuffers are stored.","\\t\\t\\t\\t\\t\\t\\t*viminfo-\'*","\\t\'\\tMaximum number of previously edited files for which the marks","\\t\\tare remembered.  This parameter must always be included when","\\t\\t\'viminfo\' is non-empty.","\\t\\tIncluding this item also means that the |jumplist| and the","\\t\\t|changelist| are stored in the viminfo file.","\\t\\t\\t\\t\\t\\t\\t*viminfo-/*","\\t/\\tMaximum number of items in the search pattern history to be","\\t\\tsaved.  If non-zero, then the previous search and substitute","\\t\\tpatterns are also saved.  When not included, the value of","\\t\\t\'history\' is used.","\\t\\t\\t\\t\\t\\t\\t*viminfo-:*","\\t:\\tMaximum number of items in the command-line history to be","\\t\\tsaved.  When not included, the value of \'history\' is used.","\\t\\t\\t\\t\\t\\t\\t*viminfo-<*","\\t<\\tMaximum number of lines saved for each register.  If zero then","\\t\\tregisters are not saved.  When not included, all lines are","\\t\\tsaved.  \'\\"\' is the old name for this item.","\\t\\tAlso see the \'s\' item below: limit specified in Kbyte.","\\t\\t\\t\\t\\t\\t\\t*viminfo-@*","\\t@\\tMaximum number of items in the input-line history to be","\\t\\tsaved.  When not included, the value of \'history\' is used.","\\t\\t\\t\\t\\t\\t\\t*viminfo-c*","\\tc\\tWhen included, convert the text in the viminfo file from the","\\t\\t\'encoding\' used when writing the file to the current","\\t\\t\'encoding\'.  See |viminfo-encoding|.","\\t\\t\\t\\t\\t\\t\\t*viminfo-f*","\\tf\\tWhether file marks need to be stored.  If zero, file marks (\'0","\\t\\tto \'9, \'A to \'Z) are not stored.  When not present or when","\\t\\tnon-zero, they are all stored.  \'0 is used for the current","\\t\\tcursor position (when exiting or when doing \\":wviminfo\\").","\\t\\t\\t\\t\\t\\t\\t*viminfo-h*","\\th\\tDisable the effect of \'hlsearch\' when loading the viminfo","\\t\\tfile.  When not included, it depends on whether \\":nohlsearch\\"","\\t\\thas been used since the last search command.","\\t\\t\\t\\t\\t\\t\\t*viminfo-n*","\\tn\\tName of the viminfo file.  The name must immediately follow","\\t\\tthe \'n\'.  Must be at the end of the option!  If the","\\t\\t\'viminfofile\' option is set, that file name overrides the one","\\t\\tgiven here with \'viminfo\'.  Environment variables are","\\t\\texpanded when opening the file, not when setting the option.","\\t\\t\\t\\t\\t\\t\\t*viminfo-r*","\\tr\\tRemovable media.  The argument is a string (up to the next","\\t\\t\',\').  This parameter can be given several times.  Each","\\t\\tspecifies the start of a path for which no marks will be","\\t\\tstored.  This is to avoid removable media.  For MS-DOS you","\\t\\tcould use \\"ra:,rb:\\", for Amiga \\"rdf0:,rdf1:,rdf2:\\".  You can","\\t\\talso use it for temp files, e.g., for Unix: \\"r/tmp\\".  Case is","\\t\\tignored.  Maximum length of each \'r\' argument is 50","\\t\\tcharacters.","\\t\\t\\t\\t\\t\\t\\t*viminfo-s*","\\ts\\tMaximum size of an item in Kbyte.  If zero then registers are","\\t\\tnot saved.  Currently only applies to registers.  The default","\\t\\t\\"s10\\" will exclude registers with more than 10 Kbyte of text.","\\t\\tAlso see the \'<\' item above: line count limit."],"viminfofile":["string\\t(default: \\"\\")","\\t\\t\\tglobal","\\t\\t\\t{not available when compiled without the |+viminfo|","\\t\\t\\tfeature}","\\tWhen non-empty, overrides the file name used for viminfo.","\\tWhen equal to \\"NONE\\" no viminfo file will be read or written.","\\tThis option can be set with the |-i| command line flag.  The |--clean|","\\tcommand line flag sets it to \\"NONE\\".","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."],"weirdinvert":["boolean\\t(default off)","\\t\\t\\tglobal","\\tThis option has the same effect as the \'t_xs\' terminal option.","\\tIt is provided for backwards compatibility with version 4.x.","\\tSetting \'weirdinvert\' has the effect of making \'t_xs\' non-empty, and","\\tvice versa.  Has no effect when the GUI is running."],"wincolor":["string (default empty)","\\t\\t\\tlocal to window","\\tHighlight group name to use for this window instead of the Normal","\\tcolor |hl-Normal|."],"winptydll":["string\\t(default \\"winpty32.dll\\" or \\"winpty64.dll\\")","\\t\\t\\tglobal","\\t\\t\\t{only available when compiled with the |terminal|","\\t\\t\\tfeature on MS-Windows}","\\tSpecifies the name of the winpty shared library, used for the","\\t|:terminal| command. The default depends on whether was build as a","\\t32-bit or 64-bit executable.  If not found, \\"winpty.dll\\" is tried as","\\ta fallback.","\\tEnvironment variables are expanded |:set_env|.","\\tThis option cannot be set from a |modeline| or in the |sandbox|, for","\\tsecurity reasons."]},"features":{"64":["bits)"],"acl":["|ACL| support"],"bsd":["BSD system (not macOS, use \\"mac\\" for that)."],"iconv":["Can use |iconv()| for conversion."],"+shellslash":["Can use backslashes in filenames (Windows)"],"clipboard":["|clipboard| provider is available."],"mac":["MacOS system."],"nvim":["This is Nvim."],"python2":["Legacy Vim |python2| interface. |has-python|"],"python3":["Legacy Vim |python3| interface. |has-python|"],"pythonx":["Legacy Vim |python_x| interface. |has-pythonx|"],"ttyin":["input is a terminal (tty)"],"ttyout":["output is a terminal (tty)"],"unix":["Unix system."],"vim_starting":["True during |startup|. "],"win32":["Windows system (32 or 64 bit)."],"win64":["Windows system (64 bit)."],"wsl":["WSL (Windows Subsystem for Linux) system"],"all_builtin_terms":["Compiled with all builtin terminals enabled."],"amiga":["Amiga version of Vim."],"arabic":["Compiled with Arabic support |Arabic|."],"arp":["Compiled with ARP support (Amiga)."],"autocmd":["Compiled with autocommand support. (always true)"],"autochdir":["Compiled with support for \'autochdir\'"],"autoservername":["Automatically enable |clientserver|"],"balloon_eval":["Compiled with |balloon-eval| support."],"balloon_multiline":["GUI supports multiline balloons."],"beos":["BeOS version of Vim."],"browse":["Compiled with |:browse| support, and browse() will","\\t\\t\\twork."],"browsefilter":["Compiled with support for |browsefilter|."],"builtin_terms":["Compiled with some builtin terminals."],"byte_offset":["Compiled with support for \'o\' in \'statusline\'"],"cindent":["Compiled with \'cindent\' support."],"clientserver":["Compiled with remote invocation support |clientserver|."],"clipboard_working":["Compiled with \'clipboard\' support and it can be used."],"cmdline_compl":["Compiled with |cmdline-completion| support."],"cmdline_hist":["Compiled with |cmdline-history| support."],"cmdline_info":["Compiled with \'showcmd\' and \'ruler\' support."],"comments":["Compiled with |\'comments\'| support."],"compatible":["Compiled to be very Vi compatible."],"conpty":["Platform where |ConPTY| can be used."],"cryptv":["Compiled with encryption support |encryption|."],"cscope":["Compiled with |cscope| support."],"cursorbind":["Compiled with |\'cursorbind\'| (always true)"],"debug":["Compiled with \\"DEBUG\\" defined."],"dialog_con":["Compiled with console dialog support."],"dialog_gui":["Compiled with GUI dialog support."],"diff":["Compiled with |vimdiff| and \'diff\' support."],"digraphs":["Compiled with support for digraphs."],"directx":["Compiled with support for DirectX and \'renderoptions\'."],"dnd":["Compiled with support for the \\"~ register |quote_~|."],"ebcdic":["Compiled on a machine with ebcdic character set."],"emacs_tags":["Compiled with support for Emacs tags."],"eval":["Compiled with expression evaluation support.  Always"],"true,":["of course!"],"ex_extra":["|+ex_extra| (always true)"],"extra_search":["Compiled with support for |\'incsearch\'| and","\\t\\t\\t|\'hlsearch\'|"],"farsi":["Support for Farsi was removed |farsi|."],"file_in_path":["Compiled with support for |gf| and |<cfile>|"],"filterpipe":["When \'shelltemp\' is off pipes are used for shell"],"read/write/filter":["commands"],"find_in_path":["Compiled with support for include file searches","\\t\\t\\t|+find_in_path|."],"float":["Compiled with support for |Float|."],"fname_case":["Case in file names matters (for Amiga, MS-DOS, and"],"Windows":["this is not present)."],"folding":["Compiled with |folding| support."],"footer":["Compiled with GUI footer support. |gui-footer|"],"fork":["Compiled to use fork()/exec() instead of system()."],"gettext":["Compiled with message translation |multi-lang|"],"gui":["Compiled with GUI enabled."],"gui_athena":["Compiled with Athena GUI."],"gui_gnome":["Compiled with Gnome support (gui_gtk is also defined)."],"gui_gtk":["Compiled with GTK+ GUI (any version)."],"gui_gtk2":["Compiled with GTK+ 2 GUI (gui_gtk is also defined)."],"gui_gtk3":["Compiled with GTK+ 3 GUI (gui_gtk is also defined)."],"gui_mac":["Compiled with Macintosh GUI."],"gui_motif":["Compiled with Motif GUI."],"gui_photon":["Compiled with Photon GUI."],"gui_running":["Vim is running in the GUI, or it will start soon."],"gui_win32":["Compiled with MS Windows Win32 GUI."],"gui_win32s":["idem, and Win32s system being used (Windows 3.1)"],"hangul_input":["Compiled with Hangul input support. |hangul|"],"hpux":["HP-UX version of Vim."],"insert_expand":["Compiled with support for CTRL-X expansion commands in"],"Insert":["mode. (always true)"],"jumplist":["Compiled with |jumplist| support."],"keymap":["Compiled with \'keymap\' support."],"lambda":["Compiled with |lambda| support."],"langmap":["Compiled with \'langmap\' support."],"libcall":["Compiled with |libcall()| support."],"linebreak":["Compiled with \'linebreak\', \'breakat\', \'showbreak\' and"],"\'breakindent\'":["support."],"linux":["Linux version of Vim."],"lispindent":["Compiled with support for lisp indenting."],"listcmds":["Compiled with commands for the buffer list |:files|"],"and":["the argument list |arglist|.","special formats of \'titlestring\' and \'iconstring\'."],"localmap":["Compiled with local mappings and abbr. |:map-local|"],"lua":["Compiled with Lua interface |Lua|."],"macunix":["Synonym for osxdarwin"],"menu":["Compiled with support for |:menu|."],"mksession":["Compiled with support for |:mksession|."],"modify_fname":["Compiled with file name modifiers. |filename-modifiers|"],"(always":["true)","true)","true)"],"mouse":["Compiled with support mouse."],"mouse_dec":["Compiled with support for Dec terminal mouse."],"mouse_gpm":["Compiled with support for gpm (Linux console mouse)"],"mouse_gpm_enabled":["GPM mouse is working"],"mouse_netterm":["Compiled with support for netterm mouse."],"mouse_pterm":["Compiled with support for qnx pterm mouse."],"mouse_sysmouse":["Compiled with support for sysmouse (*BSD console mouse)"],"mouse_sgr":["Compiled with support for sgr mouse."],"mouse_urxvt":["Compiled with support for urxvt mouse."],"mouse_xterm":["Compiled with support for xterm mouse."],"mouseshape":["Compiled with support for \'mouseshape\'."],"multi_byte":["Compiled with support for \'encoding\' (always true)"],"multi_byte_encoding":["\'encoding\' is set to a multi-byte encoding."],"multi_byte_ime":["Compiled with support for IME input method."],"multi_lang":["Compiled with support for multiple languages."],"mzscheme":["Compiled with MzScheme interface |mzscheme|."],"netbeans_enabled":["Compiled with support for |netbeans| and connected."],"netbeans_intg":["Compiled with support for |netbeans|."],"num64":["Compiled with 64-bit |Number| support."],"ole":["Compiled with OLE automation support for Win32."],"osx":["Compiled for macOS  cf. mac"],"osxdarwin":["Compiled for macOS, with |mac-darwin-feature|"],"packages":["Compiled with |packages| support."],"path_extra":["Compiled with up/downwards search in \'path\' and \'tags\'"],"perl":["Compiled with Perl interface."],"persistent_undo":["Compiled with support for persistent undo history."],"postscript":["Compiled with PostScript file printing."],"printer":["Compiled with |:hardcopy| support."],"profile":["Compiled with |:profile| support."],"python":["Python 2.x interface available. |has-python|"],"python_compiled":["Compiled with Python 2.x interface. |has-python|"],"python_dynamic":["Python 2.x interface is dynamically loaded. |has-python|"],"python3_compiled":["Compiled with Python 3.x interface. |has-python|"],"python3_dynamic":["Python 3.x interface is dynamically loaded. |has-python|"],"qnx":["QNX version of Vim."],"quickfix":["Compiled with |quickfix| support."],"reltime":["Compiled with |reltime()| support."],"rightleft":["Compiled with \'rightleft\' support."],"ruby":["Compiled with Ruby interface |ruby|."],"scrollbind":["Compiled with \'scrollbind\' support. (always true)"],"showcmd":["Compiled with \'showcmd\' support."],"signs":["Compiled with |:sign| support."],"smartindent":["Compiled with \'smartindent\' support."],"sound":["Compiled with sound support, e.g. `sound_playevent()`"],"spell":["Compiled with spell checking support |spell|."],"startuptime":["Compiled with |--startuptime| support."],"statusline":["Compiled with support for \'statusline\', \'rulerformat\'"],"sun":["SunOS version of Vim."],"sun_workshop":["Support for Sun |workshop| has been removed."],"syntax":["Compiled with syntax highlighting support |syntax|."],"syntax_items":["There are active syntax highlighting items for the"],"current":["buffer."],"system":["Compiled to use system() instead of fork()/exec()."],"tag_binary":["Compiled with binary searching in tags files","\\t\\t\\t|tag-binary-search|."],"tag_old_static":["Support for old static tags was removed, see","\\t\\t\\t|tag-old-static|."],"tcl":["Compiled with Tcl interface."],"termguicolors":["Compiled with true color in terminal support."],"terminal":["Compiled with |terminal| support."],"terminfo":["Compiled with terminfo instead of termcap."],"termresponse":["Compiled with support for |t_RV| and |v:termresponse|."],"textobjects":["Compiled with support for |text-objects|."],"textprop":["Compiled with support for |text-properties|."],"tgetent":["Compiled with tgetent support, able to use a termcap"],"or":["terminfo file."],"timers":["Compiled with |timer_start()| support."],"title":["Compiled with window title support |\'title\'|."],"toolbar":["Compiled with support for |gui-toolbar|."],"unnamedplus":["Compiled with support for \\"unnamedplus\\" in \'clipboard\'"],"user_commands":["User-defined commands. (always true)"],"vartabs":["Compiled with variable tabstop support |\'vartabstop\'|."],"vcon":["Win32: Virtual console support is working, can use"],"\'termguicolors\'.":["Also see |+vtp|."],"vertsplit":["Compiled with vertically split windows |:vsplit|."],"viminfo":["Compiled with viminfo support."],"vimscript-1":["Compiled Vim script version 1 support"],"vimscript-2":["Compiled Vim script version 2 support"],"vimscript-3":["Compiled Vim script version 3 support"],"virtualedit":["Compiled with \'virtualedit\' option. (always true)"],"visual":["Compiled with Visual mode. (always true)"],"visualextra":["Compiled with extra Visual mode commands. (always"],"true)":["|blockwise-operators|."],"vms":["VMS version of Vim."],"vreplace":["Compiled with |gR| and |gr| commands. (always true)"],"vtp":["Compiled for vcon support |+vtp| (check vcon to find"],"out":["if it works in the current console)."],"wildignore":["Compiled with \'wildignore\' option."],"wildmenu":["Compiled with \'wildmenu\' option."],"win16":["old version for MS-Windows 3.1 (always false)"],"win32unix":["Win32 version of Vim, using Unix files (Cygwin)"],"win95":["Win32 version for MS-Windows 95/98/ME (always false)"],"winaltkeys":["Compiled with \'winaltkeys\' option."],"windows":["Compiled with support for more than one window."],"writebackup":["Compiled with \'writebackup\' default on."],"xfontset":["Compiled with X fontset support |xfontset|."],"xim":["Compiled with X input method support |xim|."],"xpm":["Compiled with pixmap support."],"xpm_w32":["Compiled with pixmap support for Win32. (Only for"],"backward":["compatibility. Use \\"xpm\\" instead.)"],"xsmp":["Compiled with X session management support."],"xsmp_interact":["Compiled with interactive X session management support."],"xterm_clipboard":["Compiled with support for xterm clipboard."],"xterm_save":["Compiled with support for saving and restoring the"],"xterm":["screen."],"x11":["Compiled with X11 support."]},"expandKeywords":{"<cfile>":["file name under the cursor"],"<afile>":["autocmd file name"],"<abuf>":["autocmd buffer number (as a String!)"],"<amatch>":["autocmd matched name"],"<sfile>":["sourced script file or function name"],"<slnum>":["sourced script file line number"],"<cword>":["word under the cursor"],"<cWORD>":["WORD under the cursor"],"<client>":["the {clientid} of the last received message `server2client()`"]}}}');

/***/ }),
/* 159 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getProvider = exports.useProvider = void 0;
var fuzzy_1 = __importDefault(__webpack_require__(160));
var providers = [];
function useProvider(p) {
    providers.push(p);
}
exports.useProvider = useProvider;
function getProvider() {
    return providers.reduce(function (pre, next) {
        return function (line, uri, position, word, invalidLength, items) {
            // 200 items is enough
            if (items.length > 200) {
                return items.slice(0, 200);
            }
            var newItems = next(line, uri, position)
                .filter(function (item) { return fuzzy_1.default(item.label, word) >= invalidLength; });
            return pre(line, uri, position, word, invalidLength, items.concat(newItems));
        };
    }, function (_line, _uri, _position, _word, _invalidLength, items) { return items; });
}
exports.getProvider = getProvider;


/***/ }),
/* 160 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
function fuzzy(origin, query) {
    var score = 0;
    for (var qIdx = 0, oIdx = 0; qIdx < query.length && oIdx < origin.length; qIdx++) {
        var qc = query.charAt(qIdx).toLowerCase();
        for (; oIdx < origin.length; oIdx++) {
            var oc = origin.charAt(oIdx).toLowerCase();
            if (qc === oc) {
                score++;
                oIdx++;
                break;
            }
        }
    }
    return score;
}
exports.default = fuzzy;


/***/ }),
/* 161 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var patterns_1 = __webpack_require__(72);
var util_1 = __webpack_require__(66);
var builtin_1 = __webpack_require__(77);
var provider_1 = __webpack_require__(159);
function provider(line) {
    if (util_1.isSomeMatchPattern(patterns_1.builtinVariablePattern, line)) {
        return builtin_1.builtinDocs.getPredefinedVimVariables();
    }
    return [];
}
provider_1.useProvider(provider);


/***/ }),
/* 162 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var patterns_1 = __webpack_require__(72);
var builtin_1 = __webpack_require__(77);
var provider_1 = __webpack_require__(159);
function provider(line) {
    if (patterns_1.colorschemePattern.test(line)) {
        return builtin_1.builtinDocs.getColorschemes();
    }
    return [];
}
provider_1.useProvider(provider);


/***/ }),
/* 163 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var patterns_1 = __webpack_require__(72);
var util_1 = __webpack_require__(66);
var builtin_1 = __webpack_require__(77);
var config_1 = __importDefault(__webpack_require__(73));
var snippets_1 = __webpack_require__(164);
var provider_1 = __webpack_require__(159);
function provider(line) {
    if (util_1.isSomeMatchPattern(patterns_1.commandPattern, line)) {
        // only return snippets when snippetSupport is true
        if (config_1.default.snippetSupport) {
            return builtin_1.builtinDocs.getVimCommands().concat(snippets_1.commandSnippets);
        }
        return builtin_1.builtinDocs.getVimCommands();
    }
    return [];
}
provider_1.useProvider(provider);


/***/ }),
/* 164 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.commandSnippets = void 0;
var vscode_languageserver_1 = __webpack_require__(2);
var util_1 = __webpack_require__(66);
exports.commandSnippets = [
    {
        label: "func",
        kind: vscode_languageserver_1.CompletionItemKind.Snippet,
        insertText: [
            "function ${1:Name}(${2}) ${3:abort}",
            "\t${0}",
            "endfunction",
        ].join("\n"),
        insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
    },
    {
        label: "tryc",
        kind: vscode_languageserver_1.CompletionItemKind.Snippet,
        insertText: [
            "try",
            "\t${1}",
            "catch /.*/",
            "\t${0}",
            "endtry",
        ].join("\n"),
        insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
    },
    {
        label: "tryf",
        kind: vscode_languageserver_1.CompletionItemKind.Snippet,
        insertText: [
            "try",
            "\t${1}",
            "finally",
            "\t${0}",
            "endtry",
        ].join("\n"),
        insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
    },
    {
        label: "trycf",
        kind: vscode_languageserver_1.CompletionItemKind.Snippet,
        insertText: [
            "try",
            "\t${1}",
            "catch /.*/",
            "\t${2}",
            "finally",
            "\t${0}",
            "endtry",
        ].join("\n"),
        insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
    },
    {
        label: "aug",
        kind: vscode_languageserver_1.CompletionItemKind.Snippet,
        insertText: [
            "augroup ${1:Start}",
            "\tautocmd!",
            "\t${0}",
            "augroup END",
        ].join("\n"),
        insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
    },
    {
        label: "aut",
        kind: vscode_languageserver_1.CompletionItemKind.Snippet,
        insertText: [
            "autocmd ${1:group-event} ${2:pat} ${3:once} ${4:nested} ${5:cmd}",
        ].join("\n"),
        insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
    },
    {
        label: "if",
        kind: vscode_languageserver_1.CompletionItemKind.Snippet,
        insertText: [
            "if ${1:condition}",
            "\t${0}",
            "endif",
        ].join("\n"),
        insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
    },
    {
        label: "cmd",
        kind: vscode_languageserver_1.CompletionItemKind.Snippet,
        insertText: [
            "command! ${1:attr} ${2:cmd} ${3:rep} ${0}",
        ].join("\n"),
        insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
    },
    {
        label: "hi",
        kind: vscode_languageserver_1.CompletionItemKind.Snippet,
        insertText: [
            "highlight ${1:default} ${2:group-name} ${3:args} ${0}",
        ].join("\n"),
        insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
    },
].map(function (item) { return (__assign(__assign({}, item), { documentation: util_1.markupSnippets(item.insertText) })); });


/***/ }),
/* 165 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var patterns_1 = __webpack_require__(72);
var builtin_1 = __webpack_require__(77);
var provider_1 = __webpack_require__(159);
function provider(line) {
    if (patterns_1.expandPattern[0].test(line)) {
        return builtin_1.builtinDocs.getExpandKeywords().map(function (item) {
            return __assign(__assign({}, item), { insertText: item.insertText.slice(1) });
        });
    }
    else if (patterns_1.expandPattern[1].test(line)) {
        return builtin_1.builtinDocs.getExpandKeywords();
    }
    return [];
}
provider_1.useProvider(provider);


/***/ }),
/* 166 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var patterns_1 = __webpack_require__(72);
var util_1 = __webpack_require__(66);
var builtin_1 = __webpack_require__(77);
var config_1 = __importDefault(__webpack_require__(73));
var workspaces_1 = __webpack_require__(167);
var provider_1 = __webpack_require__(159);
function provider(line, uri, position) {
    if (/\b(g:|s:|<SID>)\w*$/.test(line)) {
        var list = [];
        if (/\bg:\w*$/.test(line)) {
            list = workspaces_1.workspace.getFunctionItems(uri)
                .filter(function (item) { return /^g:/.test(item.label); });
        }
        else if (/\b(s:|<SID>)\w*$/i.test(line)) {
            list = workspaces_1.workspace.getFunctionItems(uri)
                .filter(function (item) { return /^s:/.test(item.label); });
        }
        return list.map(function (item) { return (__assign(__assign({}, item), { insertText: !/:/.test(config_1.default.iskeyword) ? item.insertText.slice(2) : item.insertText })); });
    }
    else if (/\B:\w*$/.test(line)) {
        return workspaces_1.workspace.getFunctionItems(uri)
            .filter(function (item) { return /:/.test(item.label); })
            .map(function (item) {
            var m = line.match(/:[^:]*$/);
            return __assign(__assign({}, item), { 
                // delete the `:` symbol
                textEdit: {
                    range: {
                        start: {
                            line: position.line,
                            character: line.length - m[0].length,
                        },
                        end: {
                            line: position.line,
                            character: line.length - m[0].length + 1,
                        },
                    },
                    newText: item.insertText,
                } });
        });
    }
    else if (util_1.isSomeMatchPattern(patterns_1.notFunctionPattern, line)) {
        return [];
    }
    return workspaces_1.workspace.getFunctionItems(uri)
        .filter(function (item) {
        return !builtin_1.builtinDocs.isBuiltinFunction(item.label);
    })
        .concat(builtin_1.builtinDocs.getBuiltinVimFunctions());
}
provider_1.useProvider(provider);


/***/ }),
/* 167 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.workspace = exports.Workspace = void 0;
var vscode_uri_1 = __webpack_require__(168);
var vscode_languageserver_1 = __webpack_require__(2);
var util_1 = __webpack_require__(66);
var buffer_1 = __webpack_require__(169);
var config_1 = __importDefault(__webpack_require__(73));
var patterns_1 = __webpack_require__(72);
// import logger from '../common/logger';
// const log = logger('workspace')
var Workspace = /** @class */ (function () {
    function Workspace() {
        this.buffers = {};
        this.pendingBuffers = {};
    }
    Workspace.prototype.isExistsBuffer = function (uri) {
        if (this.buffers[uri]) {
            return true;
        }
        return false;
    };
    Workspace.prototype.updateBuffer = function (uri, node) {
        return __awaiter(this, void 0, void 0, function () {
            var loadPromise, _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (!node) {
                            return [2 /*return*/];
                        }
                        if (!this.buffers[uri]) return [3 /*break*/, 1];
                        this.buffers[uri].updateBufferByNode(node);
                        return [3 /*break*/, 3];
                    case 1:
                        loadPromise = this.loadBuffer(uri, node);
                        this.pendingBuffers[uri] = loadPromise;
                        _a = this.buffers;
                        _b = uri;
                        return [4 /*yield*/, loadPromise];
                    case 2:
                        _a[_b] = _c.sent();
                        delete this.pendingBuffers[uri];
                        _c.label = 3;
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    Workspace.prototype.loadBuffer = function (uri, node) {
        return __awaiter(this, void 0, void 0, function () {
            var projectRoot;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, util_1.findProjectRoot(vscode_uri_1.URI.parse(uri).fsPath, config_1.default.indexes.projectRootPatterns)];
                    case 1:
                        projectRoot = _a.sent();
                        if (config_1.default.vimruntime.trim() !== '' && projectRoot.indexOf(config_1.default.vimruntime) === 0) {
                            projectRoot = config_1.default.vimruntime;
                        }
                        return [2 /*return*/, new buffer_1.Buffer(uri, projectRoot, node)];
                }
            });
        });
    };
    Workspace.prototype.getBufferByUri = function (uri) {
        if (this.buffers[uri]) {
            return Promise.resolve(this.buffers[uri]);
        }
        else if (this.pendingBuffers[uri]) {
            return this.pendingBuffers[uri];
        }
        return Promise.resolve(undefined);
    };
    Workspace.prototype.getFunctionItems = function (uri) {
        return this.getScriptFunctionItems(uri).concat(this.getGlobalFunctionItems(uri));
    };
    Workspace.prototype.getIdentifierItems = function (uri, line) {
        return this.getLocalIdentifierItems(uri, line)
            .concat(this.getGlobalIdentifierItems(uri));
    };
    Workspace.prototype.getLocations = function (name, uri, position, locationType) {
        var isFunArg = false;
        var res = [];
        if (patterns_1.globalIdentifierPattern.test(name)) {
            res = this.getGlobalLocation(name, uri, position, locationType);
        }
        else if (patterns_1.normalIdentifierPattern.test(name)) {
            // get function args references first
            res = this.getFunArgLocation(name, uri, position, locationType);
            if (res.length) {
                isFunArg = true;
            }
            else {
                res = this.getLocalLocation(name, uri, position, locationType);
                if (!res.length) {
                    res = this.getGlobalLocation(name, uri, position, locationType);
                }
            }
        }
        else if (patterns_1.scriptIdentifierPattern.test(name) && this.buffers[uri]) {
            var names = [name];
            if (/^<SID>/.test(name)) {
                names.push(name.replace(/^<SID>/, "s:"));
            }
            else {
                names.push(name.replace(/^s:/, "<SID>"));
            }
            res = this.getScriptLocation(names, uri, position, locationType);
        }
        else if (patterns_1.localIdentifierPattern.test(name) && this.buffers[uri]) {
            res = this.getLocalLocation(name, uri, position, locationType);
        }
        else if (patterns_1.funcArgIdentifierPattern.test(name) && this.buffers[uri]) {
            res = this.getAIdentifierLocation(name, uri, position, locationType);
        }
        if (res.length) {
            res = res.sort(function (a, b) {
                if (a.range.start.line === b.range.start.line) {
                    return a.range.start.character - b.range.start.character;
                }
                return a.range.start.line - b.range.start.line;
            });
        }
        return {
            isFunArg: isFunArg,
            locations: res,
        };
    };
    Workspace.prototype.getLocationsByUri = function (name, uri, position, locationType) {
        var isFunArg = false;
        var res = [];
        if (patterns_1.globalIdentifierPattern.test(name) && this.buffers[uri]) {
            res = this.getGlobalLocationByUri(name, uri, position, locationType);
        }
        else if (patterns_1.normalIdentifierPattern.test(name) && this.buffers[uri]) {
            // get function args references first
            res = this.getFunArgLocation(name, uri, position, locationType);
            if (res.length) {
                isFunArg = true;
            }
            else {
                res = this.getLocalLocation(name, uri, position, locationType);
                if (!res.length) {
                    res = this.getGlobalLocationByUri(name, uri, position, locationType);
                }
            }
        }
        else if (patterns_1.scriptIdentifierPattern.test(name) && this.buffers[uri]) {
            var names = [name];
            if (/^<SID>/.test(name)) {
                names.push(name.replace(/^<SID>/, "s:"));
            }
            else {
                names.push(name.replace(/^s:/, "<SID>"));
            }
            res = this.getScriptLocation(names, uri, position, locationType);
        }
        else if (patterns_1.localIdentifierPattern.test(name) && this.buffers[uri]) {
            res = this.getLocalLocation(name, uri, position, locationType);
        }
        else if (patterns_1.funcArgIdentifierPattern.test(name) && this.buffers[uri]) {
            res = this.getAIdentifierLocation(name, uri, position, locationType);
        }
        if (res.length) {
            res = res.sort(function (a, b) {
                if (a.range.start.line === b.range.start.line) {
                    return a.range.start.character - b.range.start.character;
                }
                return a.range.start.line - b.range.start.line;
            });
        }
        return {
            isFunArg: isFunArg,
            locations: res,
        };
    };
    Workspace.prototype.filterDuplicate = function (items) {
        var tmp = {};
        return items.reduce(function (res, next) {
            if (!tmp[next.label]) {
                tmp[next.label] = true;
                res.push(next);
            }
            return res;
        }, []);
    };
    Workspace.prototype.getGlobalFunctionItems = function (uri) {
        var buf = this.buffers[uri];
        if (!buf) {
            return [];
        }
        var buffers = config_1.default.suggest.fromRuntimepath
            ? Object.values(this.buffers)
            : Object.values(this.buffers).filter(function (b) {
                if (config_1.default.suggest.fromVimruntime && b.isBelongToWorkdir(config_1.default.vimruntime)) {
                    return true;
                }
                return b.isBelongToWorkdir(buf.getProjectRoot());
            });
        return this.filterDuplicate(buffers.reduce(function (res, cur) {
            return res.concat(cur.getGlobalFunctionItems());
        }, []));
    };
    Workspace.prototype.getScriptFunctionItems = function (uri) {
        if (!this.buffers[uri]) {
            return [];
        }
        return this.buffers[uri].getScriptFunctionItems();
    };
    Workspace.prototype.getGlobalIdentifierItems = function (uri) {
        var buf = this.buffers[uri];
        if (!buf) {
            return [];
        }
        var buffers = config_1.default.suggest.fromRuntimepath
            ? Object.values(this.buffers)
            : Object.values(this.buffers).filter(function (b) {
                if (config_1.default.suggest.fromVimruntime && b.isBelongToWorkdir(config_1.default.vimruntime)) {
                    return true;
                }
                return b.isBelongToWorkdir(buf.getProjectRoot());
            });
        return this.filterDuplicate(buffers.reduce(function (res, cur) {
            return res
                .concat(cur.getGlobalIdentifierItems())
                .concat(cur.getEnvItems());
        }, []));
    };
    Workspace.prototype.getLocalIdentifierItems = function (uri, line) {
        if (!this.buffers[uri]) {
            return [];
        }
        var buf = this.buffers[uri];
        return buf.getFunctionLocalIdentifierItems(line)
            .concat(buf.getLocalIdentifierItems());
    };
    Workspace.prototype.getLocation = function (uri, item) {
        return {
            uri: uri,
            range: vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(item.startLine - 1, item.startCol - 1), vscode_languageserver_1.Position.create(item.startLine - 1, item.startCol - 1 + item.name.length)),
        };
    };
    Workspace.prototype.getGlobalLocation = function (name, 
    // tslint:disable-next-line: variable-name
    _uri, 
    // tslint:disable-next-line: variable-name
    position, locationType) {
        var _this = this;
        return Object.keys(this.buffers).reduce(function (pre, uri) {
            return pre.concat(_this.getGlobalLocationByUri(name, uri, position, locationType));
        }, []);
    };
    Workspace.prototype.getGlobalLocationByUri = function (name, 
    // tslint:disable-next-line: variable-name
    uri, 
    // tslint:disable-next-line: variable-name
    _position, locationType) {
        var _this = this;
        var res = [];
        var tmp = [];
        var list = [];
        var globalFunctions = locationType === "definition"
            ? this.buffers[uri].getGlobalFunctions()
            : this.buffers[uri].getGlobalFunctionRefs();
        Object.keys(globalFunctions).forEach(function (fname) {
            if (fname === name) {
                res = res.concat(globalFunctions[fname].map(function (item) { return _this.getLocation(uri, item); }));
            }
        });
        var identifiers = locationType === "definition"
            ? this.buffers[uri].getGlobalIdentifiers()
            : this.buffers[uri].getGlobalIdentifierRefs();
        Object.keys(identifiers).forEach(function (fname) {
            if (fname === name) {
                tmp = tmp.concat(identifiers[fname].map(function (item) { return _this.getLocation(uri, item); }));
            }
        });
        // filter function local variables
        if (/^([a-zA-Z_]\w*(\.\w+)*)$/.test(name)) {
            var glFunctions = this.buffers[uri].getGlobalFunctions();
            var scriptFunctions = this.buffers[uri].getScriptFunctions();
            var funList_1 = Object.values(glFunctions).concat(Object.values(scriptFunctions)).reduce(function (aur, fs) { return aur.concat(fs); }, []);
            tmp.forEach(function (l) {
                if (!funList_1.some(function (fun) {
                    return fun.startLine - 1 < l.range.start.line && l.range.start.line < fun.endLine - 1;
                })) {
                    list.push(l);
                }
            });
        }
        else {
            list = tmp;
        }
        res = res.concat(list);
        return res;
    };
    Workspace.prototype.getScriptLocation = function (names, uri, 
    // tslint:disable-next-line: variable-name
    _position, locationType) {
        var _this = this;
        var res = [];
        if (!this.buffers[uri]) {
            return res;
        }
        var functions = locationType === "definition"
            ? this.buffers[uri].getScriptFunctions()
            : this.buffers[uri].getScriptFunctionRefs();
        Object.keys(functions).forEach(function (fname) {
            var idx = names.indexOf(fname);
            if (idx !== -1) {
                res = res.concat(functions[names[idx]].map(function (item) { return _this.getLocation(uri, item); }));
            }
        });
        var identifiers = locationType === "definition"
            ? this.buffers[uri].getLocalIdentifiers()
            : this.buffers[uri].getLocalIdentifierRefs();
        Object.keys(identifiers).forEach(function (fname) {
            var idx = names.indexOf(fname);
            if (idx !== -1) {
                res = res.concat(identifiers[names[idx]].map(function (item) { return _this.getLocation(uri, item); }));
            }
        });
        return res;
    };
    Workspace.prototype.getLocalLocation = function (name, uri, position, locationType) {
        var _this = this;
        var list = [];
        if (!this.buffers[uri]) {
            return list;
        }
        var vimLineNum = position.line + 1;
        var startLine = -1;
        var endLine = -1;
        // get function args completion items
        []
            .concat(Object
            .values(this.buffers[uri].getGlobalFunctions())
            .reduce(function (res, next) { return res.concat(next); }, []))
            .concat(Object
            .values(this.buffers[uri].getScriptFunctions())
            .reduce(function (res, next) { return res.concat(next); }, []))
            .forEach(function (fun) {
            if (fun.startLine < vimLineNum && vimLineNum < fun.endLine) {
                startLine = fun.startLine;
                endLine = fun.endLine;
            }
        });
        if (startLine !== -1 && endLine !== -1) {
            var globalVariables_1 = locationType === "definition"
                ? this.buffers[uri].getGlobalIdentifiers()
                : this.buffers[uri].getGlobalIdentifierRefs();
            Object.keys(globalVariables_1).some(function (key) {
                if (key === name) {
                    globalVariables_1[key].forEach(function (item) {
                        if (startLine < item.startLine && item.startLine < endLine) {
                            list.push(_this.getLocation(uri, item));
                        }
                    });
                    return true;
                }
                return false;
            });
            var localVariables_1 = locationType === "definition"
                ? this.buffers[uri].getLocalIdentifiers()
                : this.buffers[uri].getLocalIdentifierRefs();
            Object.keys(localVariables_1).some(function (key) {
                if (key === name) {
                    localVariables_1[key].forEach(function (item) {
                        if (startLine < item.startLine && item.startLine < endLine) {
                            list.push(_this.getLocation(uri, item));
                        }
                    });
                    return true;
                }
                return false;
            });
        }
        return list;
    };
    Workspace.prototype.getAIdentifierLocation = function (name, uri, position, locationType) {
        var res = [];
        if (!this.buffers[uri]) {
            return res;
        }
        if (locationType === "definition") {
            var flist_1 = [];
            var globalFunctions_1 = this.buffers[uri].getGlobalFunctions();
            Object.keys(globalFunctions_1).forEach(function (fname) {
                globalFunctions_1[fname].forEach(function (item) {
                    if (item.startLine - 1 < position.line && position.line < item.endLine - 1) {
                        flist_1.push(item);
                    }
                });
            });
            var scriptFunctions_1 = this.buffers[uri].getScriptFunctions();
            Object.keys(scriptFunctions_1).forEach(function (fname) {
                scriptFunctions_1[fname].forEach(function (item) {
                    if (item.startLine - 1 < position.line && position.line < item.endLine - 1) {
                        flist_1.push(item);
                    }
                });
            });
            if (flist_1.length) {
                var n_1 = name.slice(2);
                return flist_1.filter(function (item) { return item.args && item.args.some(function (m) { return m.value === n_1; }); })
                    .map(function (item) {
                    var startLine = item.startLine - 1;
                    var startCol = item.startCol - 1;
                    var endCol = item.startCol - 1;
                    item.args.some(function (arg) {
                        if (arg.value === n_1) {
                            startCol = arg.pos.col - 1;
                            endCol = startCol + n_1.length;
                            return true;
                        }
                        return false;
                    });
                    return {
                        uri: uri,
                        range: vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(startLine, startCol), vscode_languageserver_1.Position.create(startLine, endCol)),
                    };
                });
            }
        }
        else {
            var flist_2 = [];
            var globalFunctions_2 = this.buffers[uri].getGlobalFunctions();
            Object.keys(globalFunctions_2).forEach(function (fname) {
                globalFunctions_2[fname].forEach(function (item) {
                    if (item.startLine - 1 < position.line && position.line < item.endLine - 1) {
                        flist_2.push(item);
                    }
                });
            });
            var scriptFunctions_2 = this.buffers[uri].getScriptFunctions();
            Object.keys(scriptFunctions_2).forEach(function (fname) {
                scriptFunctions_2[fname].forEach(function (item) {
                    if (item.startLine - 1 < position.line && position.line < item.endLine - 1) {
                        flist_2.push(item);
                    }
                });
            });
            if (flist_2.length) {
                var identifiers_1 = this.buffers[uri].getLocalIdentifierRefs();
                Object.keys(identifiers_1).forEach(function (key) {
                    if (key === name) {
                        identifiers_1[name].forEach(function (item) {
                            flist_2.forEach(function (fitem) {
                                if (fitem.startLine < item.startLine && item.startLine < fitem.endLine) {
                                    res.push({
                                        uri: uri,
                                        range: vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(item.startLine - 1, item.startCol - 1), vscode_languageserver_1.Position.create(item.startLine - 1, item.startCol - 1 + item.name.length)),
                                    });
                                }
                            });
                        });
                    }
                });
            }
        }
        return res;
    };
    Workspace.prototype.getFunArgLocation = function (name, uri, position, locationType) {
        var res = [];
        if (!this.buffers[uri]) {
            return res;
        }
        if (locationType === "references") {
            var globalFunctions = this.buffers[uri].getGlobalFunctions();
            var scriptFunctions = this.buffers[uri].getScriptFunctions();
            var startLine_1 = -1;
            var endLine_1 = -1;
            Object.values(globalFunctions).forEach(function (fitems) {
                fitems.forEach(function (fitem) {
                    fitem.args.forEach(function (arg) {
                        var pos = arg.pos;
                        if (pos) {
                            if (pos.lnum === position.line + 1 && arg.value === name) {
                                startLine_1 = fitem.startLine;
                                endLine_1 = fitem.endLine;
                            }
                        }
                    });
                });
            });
            if (startLine_1 === -1 && endLine_1 === -1) {
                Object.values(scriptFunctions).forEach(function (fitems) {
                    fitems.forEach(function (fitem) {
                        fitem.args.forEach(function (arg) {
                            var pos = arg.pos;
                            if (pos) {
                                if (pos.lnum === position.line + 1 && arg.value === name) {
                                    startLine_1 = fitem.startLine;
                                    endLine_1 = fitem.endLine;
                                }
                            }
                        });
                    });
                });
            }
            if (startLine_1 !== -1 && endLine_1 !== -1) {
                var identifiers_2 = this.buffers[uri].getLocalIdentifierRefs();
                Object.keys(identifiers_2).forEach(function (key) {
                    if (key === "a:" + name) {
                        identifiers_2[key].forEach(function (item) {
                            if (startLine_1 < item.startLine && item.startLine < endLine_1) {
                                res.push({
                                    uri: uri,
                                    range: vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(item.startLine - 1, item.startCol - 1), vscode_languageserver_1.Position.create(item.startLine - 1, item.startCol - 1 + item.name.length)),
                                });
                            }
                        });
                    }
                });
            }
        }
        else {
            var flist_3 = [];
            var globalFunctions_3 = this.buffers[uri].getGlobalFunctions();
            Object.keys(globalFunctions_3).forEach(function (fname) {
                globalFunctions_3[fname].forEach(function (item) {
                    if (item.startLine - 1 === position.line && position.character > item.startCol - 1) {
                        flist_3.push(item);
                    }
                });
            });
            var scriptFunctions_3 = this.buffers[uri].getScriptFunctions();
            Object.keys(scriptFunctions_3).forEach(function (fname) {
                scriptFunctions_3[fname].forEach(function (item) {
                    if (item.startLine - 1 === position.line && position.character > item.startCol - 1) {
                        flist_3.push(item);
                    }
                });
            });
            if (flist_3.length) {
                return flist_3.filter(function (item) { return item.args && item.args.some(function (n) { return n.value === name; }); })
                    .map(function (item) {
                    var startLine = item.startLine - 1;
                    var startCol = item.startCol - 1;
                    var endCol = item.startCol - 1;
                    item.args.some(function (arg) {
                        if (arg.value === name) {
                            startCol = arg.pos.col - 1;
                            endCol = startCol + name.length;
                            return true;
                        }
                        return false;
                    });
                    return {
                        uri: uri,
                        range: vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(startLine, startCol), vscode_languageserver_1.Position.create(startLine, endCol)),
                    };
                });
            }
        }
        return res;
    };
    return Workspace;
}());
exports.Workspace = Workspace;
exports.workspace = new Workspace();


/***/ }),
/* 168 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "URI": () => (/* binding */ URI),
/* harmony export */   "Utils": () => (/* binding */ Utils)
/* harmony export */ });
var LIB;LIB=(()=>{"use strict";var t={470:t=>{function e(t){if("string"!=typeof t)throw new TypeError("Path must be a string. Received "+JSON.stringify(t))}function r(t,e){for(var r,n="",o=0,i=-1,a=0,h=0;h<=t.length;++h){if(h<t.length)r=t.charCodeAt(h);else{if(47===r)break;r=47}if(47===r){if(i===h-1||1===a);else if(i!==h-1&&2===a){if(n.length<2||2!==o||46!==n.charCodeAt(n.length-1)||46!==n.charCodeAt(n.length-2))if(n.length>2){var s=n.lastIndexOf("/");if(s!==n.length-1){-1===s?(n="",o=0):o=(n=n.slice(0,s)).length-1-n.lastIndexOf("/"),i=h,a=0;continue}}else if(2===n.length||1===n.length){n="",o=0,i=h,a=0;continue}e&&(n.length>0?n+="/..":n="..",o=2)}else n.length>0?n+="/"+t.slice(i+1,h):n=t.slice(i+1,h),o=h-i-1;i=h,a=0}else 46===r&&-1!==a?++a:a=-1}return n}var n={resolve:function(){for(var t,n="",o=!1,i=arguments.length-1;i>=-1&&!o;i--){var a;i>=0?a=arguments[i]:(void 0===t&&(t=process.cwd()),a=t),e(a),0!==a.length&&(n=a+"/"+n,o=47===a.charCodeAt(0))}return n=r(n,!o),o?n.length>0?"/"+n:"/":n.length>0?n:"."},normalize:function(t){if(e(t),0===t.length)return".";var n=47===t.charCodeAt(0),o=47===t.charCodeAt(t.length-1);return 0!==(t=r(t,!n)).length||n||(t="."),t.length>0&&o&&(t+="/"),n?"/"+t:t},isAbsolute:function(t){return e(t),t.length>0&&47===t.charCodeAt(0)},join:function(){if(0===arguments.length)return".";for(var t,r=0;r<arguments.length;++r){var o=arguments[r];e(o),o.length>0&&(void 0===t?t=o:t+="/"+o)}return void 0===t?".":n.normalize(t)},relative:function(t,r){if(e(t),e(r),t===r)return"";if((t=n.resolve(t))===(r=n.resolve(r)))return"";for(var o=1;o<t.length&&47===t.charCodeAt(o);++o);for(var i=t.length,a=i-o,h=1;h<r.length&&47===r.charCodeAt(h);++h);for(var s=r.length-h,f=a<s?a:s,u=-1,c=0;c<=f;++c){if(c===f){if(s>f){if(47===r.charCodeAt(h+c))return r.slice(h+c+1);if(0===c)return r.slice(h+c)}else a>f&&(47===t.charCodeAt(o+c)?u=c:0===c&&(u=0));break}var l=t.charCodeAt(o+c);if(l!==r.charCodeAt(h+c))break;47===l&&(u=c)}var p="";for(c=o+u+1;c<=i;++c)c!==i&&47!==t.charCodeAt(c)||(0===p.length?p+="..":p+="/..");return p.length>0?p+r.slice(h+u):(h+=u,47===r.charCodeAt(h)&&++h,r.slice(h))},_makeLong:function(t){return t},dirname:function(t){if(e(t),0===t.length)return".";for(var r=t.charCodeAt(0),n=47===r,o=-1,i=!0,a=t.length-1;a>=1;--a)if(47===(r=t.charCodeAt(a))){if(!i){o=a;break}}else i=!1;return-1===o?n?"/":".":n&&1===o?"//":t.slice(0,o)},basename:function(t,r){if(void 0!==r&&"string"!=typeof r)throw new TypeError('"ext" argument must be a string');e(t);var n,o=0,i=-1,a=!0;if(void 0!==r&&r.length>0&&r.length<=t.length){if(r.length===t.length&&r===t)return"";var h=r.length-1,s=-1;for(n=t.length-1;n>=0;--n){var f=t.charCodeAt(n);if(47===f){if(!a){o=n+1;break}}else-1===s&&(a=!1,s=n+1),h>=0&&(f===r.charCodeAt(h)?-1==--h&&(i=n):(h=-1,i=s))}return o===i?i=s:-1===i&&(i=t.length),t.slice(o,i)}for(n=t.length-1;n>=0;--n)if(47===t.charCodeAt(n)){if(!a){o=n+1;break}}else-1===i&&(a=!1,i=n+1);return-1===i?"":t.slice(o,i)},extname:function(t){e(t);for(var r=-1,n=0,o=-1,i=!0,a=0,h=t.length-1;h>=0;--h){var s=t.charCodeAt(h);if(47!==s)-1===o&&(i=!1,o=h+1),46===s?-1===r?r=h:1!==a&&(a=1):-1!==r&&(a=-1);else if(!i){n=h+1;break}}return-1===r||-1===o||0===a||1===a&&r===o-1&&r===n+1?"":t.slice(r,o)},format:function(t){if(null===t||"object"!=typeof t)throw new TypeError('The "pathObject" argument must be of type Object. Received type '+typeof t);return function(t,e){var r=e.dir||e.root,n=e.base||(e.name||"")+(e.ext||"");return r?r===e.root?r+n:r+"/"+n:n}(0,t)},parse:function(t){e(t);var r={root:"",dir:"",base:"",ext:"",name:""};if(0===t.length)return r;var n,o=t.charCodeAt(0),i=47===o;i?(r.root="/",n=1):n=0;for(var a=-1,h=0,s=-1,f=!0,u=t.length-1,c=0;u>=n;--u)if(47!==(o=t.charCodeAt(u)))-1===s&&(f=!1,s=u+1),46===o?-1===a?a=u:1!==c&&(c=1):-1!==a&&(c=-1);else if(!f){h=u+1;break}return-1===a||-1===s||0===c||1===c&&a===s-1&&a===h+1?-1!==s&&(r.base=r.name=0===h&&i?t.slice(1,s):t.slice(h,s)):(0===h&&i?(r.name=t.slice(1,a),r.base=t.slice(1,s)):(r.name=t.slice(h,a),r.base=t.slice(h,s)),r.ext=t.slice(a,s)),h>0?r.dir=t.slice(0,h-1):i&&(r.dir="/"),r},sep:"/",delimiter:":",win32:null,posix:null};n.posix=n,t.exports=n},447:(t,e,r)=>{var n;if(r.r(e),r.d(e,{URI:()=>g,Utils:()=>O}),"object"==typeof process)n="win32"===process.platform;else if("object"==typeof navigator){var o=navigator.userAgent;n=o.indexOf("Windows")>=0}var i,a,h=(i=function(t,e){return(i=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r])})(t,e)},function(t,e){function r(){this.constructor=t}i(t,e),t.prototype=null===e?Object.create(e):(r.prototype=e.prototype,new r)}),s=/^\w[\w\d+.-]*$/,f=/^\//,u=/^\/\//,c="",l="/",p=/^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/,g=function(){function t(t,e,r,n,o,i){void 0===i&&(i=!1),"object"==typeof t?(this.scheme=t.scheme||c,this.authority=t.authority||c,this.path=t.path||c,this.query=t.query||c,this.fragment=t.fragment||c):(this.scheme=function(t,e){return t||e?t:"file"}(t,i),this.authority=e||c,this.path=function(t,e){switch(t){case"https":case"http":case"file":e?e[0]!==l&&(e=l+e):e=l}return e}(this.scheme,r||c),this.query=n||c,this.fragment=o||c,function(t,e){if(!t.scheme&&e)throw new Error('[UriError]: Scheme is missing: {scheme: "", authority: "'+t.authority+'", path: "'+t.path+'", query: "'+t.query+'", fragment: "'+t.fragment+'"}');if(t.scheme&&!s.test(t.scheme))throw new Error("[UriError]: Scheme contains illegal characters.");if(t.path)if(t.authority){if(!f.test(t.path))throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character')}else if(u.test(t.path))throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")')}(this,i))}return t.isUri=function(e){return e instanceof t||!!e&&"string"==typeof e.authority&&"string"==typeof e.fragment&&"string"==typeof e.path&&"string"==typeof e.query&&"string"==typeof e.scheme&&"function"==typeof e.fsPath&&"function"==typeof e.with&&"function"==typeof e.toString},Object.defineProperty(t.prototype,"fsPath",{get:function(){return C(this,!1)},enumerable:!1,configurable:!0}),t.prototype.with=function(t){if(!t)return this;var e=t.scheme,r=t.authority,n=t.path,o=t.query,i=t.fragment;return void 0===e?e=this.scheme:null===e&&(e=c),void 0===r?r=this.authority:null===r&&(r=c),void 0===n?n=this.path:null===n&&(n=c),void 0===o?o=this.query:null===o&&(o=c),void 0===i?i=this.fragment:null===i&&(i=c),e===this.scheme&&r===this.authority&&n===this.path&&o===this.query&&i===this.fragment?this:new v(e,r,n,o,i)},t.parse=function(t,e){void 0===e&&(e=!1);var r=p.exec(t);return r?new v(r[2]||c,x(r[4]||c),x(r[5]||c),x(r[7]||c),x(r[9]||c),e):new v(c,c,c,c,c)},t.file=function(t){var e=c;if(n&&(t=t.replace(/\\/g,l)),t[0]===l&&t[1]===l){var r=t.indexOf(l,2);-1===r?(e=t.substring(2),t=l):(e=t.substring(2,r),t=t.substring(r)||l)}return new v("file",e,t,c,c)},t.from=function(t){return new v(t.scheme,t.authority,t.path,t.query,t.fragment)},t.prototype.toString=function(t){return void 0===t&&(t=!1),A(this,t)},t.prototype.toJSON=function(){return this},t.revive=function(e){if(e){if(e instanceof t)return e;var r=new v(e);return r._formatted=e.external,r._fsPath=e._sep===d?e.fsPath:null,r}return e},t}(),d=n?1:void 0,v=function(t){function e(){var e=null!==t&&t.apply(this,arguments)||this;return e._formatted=null,e._fsPath=null,e}return h(e,t),Object.defineProperty(e.prototype,"fsPath",{get:function(){return this._fsPath||(this._fsPath=C(this,!1)),this._fsPath},enumerable:!1,configurable:!0}),e.prototype.toString=function(t){return void 0===t&&(t=!1),t?A(this,!0):(this._formatted||(this._formatted=A(this,!1)),this._formatted)},e.prototype.toJSON=function(){var t={$mid:1};return this._fsPath&&(t.fsPath=this._fsPath,t._sep=d),this._formatted&&(t.external=this._formatted),this.path&&(t.path=this.path),this.scheme&&(t.scheme=this.scheme),this.authority&&(t.authority=this.authority),this.query&&(t.query=this.query),this.fragment&&(t.fragment=this.fragment),t},e}(g),m=((a={})[58]="%3A",a[47]="%2F",a[63]="%3F",a[35]="%23",a[91]="%5B",a[93]="%5D",a[64]="%40",a[33]="%21",a[36]="%24",a[38]="%26",a[39]="%27",a[40]="%28",a[41]="%29",a[42]="%2A",a[43]="%2B",a[44]="%2C",a[59]="%3B",a[61]="%3D",a[32]="%20",a);function y(t,e){for(var r=void 0,n=-1,o=0;o<t.length;o++){var i=t.charCodeAt(o);if(i>=97&&i<=122||i>=65&&i<=90||i>=48&&i<=57||45===i||46===i||95===i||126===i||e&&47===i)-1!==n&&(r+=encodeURIComponent(t.substring(n,o)),n=-1),void 0!==r&&(r+=t.charAt(o));else{void 0===r&&(r=t.substr(0,o));var a=m[i];void 0!==a?(-1!==n&&(r+=encodeURIComponent(t.substring(n,o)),n=-1),r+=a):-1===n&&(n=o)}}return-1!==n&&(r+=encodeURIComponent(t.substring(n))),void 0!==r?r:t}function b(t){for(var e=void 0,r=0;r<t.length;r++){var n=t.charCodeAt(r);35===n||63===n?(void 0===e&&(e=t.substr(0,r)),e+=m[n]):void 0!==e&&(e+=t[r])}return void 0!==e?e:t}function C(t,e){var r;return r=t.authority&&t.path.length>1&&"file"===t.scheme?"//"+t.authority+t.path:47===t.path.charCodeAt(0)&&(t.path.charCodeAt(1)>=65&&t.path.charCodeAt(1)<=90||t.path.charCodeAt(1)>=97&&t.path.charCodeAt(1)<=122)&&58===t.path.charCodeAt(2)?e?t.path.substr(1):t.path[1].toLowerCase()+t.path.substr(2):t.path,n&&(r=r.replace(/\//g,"\\")),r}function A(t,e){var r=e?b:y,n="",o=t.scheme,i=t.authority,a=t.path,h=t.query,s=t.fragment;if(o&&(n+=o,n+=":"),(i||"file"===o)&&(n+=l,n+=l),i){var f=i.indexOf("@");if(-1!==f){var u=i.substr(0,f);i=i.substr(f+1),-1===(f=u.indexOf(":"))?n+=r(u,!1):(n+=r(u.substr(0,f),!1),n+=":",n+=r(u.substr(f+1),!1)),n+="@"}-1===(f=(i=i.toLowerCase()).indexOf(":"))?n+=r(i,!1):(n+=r(i.substr(0,f),!1),n+=i.substr(f))}if(a){if(a.length>=3&&47===a.charCodeAt(0)&&58===a.charCodeAt(2))(c=a.charCodeAt(1))>=65&&c<=90&&(a="/"+String.fromCharCode(c+32)+":"+a.substr(3));else if(a.length>=2&&58===a.charCodeAt(1)){var c;(c=a.charCodeAt(0))>=65&&c<=90&&(a=String.fromCharCode(c+32)+":"+a.substr(2))}n+=r(a,!0)}return h&&(n+="?",n+=r(h,!1)),s&&(n+="#",n+=e?s:y(s,!1)),n}function w(t){try{return decodeURIComponent(t)}catch(e){return t.length>3?t.substr(0,3)+w(t.substr(3)):t}}var _=/(%[0-9A-Za-z][0-9A-Za-z])+/g;function x(t){return t.match(_)?t.replace(_,(function(t){return w(t)})):t}var O,P=r(470),j=function(){for(var t=0,e=0,r=arguments.length;e<r;e++)t+=arguments[e].length;var n=Array(t),o=0;for(e=0;e<r;e++)for(var i=arguments[e],a=0,h=i.length;a<h;a++,o++)n[o]=i[a];return n},U=P.posix||P;!function(t){t.joinPath=function(t){for(var e=[],r=1;r<arguments.length;r++)e[r-1]=arguments[r];return t.with({path:U.join.apply(U,j([t.path],e))})},t.resolvePath=function(t){for(var e=[],r=1;r<arguments.length;r++)e[r-1]=arguments[r];var n=t.path||"/";return t.with({path:U.resolve.apply(U,j([n],e))})},t.dirname=function(t){var e=U.dirname(t.path);return 1===e.length&&46===e.charCodeAt(0)?t:t.with({path:e})},t.basename=function(t){return U.basename(t.path)},t.extname=function(t){return U.extname(t.path)}}(O||(O={}))}},e={};function r(n){if(e[n])return e[n].exports;var o=e[n]={exports:{}};return t[n](o,o.exports,r),o.exports}return r.d=(t,e)=>{for(var n in e)r.o(e,n)&&!r.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r(447)})();const{URI,Utils}=LIB;
//# sourceMappingURL=index.js.map

/***/ }),
/* 169 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Buffer = void 0;
var vscode_languageserver_1 = __webpack_require__(2);
var constant_1 = __webpack_require__(64);
var logger_1 = __importDefault(__webpack_require__(155));
var log = logger_1.default("buffer");
var NODE_TOPLEVEL = 1;
var NODE_EXCMD = 3;
var NODE_FUNCTION = 4;
var NODE_DELFUNCTION = 6;
var NODE_RETURN = 7;
var NODE_EXCALL = 8;
var NODE_LET = 9;
var NODE_UNLET = 10;
var NODE_LOCKVAR = 11;
var NODE_UNLOCKVAR = 12;
var NODE_IF = 13;
var NODE_ELSEIF = 14;
var NODE_ELSE = 15;
var NODE_WHILE = 17;
var NODE_FOR = 19;
var NODE_TRY = 23;
var NODE_CATCH = 24;
var NODE_FINALLY = 25;
var NODE_THROW = 27;
var NODE_ECHO = 28;
var NODE_ECHON = 29;
var NODE_ECHOMSG = 31;
var NODE_ECHOERR = 32;
var NODE_EXECUTE = 33;
var NODE_TERNARY = 34;
var NODE_OR = 35;
var NODE_AND = 36;
var NODE_EQUAL = 37;
var NODE_EQUALCI = 38;
var NODE_EQUALCS = 39;
var NODE_NEQUAL = 40;
var NODE_NEQUALCI = 41;
var NODE_NEQUALCS = 42;
var NODE_GREATER = 43;
var NODE_GREATERCI = 44;
var NODE_GREATERCS = 45;
var NODE_GEQUAL = 46;
var NODE_GEQUALCI = 47;
var NODE_GEQUALCS = 48;
var NODE_SMALLER = 49;
var NODE_SMALLERCI = 50;
var NODE_SMALLERCS = 51;
var NODE_SEQUAL = 52;
var NODE_SEQUALCI = 53;
var NODE_SEQUALCS = 54;
var NODE_MATCH = 55;
var NODE_MATCHCI = 56;
var NODE_MATCHCS = 57;
var NODE_NOMATCH = 58;
var NODE_NOMATCHCI = 59;
var NODE_NOMATCHCS = 60;
var NODE_IS = 61;
var NODE_ISCI = 62;
var NODE_ISCS = 63;
var NODE_ISNOT = 64;
var NODE_ISNOTCI = 65;
var NODE_ISNOTCS = 66;
var NODE_ADD = 67;
var NODE_SUBTRACT = 68;
var NODE_CONCAT = 69;
var NODE_MULTIPLY = 70;
var NODE_DIVIDE = 71;
var NODE_REMAINDER = 72;
var NODE_NOT = 73;
var NODE_MINUS = 74;
var NODE_PLUS = 75;
var NODE_SUBSCRIPT = 76;
var NODE_SLICE = 77;
var NODE_CALL = 78;
var NODE_DOT = 79;
var NODE_NUMBER = 80;
var NODE_STRING = 81;
var NODE_LIST = 82;
var NODE_DICT = 83;
var NODE_IDENTIFIER = 86;
var NODE_CURLYNAME = 87;
var NODE_ENV = 88;
var NODE_REG = 89; // TODO
var NODE_CURLYNAMEPART = 90; // TODO
var NODE_CURLYNAMEEXPR = 91; // TODO
var NODE_LAMBDA = 92;
var NODE_CONST = 94;
var NODE_EVAL = 95;
var NODE_HEREDOC = 96;
var NODE_METHOD = 97;
var globalFuncPattern = /^(g:\w+(\.\w+)*|[a-zA-Z_]\w*(\.\w+)*|(\w+#)+\w*)$/;
var scriptFuncPattern = /^(s:\w+(\.\w+)*|<SID>\w+(\.\w+)*)$/i;
var globalVariablePattern = /^(g:\w+(\.\w+)*|b:\w+(\.\w+)*|\w{1,}(\.\w+)*|\w+(#\w+)+)$/;
var localVariablePattern = /^(s:\w+(\.\w+)*|l:\w+(\.\w+)*|a:\w+(\.\w+)*)$/;
var envPattern = /^\$\w+$/;
var Buffer = /** @class */ (function () {
    function Buffer(uri, projectRoot, node) {
        this.uri = uri;
        this.projectRoot = projectRoot;
        this.node = node;
        this.globalFunctions = {};
        this.scriptFunctions = {};
        this.globalFunctionRefs = {};
        this.scriptFunctionRefs = {};
        this.globalVariables = {};
        this.localVariables = {};
        this.globalVariableRefs = {};
        this.localVariableRefs = {};
        this.envs = {};
        this.envRefs = {};
        this.ranges = [];
        this.updateBufferByNode(this.node);
    }
    Buffer.prototype.getGlobalFunctions = function () {
        return this.globalFunctions;
    };
    Buffer.prototype.getGlobalFunctionRefs = function () {
        return this.globalFunctionRefs;
    };
    Buffer.prototype.getScriptFunctions = function () {
        return this.scriptFunctions;
    };
    Buffer.prototype.getScriptFunctionRefs = function () {
        return this.scriptFunctionRefs;
    };
    Buffer.prototype.getGlobalIdentifiers = function () {
        return this.globalVariables;
    };
    Buffer.prototype.getGlobalIdentifierRefs = function () {
        return this.globalVariableRefs;
    };
    Buffer.prototype.getLocalIdentifiers = function () {
        return this.localVariables;
    };
    Buffer.prototype.getLocalIdentifierRefs = function () {
        return this.localVariableRefs;
    };
    Buffer.prototype.getRanges = function () {
        return this.ranges;
    };
    Buffer.prototype.getProjectRoot = function () {
        return this.projectRoot;
    };
    Buffer.prototype.isBelongToWorkdir = function (workUri) {
        return this.projectRoot === workUri;
    };
    Buffer.prototype.updateBufferByNode = function (node) {
        this.node = node;
        this.resetProperties();
        try {
            this.resolveCompletionItems([node]);
        }
        catch (error) {
            log.warn("updateBufferByNode: " + error.stack);
        }
    };
    /*
     * global function
     *
     * - g:xxx
     * - xx#xxx
     */
    Buffer.prototype.getGlobalFunctionItems = function () {
        var _this = this;
        var refs = {};
        Object.keys(this.globalFunctionRefs).forEach(function (name) {
            if (!_this.globalFunctions[name]) {
                refs[name] = _this.globalFunctionRefs[name];
            }
        });
        return this.getFunctionItems(this.globalFunctions, constant_1.sortTexts.three)
            .concat(this.getFunctionItems(refs, constant_1.sortTexts.three));
    };
    /*
     * script function
     *
     * - s:xxx
     */
    Buffer.prototype.getScriptFunctionItems = function () {
        var _this = this;
        var refs = {};
        Object.keys(this.scriptFunctionRefs).forEach(function (name) {
            if (!_this.scriptFunctions[name]) {
                refs[name] = _this.scriptFunctionRefs[name];
            }
        });
        return this.getFunctionItems(this.scriptFunctions, constant_1.sortTexts.two)
            .concat(this.getFunctionItems(refs, constant_1.sortTexts.two));
    };
    /*
     * global identifier
     *
     * - g:xxx
     * - b:xxx
     * - [a-zA-Z]+
     * - xx#xxx
     */
    Buffer.prototype.getGlobalIdentifierItems = function () {
        var _this = this;
        var refs = {};
        Object.keys(this.globalVariableRefs).forEach(function (name) {
            if (!_this.globalVariables[name]) {
                refs[name] = _this.globalVariableRefs[name];
            }
        });
        var globalVariables = [];
        var localVariables = [];
        this.getIdentifierItems(this.globalVariables, constant_1.sortTexts.three)
            .concat(this.getIdentifierItems(refs, constant_1.sortTexts.three))
            .forEach(function (item) {
            if (/^([a-zA-Z_]\w*(\.\w+)*)$/.test(item.label)) {
                localVariables.push(item);
            }
            else {
                globalVariables.push(item);
            }
        });
        if (localVariables.length) {
            var gloalFunctions = this.getGlobalFunctions();
            var scriptFunctions = this.getScriptFunctions();
            var funList_1 = Object.values(gloalFunctions).concat(Object.values(scriptFunctions)).reduce(function (res, fs) { return res.concat(fs); }, []);
            localVariables.forEach(function (l) {
                if (l.data.some(function (identifier) {
                    return funList_1.every(function (fun) {
                        return !(fun.startLine < identifier.startLine && identifier.startLine < fun.endLine);
                    });
                })) {
                    globalVariables.push(l);
                }
            });
        }
        return globalVariables;
    };
    /*
     * local identifier
     *
     * - s:xxx
     */
    Buffer.prototype.getLocalIdentifierItems = function () {
        var _this = this;
        var refs = {};
        Object.keys(this.localVariableRefs).forEach(function (name) {
            if (!_this.localVariables[name]) {
                refs[name] = _this.localVariableRefs[name];
            }
        });
        return this.getIdentifierItems(this.localVariables, constant_1.sortTexts.two)
            .concat(this.getIdentifierItems(refs, constant_1.sortTexts.two))
            .filter(function (item) { return !/^(a|l):/.test(item.label); });
    };
    /*
     * function local identifier
     *
     * - l:xxx
     * - a:xxx
     * - identifiers in function range
     */
    Buffer.prototype.getFunctionLocalIdentifierItems = function (line) {
        var vimLineNum = line + 1;
        var startLine = -1;
        var endLine = -1;
        // get function args completion items
        var funArgs = []
            .concat(Object.values(this.globalFunctions).reduce(function (res, next) { return res.concat(next); }, []))
            .concat(Object.values(this.scriptFunctions).reduce(function (res, next) { return res.concat(next); }, []))
            .filter(function (fun) {
            if (startLine === -1 && endLine === -1 && fun.startLine < vimLineNum && vimLineNum < fun.endLine) {
                startLine = fun.startLine;
                endLine = fun.endLine;
            }
            else if (fun.startLine > startLine && endLine > fun.endLine) {
                startLine = fun.startLine;
                endLine = fun.endLine;
            }
            return fun.startLine < vimLineNum && vimLineNum < fun.endLine;
        })
            .reduce(function (res, next) {
            (next.args || []).forEach(function (name) {
                if (res.indexOf(name.value) === -1) {
                    res.push(name.value);
                }
            });
            return res;
        }, [])
            .map(function (name) { return ({
            label: "a:" + name,
            kind: vscode_languageserver_1.CompletionItemKind.Variable,
            sortText: constant_1.sortTexts.one,
            insertText: "a:" + name,
            insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
        }); });
        if (startLine !== -1 && endLine !== -1) {
            var funcLocalIdentifiers = this.getIdentifierItems(this.localVariables, constant_1.sortTexts.one)
                .concat(this.getIdentifierItems(this.globalVariables, constant_1.sortTexts.one))
                .filter(function (item) {
                if (!(/^l:/.test(item.label) || /^([a-zA-Z_]\w*(\.\w+)*)$/.test(item.label))) {
                    return false;
                }
                var data = item.data;
                if (!data) {
                    return false;
                }
                return data.some(function (i) { return startLine < i.startLine && i.startLine < endLine; });
            });
            return funArgs.concat(funcLocalIdentifiers);
        }
        return [];
    };
    /*
     * environment identifier
     *
     * - $xxx
     */
    Buffer.prototype.getEnvItems = function () {
        return Object.keys(this.envs).map(function (name) {
            return {
                label: name,
                insertText: name,
                sortText: constant_1.sortTexts.three,
                insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
            };
        });
    };
    Buffer.prototype.resetProperties = function () {
        this.globalFunctions = {};
        this.scriptFunctions = {};
        this.globalFunctionRefs = {};
        this.scriptFunctionRefs = {};
        this.globalVariables = {};
        this.localVariables = {};
        this.globalVariableRefs = {};
        this.localVariableRefs = {};
        this.envs = {};
        this.envRefs = {};
        this.ranges = [];
    };
    Buffer.prototype.resolveCompletionItems = function (nodes) {
        var nodeList = [].concat(nodes);
        while (nodeList.length > 0) {
            var node = nodeList.pop();
            switch (node.type) {
                case NODE_TOPLEVEL:
                    nodeList = nodeList.concat(node.body);
                    break;
                // autocmd/command/map
                case NODE_EXCMD:
                    this.takeFuncRefByExcmd(node);
                    break;
                case NODE_EXCALL:
                case NODE_RETURN:
                case NODE_DELFUNCTION:
                case NODE_THROW:
                case NODE_EVAL:
                    nodeList = nodeList.concat(node.left);
                    break;
                case NODE_DOT:
                    nodeList = nodeList.concat(node.left);
                    this.takeIdentifier(node);
                    break;
                case NODE_ECHO:
                case NODE_ECHON:
                case NODE_ECHOMSG:
                case NODE_ECHOERR:
                case NODE_UNLET:
                case NODE_LOCKVAR:
                case NODE_UNLOCKVAR:
                case NODE_EXECUTE:
                    nodeList = nodeList.concat(node.list || []);
                    break;
                case NODE_TERNARY:
                    nodeList = nodeList.concat(node.cond || []);
                    nodeList = nodeList.concat(node.left || []);
                    nodeList = nodeList.concat(node.right || []);
                    break;
                case NODE_IF:
                case NODE_ELSEIF:
                case NODE_ELSE:
                case NODE_WHILE:
                    this.takeRange(node, ['endif', 'endwhile']);
                    nodeList = nodeList.concat(node.body || []);
                    nodeList = nodeList.concat(node.cond || []);
                    nodeList = nodeList.concat(node.elseif || []);
                    nodeList = nodeList.concat(node._else || []);
                    break;
                case NODE_OR:
                case NODE_AND:
                case NODE_EQUAL:
                case NODE_EQUALCI:
                case NODE_EQUALCS:
                case NODE_NEQUAL:
                case NODE_NEQUALCI:
                case NODE_NEQUALCS:
                case NODE_GREATER:
                case NODE_GREATERCI:
                case NODE_GREATERCS:
                case NODE_GEQUAL:
                case NODE_GEQUALCI:
                case NODE_GEQUALCS:
                case NODE_SMALLER:
                case NODE_SMALLERCI:
                case NODE_SMALLERCS:
                case NODE_SEQUAL:
                case NODE_SEQUALCI:
                case NODE_SEQUALCS:
                case NODE_MATCH:
                case NODE_MATCHCI:
                case NODE_MATCHCS:
                case NODE_NOMATCH:
                case NODE_NOMATCHCI:
                case NODE_NOMATCHCS:
                case NODE_IS:
                case NODE_ISCI:
                case NODE_ISCS:
                case NODE_ISNOT:
                case NODE_ISNOTCI:
                case NODE_ISNOTCS:
                case NODE_CONCAT:
                case NODE_MULTIPLY:
                case NODE_DIVIDE:
                case NODE_REMAINDER:
                case NODE_NOT:
                case NODE_MINUS:
                case NODE_PLUS:
                case NODE_ADD:
                case NODE_SUBTRACT:
                case NODE_SUBSCRIPT:
                case NODE_METHOD:
                    nodeList = nodeList.concat(node.left || []);
                    nodeList = nodeList.concat(node.right || []);
                    break;
                case NODE_FOR:
                    nodeList = nodeList.concat(node.body || []);
                    nodeList = nodeList.concat(node.right || []);
                    this.takeFor([].concat(node.left || []).concat(node.list || []));
                    this.takeRange(node, 'endfor');
                    break;
                case NODE_TRY:
                case NODE_CATCH:
                case NODE_FINALLY:
                    this.takeRange(node, 'endtry');
                    nodeList = nodeList.concat(node.body || []);
                    nodeList = nodeList.concat(node.catch || []);
                    nodeList = nodeList.concat(node._finally || []);
                    break;
                case NODE_FUNCTION:
                    nodeList = nodeList.concat(node.body || []);
                    if (node.left && node.left.type === NODE_DOT) {
                        nodeList = nodeList.concat(node.left.left);
                    }
                    this.takeFunction(node);
                    this.takeRange(node, 'endfunction');
                    break;
                case NODE_LIST:
                    nodeList = nodeList.concat(node.value || []);
                    break;
                case NODE_DICT:
                    nodeList = nodeList.concat((node.value || []).map(function (item) { return item[1]; }));
                    break;
                case NODE_SLICE:
                case NODE_LAMBDA:
                    nodeList = nodeList.concat(node.left || []);
                    nodeList = nodeList.concat(node.rlist || []);
                    break;
                case NODE_CALL:
                    nodeList = nodeList.concat(node.rlist || []);
                    if (node.left && node.left.type === NODE_DOT) {
                        nodeList = nodeList.concat(node.left.left);
                    }
                    this.takeFuncRefByRef(node);
                    this.takeFuncRef(node);
                    break;
                case NODE_LET:
                case NODE_CONST:
                    nodeList = nodeList.concat(node.right || []);
                    if (node.left && node.left.type === NODE_DOT) {
                        nodeList = nodeList.concat(node.left.left);
                    }
                    // not a function by function()/funcref()
                    if (!this.takeFunctionByRef(node)) {
                        this.takeLet(node);
                    }
                    break;
                case NODE_ENV:
                case NODE_IDENTIFIER:
                    this.takeIdentifier(node);
                    break;
                default:
                    break;
            }
        }
        // log.info(`parse_buffer: ${JSON.stringify(this)}`)
    };
    Buffer.prototype.takeFunction = function (node) {
        var left = node.left, rlist = node.rlist, endfunction = node.endfunction;
        var name = this.getDotName(left);
        if (!name) {
            return;
        }
        var pos = this.getDotPos(left);
        if (!pos) {
            return;
        }
        var func = {
            name: name,
            args: rlist || [],
            startLine: pos.lnum,
            startCol: pos.col,
            endLine: endfunction.pos.lnum,
            endCol: endfunction.pos.col,
            range: {
                startLine: node.pos.lnum,
                startCol: node.pos.col,
                endLine: endfunction.pos.lnum,
                endCol: endfunction.pos.col,
            }
        };
        if (globalFuncPattern.test(name)) {
            if (!this.globalFunctions[name] || !Array.isArray(this.globalFunctions[name])) {
                this.globalFunctions[name] = [];
            }
            this.globalFunctions[name].push(func);
        }
        else if (scriptFuncPattern.test(name)) {
            if (!this.scriptFunctions[name] || !Array.isArray(this.scriptFunctions[name])) {
                this.scriptFunctions[name] = [];
            }
            this.scriptFunctions[name].push(func);
        }
    };
    /*
     * vim function
     *
     * - let funcName = function()
     * - let funcName = funcref()
     */
    Buffer.prototype.takeFunctionByRef = function (node) {
        var left = node.left, right = node.right;
        if (!right || right.type !== NODE_CALL) {
            return;
        }
        // is not function()/funcref()
        if (!right.left ||
            !right.left.value ||
            ["function", "funcref"].indexOf(right.left.value) === -1) {
            return;
        }
        var name = this.getDotName(left);
        if (!name) {
            return;
        }
        var pos = this.getDotPos(left);
        if (!pos) {
            return false;
        }
        var func = {
            name: name,
            args: [],
            startLine: pos.lnum,
            startCol: pos.col,
            endLine: pos.lnum,
            endCol: pos.col,
            range: {
                startLine: pos.lnum,
                startCol: pos.col,
                endLine: pos.lnum,
                endCol: pos.col,
            }
        };
        if (globalFuncPattern.test(name)) {
            if (!this.globalFunctions[name] || !Array.isArray(this.globalFunctions[name])) {
                this.globalFunctions[name] = [];
            }
            this.globalFunctions[name].push(func);
            return true;
        }
        else if (scriptFuncPattern.test(name)) {
            if (!this.scriptFunctions[name] || !Array.isArray(this.scriptFunctions[name])) {
                this.scriptFunctions[name] = [];
            }
            this.scriptFunctions[name].push(func);
            return true;
        }
        return false;
    };
    Buffer.prototype.takeFuncRef = function (node) {
        var left = node.left, rlist = node.rlist;
        var name = "";
        if (left.type === NODE_IDENTIFIER) {
            name = left.value;
            // <SID>funName
        }
        else if (left.type === NODE_CURLYNAME) {
            name = (left.value || []).map(function (item) { return item.value; }).join("");
        }
        else if (left.type === NODE_DOT) {
            name = this.getDotName(left);
        }
        if (!name) {
            return;
        }
        var pos = this.getDotPos(left);
        if (!pos) {
            return;
        }
        var funcRef = {
            name: name,
            args: rlist || [],
            startLine: pos.lnum,
            startCol: pos.col,
        };
        if (globalFuncPattern.test(name)) {
            if (!this.globalFunctionRefs[name] || !Array.isArray(this.globalFunctionRefs[name])) {
                this.globalFunctionRefs[name] = [];
            }
            this.globalFunctionRefs[name].push(funcRef);
        }
        else if (scriptFuncPattern.test(name)) {
            if (!this.scriptFunctionRefs[name] || !Array.isArray(this.scriptFunctionRefs[name])) {
                this.scriptFunctionRefs[name] = [];
            }
            this.scriptFunctionRefs[name].push(funcRef);
        }
    };
    /*
     * vim function ref
     * first value is function name
     *
     * - function('funcName')
     * - funcref('funcName')
     */
    Buffer.prototype.takeFuncRefByRef = function (node) {
        var left = node.left, rlist = node.rlist;
        var funcNode = rlist && rlist[0];
        if (!left ||
            ["function", "funcref"].indexOf(left.value) === -1 ||
            !funcNode ||
            !funcNode.pos ||
            typeof funcNode.value !== "string") {
            return;
        }
        // delete '/" of function name
        var name = funcNode.value.replace(/^['"]|['"]$/g, "");
        var funcRef = {
            name: name,
            args: [],
            startLine: funcNode.pos.lnum,
            startCol: funcNode.pos.col + 1, // +1 by '/"
        };
        if (globalFuncPattern.test(name)) {
            if (!this.globalFunctionRefs[name] || !Array.isArray(this.globalFunctionRefs[name])) {
                this.globalFunctionRefs[name] = [];
            }
            this.globalFunctionRefs[name].push(funcRef);
        }
        else if (scriptFuncPattern.test(name)) {
            if (!this.scriptFunctionRefs[name] || !Array.isArray(this.scriptFunctionRefs[name])) {
                this.scriptFunctionRefs[name] = [];
            }
            this.scriptFunctionRefs[name].push(funcRef);
        }
    };
    /*
     * FIXME: take function ref by
     *
     * - autocmd
     * - command
     * - map
     */
    Buffer.prototype.takeFuncRefByExcmd = function (node) {
        var pos = node.pos, str = node.str;
        if (!str) {
            return;
        }
        // tslint:disable-next-line: max-line-length
        if (!/^[ \t]*((au|aut|auto|autoc|autocm|autocmd|com|comm|comma|comman|command)!?[ \t]+|([a-zA-Z]*map!?[ \t]+.*?:))/.test(str)) {
            return;
        }
        var regFunc = /(<sid>[\w_#]+|[a-zA-Z_]:[\w_#]+|[\w_#]+)[ \t]*\(/gi;
        var m = regFunc.exec(str);
        while (m) {
            var name = m[1];
            if (name) {
                var funcRef = {
                    name: name,
                    args: [],
                    startLine: pos.lnum,
                    startCol: pos.col + m.index,
                };
                if (globalFuncPattern.test(name)) {
                    if (!this.globalFunctionRefs[name] || !Array.isArray(this.globalFunctionRefs[name])) {
                        this.globalFunctionRefs[name] = [];
                    }
                    this.globalFunctionRefs[name].push(funcRef);
                }
                else if (scriptFuncPattern.test(name)) {
                    if (!this.scriptFunctionRefs[name] || !Array.isArray(this.scriptFunctionRefs[name])) {
                        this.scriptFunctionRefs[name] = [];
                    }
                    this.scriptFunctionRefs[name].push(funcRef);
                }
            }
            m = regFunc.exec(str);
        }
    };
    Buffer.prototype.takeLet = function (node) {
        var pos = this.getDotPos(node.left);
        var name = this.getDotName(node.left);
        if (!pos || !name) {
            return;
        }
        var identifier = {
            name: name,
            startLine: pos.lnum,
            startCol: pos.col,
        };
        if (localVariablePattern.test(name)) {
            if (!this.localVariables[name] || !Array.isArray(this.localVariables[name])) {
                this.localVariables[name] = [];
            }
            this.localVariables[name].push(identifier);
        }
        else if (globalVariablePattern.test(name)) {
            if (!this.globalVariables[name] || !Array.isArray(this.globalVariables[name])) {
                this.globalVariables[name] = [];
            }
            this.globalVariables[name].push(identifier);
        }
        else if (envPattern.test(name)) {
            if (!this.envs[name] || !Array.isArray(this.envs[name])) {
                this.envs[name] = [];
            }
            this.envs[name].push(identifier);
        }
    };
    Buffer.prototype.takeRange = function (node, keys) {
        var _this = this;
        [].concat(keys).forEach(function (key) {
            if (node.pos && node[key] && node[key].pos) {
                _this.ranges.push({
                    startLine: node.pos.lnum,
                    startCol: node.pos.col,
                    endLine: node[key].pos.lnum,
                    endCol: node[key].pos.col
                });
            }
        });
    };
    Buffer.prototype.takeFor = function (nodes) {
        var _this = this;
        nodes.forEach(function (node) {
            if (node.type !== NODE_IDENTIFIER || !node.pos) {
                return;
            }
            var name = node.value;
            var identifier = {
                name: name,
                startLine: node.pos.lnum,
                startCol: node.pos.col,
            };
            if (localVariablePattern.test(name)) {
                if (!_this.localVariables[name] || !Array.isArray(_this.localVariables[name])) {
                    _this.localVariables[name] = [];
                }
                _this.localVariables[name].push(identifier);
            }
            else if (globalVariablePattern.test(name)) {
                if (!_this.globalVariables[name] || !Array.isArray(_this.globalVariables[name])) {
                    _this.globalVariables[name] = [];
                }
                _this.globalVariables[name].push(identifier);
            }
            else if (envPattern.test(name)) {
                if (!_this.envs[name] || !Array.isArray(_this.envs[name])) {
                    _this.envs[name] = [];
                }
                _this.envs[name].push(identifier);
            }
        });
    };
    Buffer.prototype.takeIdentifier = function (node) {
        var name = this.getDotName(node);
        if (!name) {
            return;
        }
        var pos = this.getDotPos(node);
        if (!pos) {
            return;
        }
        var identifier = {
            name: name,
            startLine: pos.lnum,
            startCol: pos.col,
        };
        if (globalVariablePattern.test(name)) {
            if (!this.globalVariableRefs[name] || !Array.isArray(this.globalVariableRefs[name])) {
                this.globalVariableRefs[name] = [];
            }
            this.globalVariableRefs[name].push(identifier);
        }
        else if (localVariablePattern.test(name)) {
            if (!this.localVariableRefs[name] || !Array.isArray(this.localVariableRefs[name])) {
                this.localVariableRefs[name] = [];
            }
            this.localVariableRefs[name].push(identifier);
        }
        else if (envPattern.test(name)) {
            if (!this.envRefs[name] || !Array.isArray(this.envRefs[name])) {
                this.envRefs[name] = [];
            }
            this.envRefs[name].push(identifier);
        }
    };
    Buffer.prototype.getDotPos = function (node) {
        if (!node) {
            return null;
        }
        if (node.type === NODE_IDENTIFIER ||
            node.type === NODE_ENV ||
            node.type === NODE_CURLYNAME) {
            return node.pos;
        }
        var left = node.left;
        return this.getDotPos(left);
    };
    Buffer.prototype.getDotName = function (node) {
        if (node.type === NODE_IDENTIFIER ||
            node.type === NODE_STRING ||
            node.type === NODE_NUMBER ||
            node.type === NODE_ENV) {
            return node.value;
        }
        else if (node.type === NODE_CURLYNAME) {
            return (node.value || []).map(function (item) { return item.value; }).join("");
        }
        else if (node.type === NODE_SUBSCRIPT) {
            return this.getDotName(node.left);
        }
        var left = node.left, right = node.right;
        var list = [];
        if (left) {
            list.push(this.getDotName(left));
        }
        if (right) {
            list.push(this.getDotName(right));
        }
        return list.join(".");
    };
    Buffer.prototype.getFunctionItems = function (items, sortText) {
        return Object.keys(items).map(function (name) {
            var list = items[name];
            var args = "${1}";
            if (list[0] && list[0].args && list[0].args.length > 0) {
                args = (list[0].args || []).reduce(function (res, next, idx) {
                    // FIXME: resove next.value is not string
                    var value = typeof next.value !== "string" ? "param" : next.value;
                    if (idx === 0) {
                        return "${" + (idx + 1) + ":" + value + "}";
                    }
                    return res + ", ${" + (idx + 1) + ":" + value + "}";
                }, "");
            }
            var label = name;
            if (/^<SID>/.test(name)) {
                label = name.replace(/^<SID>/, "s:");
            }
            return {
                label: label,
                detail: "any",
                sortText: sortText,
                documentation: "User defined function",
                kind: vscode_languageserver_1.CompletionItemKind.Function,
                insertText: label + "(" + args + ")${0}",
                insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
            };
        });
    };
    Buffer.prototype.getIdentifierItems = function (items, sortText) {
        var _this = this;
        return Object.keys(items)
            .filter(function (name) { return !_this.globalFunctions[name] && !_this.scriptFunctions[name]; })
            .map(function (name) {
            var list = items[name];
            return {
                label: name,
                kind: vscode_languageserver_1.CompletionItemKind.Variable,
                sortText: sortText,
                documentation: "User defined variable",
                insertText: name,
                insertTextFormat: vscode_languageserver_1.InsertTextFormat.PlainText,
                data: list || [],
            };
        });
    };
    return Buffer;
}());
exports.Buffer = Buffer;


/***/ }),
/* 170 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var patterns_1 = __webpack_require__(72);
var util_1 = __webpack_require__(66);
var builtin_1 = __webpack_require__(77);
var provider_1 = __webpack_require__(159);
function provider(line) {
    if (util_1.isSomeMatchPattern(patterns_1.featurePattern, line)) {
        return builtin_1.builtinDocs.getVimFeatures();
    }
    return [];
}
provider_1.useProvider(provider);


/***/ }),
/* 171 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var patterns_1 = __webpack_require__(72);
var builtin_1 = __webpack_require__(77);
var provider_1 = __webpack_require__(159);
function provider(line) {
    if (!patterns_1.highlightLinkPattern.test(line) &&
        !patterns_1.highlightValuePattern.test(line) &&
        patterns_1.highlightPattern.test(line)) {
        return builtin_1.builtinDocs.getHighlightArgKeys().filter(function (item) {
            return line.indexOf(item.label) === -1;
        });
    }
    return [];
}
provider_1.useProvider(provider);


/***/ }),
/* 172 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var patterns_1 = __webpack_require__(72);
var builtin_1 = __webpack_require__(77);
var provider_1 = __webpack_require__(159);
function provider(line) {
    var m = line.match(patterns_1.highlightValuePattern);
    if (!patterns_1.highlightLinkPattern.test(line) && m) {
        var values = builtin_1.builtinDocs.getHighlightArgValues();
        var keyName = m[3];
        if (values[keyName]) {
            return values[keyName];
        }
    }
    return [];
}
provider_1.useProvider(provider);


/***/ }),
/* 173 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var patterns_1 = __webpack_require__(72);
var util_1 = __webpack_require__(66);
var config_1 = __importDefault(__webpack_require__(73));
var workspaces_1 = __webpack_require__(167);
var provider_1 = __webpack_require__(159);
function provider(line, uri, position) {
    if (util_1.isSomeMatchPattern(patterns_1.notIdentifierPattern, line)) {
        return [];
    }
    else if (/\b[gbsla]:\w*$/.test(line)) {
        var list = [];
        if (/\bg:\w*$/.test(line)) {
            list = workspaces_1.workspace.getIdentifierItems(uri, position.line)
                .filter(function (item) { return /^g:/.test(item.label); });
        }
        else if (/\bb:\w*$/.test(line)) {
            list = workspaces_1.workspace.getIdentifierItems(uri, position.line)
                .filter(function (item) { return /^b:/.test(item.label); });
        }
        else if (/\bs:\w*$/.test(line)) {
            list = workspaces_1.workspace.getIdentifierItems(uri, position.line)
                .filter(function (item) { return /^s:/.test(item.label); });
        }
        else if (/\bl:\w*$/.test(line)) {
            list = workspaces_1.workspace.getIdentifierItems(uri, position.line)
                .filter(function (item) { return /^l:/.test(item.label); });
        }
        else if (/\ba:\w*$/.test(line)) {
            list = workspaces_1.workspace.getIdentifierItems(uri, position.line)
                .filter(function (item) { return /^a:/.test(item.label); });
        }
        return list.map(function (item) { return (__assign(__assign({}, item), { insertText: !/:/.test(config_1.default.iskeyword) ? item.insertText.slice(2) : item.insertText })); });
    }
    else if (/\B:\w*$/.test(line)) {
        return workspaces_1.workspace.getIdentifierItems(uri, position.line)
            .filter(function (item) { return /:/.test(item.label); })
            .map(function (item) {
            var m = line.match(/:[^:]*$/);
            return __assign(__assign({}, item), { 
                // delete the `:` symbol
                textEdit: {
                    range: {
                        start: {
                            line: position.line,
                            character: line.length - m[0].length,
                        },
                        end: {
                            line: position.line,
                            character: line.length - m[0].length + 1,
                        },
                    },
                    newText: item.insertText,
                } });
        });
    }
    return workspaces_1.workspace.getIdentifierItems(uri, position.line);
}
provider_1.useProvider(provider);


/***/ }),
/* 174 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var patterns_1 = __webpack_require__(72);
var builtin_1 = __webpack_require__(77);
var provider_1 = __webpack_require__(159);
function provider(line) {
    if (patterns_1.mapCommandPattern.test(line)) {
        if (/<$/.test(line)) {
            return builtin_1.builtinDocs.getVimMapArgs().map(function (item) { return (__assign(__assign({}, item), { insertText: item.insertText.slice(1) })); });
        }
        return builtin_1.builtinDocs.getVimMapArgs();
    }
    return [];
}
provider_1.useProvider(provider);


/***/ }),
/* 175 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var patterns_1 = __webpack_require__(72);
var util_1 = __webpack_require__(66);
var builtin_1 = __webpack_require__(77);
var provider_1 = __webpack_require__(159);
function provider(line) {
    if (util_1.isSomeMatchPattern(patterns_1.optionPattern, line)) {
        return builtin_1.builtinDocs.getVimOptions();
    }
    return [];
}
provider_1.useProvider(provider);


/***/ }),
/* 176 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.completionResolveProvider = void 0;
var builtin_1 = __webpack_require__(77);
var completionResolveProvider = function (params) {
    return builtin_1.builtinDocs.getDocumentByCompletionItem(params);
};
exports.completionResolveProvider = completionResolveProvider;


/***/ }),
/* 177 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.definitionProvider = void 0;
var util_1 = __webpack_require__(66);
var documents_1 = __webpack_require__(74);
var workspaces_1 = __webpack_require__(167);
var definitionProvider = function (params) {
    var textDocument = params.textDocument, position = params.position;
    var doc = documents_1.documents.get(textDocument.uri);
    if (!doc) {
        return null;
    }
    var words = util_1.getWordFromPosition(doc, position);
    if (!words) {
        return null;
    }
    var currentName = words.word;
    if (/\./.test(words.right)) {
        var tail = words.right.replace(/^[^.]*(\.)/, "$1");
        currentName = words.word.replace(tail, "");
    }
    return workspaces_1.workspace.getLocations(currentName, doc.uri, position, "definition").locations;
};
exports.definitionProvider = definitionProvider;


/***/ }),
/* 178 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.documentHighlightProvider = void 0;
var util_1 = __webpack_require__(66);
var documents_1 = __webpack_require__(74);
var workspaces_1 = __webpack_require__(167);
exports.documentHighlightProvider = (function (params) {
    var textDocument = params.textDocument, position = params.position;
    var doc = documents_1.documents.get(textDocument.uri);
    if (!doc) {
        return [];
    }
    var words = util_1.getWordFromPosition(doc, position);
    if (!words) {
        return [];
    }
    var currentName = words.word;
    if (/\./.test(words.right)) {
        var tail = words.right.replace(/^[^.]*(\.)/, "$1");
        currentName = words.word.replace(tail, "");
    }
    var defs = workspaces_1.workspace.getLocationsByUri(currentName, doc.uri, position, "definition");
    var refs = workspaces_1.workspace.getLocationsByUri(currentName, doc.uri, position, "references");
    return defs.locations.concat(refs.locations)
        .map(function (location) {
        return {
            range: location.range,
        };
    });
});


/***/ }),
/* 179 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.foldingRangeProvider = void 0;
var workspaces_1 = __webpack_require__(167);
var foldingRangeProvider = function (params) { return __awaiter(void 0, void 0, void 0, function () {
    var res, textDocument, buffer, globalFunctions, scriptFunctions;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                res = [];
                textDocument = params.textDocument;
                return [4 /*yield*/, workspaces_1.workspace.getBufferByUri(textDocument.uri)];
            case 1:
                buffer = _a.sent();
                if (!buffer) {
                    return [2 /*return*/, res];
                }
                globalFunctions = buffer.getGlobalFunctions();
                scriptFunctions = buffer.getScriptFunctions();
                return [2 /*return*/, Object.values(globalFunctions).concat(Object.values(scriptFunctions))
                        .reduce(function (pre, cur) {
                        return pre.concat(cur);
                    }, [])
                        .map(function (func) {
                        return {
                            startLine: func.startLine - 1,
                            startCharacter: func.startCol - 1,
                            endLine: func.endLine - 1,
                            endCharacter: func.endCol - 1,
                            kind: "region",
                        };
                    })];
        }
    });
}); };
exports.foldingRangeProvider = foldingRangeProvider;


/***/ }),
/* 180 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hoverProvider = void 0;
var util_1 = __webpack_require__(66);
var builtin_1 = __webpack_require__(77);
var documents_1 = __webpack_require__(74);
var hoverProvider = function (params) {
    var textDocument = params.textDocument, position = params.position;
    var doc = documents_1.documents.get(textDocument.uri);
    if (!doc) {
        return;
    }
    var words = util_1.getWordFromPosition(doc, position);
    if (!words) {
        return;
    }
    return builtin_1.builtinDocs.getHoverDocument(words.word, words.wordLeft, words.wordRight);
};
exports.hoverProvider = hoverProvider;


/***/ }),
/* 181 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.referencesProvider = void 0;
var util_1 = __webpack_require__(66);
var documents_1 = __webpack_require__(74);
var workspaces_1 = __webpack_require__(167);
var referencesProvider = function (params) {
    var textDocument = params.textDocument, position = params.position;
    var doc = documents_1.documents.get(textDocument.uri);
    if (!doc) {
        return null;
    }
    var words = util_1.getWordFromPosition(doc, position);
    if (!words) {
        return null;
    }
    var currentName = words.word;
    if (/\./.test(words.right)) {
        var tail = words.right.replace(/^[^.]*(\.)/, "$1");
        currentName = words.word.replace(tail, "");
    }
    return workspaces_1.workspace.getLocations(currentName, doc.uri, position, "references").locations;
};
exports.referencesProvider = referencesProvider;


/***/ }),
/* 182 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.renameProvider = exports.prepareProvider = void 0;
var vscode_languageserver_1 = __webpack_require__(2);
var util_1 = __webpack_require__(66);
var documents_1 = __webpack_require__(74);
var workspaces_1 = __webpack_require__(167);
var prepareProvider = function (params) {
    var textDocument = params.textDocument, position = params.position;
    var doc = documents_1.documents.get(textDocument.uri);
    if (!doc) {
        return null;
    }
    var words = util_1.getWordFromPosition(doc, position);
    if (!words) {
        return null;
    }
    var currentName = words.word;
    if (/\./.test(words.right)) {
        var tail = words.right.replace(/^[^.]*(\.)/, "$1");
        currentName = words.word.replace(tail, "");
    }
    return {
        range: vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(position.line, position.character - words.left.length), vscode_languageserver_1.Position.create(position.line, position.character + words.right.length - 1)),
        placeholder: currentName,
    };
};
exports.prepareProvider = prepareProvider;
var renameProvider = function (params) {
    var textDocument = params.textDocument, position = params.position, newName = params.newName;
    var doc = documents_1.documents.get(textDocument.uri);
    if (!doc) {
        return null;
    }
    var words = util_1.getWordFromPosition(doc, position);
    if (!words) {
        return null;
    }
    var currentName = words.word;
    if (/\./.test(words.right)) {
        var tail = words.right.replace(/^[^.]*(\.)/, "$1");
        currentName = words.word.replace(tail, "");
    }
    var changes = {};
    var isChange = false;
    workspaces_1.workspace.getLocations(currentName, doc.uri, position, "definition").locations
        .forEach(function (l) {
        isChange = true;
        if (!changes[l.uri] || !Array.isArray(changes[l.uri])) {
            changes[l.uri] = [];
        }
        changes[l.uri].push({
            newText: /^a:/.test(newName) ? newName.slice(2) : newName,
            range: l.range,
        });
    });
    var refs = workspaces_1.workspace.getLocations(currentName, doc.uri, position, "references");
    refs.locations.forEach(function (l) {
        isChange = true;
        if (!changes[l.uri] || !Array.isArray(changes[l.uri])) {
            changes[l.uri] = [];
        }
        changes[l.uri].push({
            newText: refs.isFunArg ? "a:" + newName : newName,
            range: l.range,
        });
    });
    if (isChange) {
        return {
            changes: changes,
        };
    }
    return null;
};
exports.renameProvider = renameProvider;


/***/ }),
/* 183 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.signatureHelpProvider = void 0;
var vscode_languageserver_1 = __webpack_require__(2);
var patterns_1 = __webpack_require__(72);
var builtin_1 = __webpack_require__(77);
var documents_1 = __webpack_require__(74);
var signatureHelpProvider = function (params) {
    var textDocument = params.textDocument, position = params.position;
    var doc = documents_1.documents.get(textDocument.uri);
    if (!doc) {
        return;
    }
    var currentLine = doc.getText(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(position.line, 0), vscode_languageserver_1.Position.create(position.line + 1, 0)));
    // comment line
    if (patterns_1.commentPattern.test(currentLine)) {
        return;
    }
    var preSegment = currentLine.slice(0, position.character);
    var m = preSegment.match(/([\w#&:]+?)[ \t]*\([ \t]*([^()]*?)$/);
    if (!m) {
        return;
    }
    var functionName = m["1"];
    var placeIdx = m[0].split(",").length - 1;
    return builtin_1.builtinDocs.getSignatureHelpByName(functionName, placeIdx);
};
exports.signatureHelpProvider = signatureHelpProvider;


/***/ }),
/* 184 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parserFiles = exports.scanRuntimePaths = exports.unsubscribe = exports.next = void 0;
var child_process_1 = __importDefault(__webpack_require__(61));
var path_1 = __webpack_require__(23);
var rxjs_1 = __webpack_require__(185);
var waitMap_1 = __webpack_require__(288);
var operators_1 = __webpack_require__(289);
var vscode_uri_1 = __webpack_require__(168);
var logger_1 = __importDefault(__webpack_require__(155));
var util_1 = __webpack_require__(66);
var diagnostic_1 = __webpack_require__(387);
var config_1 = __importDefault(__webpack_require__(73));
var workspaces_1 = __webpack_require__(167);
var log = logger_1.default("parser");
var parserHandles = {};
var indexes = {};
var indexesFsPaths = {};
var origin$ = new rxjs_1.Subject();
var parserCallbacks = {};
var queueFsPaths = [];
var scanProcess;
var isScanRuntimepath = false;
var isParsing = false;
function send(params) {
    if (!scanProcess) {
        log.log('scan process do not exists');
        return false;
    }
    if (scanProcess.signalCode) {
        log.log("scan process signal code: " + scanProcess.signalCode);
        return false;
    }
    if (scanProcess.killed) {
        log.log('scan process was killed');
        return false;
    }
    scanProcess.send(params, function (err) {
        if (err) {
            log.warn("Send error: " + (err.stack || err.message || err.name));
        }
    });
    return true;
}
function startIndex() {
    if (scanProcess) {
        return;
    }
    scanProcess = child_process_1.default.fork(path_1.join(__dirname, "scan.js"), ["--node-ipc"]);
    scanProcess.on("message", function (mess) {
        var msglog = mess.msglog, id = mess.id, res = mess.res, error = mess.error, fsPaths = mess.fsPaths;
        if (msglog) {
            log.info("child_log: " + msglog);
        }
        if (fsPaths) {
            parserFiles(fsPaths);
        }
        if (id && parserCallbacks[id]) {
            parserCallbacks[id]({
                res: res,
                error: error
            });
            delete parserCallbacks[id];
        }
    });
    scanProcess.on("error", function (err) {
        log.warn("" + (err.stack || err.message || err));
    });
    scanProcess.on('exit', function (code, signal) {
        log.log("exit: " + code + ", signal: " + signal);
    });
    scanProcess.on('close', function (code, signal) {
        log.log("close: " + code + ", signal: " + signal);
    });
    scanProcess.on('uncaughtException', function (err) {
        log.log("Uncaught exception: " + (err.stack || err.message || err.name || err));
    });
    scanProcess.on('disconnect', function () {
        log.log("disconnect");
    });
    send({
        config: {
            gap: config_1.default.indexes.gap,
            count: config_1.default.indexes.count,
            projectRootPatterns: config_1.default.indexes.projectRootPatterns,
        },
    });
}
function next(textDoc) {
    if (!parserHandles[textDoc.uri]) {
        var uri_1 = textDoc.uri;
        parserHandles[uri_1] = origin$.pipe(operators_1.filter(function (td) { return uri_1 === td.uri; }), operators_1.switchMap(function (td) {
            return rxjs_1.timer(100).pipe(operators_1.map(function () { return td; }));
        }), waitMap_1.waitMap(function (td) {
            var id = Date.now() + "-" + Math.random();
            return rxjs_1.from(new Promise(function (res) {
                parserCallbacks[id] = res;
                send({
                    id: id,
                    uri: uri_1,
                    text: td.getText()
                });
            })).pipe(operators_1.timeout(50000), operators_1.catchError(function () {
                if (parserCallbacks[id]) {
                    delete parserCallbacks[id];
                }
                scanProcess.kill();
                scanProcess = undefined;
                return rxjs_1.of({
                    res: '',
                    error: "Timeout: 50000ms",
                    isTimeout: true,
                });
            }));
        }, true)).subscribe(function (data) {
            var res = data.res, error = data.error, isTimeout = data.isTimeout;
            if (res) {
                if (config_1.default.diagnostic.enable) {
                    // handle diagnostic
                    diagnostic_1.handleDiagnostic(textDoc, res[1]);
                }
                // handle node
                workspaces_1.workspace.updateBuffer(uri_1, res[0]);
            }
            if (error) {
                log.error("Parse " + uri_1 + " error: " + error);
            }
            if (isTimeout) {
                log.showErrorMessage("Parse " + uri_1 + " error: " + error);
            }
            // scan project
            if (!indexes[uri_1]) {
                indexes[uri_1] = true;
                send({
                    uri: uri_1,
                });
                if (!isScanRuntimepath) {
                    isScanRuntimepath = true;
                    scanRuntimePaths([config_1.default.vimruntime].concat(config_1.default.runtimepath));
                }
            }
        }, function (err) {
            log.warn("" + (err.stack || err.message || err));
        });
    }
    if (!scanProcess) {
        startIndex();
    }
    origin$.next(textDoc);
}
exports.next = next;
function unsubscribe(textDoc) {
    if (parserHandles[textDoc.uri] !== undefined) {
        parserHandles[textDoc.uri].unsubscribe();
    }
    parserHandles[textDoc.uri] = undefined;
}
exports.unsubscribe = unsubscribe;
// scan directory
function scanRuntimePaths(paths) {
    if (!scanProcess) {
        startIndex();
    }
    if (config_1.default.indexes.runtimepath) {
        var list = [].concat(paths);
        for (var _i = 0, list_1 = list; _i < list_1.length; _i++) {
            var p = list_1[_i];
            if (!p) {
                continue;
            }
            p = p.trim();
            if (!p || p === "/") {
                continue;
            }
            var uri = vscode_uri_1.URI.file(path_1.join(p, "f")).toString();
            if (!indexes[uri]) {
                indexes[uri] = true;
                send({
                    uri: uri
                });
            }
        }
    }
}
exports.scanRuntimePaths = scanRuntimePaths;
function parserFiles(paths) {
    return __awaiter(this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    queueFsPaths.push.apply(queueFsPaths, paths);
                    if (isParsing) {
                        return [2 /*return*/];
                    }
                    isParsing = true;
                    _a.label = 1;
                case 1:
                    if (!queueFsPaths.length) return [3 /*break*/, 4];
                    return [4 /*yield*/, Promise.all(Array(config_1.default.indexes.count).fill('').map(function () { return __awaiter(_this, void 0, void 0, function () {
                            var fsPath, id, data, uri;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        fsPath = queueFsPaths.shift();
                                        if (!fsPath || indexesFsPaths[fsPath]) {
                                            return [2 /*return*/];
                                        }
                                        indexesFsPaths[fsPath] = true;
                                        id = Date.now() + "-" + Math.random();
                                        return [4 /*yield*/, new Promise(function (res) {
                                                parserCallbacks[id] = res;
                                                var isSend = send({
                                                    id: id,
                                                    fsPath: fsPath
                                                });
                                                if (isSend) {
                                                    setTimeout(function () {
                                                        delete parserCallbacks[id];
                                                        res({
                                                            error: 'Timeout 50000ms',
                                                            timeout: true
                                                        });
                                                    }, 50000);
                                                }
                                                else {
                                                    queueFsPaths.unshift(fsPath);
                                                    delete parserCallbacks[id];
                                                    res({
                                                        error: "Cancel parser since scan process does not exists"
                                                    });
                                                }
                                            })];
                                    case 1:
                                        data = _a.sent();
                                        if (data.res && data.res[0]) {
                                            uri = vscode_uri_1.URI.file(fsPath).toString();
                                            if (!workspaces_1.workspace.isExistsBuffer(uri)) {
                                                workspaces_1.workspace.updateBuffer(uri, data.res[0]);
                                            }
                                        }
                                        if (data.error) {
                                            log.error("Parse " + fsPath + " error: " + data.error);
                                        }
                                        if (data.timeout) {
                                            scanProcess.kill();
                                            scanProcess = undefined;
                                            startIndex();
                                            log.showErrorMessage("Parse " + fsPath + " error: " + data.error);
                                        }
                                        return [2 /*return*/];
                                }
                            });
                        }); }))];
                case 2:
                    _a.sent();
                    return [4 /*yield*/, util_1.delay(config_1.default.indexes.gap)];
                case 3:
                    _a.sent();
                    return [3 /*break*/, 1];
                case 4:
                    isParsing = false;
                    return [2 /*return*/];
            }
        });
    });
}
exports.parserFiles = parserFiles;


/***/ }),
/* 185 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Observable": () => (/* reexport safe */ _internal_Observable__WEBPACK_IMPORTED_MODULE_0__.Observable),
/* harmony export */   "ConnectableObservable": () => (/* reexport safe */ _internal_observable_ConnectableObservable__WEBPACK_IMPORTED_MODULE_1__.ConnectableObservable),
/* harmony export */   "GroupedObservable": () => (/* reexport safe */ _internal_operators_groupBy__WEBPACK_IMPORTED_MODULE_2__.GroupedObservable),
/* harmony export */   "observable": () => (/* reexport safe */ _internal_symbol_observable__WEBPACK_IMPORTED_MODULE_3__.observable),
/* harmony export */   "Subject": () => (/* reexport safe */ _internal_Subject__WEBPACK_IMPORTED_MODULE_4__.Subject),
/* harmony export */   "BehaviorSubject": () => (/* reexport safe */ _internal_BehaviorSubject__WEBPACK_IMPORTED_MODULE_5__.BehaviorSubject),
/* harmony export */   "ReplaySubject": () => (/* reexport safe */ _internal_ReplaySubject__WEBPACK_IMPORTED_MODULE_6__.ReplaySubject),
/* harmony export */   "AsyncSubject": () => (/* reexport safe */ _internal_AsyncSubject__WEBPACK_IMPORTED_MODULE_7__.AsyncSubject),
/* harmony export */   "asap": () => (/* reexport safe */ _internal_scheduler_asap__WEBPACK_IMPORTED_MODULE_8__.asap),
/* harmony export */   "asapScheduler": () => (/* reexport safe */ _internal_scheduler_asap__WEBPACK_IMPORTED_MODULE_8__.asapScheduler),
/* harmony export */   "async": () => (/* reexport safe */ _internal_scheduler_async__WEBPACK_IMPORTED_MODULE_9__.async),
/* harmony export */   "asyncScheduler": () => (/* reexport safe */ _internal_scheduler_async__WEBPACK_IMPORTED_MODULE_9__.asyncScheduler),
/* harmony export */   "queue": () => (/* reexport safe */ _internal_scheduler_queue__WEBPACK_IMPORTED_MODULE_10__.queue),
/* harmony export */   "queueScheduler": () => (/* reexport safe */ _internal_scheduler_queue__WEBPACK_IMPORTED_MODULE_10__.queueScheduler),
/* harmony export */   "animationFrame": () => (/* reexport safe */ _internal_scheduler_animationFrame__WEBPACK_IMPORTED_MODULE_11__.animationFrame),
/* harmony export */   "animationFrameScheduler": () => (/* reexport safe */ _internal_scheduler_animationFrame__WEBPACK_IMPORTED_MODULE_11__.animationFrameScheduler),
/* harmony export */   "VirtualTimeScheduler": () => (/* reexport safe */ _internal_scheduler_VirtualTimeScheduler__WEBPACK_IMPORTED_MODULE_12__.VirtualTimeScheduler),
/* harmony export */   "VirtualAction": () => (/* reexport safe */ _internal_scheduler_VirtualTimeScheduler__WEBPACK_IMPORTED_MODULE_12__.VirtualAction),
/* harmony export */   "Scheduler": () => (/* reexport safe */ _internal_Scheduler__WEBPACK_IMPORTED_MODULE_13__.Scheduler),
/* harmony export */   "Subscription": () => (/* reexport safe */ _internal_Subscription__WEBPACK_IMPORTED_MODULE_14__.Subscription),
/* harmony export */   "Subscriber": () => (/* reexport safe */ _internal_Subscriber__WEBPACK_IMPORTED_MODULE_15__.Subscriber),
/* harmony export */   "Notification": () => (/* reexport safe */ _internal_Notification__WEBPACK_IMPORTED_MODULE_16__.Notification),
/* harmony export */   "NotificationKind": () => (/* reexport safe */ _internal_Notification__WEBPACK_IMPORTED_MODULE_16__.NotificationKind),
/* harmony export */   "pipe": () => (/* reexport safe */ _internal_util_pipe__WEBPACK_IMPORTED_MODULE_17__.pipe),
/* harmony export */   "noop": () => (/* reexport safe */ _internal_util_noop__WEBPACK_IMPORTED_MODULE_18__.noop),
/* harmony export */   "identity": () => (/* reexport safe */ _internal_util_identity__WEBPACK_IMPORTED_MODULE_19__.identity),
/* harmony export */   "isObservable": () => (/* reexport safe */ _internal_util_isObservable__WEBPACK_IMPORTED_MODULE_20__.isObservable),
/* harmony export */   "ArgumentOutOfRangeError": () => (/* reexport safe */ _internal_util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_21__.ArgumentOutOfRangeError),
/* harmony export */   "EmptyError": () => (/* reexport safe */ _internal_util_EmptyError__WEBPACK_IMPORTED_MODULE_22__.EmptyError),
/* harmony export */   "ObjectUnsubscribedError": () => (/* reexport safe */ _internal_util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_23__.ObjectUnsubscribedError),
/* harmony export */   "UnsubscriptionError": () => (/* reexport safe */ _internal_util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_24__.UnsubscriptionError),
/* harmony export */   "TimeoutError": () => (/* reexport safe */ _internal_util_TimeoutError__WEBPACK_IMPORTED_MODULE_25__.TimeoutError),
/* harmony export */   "bindCallback": () => (/* reexport safe */ _internal_observable_bindCallback__WEBPACK_IMPORTED_MODULE_26__.bindCallback),
/* harmony export */   "bindNodeCallback": () => (/* reexport safe */ _internal_observable_bindNodeCallback__WEBPACK_IMPORTED_MODULE_27__.bindNodeCallback),
/* harmony export */   "combineLatest": () => (/* reexport safe */ _internal_observable_combineLatest__WEBPACK_IMPORTED_MODULE_28__.combineLatest),
/* harmony export */   "concat": () => (/* reexport safe */ _internal_observable_concat__WEBPACK_IMPORTED_MODULE_29__.concat),
/* harmony export */   "defer": () => (/* reexport safe */ _internal_observable_defer__WEBPACK_IMPORTED_MODULE_30__.defer),
/* harmony export */   "empty": () => (/* reexport safe */ _internal_observable_empty__WEBPACK_IMPORTED_MODULE_31__.empty),
/* harmony export */   "forkJoin": () => (/* reexport safe */ _internal_observable_forkJoin__WEBPACK_IMPORTED_MODULE_32__.forkJoin),
/* harmony export */   "from": () => (/* reexport safe */ _internal_observable_from__WEBPACK_IMPORTED_MODULE_33__.from),
/* harmony export */   "fromEvent": () => (/* reexport safe */ _internal_observable_fromEvent__WEBPACK_IMPORTED_MODULE_34__.fromEvent),
/* harmony export */   "fromEventPattern": () => (/* reexport safe */ _internal_observable_fromEventPattern__WEBPACK_IMPORTED_MODULE_35__.fromEventPattern),
/* harmony export */   "generate": () => (/* reexport safe */ _internal_observable_generate__WEBPACK_IMPORTED_MODULE_36__.generate),
/* harmony export */   "iif": () => (/* reexport safe */ _internal_observable_iif__WEBPACK_IMPORTED_MODULE_37__.iif),
/* harmony export */   "interval": () => (/* reexport safe */ _internal_observable_interval__WEBPACK_IMPORTED_MODULE_38__.interval),
/* harmony export */   "merge": () => (/* reexport safe */ _internal_observable_merge__WEBPACK_IMPORTED_MODULE_39__.merge),
/* harmony export */   "never": () => (/* reexport safe */ _internal_observable_never__WEBPACK_IMPORTED_MODULE_40__.never),
/* harmony export */   "of": () => (/* reexport safe */ _internal_observable_of__WEBPACK_IMPORTED_MODULE_41__.of),
/* harmony export */   "onErrorResumeNext": () => (/* reexport safe */ _internal_observable_onErrorResumeNext__WEBPACK_IMPORTED_MODULE_42__.onErrorResumeNext),
/* harmony export */   "pairs": () => (/* reexport safe */ _internal_observable_pairs__WEBPACK_IMPORTED_MODULE_43__.pairs),
/* harmony export */   "partition": () => (/* reexport safe */ _internal_observable_partition__WEBPACK_IMPORTED_MODULE_44__.partition),
/* harmony export */   "race": () => (/* reexport safe */ _internal_observable_race__WEBPACK_IMPORTED_MODULE_45__.race),
/* harmony export */   "range": () => (/* reexport safe */ _internal_observable_range__WEBPACK_IMPORTED_MODULE_46__.range),
/* harmony export */   "throwError": () => (/* reexport safe */ _internal_observable_throwError__WEBPACK_IMPORTED_MODULE_47__.throwError),
/* harmony export */   "timer": () => (/* reexport safe */ _internal_observable_timer__WEBPACK_IMPORTED_MODULE_48__.timer),
/* harmony export */   "using": () => (/* reexport safe */ _internal_observable_using__WEBPACK_IMPORTED_MODULE_49__.using),
/* harmony export */   "zip": () => (/* reexport safe */ _internal_observable_zip__WEBPACK_IMPORTED_MODULE_50__.zip),
/* harmony export */   "scheduled": () => (/* reexport safe */ _internal_scheduled_scheduled__WEBPACK_IMPORTED_MODULE_51__.scheduled),
/* harmony export */   "EMPTY": () => (/* reexport safe */ _internal_observable_empty__WEBPACK_IMPORTED_MODULE_31__.EMPTY),
/* harmony export */   "NEVER": () => (/* reexport safe */ _internal_observable_never__WEBPACK_IMPORTED_MODULE_40__.NEVER),
/* harmony export */   "config": () => (/* reexport safe */ _internal_config__WEBPACK_IMPORTED_MODULE_52__.config)
/* harmony export */ });
/* harmony import */ var _internal_Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(186);
/* harmony import */ var _internal_observable_ConnectableObservable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(203);
/* harmony import */ var _internal_operators_groupBy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(208);
/* harmony import */ var _internal_symbol_observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(200);
/* harmony import */ var _internal_Subject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(205);
/* harmony import */ var _internal_BehaviorSubject__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(209);
/* harmony import */ var _internal_ReplaySubject__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(210);
/* harmony import */ var _internal_AsyncSubject__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(227);
/* harmony import */ var _internal_scheduler_asap__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(228);
/* harmony import */ var _internal_scheduler_async__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(232);
/* harmony import */ var _internal_scheduler_queue__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(220);
/* harmony import */ var _internal_scheduler_animationFrame__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(233);
/* harmony import */ var _internal_scheduler_VirtualTimeScheduler__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(236);
/* harmony import */ var _internal_Scheduler__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(223);
/* harmony import */ var _internal_Subscription__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(194);
/* harmony import */ var _internal_Subscriber__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(188);
/* harmony import */ var _internal_Notification__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(212);
/* harmony import */ var _internal_util_pipe__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(201);
/* harmony import */ var _internal_util_noop__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(237);
/* harmony import */ var _internal_util_identity__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(202);
/* harmony import */ var _internal_util_isObservable__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(238);
/* harmony import */ var _internal_util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(239);
/* harmony import */ var _internal_util_EmptyError__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(240);
/* harmony import */ var _internal_util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(206);
/* harmony import */ var _internal_util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(196);
/* harmony import */ var _internal_util_TimeoutError__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(241);
/* harmony import */ var _internal_observable_bindCallback__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(242);
/* harmony import */ var _internal_observable_bindNodeCallback__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(244);
/* harmony import */ var _internal_observable_combineLatest__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(245);
/* harmony import */ var _internal_observable_concat__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(256);
/* harmony import */ var _internal_observable_defer__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(268);
/* harmony import */ var _internal_observable_empty__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(219);
/* harmony import */ var _internal_observable_forkJoin__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(269);
/* harmony import */ var _internal_observable_from__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(260);
/* harmony import */ var _internal_observable_fromEvent__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(270);
/* harmony import */ var _internal_observable_fromEventPattern__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(271);
/* harmony import */ var _internal_observable_generate__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(272);
/* harmony import */ var _internal_observable_iif__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(273);
/* harmony import */ var _internal_observable_interval__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(274);
/* harmony import */ var _internal_observable_merge__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(276);
/* harmony import */ var _internal_observable_never__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(277);
/* harmony import */ var _internal_observable_of__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(213);
/* harmony import */ var _internal_observable_onErrorResumeNext__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(278);
/* harmony import */ var _internal_observable_pairs__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(279);
/* harmony import */ var _internal_observable_partition__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(280);
/* harmony import */ var _internal_observable_race__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(283);
/* harmony import */ var _internal_observable_range__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(284);
/* harmony import */ var _internal_observable_throwError__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(218);
/* harmony import */ var _internal_observable_timer__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(285);
/* harmony import */ var _internal_observable_using__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(286);
/* harmony import */ var _internal_observable_zip__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(287);
/* harmony import */ var _internal_scheduled_scheduled__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(261);
/* harmony import */ var _internal_config__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(191);
/** PURE_IMPORTS_START  PURE_IMPORTS_END */























































//# sourceMappingURL=index.js.map


/***/ }),
/* 186 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Observable": () => (/* binding */ Observable)
/* harmony export */ });
/* harmony import */ var _util_canReportError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(199);
/* harmony import */ var _util_toSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(187);
/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(200);
/* harmony import */ var _util_pipe__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(201);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(191);
/** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */





var Observable = /*@__PURE__*/ (function () {
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = (0,_util_toSubscriber__WEBPACK_IMPORTED_MODULE_0__.toSubscriber)(observerOrNext, error, complete);
        if (operator) {
            sink.add(operator.call(sink, this.source));
        }
        else {
            sink.add(this.source || (_config__WEBPACK_IMPORTED_MODULE_1__.config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                this._subscribe(sink) :
                this._trySubscribe(sink));
        }
        if (_config__WEBPACK_IMPORTED_MODULE_1__.config.useDeprecatedSynchronousErrorHandling) {
            if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                }
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            if (_config__WEBPACK_IMPORTED_MODULE_1__.config.useDeprecatedSynchronousErrorHandling) {
                sink.syncErrorThrown = true;
                sink.syncErrorValue = err;
            }
            if ((0,_util_canReportError__WEBPACK_IMPORTED_MODULE_2__.canReportError)(sink)) {
                sink.error(err);
            }
            else {
                console.warn(err);
            }
        }
    };
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var subscription;
            subscription = _this.subscribe(function (value) {
                try {
                    next(value);
                }
                catch (err) {
                    reject(err);
                    if (subscription) {
                        subscription.unsubscribe();
                    }
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
    };
    Observable.prototype[_symbol_observable__WEBPACK_IMPORTED_MODULE_3__.observable] = function () {
        return this;
    };
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return (0,_util_pipe__WEBPACK_IMPORTED_MODULE_4__.pipeFromArray)(operations)(this);
    };
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());

function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
        promiseCtor = _config__WEBPACK_IMPORTED_MODULE_1__.config.Promise || Promise;
    }
    if (!promiseCtor) {
        throw new Error('no Promise impl found');
    }
    return promiseCtor;
}
//# sourceMappingURL=Observable.js.map


/***/ }),
/* 187 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "toSubscriber": () => (/* binding */ toSubscriber)
/* harmony export */ });
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(188);
/* harmony import */ var _symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(193);
/* harmony import */ var _Observer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(190);
/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */



function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof _Subscriber__WEBPACK_IMPORTED_MODULE_0__.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_1__.rxSubscriber]) {
            return nextOrObserver[_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_1__.rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new _Subscriber__WEBPACK_IMPORTED_MODULE_0__.Subscriber(_Observer__WEBPACK_IMPORTED_MODULE_2__.empty);
    }
    return new _Subscriber__WEBPACK_IMPORTED_MODULE_0__.Subscriber(nextOrObserver, error, complete);
}
//# sourceMappingURL=toSubscriber.js.map


/***/ }),
/* 188 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Subscriber": () => (/* binding */ Subscriber),
/* harmony export */   "SafeSubscriber": () => (/* binding */ SafeSubscriber)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(195);
/* harmony import */ var _Observer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(190);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(194);
/* harmony import */ var _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(193);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(191);
/* harmony import */ var _util_hostReportError__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(192);
/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */







var Subscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(Subscriber, _super);
    function Subscriber(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch (arguments.length) {
            case 0:
                _this.destination = _Observer__WEBPACK_IMPORTED_MODULE_1__.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    _this.destination = _Observer__WEBPACK_IMPORTED_MODULE_1__.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                        _this.destination = destinationOrNext;
                        destinationOrNext.add(_this);
                    }
                    else {
                        _this.syncErrorThrowable = true;
                        _this.destination = new SafeSubscriber(_this, destinationOrNext);
                    }
                    break;
                }
            default:
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                break;
        }
        return _this;
    }
    Subscriber.prototype[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_2__.rxSubscriber] = function () { return this; };
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _parentOrParents = this._parentOrParents;
        this._parentOrParents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parentOrParents = _parentOrParents;
        return this;
    };
    return Subscriber;
}(_Subscription__WEBPACK_IMPORTED_MODULE_3__.Subscription));

var SafeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_4__.isFunction)(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== _Observer__WEBPACK_IMPORTED_MODULE_1__.empty) {
                context = Object.create(observerOrNext);
                if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_4__.isFunction)(context.unsubscribe)) {
                    _this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = _this.unsubscribe.bind(_this);
            }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!_config__WEBPACK_IMPORTED_MODULE_5__.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            var useDeprecatedSynchronousErrorHandling = _config__WEBPACK_IMPORTED_MODULE_5__.config.useDeprecatedSynchronousErrorHandling;
            if (this._error) {
                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                if (useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                (0,_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.hostReportError)(err);
            }
            else {
                if (useDeprecatedSynchronousErrorHandling) {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                }
                else {
                    (0,_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.hostReportError)(err);
                }
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!_config__WEBPACK_IMPORTED_MODULE_5__.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            if (_config__WEBPACK_IMPORTED_MODULE_5__.config.useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                (0,_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.hostReportError)(err);
            }
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        if (!_config__WEBPACK_IMPORTED_MODULE_5__.config.useDeprecatedSynchronousErrorHandling) {
            throw new Error('bad call');
        }
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            if (_config__WEBPACK_IMPORTED_MODULE_5__.config.useDeprecatedSynchronousErrorHandling) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            }
            else {
                (0,_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.hostReportError)(err);
                return true;
            }
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));

//# sourceMappingURL=Subscriber.js.map


/***/ }),
/* 189 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "__extends": () => (/* binding */ __extends),
/* harmony export */   "__assign": () => (/* binding */ __assign),
/* harmony export */   "__rest": () => (/* binding */ __rest),
/* harmony export */   "__decorate": () => (/* binding */ __decorate),
/* harmony export */   "__param": () => (/* binding */ __param),
/* harmony export */   "__metadata": () => (/* binding */ __metadata),
/* harmony export */   "__awaiter": () => (/* binding */ __awaiter),
/* harmony export */   "__generator": () => (/* binding */ __generator),
/* harmony export */   "__exportStar": () => (/* binding */ __exportStar),
/* harmony export */   "__values": () => (/* binding */ __values),
/* harmony export */   "__read": () => (/* binding */ __read),
/* harmony export */   "__spread": () => (/* binding */ __spread),
/* harmony export */   "__spreadArrays": () => (/* binding */ __spreadArrays),
/* harmony export */   "__await": () => (/* binding */ __await),
/* harmony export */   "__asyncGenerator": () => (/* binding */ __asyncGenerator),
/* harmony export */   "__asyncDelegator": () => (/* binding */ __asyncDelegator),
/* harmony export */   "__asyncValues": () => (/* binding */ __asyncValues),
/* harmony export */   "__makeTemplateObject": () => (/* binding */ __makeTemplateObject),
/* harmony export */   "__importStar": () => (/* binding */ __importStar),
/* harmony export */   "__importDefault": () => (/* binding */ __importDefault)
/* harmony export */ });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}


/***/ }),
/* 190 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "empty": () => (/* binding */ empty)
/* harmony export */ });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(191);
/* harmony import */ var _util_hostReportError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(192);
/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */


var empty = {
    closed: true,
    next: function (value) { },
    error: function (err) {
        if (_config__WEBPACK_IMPORTED_MODULE_0__.config.useDeprecatedSynchronousErrorHandling) {
            throw err;
        }
        else {
            (0,_util_hostReportError__WEBPACK_IMPORTED_MODULE_1__.hostReportError)(err);
        }
    },
    complete: function () { }
};
//# sourceMappingURL=Observer.js.map


/***/ }),
/* 191 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "config": () => (/* binding */ config)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var _enable_super_gross_mode_that_will_cause_bad_things = false;
var config = {
    Promise: undefined,
    set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
            var error = /*@__PURE__*/ new Error();
            /*@__PURE__*/ console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
        }
        else if (_enable_super_gross_mode_that_will_cause_bad_things) {
            /*@__PURE__*/ console.log('RxJS: Back to a better error behavior. Thank you. <3');
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
    },
};
//# sourceMappingURL=config.js.map


/***/ }),
/* 192 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hostReportError": () => (/* binding */ hostReportError)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function hostReportError(err) {
    setTimeout(function () { throw err; }, 0);
}
//# sourceMappingURL=hostReportError.js.map


/***/ }),
/* 193 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "rxSubscriber": () => (/* binding */ rxSubscriber),
/* harmony export */   "$$rxSubscriber": () => (/* binding */ $$rxSubscriber)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var rxSubscriber = /*@__PURE__*/ (function () {
    return typeof Symbol === 'function'
        ? /*@__PURE__*/ Symbol('rxSubscriber')
        : '@@rxSubscriber_' + /*@__PURE__*/ Math.random();
})();
var $$rxSubscriber = rxSubscriber;
//# sourceMappingURL=rxSubscriber.js.map


/***/ }),
/* 194 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Subscription": () => (/* binding */ Subscription)
/* harmony export */ });
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(197);
/* harmony import */ var _util_isObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(198);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(195);
/* harmony import */ var _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(196);
/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */




var Subscription = /*@__PURE__*/ (function () {
    function Subscription(unsubscribe) {
        this.closed = false;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._ctorUnsubscribe = true;
            this._unsubscribe = unsubscribe;
        }
    }
    Subscription.prototype.unsubscribe = function () {
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parentOrParents = _a._parentOrParents, _ctorUnsubscribe = _a._ctorUnsubscribe, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (_parentOrParents instanceof Subscription) {
            _parentOrParents.remove(this);
        }
        else if (_parentOrParents !== null) {
            for (var index = 0; index < _parentOrParents.length; ++index) {
                var parent_1 = _parentOrParents[index];
                parent_1.remove(this);
            }
        }
        if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(_unsubscribe)) {
            if (_ctorUnsubscribe) {
                this._unsubscribe = undefined;
            }
            try {
                _unsubscribe.call(this);
            }
            catch (e) {
                errors = e instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_1__.UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
            }
        }
        if ((0,_util_isArray__WEBPACK_IMPORTED_MODULE_2__.isArray)(_subscriptions)) {
            var index = -1;
            var len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if ((0,_util_isObject__WEBPACK_IMPORTED_MODULE_3__.isObject)(sub)) {
                    try {
                        sub.unsubscribe();
                    }
                    catch (e) {
                        errors = errors || [];
                        if (e instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_1__.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                        }
                        else {
                            errors.push(e);
                        }
                    }
                }
            }
        }
        if (errors) {
            throw new _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_1__.UnsubscriptionError(errors);
        }
    };
    Subscription.prototype.add = function (teardown) {
        var subscription = teardown;
        if (!teardown) {
            return Subscription.EMPTY;
        }
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (!(subscription instanceof Subscription)) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default: {
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
            }
        }
        var _parentOrParents = subscription._parentOrParents;
        if (_parentOrParents === null) {
            subscription._parentOrParents = this;
        }
        else if (_parentOrParents instanceof Subscription) {
            if (_parentOrParents === this) {
                return subscription;
            }
            subscription._parentOrParents = [_parentOrParents, this];
        }
        else if (_parentOrParents.indexOf(this) === -1) {
            _parentOrParents.push(this);
        }
        else {
            return subscription;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions === null) {
            this._subscriptions = [subscription];
        }
        else {
            subscriptions.push(subscription);
        }
        return subscription;
    };
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());

function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_1__.UnsubscriptionError) ? err.errors : err); }, []);
}
//# sourceMappingURL=Subscription.js.map


/***/ }),
/* 195 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isFunction": () => (/* binding */ isFunction)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isFunction(x) {
    return typeof x === 'function';
}
//# sourceMappingURL=isFunction.js.map


/***/ }),
/* 196 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UnsubscriptionError": () => (/* binding */ UnsubscriptionError)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var UnsubscriptionErrorImpl = /*@__PURE__*/ (function () {
    function UnsubscriptionErrorImpl(errors) {
        Error.call(this);
        this.message = errors ?
            errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
        this.name = 'UnsubscriptionError';
        this.errors = errors;
        return this;
    }
    UnsubscriptionErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return UnsubscriptionErrorImpl;
})();
var UnsubscriptionError = UnsubscriptionErrorImpl;
//# sourceMappingURL=UnsubscriptionError.js.map


/***/ }),
/* 197 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isArray": () => (/* binding */ isArray)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArray = /*@__PURE__*/ (function () { return Array.isArray || (function (x) { return x && typeof x.length === 'number'; }); })();
//# sourceMappingURL=isArray.js.map


/***/ }),
/* 198 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isObject": () => (/* binding */ isObject)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isObject(x) {
    return x !== null && typeof x === 'object';
}
//# sourceMappingURL=isObject.js.map


/***/ }),
/* 199 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "canReportError": () => (/* binding */ canReportError)
/* harmony export */ });
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(188);
/** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */

function canReportError(observer) {
    while (observer) {
        var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
        if (closed_1 || isStopped) {
            return false;
        }
        else if (destination && destination instanceof _Subscriber__WEBPACK_IMPORTED_MODULE_0__.Subscriber) {
            observer = destination;
        }
        else {
            observer = null;
        }
    }
    return true;
}
//# sourceMappingURL=canReportError.js.map


/***/ }),
/* 200 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "observable": () => (/* binding */ observable)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var observable = /*@__PURE__*/ (function () { return typeof Symbol === 'function' && Symbol.observable || '@@observable'; })();
//# sourceMappingURL=observable.js.map


/***/ }),
/* 201 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pipe": () => (/* binding */ pipe),
/* harmony export */   "pipeFromArray": () => (/* binding */ pipeFromArray)
/* harmony export */ });
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(202);
/** PURE_IMPORTS_START _identity PURE_IMPORTS_END */

function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
}
function pipeFromArray(fns) {
    if (fns.length === 0) {
        return _identity__WEBPACK_IMPORTED_MODULE_0__.identity;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}
//# sourceMappingURL=pipe.js.map


/***/ }),
/* 202 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "identity": () => (/* binding */ identity)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function identity(x) {
    return x;
}
//# sourceMappingURL=identity.js.map


/***/ }),
/* 203 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConnectableObservable": () => (/* binding */ ConnectableObservable),
/* harmony export */   "connectableObservableDescriptor": () => (/* binding */ connectableObservableDescriptor)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(205);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(186);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(188);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(194);
/* harmony import */ var _operators_refCount__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(204);
/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */






var ConnectableObservable = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._refCount = 0;
        _this._isComplete = false;
        return _this;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new _Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription();
            connection.add(this.source
                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = _Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription.EMPTY;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return (0,_operators_refCount__WEBPACK_IMPORTED_MODULE_2__.refCount)()(this);
    };
    return ConnectableObservable;
}(_Observable__WEBPACK_IMPORTED_MODULE_3__.Observable));

var connectableObservableDescriptor = /*@__PURE__*/ (function () {
    var connectableProto = ConnectableObservable.prototype;
    return {
        operator: { value: null },
        _refCount: { value: 0, writable: true },
        _subject: { value: null, writable: true },
        _connection: { value: null, writable: true },
        _subscribe: { value: connectableProto._subscribe },
        _isComplete: { value: connectableProto._isComplete, writable: true },
        getSubject: { value: connectableProto.getSubject },
        connect: { value: connectableProto.connect },
        refCount: { value: connectableProto.refCount }
    };
})();
var ConnectableSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(_Subject__WEBPACK_IMPORTED_MODULE_4__.SubjectSubscriber));
var RefCountOperator = /*@__PURE__*/ (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_5__.Subscriber));
//# sourceMappingURL=ConnectableObservable.js.map


/***/ }),
/* 204 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "refCount": () => (/* binding */ refCount)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function refCount() {
    return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator(source));
    };
}
var RefCountOperator = /*@__PURE__*/ (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));
//# sourceMappingURL=refCount.js.map


/***/ }),
/* 205 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SubjectSubscriber": () => (/* binding */ SubjectSubscriber),
/* harmony export */   "Subject": () => (/* binding */ Subject),
/* harmony export */   "AnonymousSubject": () => (/* binding */ AnonymousSubject)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(186);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(194);
/* harmony import */ var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(206);
/* harmony import */ var _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(207);
/* harmony import */ var _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(193);
/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */







var SubjectSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
    }
    return SubjectSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));

var Subject = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_2__.rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__.ObjectUnsubscribedError();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return _Subscription__WEBPACK_IMPORTED_MODULE_4__.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return _Subscription__WEBPACK_IMPORTED_MODULE_4__.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new _Observable__WEBPACK_IMPORTED_MODULE_6__.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(_Observable__WEBPACK_IMPORTED_MODULE_6__.Observable));

var AnonymousSubject = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return _Subscription__WEBPACK_IMPORTED_MODULE_4__.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));

//# sourceMappingURL=Subject.js.map


/***/ }),
/* 206 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ObjectUnsubscribedError": () => (/* binding */ ObjectUnsubscribedError)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var ObjectUnsubscribedErrorImpl = /*@__PURE__*/ (function () {
    function ObjectUnsubscribedErrorImpl() {
        Error.call(this);
        this.message = 'object unsubscribed';
        this.name = 'ObjectUnsubscribedError';
        return this;
    }
    ObjectUnsubscribedErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return ObjectUnsubscribedErrorImpl;
})();
var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
//# sourceMappingURL=ObjectUnsubscribedError.js.map


/***/ }),
/* 207 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SubjectSubscription": () => (/* binding */ SubjectSubscription)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(194);
/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */


var SubjectSubscription = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(_Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription));

//# sourceMappingURL=SubjectSubscription.js.map


/***/ }),
/* 208 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "groupBy": () => (/* binding */ groupBy),
/* harmony export */   "GroupedObservable": () => (/* binding */ GroupedObservable)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(188);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(194);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(186);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(205);
/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription,_Observable,_Subject PURE_IMPORTS_END */





function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
    return function (source) {
        return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
    };
}
var GroupByOperator = /*@__PURE__*/ (function () {
    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
    }
    GroupByOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
    };
    return GroupByOperator;
}());
var GroupBySubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(GroupBySubscriber, _super);
    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.elementSelector = elementSelector;
        _this.durationSelector = durationSelector;
        _this.subjectSelector = subjectSelector;
        _this.groups = null;
        _this.attemptedToUnsubscribe = false;
        _this.count = 0;
        return _this;
    }
    GroupBySubscriber.prototype._next = function (value) {
        var key;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            this.error(err);
            return;
        }
        this._group(value, key);
    };
    GroupBySubscriber.prototype._group = function (value, key) {
        var groups = this.groups;
        if (!groups) {
            groups = this.groups = new Map();
        }
        var group = groups.get(key);
        var element;
        if (this.elementSelector) {
            try {
                element = this.elementSelector(value);
            }
            catch (err) {
                this.error(err);
            }
        }
        else {
            element = value;
        }
        if (!group) {
            group = (this.subjectSelector ? this.subjectSelector() : new _Subject__WEBPACK_IMPORTED_MODULE_1__.Subject());
            groups.set(key, group);
            var groupedObservable = new GroupedObservable(key, group, this);
            this.destination.next(groupedObservable);
            if (this.durationSelector) {
                var duration = void 0;
                try {
                    duration = this.durationSelector(new GroupedObservable(key, group));
                }
                catch (err) {
                    this.error(err);
                    return;
                }
                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
            }
        }
        if (!group.closed) {
            group.next(element);
        }
    };
    GroupBySubscriber.prototype._error = function (err) {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.error(err);
            });
            groups.clear();
        }
        this.destination.error(err);
    };
    GroupBySubscriber.prototype._complete = function () {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.complete();
            });
            groups.clear();
        }
        this.destination.complete();
    };
    GroupBySubscriber.prototype.removeGroup = function (key) {
        this.groups.delete(key);
    };
    GroupBySubscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.attemptedToUnsubscribe = true;
            if (this.count === 0) {
                _super.prototype.unsubscribe.call(this);
            }
        }
    };
    return GroupBySubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_2__.Subscriber));
var GroupDurationSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(GroupDurationSubscriber, _super);
    function GroupDurationSubscriber(key, group, parent) {
        var _this = _super.call(this, group) || this;
        _this.key = key;
        _this.group = group;
        _this.parent = parent;
        return _this;
    }
    GroupDurationSubscriber.prototype._next = function (value) {
        this.complete();
    };
    GroupDurationSubscriber.prototype._unsubscribe = function () {
        var _a = this, parent = _a.parent, key = _a.key;
        this.key = this.parent = null;
        if (parent) {
            parent.removeGroup(key);
        }
    };
    return GroupDurationSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_2__.Subscriber));
var GroupedObservable = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(GroupedObservable, _super);
    function GroupedObservable(key, groupSubject, refCountSubscription) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.groupSubject = groupSubject;
        _this.refCountSubscription = refCountSubscription;
        return _this;
    }
    GroupedObservable.prototype._subscribe = function (subscriber) {
        var subscription = new _Subscription__WEBPACK_IMPORTED_MODULE_3__.Subscription();
        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
            subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
    };
    return GroupedObservable;
}(_Observable__WEBPACK_IMPORTED_MODULE_4__.Observable));

var InnerRefCountSubscription = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(InnerRefCountSubscription, _super);
    function InnerRefCountSubscription(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        parent.count++;
        return _this;
    }
    InnerRefCountSubscription.prototype.unsubscribe = function () {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
            _super.prototype.unsubscribe.call(this);
            parent.count -= 1;
            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                parent.unsubscribe();
            }
        }
    };
    return InnerRefCountSubscription;
}(_Subscription__WEBPACK_IMPORTED_MODULE_3__.Subscription));
//# sourceMappingURL=groupBy.js.map


/***/ }),
/* 209 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BehaviorSubject": () => (/* binding */ BehaviorSubject)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(205);
/* harmony import */ var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(206);
/** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */



var BehaviorSubject = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        }
        else if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_1__.ObjectUnsubscribedError();
        }
        else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(_Subject__WEBPACK_IMPORTED_MODULE_2__.Subject));

//# sourceMappingURL=BehaviorSubject.js.map


/***/ }),
/* 210 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReplaySubject": () => (/* binding */ ReplaySubject)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(205);
/* harmony import */ var _scheduler_queue__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(220);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(194);
/* harmony import */ var _operators_observeOn__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(211);
/* harmony import */ var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(206);
/* harmony import */ var _SubjectSubscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(207);
/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */







var ReplaySubject = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) {
            bufferSize = Number.POSITIVE_INFINITY;
        }
        if (windowTime === void 0) {
            windowTime = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime < 1 ? 1 : windowTime;
        if (windowTime === Number.POSITIVE_INFINITY) {
            _this._infiniteTimeWindow = true;
            _this.next = _this.nextInfiniteTimeWindow;
        }
        else {
            _this.next = _this.nextTimeWindow;
        }
        return _this;
    }
    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
        if (!this.isStopped) {
            var _events = this._events;
            _events.push(value);
            if (_events.length > this._bufferSize) {
                _events.shift();
            }
        }
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype.nextTimeWindow = function (value) {
        if (!this.isStopped) {
            this._events.push(new ReplayEvent(this._getNow(), value));
            this._trimBufferThenGetEvents();
        }
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_1__.ObjectUnsubscribedError();
        }
        else if (this.isStopped || this.hasError) {
            subscription = _Subscription__WEBPACK_IMPORTED_MODULE_2__.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new _SubjectSubscription__WEBPACK_IMPORTED_MODULE_3__.SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new _operators_observeOn__WEBPACK_IMPORTED_MODULE_4__.ObserveOnSubscriber(subscriber, scheduler));
        }
        if (_infiniteTimeWindow) {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i]);
            }
        }
        else {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i].value);
            }
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || _scheduler_queue__WEBPACK_IMPORTED_MODULE_5__.queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(_Subject__WEBPACK_IMPORTED_MODULE_6__.Subject));

var ReplayEvent = /*@__PURE__*/ (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());
//# sourceMappingURL=ReplaySubject.js.map


/***/ }),
/* 211 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "observeOn": () => (/* binding */ observeOn),
/* harmony export */   "ObserveOnOperator": () => (/* binding */ ObserveOnOperator),
/* harmony export */   "ObserveOnSubscriber": () => (/* binding */ ObserveOnSubscriber),
/* harmony export */   "ObserveOnMessage": () => (/* binding */ ObserveOnMessage)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(188);
/* harmony import */ var _Notification__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(212);
/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */



function observeOn(scheduler, delay) {
    if (delay === void 0) {
        delay = 0;
    }
    return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
    };
}
var ObserveOnOperator = /*@__PURE__*/ (function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}());

var ObserveOnSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        var _this = _super.call(this, destination) || this;
        _this.scheduler = scheduler;
        _this.delay = delay;
        return _this;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        var destination = this.destination;
        destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(_Notification__WEBPACK_IMPORTED_MODULE_1__.Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(_Notification__WEBPACK_IMPORTED_MODULE_1__.Notification.createError(err));
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(_Notification__WEBPACK_IMPORTED_MODULE_1__.Notification.createComplete());
        this.unsubscribe();
    };
    return ObserveOnSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_2__.Subscriber));

var ObserveOnMessage = /*@__PURE__*/ (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());

//# sourceMappingURL=observeOn.js.map


/***/ }),
/* 212 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NotificationKind": () => (/* binding */ NotificationKind),
/* harmony export */   "Notification": () => (/* binding */ Notification)
/* harmony export */ });
/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(219);
/* harmony import */ var _observable_of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(213);
/* harmony import */ var _observable_throwError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(218);
/** PURE_IMPORTS_START _observable_empty,_observable_of,_observable_throwError PURE_IMPORTS_END */



var NotificationKind;
/*@__PURE__*/ (function (NotificationKind) {
    NotificationKind["NEXT"] = "N";
    NotificationKind["ERROR"] = "E";
    NotificationKind["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = /*@__PURE__*/ (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return (0,_observable_of__WEBPACK_IMPORTED_MODULE_0__.of)(this.value);
            case 'E':
                return (0,_observable_throwError__WEBPACK_IMPORTED_MODULE_1__.throwError)(this.error);
            case 'C':
                return (0,_observable_empty__WEBPACK_IMPORTED_MODULE_2__.empty)();
        }
        throw new Error('unexpected notification kind value');
    };
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());

//# sourceMappingURL=Notification.js.map


/***/ }),
/* 213 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "of": () => (/* binding */ of)
/* harmony export */ });
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(214);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(216);
/* harmony import */ var _scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(215);
/** PURE_IMPORTS_START _util_isScheduler,_fromArray,_scheduled_scheduleArray PURE_IMPORTS_END */



function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var scheduler = args[args.length - 1];
    if ((0,_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__.isScheduler)(scheduler)) {
        args.pop();
        return (0,_scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_1__.scheduleArray)(args, scheduler);
    }
    else {
        return (0,_fromArray__WEBPACK_IMPORTED_MODULE_2__.fromArray)(args);
    }
}
//# sourceMappingURL=of.js.map


/***/ }),
/* 214 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isScheduler": () => (/* binding */ isScheduler)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
//# sourceMappingURL=isScheduler.js.map


/***/ }),
/* 215 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "scheduleArray": () => (/* binding */ scheduleArray)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(186);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(194);
/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */


function scheduleArray(input, scheduler) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {
        var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription();
        var i = 0;
        sub.add(scheduler.schedule(function () {
            if (i === input.length) {
                subscriber.complete();
                return;
            }
            subscriber.next(input[i++]);
            if (!subscriber.closed) {
                sub.add(this.schedule());
            }
        }));
        return sub;
    });
}
//# sourceMappingURL=scheduleArray.js.map


/***/ }),
/* 216 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fromArray": () => (/* binding */ fromArray)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(186);
/* harmony import */ var _util_subscribeToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(217);
/* harmony import */ var _scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(215);
/** PURE_IMPORTS_START _Observable,_util_subscribeToArray,_scheduled_scheduleArray PURE_IMPORTS_END */



function fromArray(input, scheduler) {
    if (!scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable((0,_util_subscribeToArray__WEBPACK_IMPORTED_MODULE_1__.subscribeToArray)(input));
    }
    else {
        return (0,_scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__.scheduleArray)(input, scheduler);
    }
}
//# sourceMappingURL=fromArray.js.map


/***/ }),
/* 217 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "subscribeToArray": () => (/* binding */ subscribeToArray)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var subscribeToArray = function (array) {
    return function (subscriber) {
        for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
            subscriber.next(array[i]);
        }
        subscriber.complete();
    };
};
//# sourceMappingURL=subscribeToArray.js.map


/***/ }),
/* 218 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "throwError": () => (/* binding */ throwError)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(186);
/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

function throwError(error, scheduler) {
    if (!scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) { return subscriber.error(error); });
    }
    else {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) { return scheduler.schedule(dispatch, 0, { error: error, subscriber: subscriber }); });
    }
}
function dispatch(_a) {
    var error = _a.error, subscriber = _a.subscriber;
    subscriber.error(error);
}
//# sourceMappingURL=throwError.js.map


/***/ }),
/* 219 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EMPTY": () => (/* binding */ EMPTY),
/* harmony export */   "empty": () => (/* binding */ empty)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(186);
/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

var EMPTY = /*@__PURE__*/ new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) { return subscriber.complete(); });
function empty(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
}
//# sourceMappingURL=empty.js.map


/***/ }),
/* 220 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "queueScheduler": () => (/* binding */ queueScheduler),
/* harmony export */   "queue": () => (/* binding */ queue)
/* harmony export */ });
/* harmony import */ var _QueueAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(224);
/* harmony import */ var _QueueScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(221);
/** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */


var queueScheduler = /*@__PURE__*/ new _QueueScheduler__WEBPACK_IMPORTED_MODULE_0__.QueueScheduler(_QueueAction__WEBPACK_IMPORTED_MODULE_1__.QueueAction);
var queue = queueScheduler;
//# sourceMappingURL=queue.js.map


/***/ }),
/* 221 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueueScheduler": () => (/* binding */ QueueScheduler)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(222);
/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */


var QueueScheduler = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(QueueScheduler, _super);
    function QueueScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler;
}(_AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__.AsyncScheduler));

//# sourceMappingURL=QueueScheduler.js.map


/***/ }),
/* 222 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AsyncScheduler": () => (/* binding */ AsyncScheduler)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Scheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(223);
/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */


var AsyncScheduler = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(AsyncScheduler, _super);
    function AsyncScheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = _Scheduler__WEBPACK_IMPORTED_MODULE_1__.Scheduler.now;
        }
        var _this = _super.call(this, SchedulerAction, function () {
            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
                return AsyncScheduler.delegate.now();
            }
            else {
                return now();
            }
        }) || this;
        _this.actions = [];
        _this.active = false;
        _this.scheduled = undefined;
        return _this;
    }
    AsyncScheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
            return AsyncScheduler.delegate.schedule(work, delay, state);
        }
        else {
            return _super.prototype.schedule.call(this, work, delay, state);
        }
    };
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift());
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(_Scheduler__WEBPACK_IMPORTED_MODULE_1__.Scheduler));

//# sourceMappingURL=AsyncScheduler.js.map


/***/ }),
/* 223 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Scheduler": () => (/* binding */ Scheduler)
/* harmony export */ });
var Scheduler = /*@__PURE__*/ (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = Scheduler.now;
        }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = function () { return Date.now(); };
    return Scheduler;
}());

//# sourceMappingURL=Scheduler.js.map


/***/ }),
/* 224 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QueueAction": () => (/* binding */ QueueAction)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _AsyncAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(225);
/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */


var QueueAction = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(QueueAction, _super);
    function QueueAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        return scheduler.flush(this);
    };
    return QueueAction;
}(_AsyncAction__WEBPACK_IMPORTED_MODULE_1__.AsyncAction));

//# sourceMappingURL=QueueAction.js.map


/***/ }),
/* 225 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AsyncAction": () => (/* binding */ AsyncAction)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(226);
/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */


var AsyncAction = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (this.closed) {
            return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        clearInterval(id);
        return undefined;
    };
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(_Action__WEBPACK_IMPORTED_MODULE_1__.Action));

//# sourceMappingURL=AsyncAction.js.map


/***/ }),
/* 226 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Action": () => (/* binding */ Action)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(194);
/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */


var Action = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(Action, _super);
    function Action(scheduler, work) {
        return _super.call(this) || this;
    }
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return this;
    };
    return Action;
}(_Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription));

//# sourceMappingURL=Action.js.map


/***/ }),
/* 227 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AsyncSubject": () => (/* binding */ AsyncSubject)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(205);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(194);
/** PURE_IMPORTS_START tslib,_Subject,_Subscription PURE_IMPORTS_END */



var AsyncSubject = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(AsyncSubject, _super);
    function AsyncSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.value = null;
        _this.hasNext = false;
        _this.hasCompleted = false;
        return _this;
    }
    AsyncSubject.prototype._subscribe = function (subscriber) {
        if (this.hasError) {
            subscriber.error(this.thrownError);
            return _Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription.EMPTY;
        }
        else if (this.hasCompleted && this.hasNext) {
            subscriber.next(this.value);
            subscriber.complete();
            return _Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription.EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
    };
    AsyncSubject.prototype.next = function (value) {
        if (!this.hasCompleted) {
            this.value = value;
            this.hasNext = true;
        }
    };
    AsyncSubject.prototype.error = function (error) {
        if (!this.hasCompleted) {
            _super.prototype.error.call(this, error);
        }
    };
    AsyncSubject.prototype.complete = function () {
        this.hasCompleted = true;
        if (this.hasNext) {
            _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
    };
    return AsyncSubject;
}(_Subject__WEBPACK_IMPORTED_MODULE_2__.Subject));

//# sourceMappingURL=AsyncSubject.js.map


/***/ }),
/* 228 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "asapScheduler": () => (/* binding */ asapScheduler),
/* harmony export */   "asap": () => (/* binding */ asap)
/* harmony export */ });
/* harmony import */ var _AsapAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(230);
/* harmony import */ var _AsapScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(229);
/** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */


var asapScheduler = /*@__PURE__*/ new _AsapScheduler__WEBPACK_IMPORTED_MODULE_0__.AsapScheduler(_AsapAction__WEBPACK_IMPORTED_MODULE_1__.AsapAction);
var asap = asapScheduler;
//# sourceMappingURL=asap.js.map


/***/ }),
/* 229 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AsapScheduler": () => (/* binding */ AsapScheduler)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(222);
/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */


var AsapScheduler = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(AsapScheduler, _super);
    function AsapScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsapScheduler;
}(_AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__.AsyncScheduler));

//# sourceMappingURL=AsapScheduler.js.map


/***/ }),
/* 230 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AsapAction": () => (/* binding */ AsapAction)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _util_Immediate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(231);
/* harmony import */ var _AsyncAction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(225);
/** PURE_IMPORTS_START tslib,_util_Immediate,_AsyncAction PURE_IMPORTS_END */



var AsapAction = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(AsapAction, _super);
    function AsapAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = _util_Immediate__WEBPACK_IMPORTED_MODULE_1__.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
    };
    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            _util_Immediate__WEBPACK_IMPORTED_MODULE_1__.Immediate.clearImmediate(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AsapAction;
}(_AsyncAction__WEBPACK_IMPORTED_MODULE_2__.AsyncAction));

//# sourceMappingURL=AsapAction.js.map


/***/ }),
/* 231 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Immediate": () => (/* binding */ Immediate),
/* harmony export */   "TestTools": () => (/* binding */ TestTools)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var nextHandle = 1;
var RESOLVED = /*@__PURE__*/ (function () { return /*@__PURE__*/ Promise.resolve(); })();
var activeHandles = {};
function findAndClearHandle(handle) {
    if (handle in activeHandles) {
        delete activeHandles[handle];
        return true;
    }
    return false;
}
var Immediate = {
    setImmediate: function (cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        RESOLVED.then(function () { return findAndClearHandle(handle) && cb(); });
        return handle;
    },
    clearImmediate: function (handle) {
        findAndClearHandle(handle);
    },
};
var TestTools = {
    pending: function () {
        return Object.keys(activeHandles).length;
    }
};
//# sourceMappingURL=Immediate.js.map


/***/ }),
/* 232 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "asyncScheduler": () => (/* binding */ asyncScheduler),
/* harmony export */   "async": () => (/* binding */ async)
/* harmony export */ });
/* harmony import */ var _AsyncAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(225);
/* harmony import */ var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(222);
/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */


var asyncScheduler = /*@__PURE__*/ new _AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__.AsyncScheduler(_AsyncAction__WEBPACK_IMPORTED_MODULE_1__.AsyncAction);
var async = asyncScheduler;
//# sourceMappingURL=async.js.map


/***/ }),
/* 233 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "animationFrameScheduler": () => (/* binding */ animationFrameScheduler),
/* harmony export */   "animationFrame": () => (/* binding */ animationFrame)
/* harmony export */ });
/* harmony import */ var _AnimationFrameAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(235);
/* harmony import */ var _AnimationFrameScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(234);
/** PURE_IMPORTS_START _AnimationFrameAction,_AnimationFrameScheduler PURE_IMPORTS_END */


var animationFrameScheduler = /*@__PURE__*/ new _AnimationFrameScheduler__WEBPACK_IMPORTED_MODULE_0__.AnimationFrameScheduler(_AnimationFrameAction__WEBPACK_IMPORTED_MODULE_1__.AnimationFrameAction);
var animationFrame = animationFrameScheduler;
//# sourceMappingURL=animationFrame.js.map


/***/ }),
/* 234 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnimationFrameScheduler": () => (/* binding */ AnimationFrameScheduler)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(222);
/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */


var AnimationFrameScheduler = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(AnimationFrameScheduler, _super);
    function AnimationFrameScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AnimationFrameScheduler;
}(_AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__.AsyncScheduler));

//# sourceMappingURL=AnimationFrameScheduler.js.map


/***/ }),
/* 235 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnimationFrameAction": () => (/* binding */ AnimationFrameAction)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _AsyncAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(225);
/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */


var AnimationFrameAction = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(AnimationFrameAction, _super);
    function AnimationFrameAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () { return scheduler.flush(null); }));
    };
    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            cancelAnimationFrame(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AnimationFrameAction;
}(_AsyncAction__WEBPACK_IMPORTED_MODULE_1__.AsyncAction));

//# sourceMappingURL=AnimationFrameAction.js.map


/***/ }),
/* 236 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VirtualTimeScheduler": () => (/* binding */ VirtualTimeScheduler),
/* harmony export */   "VirtualAction": () => (/* binding */ VirtualAction)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _AsyncAction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(225);
/* harmony import */ var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(222);
/** PURE_IMPORTS_START tslib,_AsyncAction,_AsyncScheduler PURE_IMPORTS_END */



var VirtualTimeScheduler = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(VirtualTimeScheduler, _super);
    function VirtualTimeScheduler(SchedulerAction, maxFrames) {
        if (SchedulerAction === void 0) {
            SchedulerAction = VirtualAction;
        }
        if (maxFrames === void 0) {
            maxFrames = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, SchedulerAction, function () { return _this.frame; }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
    }
    VirtualTimeScheduler.prototype.flush = function () {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error, action;
        while ((action = actions[0]) && action.delay <= maxFrames) {
            actions.shift();
            this.frame = action.delay;
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        }
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    VirtualTimeScheduler.frameTimeFactor = 10;
    return VirtualTimeScheduler;
}(_AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__.AsyncScheduler));

var VirtualAction = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(VirtualAction, _super);
    function VirtualAction(scheduler, work, index) {
        if (index === void 0) {
            index = scheduler.index += 1;
        }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
    }
    VirtualAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.active = false;
        var action = new VirtualAction(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
    };
    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction.sortActions);
        return true;
    };
    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return undefined;
    };
    VirtualAction.prototype._execute = function (state, delay) {
        if (this.active === true) {
            return _super.prototype._execute.call(this, state, delay);
        }
    };
    VirtualAction.sortActions = function (a, b) {
        if (a.delay === b.delay) {
            if (a.index === b.index) {
                return 0;
            }
            else if (a.index > b.index) {
                return 1;
            }
            else {
                return -1;
            }
        }
        else if (a.delay > b.delay) {
            return 1;
        }
        else {
            return -1;
        }
    };
    return VirtualAction;
}(_AsyncAction__WEBPACK_IMPORTED_MODULE_2__.AsyncAction));

//# sourceMappingURL=VirtualTimeScheduler.js.map


/***/ }),
/* 237 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "noop": () => (/* binding */ noop)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function noop() { }
//# sourceMappingURL=noop.js.map


/***/ }),
/* 238 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isObservable": () => (/* binding */ isObservable)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(186);
/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

function isObservable(obj) {
    return !!obj && (obj instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable || (typeof obj.lift === 'function' && typeof obj.subscribe === 'function'));
}
//# sourceMappingURL=isObservable.js.map


/***/ }),
/* 239 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ArgumentOutOfRangeError": () => (/* binding */ ArgumentOutOfRangeError)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var ArgumentOutOfRangeErrorImpl = /*@__PURE__*/ (function () {
    function ArgumentOutOfRangeErrorImpl() {
        Error.call(this);
        this.message = 'argument out of range';
        this.name = 'ArgumentOutOfRangeError';
        return this;
    }
    ArgumentOutOfRangeErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return ArgumentOutOfRangeErrorImpl;
})();
var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
//# sourceMappingURL=ArgumentOutOfRangeError.js.map


/***/ }),
/* 240 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EmptyError": () => (/* binding */ EmptyError)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var EmptyErrorImpl = /*@__PURE__*/ (function () {
    function EmptyErrorImpl() {
        Error.call(this);
        this.message = 'no elements in sequence';
        this.name = 'EmptyError';
        return this;
    }
    EmptyErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return EmptyErrorImpl;
})();
var EmptyError = EmptyErrorImpl;
//# sourceMappingURL=EmptyError.js.map


/***/ }),
/* 241 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TimeoutError": () => (/* binding */ TimeoutError)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var TimeoutErrorImpl = /*@__PURE__*/ (function () {
    function TimeoutErrorImpl() {
        Error.call(this);
        this.message = 'Timeout has occurred';
        this.name = 'TimeoutError';
        return this;
    }
    TimeoutErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return TimeoutErrorImpl;
})();
var TimeoutError = TimeoutErrorImpl;
//# sourceMappingURL=TimeoutError.js.map


/***/ }),
/* 242 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bindCallback": () => (/* binding */ bindCallback)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(186);
/* harmony import */ var _AsyncSubject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(227);
/* harmony import */ var _operators_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(243);
/* harmony import */ var _util_canReportError__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(199);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(197);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(214);
/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isArray,_util_isScheduler PURE_IMPORTS_END */






function bindCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if ((0,_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__.isScheduler)(resultSelector)) {
            scheduler = resultSelector;
        }
        else {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe((0,_operators_map__WEBPACK_IMPORTED_MODULE_1__.map)(function (args) { return (0,_util_isArray__WEBPACK_IMPORTED_MODULE_2__.isArray)(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
            };
        }
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var context = this;
        var subject;
        var params = {
            context: context,
            subject: subject,
            callbackFunc: callbackFunc,
            scheduler: scheduler,
        };
        return new _Observable__WEBPACK_IMPORTED_MODULE_3__.Observable(function (subscriber) {
            if (!scheduler) {
                if (!subject) {
                    subject = new _AsyncSubject__WEBPACK_IMPORTED_MODULE_4__.AsyncSubject();
                    var handler = function () {
                        var innerArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            innerArgs[_i] = arguments[_i];
                        }
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    };
                    try {
                        callbackFunc.apply(context, args.concat([handler]));
                    }
                    catch (err) {
                        if ((0,_util_canReportError__WEBPACK_IMPORTED_MODULE_5__.canReportError)(subject)) {
                            subject.error(err);
                        }
                        else {
                            console.warn(err);
                        }
                    }
                }
                return subject.subscribe(subscriber);
            }
            else {
                var state = {
                    args: args, subscriber: subscriber, params: params,
                };
                return scheduler.schedule(dispatch, 0, state);
            }
        });
    };
}
function dispatch(state) {
    var _this = this;
    var self = this;
    var args = state.args, subscriber = state.subscriber, params = state.params;
    var callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
        subject = params.subject = new _AsyncSubject__WEBPACK_IMPORTED_MODULE_4__.AsyncSubject();
        var handler = function () {
            var innerArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
            }
            var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
            _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
        };
        try {
            callbackFunc.apply(context, args.concat([handler]));
        }
        catch (err) {
            subject.error(err);
        }
    }
    this.add(subject.subscribe(subscriber));
}
function dispatchNext(state) {
    var value = state.value, subject = state.subject;
    subject.next(value);
    subject.complete();
}
function dispatchError(state) {
    var err = state.err, subject = state.subject;
    subject.error(err);
}
//# sourceMappingURL=bindCallback.js.map


/***/ }),
/* 243 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "map": () => (/* binding */ map),
/* harmony export */   "MapOperator": () => (/* binding */ MapOperator)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
var MapOperator = /*@__PURE__*/ (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());

var MapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));
//# sourceMappingURL=map.js.map


/***/ }),
/* 244 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bindNodeCallback": () => (/* binding */ bindNodeCallback)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(186);
/* harmony import */ var _AsyncSubject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(227);
/* harmony import */ var _operators_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(243);
/* harmony import */ var _util_canReportError__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(199);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(214);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(197);
/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isScheduler,_util_isArray PURE_IMPORTS_END */






function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if ((0,_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__.isScheduler)(resultSelector)) {
            scheduler = resultSelector;
        }
        else {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe((0,_operators_map__WEBPACK_IMPORTED_MODULE_1__.map)(function (args) { return (0,_util_isArray__WEBPACK_IMPORTED_MODULE_2__.isArray)(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
            };
        }
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var params = {
            subject: undefined,
            args: args,
            callbackFunc: callbackFunc,
            scheduler: scheduler,
            context: this,
        };
        return new _Observable__WEBPACK_IMPORTED_MODULE_3__.Observable(function (subscriber) {
            var context = params.context;
            var subject = params.subject;
            if (!scheduler) {
                if (!subject) {
                    subject = params.subject = new _AsyncSubject__WEBPACK_IMPORTED_MODULE_4__.AsyncSubject();
                    var handler = function () {
                        var innerArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            innerArgs[_i] = arguments[_i];
                        }
                        var err = innerArgs.shift();
                        if (err) {
                            subject.error(err);
                            return;
                        }
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    };
                    try {
                        callbackFunc.apply(context, args.concat([handler]));
                    }
                    catch (err) {
                        if ((0,_util_canReportError__WEBPACK_IMPORTED_MODULE_5__.canReportError)(subject)) {
                            subject.error(err);
                        }
                        else {
                            console.warn(err);
                        }
                    }
                }
                return subject.subscribe(subscriber);
            }
            else {
                return scheduler.schedule(dispatch, 0, { params: params, subscriber: subscriber, context: context });
            }
        });
    };
}
function dispatch(state) {
    var _this = this;
    var params = state.params, subscriber = state.subscriber, context = state.context;
    var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
        subject = params.subject = new _AsyncSubject__WEBPACK_IMPORTED_MODULE_4__.AsyncSubject();
        var handler = function () {
            var innerArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
            }
            var err = innerArgs.shift();
            if (err) {
                _this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));
            }
            else {
                var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
                _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
            }
        };
        try {
            callbackFunc.apply(context, args.concat([handler]));
        }
        catch (err) {
            this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));
        }
    }
    this.add(subject.subscribe(subscriber));
}
function dispatchNext(arg) {
    var value = arg.value, subject = arg.subject;
    subject.next(value);
    subject.complete();
}
function dispatchError(arg) {
    var err = arg.err, subject = arg.subject;
    subject.error(err);
}
//# sourceMappingURL=bindNodeCallback.js.map


/***/ }),
/* 245 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "combineLatest": () => (/* binding */ combineLatest),
/* harmony export */   "CombineLatestOperator": () => (/* binding */ CombineLatestOperator),
/* harmony export */   "CombineLatestSubscriber": () => (/* binding */ CombineLatestSubscriber)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(214);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(197);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(255);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(246);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(216);
/** PURE_IMPORTS_START tslib,_util_isScheduler,_util_isArray,_OuterSubscriber,_util_subscribeToResult,_fromArray PURE_IMPORTS_END */






var NONE = {};
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = undefined;
    var scheduler = undefined;
    if ((0,_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__.isScheduler)(observables[observables.length - 1])) {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        resultSelector = observables.pop();
    }
    if (observables.length === 1 && (0,_util_isArray__WEBPACK_IMPORTED_MODULE_2__.isArray)(observables[0])) {
        observables = observables[0];
    }
    return (0,_fromArray__WEBPACK_IMPORTED_MODULE_3__.fromArray)(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
var CombineLatestOperator = /*@__PURE__*/ (function () {
    function CombineLatestOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
    };
    return CombineLatestOperator;
}());

var CombineLatestSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, resultSelector) {
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.active = 0;
        _this.values = [];
        _this.observables = [];
        return _this;
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(NONE);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add((0,_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__.subscribeToResult)(this, observable, undefined, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (_outerValue, innerValue, outerIndex) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.resultSelector) {
                this._tryResultSelector(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
        var result;
        try {
            result = this.resultSelector.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_5__.OuterSubscriber));

//# sourceMappingURL=combineLatest.js.map


/***/ }),
/* 246 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "subscribeToResult": () => (/* binding */ subscribeToResult)
/* harmony export */ });
/* harmony import */ var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(247);
/* harmony import */ var _subscribeTo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(248);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(186);
/** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo,_Observable PURE_IMPORTS_END */



function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
    if (innerSubscriber === void 0) {
        innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_0__.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    }
    if (innerSubscriber.closed) {
        return undefined;
    }
    if (result instanceof _Observable__WEBPACK_IMPORTED_MODULE_1__.Observable) {
        return result.subscribe(innerSubscriber);
    }
    return (0,_subscribeTo__WEBPACK_IMPORTED_MODULE_2__.subscribeTo)(result)(innerSubscriber);
}
//# sourceMappingURL=subscribeToResult.js.map


/***/ }),
/* 247 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InnerSubscriber": () => (/* binding */ InnerSubscriber)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


var InnerSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));

//# sourceMappingURL=InnerSubscriber.js.map


/***/ }),
/* 248 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "subscribeTo": () => (/* binding */ subscribeTo)
/* harmony export */ });
/* harmony import */ var _subscribeToArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(217);
/* harmony import */ var _subscribeToPromise__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(252);
/* harmony import */ var _subscribeToIterable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(254);
/* harmony import */ var _subscribeToObservable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(249);
/* harmony import */ var _isArrayLike__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(250);
/* harmony import */ var _isPromise__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(251);
/* harmony import */ var _isObject__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(198);
/* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(253);
/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(200);
/** PURE_IMPORTS_START _subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */









var subscribeTo = function (result) {
    if (!!result && typeof result[_symbol_observable__WEBPACK_IMPORTED_MODULE_0__.observable] === 'function') {
        return (0,_subscribeToObservable__WEBPACK_IMPORTED_MODULE_1__.subscribeToObservable)(result);
    }
    else if ((0,_isArrayLike__WEBPACK_IMPORTED_MODULE_2__.isArrayLike)(result)) {
        return (0,_subscribeToArray__WEBPACK_IMPORTED_MODULE_3__.subscribeToArray)(result);
    }
    else if ((0,_isPromise__WEBPACK_IMPORTED_MODULE_4__.isPromise)(result)) {
        return (0,_subscribeToPromise__WEBPACK_IMPORTED_MODULE_5__.subscribeToPromise)(result);
    }
    else if (!!result && typeof result[_symbol_iterator__WEBPACK_IMPORTED_MODULE_6__.iterator] === 'function') {
        return (0,_subscribeToIterable__WEBPACK_IMPORTED_MODULE_7__.subscribeToIterable)(result);
    }
    else {
        var value = (0,_isObject__WEBPACK_IMPORTED_MODULE_8__.isObject)(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected."
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        throw new TypeError(msg);
    }
};
//# sourceMappingURL=subscribeTo.js.map


/***/ }),
/* 249 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "subscribeToObservable": () => (/* binding */ subscribeToObservable)
/* harmony export */ });
/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(200);
/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */

var subscribeToObservable = function (obj) {
    return function (subscriber) {
        var obs = obj[_symbol_observable__WEBPACK_IMPORTED_MODULE_0__.observable]();
        if (typeof obs.subscribe !== 'function') {
            throw new TypeError('Provided object does not correctly implement Symbol.observable');
        }
        else {
            return obs.subscribe(subscriber);
        }
    };
};
//# sourceMappingURL=subscribeToObservable.js.map


/***/ }),
/* 250 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isArrayLike": () => (/* binding */ isArrayLike)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });
//# sourceMappingURL=isArrayLike.js.map


/***/ }),
/* 251 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isPromise": () => (/* binding */ isPromise)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isPromise(value) {
    return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
//# sourceMappingURL=isPromise.js.map


/***/ }),
/* 252 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "subscribeToPromise": () => (/* binding */ subscribeToPromise)
/* harmony export */ });
/* harmony import */ var _hostReportError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(192);
/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */

var subscribeToPromise = function (promise) {
    return function (subscriber) {
        promise.then(function (value) {
            if (!subscriber.closed) {
                subscriber.next(value);
                subscriber.complete();
            }
        }, function (err) { return subscriber.error(err); })
            .then(null, _hostReportError__WEBPACK_IMPORTED_MODULE_0__.hostReportError);
        return subscriber;
    };
};
//# sourceMappingURL=subscribeToPromise.js.map


/***/ }),
/* 253 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getSymbolIterator": () => (/* binding */ getSymbolIterator),
/* harmony export */   "iterator": () => (/* binding */ iterator),
/* harmony export */   "$$iterator": () => (/* binding */ $$iterator)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
    }
    return Symbol.iterator;
}
var iterator = /*@__PURE__*/ getSymbolIterator();
var $$iterator = iterator;
//# sourceMappingURL=iterator.js.map


/***/ }),
/* 254 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "subscribeToIterable": () => (/* binding */ subscribeToIterable)
/* harmony export */ });
/* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(253);
/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */

var subscribeToIterable = function (iterable) {
    return function (subscriber) {
        var iterator = iterable[_symbol_iterator__WEBPACK_IMPORTED_MODULE_0__.iterator]();
        do {
            var item = void 0;
            try {
                item = iterator.next();
            }
            catch (err) {
                subscriber.error(err);
                return subscriber;
            }
            if (item.done) {
                subscriber.complete();
                break;
            }
            subscriber.next(item.value);
            if (subscriber.closed) {
                break;
            }
        } while (true);
        if (typeof iterator.return === 'function') {
            subscriber.add(function () {
                if (iterator.return) {
                    iterator.return();
                }
            });
        }
        return subscriber;
    };
};
//# sourceMappingURL=subscribeToIterable.js.map


/***/ }),
/* 255 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OuterSubscriber": () => (/* binding */ OuterSubscriber)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


var OuterSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));

//# sourceMappingURL=OuterSubscriber.js.map


/***/ }),
/* 256 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "concat": () => (/* binding */ concat)
/* harmony export */ });
/* harmony import */ var _of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(213);
/* harmony import */ var _operators_concatAll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(257);
/** PURE_IMPORTS_START _of,_operators_concatAll PURE_IMPORTS_END */


function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return (0,_operators_concatAll__WEBPACK_IMPORTED_MODULE_0__.concatAll)()(_of__WEBPACK_IMPORTED_MODULE_1__.of.apply(void 0, observables));
}
//# sourceMappingURL=concat.js.map


/***/ }),
/* 257 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "concatAll": () => (/* binding */ concatAll)
/* harmony export */ });
/* harmony import */ var _mergeAll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(258);
/** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */

function concatAll() {
    return (0,_mergeAll__WEBPACK_IMPORTED_MODULE_0__.mergeAll)(1);
}
//# sourceMappingURL=concatAll.js.map


/***/ }),
/* 258 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mergeAll": () => (/* binding */ mergeAll)
/* harmony export */ });
/* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(259);
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(202);
/** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */


function mergeAll(concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    return (0,_mergeMap__WEBPACK_IMPORTED_MODULE_0__.mergeMap)(_util_identity__WEBPACK_IMPORTED_MODULE_1__.identity, concurrent);
}
//# sourceMappingURL=mergeAll.js.map


/***/ }),
/* 259 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mergeMap": () => (/* binding */ mergeMap),
/* harmony export */   "MergeMapOperator": () => (/* binding */ MergeMapOperator),
/* harmony export */   "MergeMapSubscriber": () => (/* binding */ MergeMapSubscriber),
/* harmony export */   "flatMap": () => (/* binding */ flatMap)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(243);
/* harmony import */ var _observable_from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(260);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(267);
/** PURE_IMPORTS_START tslib,_map,_observable_from,_innerSubscribe PURE_IMPORTS_END */




function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(mergeMap(function (a, i) { return (0,_observable_from__WEBPACK_IMPORTED_MODULE_1__.from)(project(a, i)).pipe((0,_map__WEBPACK_IMPORTED_MODULE_2__.map)(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
    }
    else if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
}
var MergeMapOperator = /*@__PURE__*/ (function () {
    function MergeMapOperator(project, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        this.project = project;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
    };
    return MergeMapOperator;
}());

var MergeMapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish) {
        var innerSubscriber = new _innerSubscribe__WEBPACK_IMPORTED_MODULE_3__.SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = (0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_3__.innerSubscribe)(ish, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
        }
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeMapSubscriber.prototype.notifyNext = function (innerValue) {
        this.destination.next(innerValue);
    };
    MergeMapSubscriber.prototype.notifyComplete = function () {
        var buffer = this.buffer;
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_3__.SimpleOuterSubscriber));

var flatMap = mergeMap;
//# sourceMappingURL=mergeMap.js.map


/***/ }),
/* 260 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "from": () => (/* binding */ from)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(186);
/* harmony import */ var _util_subscribeTo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(248);
/* harmony import */ var _scheduled_scheduled__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(261);
/** PURE_IMPORTS_START _Observable,_util_subscribeTo,_scheduled_scheduled PURE_IMPORTS_END */



function from(input, scheduler) {
    if (!scheduler) {
        if (input instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable) {
            return input;
        }
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable((0,_util_subscribeTo__WEBPACK_IMPORTED_MODULE_1__.subscribeTo)(input));
    }
    else {
        return (0,_scheduled_scheduled__WEBPACK_IMPORTED_MODULE_2__.scheduled)(input, scheduler);
    }
}
//# sourceMappingURL=from.js.map


/***/ }),
/* 261 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "scheduled": () => (/* binding */ scheduled)
/* harmony export */ });
/* harmony import */ var _scheduleObservable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(263);
/* harmony import */ var _schedulePromise__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(264);
/* harmony import */ var _scheduleArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(215);
/* harmony import */ var _scheduleIterable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(266);
/* harmony import */ var _util_isInteropObservable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(262);
/* harmony import */ var _util_isPromise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(251);
/* harmony import */ var _util_isArrayLike__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(250);
/* harmony import */ var _util_isIterable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(265);
/** PURE_IMPORTS_START _scheduleObservable,_schedulePromise,_scheduleArray,_scheduleIterable,_util_isInteropObservable,_util_isPromise,_util_isArrayLike,_util_isIterable PURE_IMPORTS_END */








function scheduled(input, scheduler) {
    if (input != null) {
        if ((0,_util_isInteropObservable__WEBPACK_IMPORTED_MODULE_0__.isInteropObservable)(input)) {
            return (0,_scheduleObservable__WEBPACK_IMPORTED_MODULE_1__.scheduleObservable)(input, scheduler);
        }
        else if ((0,_util_isPromise__WEBPACK_IMPORTED_MODULE_2__.isPromise)(input)) {
            return (0,_schedulePromise__WEBPACK_IMPORTED_MODULE_3__.schedulePromise)(input, scheduler);
        }
        else if ((0,_util_isArrayLike__WEBPACK_IMPORTED_MODULE_4__.isArrayLike)(input)) {
            return (0,_scheduleArray__WEBPACK_IMPORTED_MODULE_5__.scheduleArray)(input, scheduler);
        }
        else if ((0,_util_isIterable__WEBPACK_IMPORTED_MODULE_6__.isIterable)(input) || typeof input === 'string') {
            return (0,_scheduleIterable__WEBPACK_IMPORTED_MODULE_7__.scheduleIterable)(input, scheduler);
        }
    }
    throw new TypeError((input !== null && typeof input || input) + ' is not observable');
}
//# sourceMappingURL=scheduled.js.map


/***/ }),
/* 262 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isInteropObservable": () => (/* binding */ isInteropObservable)
/* harmony export */ });
/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(200);
/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */

function isInteropObservable(input) {
    return input && typeof input[_symbol_observable__WEBPACK_IMPORTED_MODULE_0__.observable] === 'function';
}
//# sourceMappingURL=isInteropObservable.js.map


/***/ }),
/* 263 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "scheduleObservable": () => (/* binding */ scheduleObservable)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(186);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(194);
/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(200);
/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable PURE_IMPORTS_END */



function scheduleObservable(input, scheduler) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {
        var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription();
        sub.add(scheduler.schedule(function () {
            var observable = input[_symbol_observable__WEBPACK_IMPORTED_MODULE_2__.observable]();
            sub.add(observable.subscribe({
                next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
                error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
                complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
            }));
        }));
        return sub;
    });
}
//# sourceMappingURL=scheduleObservable.js.map


/***/ }),
/* 264 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "schedulePromise": () => (/* binding */ schedulePromise)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(186);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(194);
/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */


function schedulePromise(input, scheduler) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {
        var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription();
        sub.add(scheduler.schedule(function () {
            return input.then(function (value) {
                sub.add(scheduler.schedule(function () {
                    subscriber.next(value);
                    sub.add(scheduler.schedule(function () { return subscriber.complete(); }));
                }));
            }, function (err) {
                sub.add(scheduler.schedule(function () { return subscriber.error(err); }));
            });
        }));
        return sub;
    });
}
//# sourceMappingURL=schedulePromise.js.map


/***/ }),
/* 265 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isIterable": () => (/* binding */ isIterable)
/* harmony export */ });
/* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(253);
/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */

function isIterable(input) {
    return input && typeof input[_symbol_iterator__WEBPACK_IMPORTED_MODULE_0__.iterator] === 'function';
}
//# sourceMappingURL=isIterable.js.map


/***/ }),
/* 266 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "scheduleIterable": () => (/* binding */ scheduleIterable)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(186);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(194);
/* harmony import */ var _symbol_iterator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(253);
/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator PURE_IMPORTS_END */



function scheduleIterable(input, scheduler) {
    if (!input) {
        throw new Error('Iterable cannot be null');
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {
        var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription();
        var iterator;
        sub.add(function () {
            if (iterator && typeof iterator.return === 'function') {
                iterator.return();
            }
        });
        sub.add(scheduler.schedule(function () {
            iterator = input[_symbol_iterator__WEBPACK_IMPORTED_MODULE_2__.iterator]();
            sub.add(scheduler.schedule(function () {
                if (subscriber.closed) {
                    return;
                }
                var value;
                var done;
                try {
                    var result = iterator.next();
                    value = result.value;
                    done = result.done;
                }
                catch (err) {
                    subscriber.error(err);
                    return;
                }
                if (done) {
                    subscriber.complete();
                }
                else {
                    subscriber.next(value);
                    this.schedule();
                }
            }));
        }));
        return sub;
    });
}
//# sourceMappingURL=scheduleIterable.js.map


/***/ }),
/* 267 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SimpleInnerSubscriber": () => (/* binding */ SimpleInnerSubscriber),
/* harmony export */   "ComplexInnerSubscriber": () => (/* binding */ ComplexInnerSubscriber),
/* harmony export */   "SimpleOuterSubscriber": () => (/* binding */ SimpleOuterSubscriber),
/* harmony export */   "ComplexOuterSubscriber": () => (/* binding */ ComplexOuterSubscriber),
/* harmony export */   "innerSubscribe": () => (/* binding */ innerSubscribe)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(186);
/* harmony import */ var _util_subscribeTo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(248);
/** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_util_subscribeTo PURE_IMPORTS_END */




var SimpleInnerSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(SimpleInnerSubscriber, _super);
    function SimpleInnerSubscriber(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        return _this;
    }
    SimpleInnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(value);
    };
    SimpleInnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error);
        this.unsubscribe();
    };
    SimpleInnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete();
        this.unsubscribe();
    };
    return SimpleInnerSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));

var ComplexInnerSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(ComplexInnerSubscriber, _super);
    function ComplexInnerSubscriber(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        return _this;
    }
    ComplexInnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this);
    };
    ComplexInnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error);
        this.unsubscribe();
    };
    ComplexInnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return ComplexInnerSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));

var SimpleOuterSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(SimpleOuterSubscriber, _super);
    function SimpleOuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SimpleOuterSubscriber.prototype.notifyNext = function (innerValue) {
        this.destination.next(innerValue);
    };
    SimpleOuterSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    SimpleOuterSubscriber.prototype.notifyComplete = function () {
        this.destination.complete();
    };
    return SimpleOuterSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));

var ComplexOuterSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(ComplexOuterSubscriber, _super);
    function ComplexOuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ComplexOuterSubscriber.prototype.notifyNext = function (_outerValue, innerValue, _outerIndex, _innerSub) {
        this.destination.next(innerValue);
    };
    ComplexOuterSubscriber.prototype.notifyError = function (error) {
        this.destination.error(error);
    };
    ComplexOuterSubscriber.prototype.notifyComplete = function (_innerSub) {
        this.destination.complete();
    };
    return ComplexOuterSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));

function innerSubscribe(result, innerSubscriber) {
    if (innerSubscriber.closed) {
        return undefined;
    }
    if (result instanceof _Observable__WEBPACK_IMPORTED_MODULE_2__.Observable) {
        return result.subscribe(innerSubscriber);
    }
    var subscription;
    try {
        subscription = (0,_util_subscribeTo__WEBPACK_IMPORTED_MODULE_3__.subscribeTo)(result)(innerSubscriber);
    }
    catch (error) {
        innerSubscriber.error(error);
    }
    return subscription;
}
//# sourceMappingURL=innerSubscribe.js.map


/***/ }),
/* 268 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defer": () => (/* binding */ defer)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(186);
/* harmony import */ var _from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(260);
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(219);
/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */



function defer(observableFactory) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {
        var input;
        try {
            input = observableFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = input ? (0,_from__WEBPACK_IMPORTED_MODULE_1__.from)(input) : (0,_empty__WEBPACK_IMPORTED_MODULE_2__.empty)();
        return source.subscribe(subscriber);
    });
}
//# sourceMappingURL=defer.js.map


/***/ }),
/* 269 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "forkJoin": () => (/* binding */ forkJoin)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(186);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(197);
/* harmony import */ var _operators_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(243);
/* harmony import */ var _util_isObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(198);
/* harmony import */ var _from__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(260);
/** PURE_IMPORTS_START _Observable,_util_isArray,_operators_map,_util_isObject,_from PURE_IMPORTS_END */





function forkJoin() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (sources.length === 1) {
        var first_1 = sources[0];
        if ((0,_util_isArray__WEBPACK_IMPORTED_MODULE_0__.isArray)(first_1)) {
            return forkJoinInternal(first_1, null);
        }
        if ((0,_util_isObject__WEBPACK_IMPORTED_MODULE_1__.isObject)(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {
            var keys = Object.keys(first_1);
            return forkJoinInternal(keys.map(function (key) { return first_1[key]; }), keys);
        }
    }
    if (typeof sources[sources.length - 1] === 'function') {
        var resultSelector_1 = sources.pop();
        sources = (sources.length === 1 && (0,_util_isArray__WEBPACK_IMPORTED_MODULE_0__.isArray)(sources[0])) ? sources[0] : sources;
        return forkJoinInternal(sources, null).pipe((0,_operators_map__WEBPACK_IMPORTED_MODULE_2__.map)(function (args) { return resultSelector_1.apply(void 0, args); }));
    }
    return forkJoinInternal(sources, null);
}
function forkJoinInternal(sources, keys) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_3__.Observable(function (subscriber) {
        var len = sources.length;
        if (len === 0) {
            subscriber.complete();
            return;
        }
        var values = new Array(len);
        var completed = 0;
        var emitted = 0;
        var _loop_1 = function (i) {
            var source = (0,_from__WEBPACK_IMPORTED_MODULE_4__.from)(sources[i]);
            var hasValue = false;
            subscriber.add(source.subscribe({
                next: function (value) {
                    if (!hasValue) {
                        hasValue = true;
                        emitted++;
                    }
                    values[i] = value;
                },
                error: function (err) { return subscriber.error(err); },
                complete: function () {
                    completed++;
                    if (completed === len || !hasValue) {
                        if (emitted === len) {
                            subscriber.next(keys ?
                                keys.reduce(function (result, key, i) { return (result[key] = values[i], result); }, {}) :
                                values);
                        }
                        subscriber.complete();
                    }
                }
            }));
        };
        for (var i = 0; i < len; i++) {
            _loop_1(i);
        }
    });
}
//# sourceMappingURL=forkJoin.js.map


/***/ }),
/* 270 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fromEvent": () => (/* binding */ fromEvent)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(186);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(197);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(195);
/* harmony import */ var _operators_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(243);
/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */




var toString = /*@__PURE__*/ (function () { return Object.prototype.toString; })();
function fromEvent(target, eventName, options, resultSelector) {
    if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(options)) {
        resultSelector = options;
        options = undefined;
    }
    if (resultSelector) {
        return fromEvent(target, eventName, options).pipe((0,_operators_map__WEBPACK_IMPORTED_MODULE_1__.map)(function (args) { return (0,_util_isArray__WEBPACK_IMPORTED_MODULE_2__.isArray)(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_3__.Observable(function (subscriber) {
        function handler(e) {
            if (arguments.length > 1) {
                subscriber.next(Array.prototype.slice.call(arguments));
            }
            else {
                subscriber.next(e);
            }
        }
        setupSubscription(target, eventName, handler, subscriber, options);
    });
}
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
    var unsubscribe;
    if (isEventTarget(sourceObj)) {
        var source_1 = sourceObj;
        sourceObj.addEventListener(eventName, handler, options);
        unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };
    }
    else if (isJQueryStyleEventEmitter(sourceObj)) {
        var source_2 = sourceObj;
        sourceObj.on(eventName, handler);
        unsubscribe = function () { return source_2.off(eventName, handler); };
    }
    else if (isNodeStyleEventEmitter(sourceObj)) {
        var source_3 = sourceObj;
        sourceObj.addListener(eventName, handler);
        unsubscribe = function () { return source_3.removeListener(eventName, handler); };
    }
    else if (sourceObj && sourceObj.length) {
        for (var i = 0, len = sourceObj.length; i < len; i++) {
            setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
        }
    }
    else {
        throw new TypeError('Invalid event target');
    }
    subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isEventTarget(sourceObj) {
    return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}
//# sourceMappingURL=fromEvent.js.map


/***/ }),
/* 271 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fromEventPattern": () => (/* binding */ fromEventPattern)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(186);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(197);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(195);
/* harmony import */ var _operators_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(243);
/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */




function fromEventPattern(addHandler, removeHandler, resultSelector) {
    if (resultSelector) {
        return fromEventPattern(addHandler, removeHandler).pipe((0,_operators_map__WEBPACK_IMPORTED_MODULE_0__.map)(function (args) { return (0,_util_isArray__WEBPACK_IMPORTED_MODULE_1__.isArray)(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_2__.Observable(function (subscriber) {
        var handler = function () {
            var e = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                e[_i] = arguments[_i];
            }
            return subscriber.next(e.length === 1 ? e[0] : e);
        };
        var retValue;
        try {
            retValue = addHandler(handler);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        if (!(0,_util_isFunction__WEBPACK_IMPORTED_MODULE_3__.isFunction)(removeHandler)) {
            return undefined;
        }
        return function () { return removeHandler(handler, retValue); };
    });
}
//# sourceMappingURL=fromEventPattern.js.map


/***/ }),
/* 272 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "generate": () => (/* binding */ generate)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(186);
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(202);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(214);
/** PURE_IMPORTS_START _Observable,_util_identity,_util_isScheduler PURE_IMPORTS_END */



function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
    var resultSelector;
    var initialState;
    if (arguments.length == 1) {
        var options = initialStateOrOptions;
        initialState = options.initialState;
        condition = options.condition;
        iterate = options.iterate;
        resultSelector = options.resultSelector || _util_identity__WEBPACK_IMPORTED_MODULE_0__.identity;
        scheduler = options.scheduler;
    }
    else if (resultSelectorOrObservable === undefined || (0,_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__.isScheduler)(resultSelectorOrObservable)) {
        initialState = initialStateOrOptions;
        resultSelector = _util_identity__WEBPACK_IMPORTED_MODULE_0__.identity;
        scheduler = resultSelectorOrObservable;
    }
    else {
        initialState = initialStateOrOptions;
        resultSelector = resultSelectorOrObservable;
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_2__.Observable(function (subscriber) {
        var state = initialState;
        if (scheduler) {
            return scheduler.schedule(dispatch, 0, {
                subscriber: subscriber,
                iterate: iterate,
                condition: condition,
                resultSelector: resultSelector,
                state: state
            });
        }
        do {
            if (condition) {
                var conditionResult = void 0;
                try {
                    conditionResult = condition(state);
                }
                catch (err) {
                    subscriber.error(err);
                    return undefined;
                }
                if (!conditionResult) {
                    subscriber.complete();
                    break;
                }
            }
            var value = void 0;
            try {
                value = resultSelector(state);
            }
            catch (err) {
                subscriber.error(err);
                return undefined;
            }
            subscriber.next(value);
            if (subscriber.closed) {
                break;
            }
            try {
                state = iterate(state);
            }
            catch (err) {
                subscriber.error(err);
                return undefined;
            }
        } while (true);
        return undefined;
    });
}
function dispatch(state) {
    var subscriber = state.subscriber, condition = state.condition;
    if (subscriber.closed) {
        return undefined;
    }
    if (state.needIterate) {
        try {
            state.state = state.iterate(state.state);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
    }
    else {
        state.needIterate = true;
    }
    if (condition) {
        var conditionResult = void 0;
        try {
            conditionResult = condition(state.state);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        if (!conditionResult) {
            subscriber.complete();
            return undefined;
        }
        if (subscriber.closed) {
            return undefined;
        }
    }
    var value;
    try {
        value = state.resultSelector(state.state);
    }
    catch (err) {
        subscriber.error(err);
        return undefined;
    }
    if (subscriber.closed) {
        return undefined;
    }
    subscriber.next(value);
    if (subscriber.closed) {
        return undefined;
    }
    return this.schedule(state);
}
//# sourceMappingURL=generate.js.map


/***/ }),
/* 273 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "iif": () => (/* binding */ iif)
/* harmony export */ });
/* harmony import */ var _defer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(268);
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(219);
/** PURE_IMPORTS_START _defer,_empty PURE_IMPORTS_END */


function iif(condition, trueResult, falseResult) {
    if (trueResult === void 0) {
        trueResult = _empty__WEBPACK_IMPORTED_MODULE_0__.EMPTY;
    }
    if (falseResult === void 0) {
        falseResult = _empty__WEBPACK_IMPORTED_MODULE_0__.EMPTY;
    }
    return (0,_defer__WEBPACK_IMPORTED_MODULE_1__.defer)(function () { return condition() ? trueResult : falseResult; });
}
//# sourceMappingURL=iif.js.map


/***/ }),
/* 274 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "interval": () => (/* binding */ interval)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(186);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(232);
/* harmony import */ var _util_isNumeric__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(275);
/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */



function interval(period, scheduler) {
    if (period === void 0) {
        period = 0;
    }
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__.async;
    }
    if (!(0,_util_isNumeric__WEBPACK_IMPORTED_MODULE_1__.isNumeric)(period) || period < 0) {
        period = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== 'function') {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__.async;
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_2__.Observable(function (subscriber) {
        subscriber.add(scheduler.schedule(dispatch, period, { subscriber: subscriber, counter: 0, period: period }));
        return subscriber;
    });
}
function dispatch(state) {
    var subscriber = state.subscriber, counter = state.counter, period = state.period;
    subscriber.next(counter);
    this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);
}
//# sourceMappingURL=interval.js.map


/***/ }),
/* 275 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isNumeric": () => (/* binding */ isNumeric)
/* harmony export */ });
/* harmony import */ var _isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(197);
/** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */

function isNumeric(val) {
    return !(0,_isArray__WEBPACK_IMPORTED_MODULE_0__.isArray)(val) && (val - parseFloat(val) + 1) >= 0;
}
//# sourceMappingURL=isNumeric.js.map


/***/ }),
/* 276 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "merge": () => (/* binding */ merge)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(186);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(214);
/* harmony import */ var _operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(258);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(216);
/** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */




function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if ((0,_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__.isScheduler)(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    }
    else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof _Observable__WEBPACK_IMPORTED_MODULE_1__.Observable) {
        return observables[0];
    }
    return (0,_operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__.mergeAll)(concurrent)((0,_fromArray__WEBPACK_IMPORTED_MODULE_3__.fromArray)(observables, scheduler));
}
//# sourceMappingURL=merge.js.map


/***/ }),
/* 277 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NEVER": () => (/* binding */ NEVER),
/* harmony export */   "never": () => (/* binding */ never)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(186);
/* harmony import */ var _util_noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(237);
/** PURE_IMPORTS_START _Observable,_util_noop PURE_IMPORTS_END */


var NEVER = /*@__PURE__*/ new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(_util_noop__WEBPACK_IMPORTED_MODULE_1__.noop);
function never() {
    return NEVER;
}
//# sourceMappingURL=never.js.map


/***/ }),
/* 278 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "onErrorResumeNext": () => (/* binding */ onErrorResumeNext)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(186);
/* harmony import */ var _from__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(260);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(197);
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(219);
/** PURE_IMPORTS_START _Observable,_from,_util_isArray,_empty PURE_IMPORTS_END */




function onErrorResumeNext() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (sources.length === 0) {
        return _empty__WEBPACK_IMPORTED_MODULE_0__.EMPTY;
    }
    var first = sources[0], remainder = sources.slice(1);
    if (sources.length === 1 && (0,_util_isArray__WEBPACK_IMPORTED_MODULE_1__.isArray)(first)) {
        return onErrorResumeNext.apply(void 0, first);
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_2__.Observable(function (subscriber) {
        var subNext = function () { return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber)); };
        return (0,_from__WEBPACK_IMPORTED_MODULE_3__.from)(first).subscribe({
            next: function (value) { subscriber.next(value); },
            error: subNext,
            complete: subNext,
        });
    });
}
//# sourceMappingURL=onErrorResumeNext.js.map


/***/ }),
/* 279 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pairs": () => (/* binding */ pairs),
/* harmony export */   "dispatch": () => (/* binding */ dispatch)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(186);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(194);
/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */


function pairs(obj, scheduler) {
    if (!scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {
            var keys = Object.keys(obj);
            for (var i = 0; i < keys.length && !subscriber.closed; i++) {
                var key = keys[i];
                if (obj.hasOwnProperty(key)) {
                    subscriber.next([key, obj[key]]);
                }
            }
            subscriber.complete();
        });
    }
    else {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {
            var keys = Object.keys(obj);
            var subscription = new _Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription();
            subscription.add(scheduler.schedule(dispatch, 0, { keys: keys, index: 0, subscriber: subscriber, subscription: subscription, obj: obj }));
            return subscription;
        });
    }
}
function dispatch(state) {
    var keys = state.keys, index = state.index, subscriber = state.subscriber, subscription = state.subscription, obj = state.obj;
    if (!subscriber.closed) {
        if (index < keys.length) {
            var key = keys[index];
            subscriber.next([key, obj[key]]);
            subscription.add(this.schedule({ keys: keys, index: index + 1, subscriber: subscriber, subscription: subscription, obj: obj }));
        }
        else {
            subscriber.complete();
        }
    }
}
//# sourceMappingURL=pairs.js.map


/***/ }),
/* 280 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "partition": () => (/* binding */ partition)
/* harmony export */ });
/* harmony import */ var _util_not__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(282);
/* harmony import */ var _util_subscribeTo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(248);
/* harmony import */ var _operators_filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(281);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(186);
/** PURE_IMPORTS_START _util_not,_util_subscribeTo,_operators_filter,_Observable PURE_IMPORTS_END */




function partition(source, predicate, thisArg) {
    return [
        (0,_operators_filter__WEBPACK_IMPORTED_MODULE_0__.filter)(predicate, thisArg)(new _Observable__WEBPACK_IMPORTED_MODULE_1__.Observable((0,_util_subscribeTo__WEBPACK_IMPORTED_MODULE_2__.subscribeTo)(source))),
        (0,_operators_filter__WEBPACK_IMPORTED_MODULE_0__.filter)((0,_util_not__WEBPACK_IMPORTED_MODULE_3__.not)(predicate, thisArg))(new _Observable__WEBPACK_IMPORTED_MODULE_1__.Observable((0,_util_subscribeTo__WEBPACK_IMPORTED_MODULE_2__.subscribeTo)(source)))
    ];
}
//# sourceMappingURL=partition.js.map


/***/ }),
/* 281 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "filter": () => (/* binding */ filter)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
var FilterOperator = /*@__PURE__*/ (function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}());
var FilterSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.count = 0;
        return _this;
    }
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));
//# sourceMappingURL=filter.js.map


/***/ }),
/* 282 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "not": () => (/* binding */ not)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function not(pred, thisArg) {
    function notPred() {
        return !(notPred.pred.apply(notPred.thisArg, arguments));
    }
    notPred.pred = pred;
    notPred.thisArg = thisArg;
    return notPred;
}
//# sourceMappingURL=not.js.map


/***/ }),
/* 283 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "race": () => (/* binding */ race),
/* harmony export */   "RaceOperator": () => (/* binding */ RaceOperator),
/* harmony export */   "RaceSubscriber": () => (/* binding */ RaceSubscriber)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(197);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(216);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(255);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(246);
/** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */





function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    if (observables.length === 1) {
        if ((0,_util_isArray__WEBPACK_IMPORTED_MODULE_1__.isArray)(observables[0])) {
            observables = observables[0];
        }
        else {
            return observables[0];
        }
    }
    return (0,_fromArray__WEBPACK_IMPORTED_MODULE_2__.fromArray)(observables, undefined).lift(new RaceOperator());
}
var RaceOperator = /*@__PURE__*/ (function () {
    function RaceOperator() {
    }
    RaceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
    };
    return RaceOperator;
}());

var RaceSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(RaceSubscriber, _super);
    function RaceSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasFirst = false;
        _this.observables = [];
        _this.subscriptions = [];
        return _this;
    }
    RaceSubscriber.prototype._next = function (observable) {
        this.observables.push(observable);
    };
    RaceSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            for (var i = 0; i < len && !this.hasFirst; i++) {
                var observable = observables[i];
                var subscription = (0,_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__.subscribeToResult)(this, observable, undefined, i);
                if (this.subscriptions) {
                    this.subscriptions.push(subscription);
                }
                this.add(subscription);
            }
            this.observables = null;
        }
    };
    RaceSubscriber.prototype.notifyNext = function (_outerValue, innerValue, outerIndex) {
        if (!this.hasFirst) {
            this.hasFirst = true;
            for (var i = 0; i < this.subscriptions.length; i++) {
                if (i !== outerIndex) {
                    var subscription = this.subscriptions[i];
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
            }
            this.subscriptions = null;
        }
        this.destination.next(innerValue);
    };
    return RaceSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_4__.OuterSubscriber));

//# sourceMappingURL=race.js.map


/***/ }),
/* 284 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "range": () => (/* binding */ range),
/* harmony export */   "dispatch": () => (/* binding */ dispatch)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(186);
/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

function range(start, count, scheduler) {
    if (start === void 0) {
        start = 0;
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {
        if (count === undefined) {
            count = start;
            start = 0;
        }
        var index = 0;
        var current = start;
        if (scheduler) {
            return scheduler.schedule(dispatch, 0, {
                index: index, count: count, start: start, subscriber: subscriber
            });
        }
        else {
            do {
                if (index++ >= count) {
                    subscriber.complete();
                    break;
                }
                subscriber.next(current++);
                if (subscriber.closed) {
                    break;
                }
            } while (true);
        }
        return undefined;
    });
}
function dispatch(state) {
    var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;
    if (index >= count) {
        subscriber.complete();
        return;
    }
    subscriber.next(start);
    if (subscriber.closed) {
        return;
    }
    state.index = index + 1;
    state.start = start + 1;
    this.schedule(state);
}
//# sourceMappingURL=range.js.map


/***/ }),
/* 285 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "timer": () => (/* binding */ timer)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(186);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(232);
/* harmony import */ var _util_isNumeric__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(275);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(214);
/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */




function timer(dueTime, periodOrScheduler, scheduler) {
    if (dueTime === void 0) {
        dueTime = 0;
    }
    var period = -1;
    if ((0,_util_isNumeric__WEBPACK_IMPORTED_MODULE_0__.isNumeric)(periodOrScheduler)) {
        period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
    }
    else if ((0,_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__.isScheduler)(periodOrScheduler)) {
        scheduler = periodOrScheduler;
    }
    if (!(0,_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__.isScheduler)(scheduler)) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_2__.async;
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_3__.Observable(function (subscriber) {
        var due = (0,_util_isNumeric__WEBPACK_IMPORTED_MODULE_0__.isNumeric)(dueTime)
            ? dueTime
            : (+dueTime - scheduler.now());
        return scheduler.schedule(dispatch, due, {
            index: 0, period: period, subscriber: subscriber
        });
    });
}
function dispatch(state) {
    var index = state.index, period = state.period, subscriber = state.subscriber;
    subscriber.next(index);
    if (subscriber.closed) {
        return;
    }
    else if (period === -1) {
        return subscriber.complete();
    }
    state.index = index + 1;
    this.schedule(state, period);
}
//# sourceMappingURL=timer.js.map


/***/ }),
/* 286 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "using": () => (/* binding */ using)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(186);
/* harmony import */ var _from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(260);
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(219);
/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */



function using(resourceFactory, observableFactory) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) {
        var resource;
        try {
            resource = resourceFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var result;
        try {
            result = observableFactory(resource);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = result ? (0,_from__WEBPACK_IMPORTED_MODULE_1__.from)(result) : _empty__WEBPACK_IMPORTED_MODULE_2__.EMPTY;
        var subscription = source.subscribe(subscriber);
        return function () {
            subscription.unsubscribe();
            if (resource) {
                resource.unsubscribe();
            }
        };
    });
}
//# sourceMappingURL=using.js.map


/***/ }),
/* 287 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "zip": () => (/* binding */ zip),
/* harmony export */   "ZipOperator": () => (/* binding */ ZipOperator),
/* harmony export */   "ZipSubscriber": () => (/* binding */ ZipSubscriber)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(216);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(197);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(188);
/* harmony import */ var _internal_symbol_iterator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(253);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(267);
/** PURE_IMPORTS_START tslib,_fromArray,_util_isArray,_Subscriber,_.._internal_symbol_iterator,_innerSubscribe PURE_IMPORTS_END */






function zip() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = observables[observables.length - 1];
    if (typeof resultSelector === 'function') {
        observables.pop();
    }
    return (0,_fromArray__WEBPACK_IMPORTED_MODULE_1__.fromArray)(observables, undefined).lift(new ZipOperator(resultSelector));
}
var ZipOperator = /*@__PURE__*/ (function () {
    function ZipOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
    };
    return ZipOperator;
}());

var ZipSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(ZipSubscriber, _super);
    function ZipSubscriber(destination, resultSelector, values) {
        if (values === void 0) {
            values = Object.create(null);
        }
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.iterators = [];
        _this.active = 0;
        _this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : undefined;
        return _this;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if ((0,_util_isArray__WEBPACK_IMPORTED_MODULE_2__.isArray)(value)) {
            iterators.push(new StaticArrayIterator(value));
        }
        else if (typeof value[_internal_symbol_iterator__WEBPACK_IMPORTED_MODULE_3__.iterator] === 'function') {
            iterators.push(new StaticIterator(value[_internal_symbol_iterator__WEBPACK_IMPORTED_MODULE_3__.iterator]()));
        }
        else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        this.unsubscribe();
        if (len === 0) {
            this.destination.complete();
            return;
        }
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (iterator.stillUnsubscribed) {
                var destination = this.destination;
                destination.add(iterator.subscribe());
            }
            else {
                this.active--;
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            var result = iterator.next();
            if (iterator.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.resultSelector) {
            this._tryresultSelector(args);
        }
        else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryresultSelector = function (args) {
        var result;
        try {
            result = this.resultSelector.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_4__.Subscriber));

var StaticIterator = /*@__PURE__*/ (function () {
    function StaticIterator(iterator) {
        this.iterator = iterator;
        this.nextResult = iterator.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return Boolean(nextResult && nextResult.done);
    };
    return StaticIterator;
}());
var StaticArrayIterator = /*@__PURE__*/ (function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[_internal_symbol_iterator__WEBPACK_IMPORTED_MODULE_3__.iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}());
var ZipBufferIterator = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        _this.observable = observable;
        _this.stillUnsubscribed = true;
        _this.buffer = [];
        _this.isComplete = false;
        return _this;
    }
    ZipBufferIterator.prototype[_internal_symbol_iterator__WEBPACK_IMPORTED_MODULE_3__.iterator] = function () {
        return this;
    };
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        }
        else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        }
        else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (innerValue) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function () {
        return (0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_5__.innerSubscribe)(this.observable, new _innerSubscribe__WEBPACK_IMPORTED_MODULE_5__.SimpleInnerSubscriber(this));
    };
    return ZipBufferIterator;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_5__.SimpleOuterSubscriber));
//# sourceMappingURL=zip.js.map


/***/ }),
/* 288 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var rxjs_1 = __webpack_require__(185);
/**
 *
 * only keep the lastest source observable value until the inner observable complete,
 * then trigger the lastest source observable value
 *
 * @param isAbandon - is abandon inner observable value when there is newer source observable value
 *
 */
function waitMap(fn, isAbandon) {
    if (isAbandon === void 0) { isAbandon = true; }
    return function (preObs) {
        return rxjs_1.Observable.create(function (observer) {
            var closed = false;
            var latestRes;
            var resultSubp;
            var subp;
            var run = function (res) {
                var obs = fn(res);
                return obs.subscribe({
                    next: function (res) {
                        if (latestRes !== undefined && isAbandon) {
                            return;
                        }
                        observer.next(res);
                    },
                    error: function (err) {
                        closed = true;
                        observer.error(err);
                        resultSubp.unsubscribe();
                    },
                    complete: function () {
                        if (latestRes && !closed) {
                            var res_1 = latestRes;
                            latestRes = undefined;
                            run(res_1);
                        }
                    }
                });
            };
            resultSubp = preObs.subscribe({
                next: function (res) {
                    latestRes = res;
                    if (!subp || subp.closed) {
                        latestRes = undefined;
                        subp = run(res);
                    }
                },
                error: function (err) {
                    closed = true;
                    observer.error(err);
                },
                complete: function () {
                    closed = true;
                    observer.complete();
                }
            });
            return resultSubp;
        });
    };
}
exports.waitMap = waitMap;


/***/ }),
/* 289 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "audit": () => (/* reexport safe */ _internal_operators_audit__WEBPACK_IMPORTED_MODULE_0__.audit),
/* harmony export */   "auditTime": () => (/* reexport safe */ _internal_operators_auditTime__WEBPACK_IMPORTED_MODULE_1__.auditTime),
/* harmony export */   "buffer": () => (/* reexport safe */ _internal_operators_buffer__WEBPACK_IMPORTED_MODULE_2__.buffer),
/* harmony export */   "bufferCount": () => (/* reexport safe */ _internal_operators_bufferCount__WEBPACK_IMPORTED_MODULE_3__.bufferCount),
/* harmony export */   "bufferTime": () => (/* reexport safe */ _internal_operators_bufferTime__WEBPACK_IMPORTED_MODULE_4__.bufferTime),
/* harmony export */   "bufferToggle": () => (/* reexport safe */ _internal_operators_bufferToggle__WEBPACK_IMPORTED_MODULE_5__.bufferToggle),
/* harmony export */   "bufferWhen": () => (/* reexport safe */ _internal_operators_bufferWhen__WEBPACK_IMPORTED_MODULE_6__.bufferWhen),
/* harmony export */   "catchError": () => (/* reexport safe */ _internal_operators_catchError__WEBPACK_IMPORTED_MODULE_7__.catchError),
/* harmony export */   "combineAll": () => (/* reexport safe */ _internal_operators_combineAll__WEBPACK_IMPORTED_MODULE_8__.combineAll),
/* harmony export */   "combineLatest": () => (/* reexport safe */ _internal_operators_combineLatest__WEBPACK_IMPORTED_MODULE_9__.combineLatest),
/* harmony export */   "concat": () => (/* reexport safe */ _internal_operators_concat__WEBPACK_IMPORTED_MODULE_10__.concat),
/* harmony export */   "concatAll": () => (/* reexport safe */ _internal_operators_concatAll__WEBPACK_IMPORTED_MODULE_11__.concatAll),
/* harmony export */   "concatMap": () => (/* reexport safe */ _internal_operators_concatMap__WEBPACK_IMPORTED_MODULE_12__.concatMap),
/* harmony export */   "concatMapTo": () => (/* reexport safe */ _internal_operators_concatMapTo__WEBPACK_IMPORTED_MODULE_13__.concatMapTo),
/* harmony export */   "count": () => (/* reexport safe */ _internal_operators_count__WEBPACK_IMPORTED_MODULE_14__.count),
/* harmony export */   "debounce": () => (/* reexport safe */ _internal_operators_debounce__WEBPACK_IMPORTED_MODULE_15__.debounce),
/* harmony export */   "debounceTime": () => (/* reexport safe */ _internal_operators_debounceTime__WEBPACK_IMPORTED_MODULE_16__.debounceTime),
/* harmony export */   "defaultIfEmpty": () => (/* reexport safe */ _internal_operators_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_17__.defaultIfEmpty),
/* harmony export */   "delay": () => (/* reexport safe */ _internal_operators_delay__WEBPACK_IMPORTED_MODULE_18__.delay),
/* harmony export */   "delayWhen": () => (/* reexport safe */ _internal_operators_delayWhen__WEBPACK_IMPORTED_MODULE_19__.delayWhen),
/* harmony export */   "dematerialize": () => (/* reexport safe */ _internal_operators_dematerialize__WEBPACK_IMPORTED_MODULE_20__.dematerialize),
/* harmony export */   "distinct": () => (/* reexport safe */ _internal_operators_distinct__WEBPACK_IMPORTED_MODULE_21__.distinct),
/* harmony export */   "distinctUntilChanged": () => (/* reexport safe */ _internal_operators_distinctUntilChanged__WEBPACK_IMPORTED_MODULE_22__.distinctUntilChanged),
/* harmony export */   "distinctUntilKeyChanged": () => (/* reexport safe */ _internal_operators_distinctUntilKeyChanged__WEBPACK_IMPORTED_MODULE_23__.distinctUntilKeyChanged),
/* harmony export */   "elementAt": () => (/* reexport safe */ _internal_operators_elementAt__WEBPACK_IMPORTED_MODULE_24__.elementAt),
/* harmony export */   "endWith": () => (/* reexport safe */ _internal_operators_endWith__WEBPACK_IMPORTED_MODULE_25__.endWith),
/* harmony export */   "every": () => (/* reexport safe */ _internal_operators_every__WEBPACK_IMPORTED_MODULE_26__.every),
/* harmony export */   "exhaust": () => (/* reexport safe */ _internal_operators_exhaust__WEBPACK_IMPORTED_MODULE_27__.exhaust),
/* harmony export */   "exhaustMap": () => (/* reexport safe */ _internal_operators_exhaustMap__WEBPACK_IMPORTED_MODULE_28__.exhaustMap),
/* harmony export */   "expand": () => (/* reexport safe */ _internal_operators_expand__WEBPACK_IMPORTED_MODULE_29__.expand),
/* harmony export */   "filter": () => (/* reexport safe */ _internal_operators_filter__WEBPACK_IMPORTED_MODULE_30__.filter),
/* harmony export */   "finalize": () => (/* reexport safe */ _internal_operators_finalize__WEBPACK_IMPORTED_MODULE_31__.finalize),
/* harmony export */   "find": () => (/* reexport safe */ _internal_operators_find__WEBPACK_IMPORTED_MODULE_32__.find),
/* harmony export */   "findIndex": () => (/* reexport safe */ _internal_operators_findIndex__WEBPACK_IMPORTED_MODULE_33__.findIndex),
/* harmony export */   "first": () => (/* reexport safe */ _internal_operators_first__WEBPACK_IMPORTED_MODULE_34__.first),
/* harmony export */   "groupBy": () => (/* reexport safe */ _internal_operators_groupBy__WEBPACK_IMPORTED_MODULE_35__.groupBy),
/* harmony export */   "ignoreElements": () => (/* reexport safe */ _internal_operators_ignoreElements__WEBPACK_IMPORTED_MODULE_36__.ignoreElements),
/* harmony export */   "isEmpty": () => (/* reexport safe */ _internal_operators_isEmpty__WEBPACK_IMPORTED_MODULE_37__.isEmpty),
/* harmony export */   "last": () => (/* reexport safe */ _internal_operators_last__WEBPACK_IMPORTED_MODULE_38__.last),
/* harmony export */   "map": () => (/* reexport safe */ _internal_operators_map__WEBPACK_IMPORTED_MODULE_39__.map),
/* harmony export */   "mapTo": () => (/* reexport safe */ _internal_operators_mapTo__WEBPACK_IMPORTED_MODULE_40__.mapTo),
/* harmony export */   "materialize": () => (/* reexport safe */ _internal_operators_materialize__WEBPACK_IMPORTED_MODULE_41__.materialize),
/* harmony export */   "max": () => (/* reexport safe */ _internal_operators_max__WEBPACK_IMPORTED_MODULE_42__.max),
/* harmony export */   "merge": () => (/* reexport safe */ _internal_operators_merge__WEBPACK_IMPORTED_MODULE_43__.merge),
/* harmony export */   "mergeAll": () => (/* reexport safe */ _internal_operators_mergeAll__WEBPACK_IMPORTED_MODULE_44__.mergeAll),
/* harmony export */   "mergeMap": () => (/* reexport safe */ _internal_operators_mergeMap__WEBPACK_IMPORTED_MODULE_45__.mergeMap),
/* harmony export */   "flatMap": () => (/* reexport safe */ _internal_operators_mergeMap__WEBPACK_IMPORTED_MODULE_45__.flatMap),
/* harmony export */   "mergeMapTo": () => (/* reexport safe */ _internal_operators_mergeMapTo__WEBPACK_IMPORTED_MODULE_46__.mergeMapTo),
/* harmony export */   "mergeScan": () => (/* reexport safe */ _internal_operators_mergeScan__WEBPACK_IMPORTED_MODULE_47__.mergeScan),
/* harmony export */   "min": () => (/* reexport safe */ _internal_operators_min__WEBPACK_IMPORTED_MODULE_48__.min),
/* harmony export */   "multicast": () => (/* reexport safe */ _internal_operators_multicast__WEBPACK_IMPORTED_MODULE_49__.multicast),
/* harmony export */   "observeOn": () => (/* reexport safe */ _internal_operators_observeOn__WEBPACK_IMPORTED_MODULE_50__.observeOn),
/* harmony export */   "onErrorResumeNext": () => (/* reexport safe */ _internal_operators_onErrorResumeNext__WEBPACK_IMPORTED_MODULE_51__.onErrorResumeNext),
/* harmony export */   "pairwise": () => (/* reexport safe */ _internal_operators_pairwise__WEBPACK_IMPORTED_MODULE_52__.pairwise),
/* harmony export */   "partition": () => (/* reexport safe */ _internal_operators_partition__WEBPACK_IMPORTED_MODULE_53__.partition),
/* harmony export */   "pluck": () => (/* reexport safe */ _internal_operators_pluck__WEBPACK_IMPORTED_MODULE_54__.pluck),
/* harmony export */   "publish": () => (/* reexport safe */ _internal_operators_publish__WEBPACK_IMPORTED_MODULE_55__.publish),
/* harmony export */   "publishBehavior": () => (/* reexport safe */ _internal_operators_publishBehavior__WEBPACK_IMPORTED_MODULE_56__.publishBehavior),
/* harmony export */   "publishLast": () => (/* reexport safe */ _internal_operators_publishLast__WEBPACK_IMPORTED_MODULE_57__.publishLast),
/* harmony export */   "publishReplay": () => (/* reexport safe */ _internal_operators_publishReplay__WEBPACK_IMPORTED_MODULE_58__.publishReplay),
/* harmony export */   "race": () => (/* reexport safe */ _internal_operators_race__WEBPACK_IMPORTED_MODULE_59__.race),
/* harmony export */   "reduce": () => (/* reexport safe */ _internal_operators_reduce__WEBPACK_IMPORTED_MODULE_60__.reduce),
/* harmony export */   "repeat": () => (/* reexport safe */ _internal_operators_repeat__WEBPACK_IMPORTED_MODULE_61__.repeat),
/* harmony export */   "repeatWhen": () => (/* reexport safe */ _internal_operators_repeatWhen__WEBPACK_IMPORTED_MODULE_62__.repeatWhen),
/* harmony export */   "retry": () => (/* reexport safe */ _internal_operators_retry__WEBPACK_IMPORTED_MODULE_63__.retry),
/* harmony export */   "retryWhen": () => (/* reexport safe */ _internal_operators_retryWhen__WEBPACK_IMPORTED_MODULE_64__.retryWhen),
/* harmony export */   "refCount": () => (/* reexport safe */ _internal_operators_refCount__WEBPACK_IMPORTED_MODULE_65__.refCount),
/* harmony export */   "sample": () => (/* reexport safe */ _internal_operators_sample__WEBPACK_IMPORTED_MODULE_66__.sample),
/* harmony export */   "sampleTime": () => (/* reexport safe */ _internal_operators_sampleTime__WEBPACK_IMPORTED_MODULE_67__.sampleTime),
/* harmony export */   "scan": () => (/* reexport safe */ _internal_operators_scan__WEBPACK_IMPORTED_MODULE_68__.scan),
/* harmony export */   "sequenceEqual": () => (/* reexport safe */ _internal_operators_sequenceEqual__WEBPACK_IMPORTED_MODULE_69__.sequenceEqual),
/* harmony export */   "share": () => (/* reexport safe */ _internal_operators_share__WEBPACK_IMPORTED_MODULE_70__.share),
/* harmony export */   "shareReplay": () => (/* reexport safe */ _internal_operators_shareReplay__WEBPACK_IMPORTED_MODULE_71__.shareReplay),
/* harmony export */   "single": () => (/* reexport safe */ _internal_operators_single__WEBPACK_IMPORTED_MODULE_72__.single),
/* harmony export */   "skip": () => (/* reexport safe */ _internal_operators_skip__WEBPACK_IMPORTED_MODULE_73__.skip),
/* harmony export */   "skipLast": () => (/* reexport safe */ _internal_operators_skipLast__WEBPACK_IMPORTED_MODULE_74__.skipLast),
/* harmony export */   "skipUntil": () => (/* reexport safe */ _internal_operators_skipUntil__WEBPACK_IMPORTED_MODULE_75__.skipUntil),
/* harmony export */   "skipWhile": () => (/* reexport safe */ _internal_operators_skipWhile__WEBPACK_IMPORTED_MODULE_76__.skipWhile),
/* harmony export */   "startWith": () => (/* reexport safe */ _internal_operators_startWith__WEBPACK_IMPORTED_MODULE_77__.startWith),
/* harmony export */   "subscribeOn": () => (/* reexport safe */ _internal_operators_subscribeOn__WEBPACK_IMPORTED_MODULE_78__.subscribeOn),
/* harmony export */   "switchAll": () => (/* reexport safe */ _internal_operators_switchAll__WEBPACK_IMPORTED_MODULE_79__.switchAll),
/* harmony export */   "switchMap": () => (/* reexport safe */ _internal_operators_switchMap__WEBPACK_IMPORTED_MODULE_80__.switchMap),
/* harmony export */   "switchMapTo": () => (/* reexport safe */ _internal_operators_switchMapTo__WEBPACK_IMPORTED_MODULE_81__.switchMapTo),
/* harmony export */   "take": () => (/* reexport safe */ _internal_operators_take__WEBPACK_IMPORTED_MODULE_82__.take),
/* harmony export */   "takeLast": () => (/* reexport safe */ _internal_operators_takeLast__WEBPACK_IMPORTED_MODULE_83__.takeLast),
/* harmony export */   "takeUntil": () => (/* reexport safe */ _internal_operators_takeUntil__WEBPACK_IMPORTED_MODULE_84__.takeUntil),
/* harmony export */   "takeWhile": () => (/* reexport safe */ _internal_operators_takeWhile__WEBPACK_IMPORTED_MODULE_85__.takeWhile),
/* harmony export */   "tap": () => (/* reexport safe */ _internal_operators_tap__WEBPACK_IMPORTED_MODULE_86__.tap),
/* harmony export */   "throttle": () => (/* reexport safe */ _internal_operators_throttle__WEBPACK_IMPORTED_MODULE_87__.throttle),
/* harmony export */   "throttleTime": () => (/* reexport safe */ _internal_operators_throttleTime__WEBPACK_IMPORTED_MODULE_88__.throttleTime),
/* harmony export */   "throwIfEmpty": () => (/* reexport safe */ _internal_operators_throwIfEmpty__WEBPACK_IMPORTED_MODULE_89__.throwIfEmpty),
/* harmony export */   "timeInterval": () => (/* reexport safe */ _internal_operators_timeInterval__WEBPACK_IMPORTED_MODULE_90__.timeInterval),
/* harmony export */   "timeout": () => (/* reexport safe */ _internal_operators_timeout__WEBPACK_IMPORTED_MODULE_91__.timeout),
/* harmony export */   "timeoutWith": () => (/* reexport safe */ _internal_operators_timeoutWith__WEBPACK_IMPORTED_MODULE_92__.timeoutWith),
/* harmony export */   "timestamp": () => (/* reexport safe */ _internal_operators_timestamp__WEBPACK_IMPORTED_MODULE_93__.timestamp),
/* harmony export */   "toArray": () => (/* reexport safe */ _internal_operators_toArray__WEBPACK_IMPORTED_MODULE_94__.toArray),
/* harmony export */   "window": () => (/* reexport safe */ _internal_operators_window__WEBPACK_IMPORTED_MODULE_95__.window),
/* harmony export */   "windowCount": () => (/* reexport safe */ _internal_operators_windowCount__WEBPACK_IMPORTED_MODULE_96__.windowCount),
/* harmony export */   "windowTime": () => (/* reexport safe */ _internal_operators_windowTime__WEBPACK_IMPORTED_MODULE_97__.windowTime),
/* harmony export */   "windowToggle": () => (/* reexport safe */ _internal_operators_windowToggle__WEBPACK_IMPORTED_MODULE_98__.windowToggle),
/* harmony export */   "windowWhen": () => (/* reexport safe */ _internal_operators_windowWhen__WEBPACK_IMPORTED_MODULE_99__.windowWhen),
/* harmony export */   "withLatestFrom": () => (/* reexport safe */ _internal_operators_withLatestFrom__WEBPACK_IMPORTED_MODULE_100__.withLatestFrom),
/* harmony export */   "zip": () => (/* reexport safe */ _internal_operators_zip__WEBPACK_IMPORTED_MODULE_101__.zip),
/* harmony export */   "zipAll": () => (/* reexport safe */ _internal_operators_zipAll__WEBPACK_IMPORTED_MODULE_102__.zipAll)
/* harmony export */ });
/* harmony import */ var _internal_operators_audit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(290);
/* harmony import */ var _internal_operators_auditTime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(291);
/* harmony import */ var _internal_operators_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(292);
/* harmony import */ var _internal_operators_bufferCount__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(293);
/* harmony import */ var _internal_operators_bufferTime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(294);
/* harmony import */ var _internal_operators_bufferToggle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(295);
/* harmony import */ var _internal_operators_bufferWhen__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(296);
/* harmony import */ var _internal_operators_catchError__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(297);
/* harmony import */ var _internal_operators_combineAll__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(298);
/* harmony import */ var _internal_operators_combineLatest__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(299);
/* harmony import */ var _internal_operators_concat__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(300);
/* harmony import */ var _internal_operators_concatAll__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(257);
/* harmony import */ var _internal_operators_concatMap__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(301);
/* harmony import */ var _internal_operators_concatMapTo__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(302);
/* harmony import */ var _internal_operators_count__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(303);
/* harmony import */ var _internal_operators_debounce__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(304);
/* harmony import */ var _internal_operators_debounceTime__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(305);
/* harmony import */ var _internal_operators_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(306);
/* harmony import */ var _internal_operators_delay__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(307);
/* harmony import */ var _internal_operators_delayWhen__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(309);
/* harmony import */ var _internal_operators_dematerialize__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(310);
/* harmony import */ var _internal_operators_distinct__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(311);
/* harmony import */ var _internal_operators_distinctUntilChanged__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(312);
/* harmony import */ var _internal_operators_distinctUntilKeyChanged__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(313);
/* harmony import */ var _internal_operators_elementAt__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(314);
/* harmony import */ var _internal_operators_endWith__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(317);
/* harmony import */ var _internal_operators_every__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(318);
/* harmony import */ var _internal_operators_exhaust__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(319);
/* harmony import */ var _internal_operators_exhaustMap__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(320);
/* harmony import */ var _internal_operators_expand__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(321);
/* harmony import */ var _internal_operators_filter__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(281);
/* harmony import */ var _internal_operators_finalize__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(322);
/* harmony import */ var _internal_operators_find__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(323);
/* harmony import */ var _internal_operators_findIndex__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(324);
/* harmony import */ var _internal_operators_first__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(325);
/* harmony import */ var _internal_operators_groupBy__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(208);
/* harmony import */ var _internal_operators_ignoreElements__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(326);
/* harmony import */ var _internal_operators_isEmpty__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(327);
/* harmony import */ var _internal_operators_last__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(328);
/* harmony import */ var _internal_operators_map__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(243);
/* harmony import */ var _internal_operators_mapTo__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(330);
/* harmony import */ var _internal_operators_materialize__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(331);
/* harmony import */ var _internal_operators_max__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(332);
/* harmony import */ var _internal_operators_merge__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(335);
/* harmony import */ var _internal_operators_mergeAll__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(258);
/* harmony import */ var _internal_operators_mergeMap__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(259);
/* harmony import */ var _internal_operators_mergeMapTo__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(336);
/* harmony import */ var _internal_operators_mergeScan__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(337);
/* harmony import */ var _internal_operators_min__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(338);
/* harmony import */ var _internal_operators_multicast__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(339);
/* harmony import */ var _internal_operators_observeOn__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(211);
/* harmony import */ var _internal_operators_onErrorResumeNext__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(340);
/* harmony import */ var _internal_operators_pairwise__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(341);
/* harmony import */ var _internal_operators_partition__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(342);
/* harmony import */ var _internal_operators_pluck__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(343);
/* harmony import */ var _internal_operators_publish__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(344);
/* harmony import */ var _internal_operators_publishBehavior__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(345);
/* harmony import */ var _internal_operators_publishLast__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(346);
/* harmony import */ var _internal_operators_publishReplay__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(347);
/* harmony import */ var _internal_operators_race__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(348);
/* harmony import */ var _internal_operators_reduce__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(333);
/* harmony import */ var _internal_operators_repeat__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(349);
/* harmony import */ var _internal_operators_repeatWhen__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(350);
/* harmony import */ var _internal_operators_retry__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(351);
/* harmony import */ var _internal_operators_retryWhen__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(352);
/* harmony import */ var _internal_operators_refCount__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(204);
/* harmony import */ var _internal_operators_sample__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(353);
/* harmony import */ var _internal_operators_sampleTime__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(354);
/* harmony import */ var _internal_operators_scan__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(334);
/* harmony import */ var _internal_operators_sequenceEqual__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(355);
/* harmony import */ var _internal_operators_share__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(356);
/* harmony import */ var _internal_operators_shareReplay__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(357);
/* harmony import */ var _internal_operators_single__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(358);
/* harmony import */ var _internal_operators_skip__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(359);
/* harmony import */ var _internal_operators_skipLast__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(360);
/* harmony import */ var _internal_operators_skipUntil__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(361);
/* harmony import */ var _internal_operators_skipWhile__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(362);
/* harmony import */ var _internal_operators_startWith__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(363);
/* harmony import */ var _internal_operators_subscribeOn__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(364);
/* harmony import */ var _internal_operators_switchAll__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(366);
/* harmony import */ var _internal_operators_switchMap__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(367);
/* harmony import */ var _internal_operators_switchMapTo__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(368);
/* harmony import */ var _internal_operators_take__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(315);
/* harmony import */ var _internal_operators_takeLast__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(329);
/* harmony import */ var _internal_operators_takeUntil__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(369);
/* harmony import */ var _internal_operators_takeWhile__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(370);
/* harmony import */ var _internal_operators_tap__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(371);
/* harmony import */ var _internal_operators_throttle__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(372);
/* harmony import */ var _internal_operators_throttleTime__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(373);
/* harmony import */ var _internal_operators_throwIfEmpty__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(316);
/* harmony import */ var _internal_operators_timeInterval__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(374);
/* harmony import */ var _internal_operators_timeout__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(375);
/* harmony import */ var _internal_operators_timeoutWith__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(376);
/* harmony import */ var _internal_operators_timestamp__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(377);
/* harmony import */ var _internal_operators_toArray__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(378);
/* harmony import */ var _internal_operators_window__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(379);
/* harmony import */ var _internal_operators_windowCount__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(380);
/* harmony import */ var _internal_operators_windowTime__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(381);
/* harmony import */ var _internal_operators_windowToggle__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(382);
/* harmony import */ var _internal_operators_windowWhen__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(383);
/* harmony import */ var _internal_operators_withLatestFrom__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(384);
/* harmony import */ var _internal_operators_zip__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(385);
/* harmony import */ var _internal_operators_zipAll__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(386);
/** PURE_IMPORTS_START  PURE_IMPORTS_END */







































































































//# sourceMappingURL=index.js.map


/***/ }),
/* 290 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "audit": () => (/* binding */ audit)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(267);
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function audit(durationSelector) {
    return function auditOperatorFunction(source) {
        return source.lift(new AuditOperator(durationSelector));
    };
}
var AuditOperator = /*@__PURE__*/ (function () {
    function AuditOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    AuditOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
    };
    return AuditOperator;
}());
var AuditSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(AuditSubscriber, _super);
    function AuditSubscriber(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
    }
    AuditSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
        if (!this.throttled) {
            var duration = void 0;
            try {
                var durationSelector = this.durationSelector;
                duration = durationSelector(value);
            }
            catch (err) {
                return this.destination.error(err);
            }
            var innerSubscription = (0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.innerSubscribe)(duration, new _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleInnerSubscriber(this));
            if (!innerSubscription || innerSubscription.closed) {
                this.clearThrottle();
            }
            else {
                this.add(this.throttled = innerSubscription);
            }
        }
    };
    AuditSubscriber.prototype.clearThrottle = function () {
        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
        if (throttled) {
            this.remove(throttled);
            this.throttled = undefined;
            throttled.unsubscribe();
        }
        if (hasValue) {
            this.value = undefined;
            this.hasValue = false;
            this.destination.next(value);
        }
    };
    AuditSubscriber.prototype.notifyNext = function () {
        this.clearThrottle();
    };
    AuditSubscriber.prototype.notifyComplete = function () {
        this.clearThrottle();
    };
    return AuditSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleOuterSubscriber));
//# sourceMappingURL=audit.js.map


/***/ }),
/* 291 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "auditTime": () => (/* binding */ auditTime)
/* harmony export */ });
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(232);
/* harmony import */ var _audit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(290);
/* harmony import */ var _observable_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(285);
/** PURE_IMPORTS_START _scheduler_async,_audit,_observable_timer PURE_IMPORTS_END */



function auditTime(duration, scheduler) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__.async;
    }
    return (0,_audit__WEBPACK_IMPORTED_MODULE_1__.audit)(function () { return (0,_observable_timer__WEBPACK_IMPORTED_MODULE_2__.timer)(duration, scheduler); });
}
//# sourceMappingURL=auditTime.js.map


/***/ }),
/* 292 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "buffer": () => (/* binding */ buffer)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(267);
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function buffer(closingNotifier) {
    return function bufferOperatorFunction(source) {
        return source.lift(new BufferOperator(closingNotifier));
    };
}
var BufferOperator = /*@__PURE__*/ (function () {
    function BufferOperator(closingNotifier) {
        this.closingNotifier = closingNotifier;
    }
    BufferOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
    };
    return BufferOperator;
}());
var BufferSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(BufferSubscriber, _super);
    function BufferSubscriber(destination, closingNotifier) {
        var _this = _super.call(this, destination) || this;
        _this.buffer = [];
        _this.add((0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.innerSubscribe)(closingNotifier, new _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleInnerSubscriber(_this)));
        return _this;
    }
    BufferSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferSubscriber.prototype.notifyNext = function () {
        var buffer = this.buffer;
        this.buffer = [];
        this.destination.next(buffer);
    };
    return BufferSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleOuterSubscriber));
//# sourceMappingURL=buffer.js.map


/***/ }),
/* 293 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bufferCount": () => (/* binding */ bufferCount)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function bufferCount(bufferSize, startBufferEvery) {
    if (startBufferEvery === void 0) {
        startBufferEvery = null;
    }
    return function bufferCountOperatorFunction(source) {
        return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
    };
}
var BufferCountOperator = /*@__PURE__*/ (function () {
    function BufferCountOperator(bufferSize, startBufferEvery) {
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        if (!startBufferEvery || bufferSize === startBufferEvery) {
            this.subscriberClass = BufferCountSubscriber;
        }
        else {
            this.subscriberClass = BufferSkipCountSubscriber;
        }
    }
    BufferCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
    };
    return BufferCountOperator;
}());
var BufferCountSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(BufferCountSubscriber, _super);
    function BufferCountSubscriber(destination, bufferSize) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.buffer = [];
        return _this;
    }
    BufferCountSubscriber.prototype._next = function (value) {
        var buffer = this.buffer;
        buffer.push(value);
        if (buffer.length == this.bufferSize) {
            this.destination.next(buffer);
            this.buffer = [];
        }
    };
    BufferCountSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer.length > 0) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    return BufferCountSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));
var BufferSkipCountSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(BufferSkipCountSubscriber, _super);
    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.startBufferEvery = startBufferEvery;
        _this.buffers = [];
        _this.count = 0;
        return _this;
    }
    BufferSkipCountSubscriber.prototype._next = function (value) {
        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;
        this.count++;
        if (count % startBufferEvery === 0) {
            buffers.push([]);
        }
        for (var i = buffers.length; i--;) {
            var buffer = buffers[i];
            buffer.push(value);
            if (buffer.length === bufferSize) {
                buffers.splice(i, 1);
                this.destination.next(buffer);
            }
        }
    };
    BufferSkipCountSubscriber.prototype._complete = function () {
        var _a = this, buffers = _a.buffers, destination = _a.destination;
        while (buffers.length > 0) {
            var buffer = buffers.shift();
            if (buffer.length > 0) {
                destination.next(buffer);
            }
        }
        _super.prototype._complete.call(this);
    };
    return BufferSkipCountSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));
//# sourceMappingURL=bufferCount.js.map


/***/ }),
/* 294 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bufferTime": () => (/* binding */ bufferTime)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(188);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(214);
/** PURE_IMPORTS_START tslib,_scheduler_async,_Subscriber,_util_isScheduler PURE_IMPORTS_END */




function bufferTime(bufferTimeSpan) {
    var length = arguments.length;
    var scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__.async;
    if ((0,_util_isScheduler__WEBPACK_IMPORTED_MODULE_2__.isScheduler)(arguments[arguments.length - 1])) {
        scheduler = arguments[arguments.length - 1];
        length--;
    }
    var bufferCreationInterval = null;
    if (length >= 2) {
        bufferCreationInterval = arguments[1];
    }
    var maxBufferSize = Number.POSITIVE_INFINITY;
    if (length >= 3) {
        maxBufferSize = arguments[2];
    }
    return function bufferTimeOperatorFunction(source) {
        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
    };
}
var BufferTimeOperator = /*@__PURE__*/ (function () {
    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
    }
    BufferTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
    };
    return BufferTimeOperator;
}());
var Context = /*@__PURE__*/ (function () {
    function Context() {
        this.buffer = [];
    }
    return Context;
}());
var BufferTimeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(BufferTimeSubscriber, _super);
    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.bufferTimeSpan = bufferTimeSpan;
        _this.bufferCreationInterval = bufferCreationInterval;
        _this.maxBufferSize = maxBufferSize;
        _this.scheduler = scheduler;
        _this.contexts = [];
        var context = _this.openContext();
        _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (_this.timespanOnly) {
            var timeSpanOnlyState = { subscriber: _this, context: context, bufferTimeSpan: bufferTimeSpan };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
        else {
            var closeState = { subscriber: _this, context: context };
            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }
        return _this;
    }
    BufferTimeSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        var filledBufferContext;
        for (var i = 0; i < len; i++) {
            var context_1 = contexts[i];
            var buffer = context_1.buffer;
            buffer.push(value);
            if (buffer.length == this.maxBufferSize) {
                filledBufferContext = context_1;
            }
        }
        if (filledBufferContext) {
            this.onBufferFull(filledBufferContext);
        }
    };
    BufferTimeSubscriber.prototype._error = function (err) {
        this.contexts.length = 0;
        _super.prototype._error.call(this, err);
    };
    BufferTimeSubscriber.prototype._complete = function () {
        var _a = this, contexts = _a.contexts, destination = _a.destination;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            destination.next(context_2.buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferTimeSubscriber.prototype._unsubscribe = function () {
        this.contexts = null;
    };
    BufferTimeSubscriber.prototype.onBufferFull = function (context) {
        this.closeContext(context);
        var closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) {
            context = this.openContext();
            var bufferTimeSpan = this.bufferTimeSpan;
            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
    };
    BufferTimeSubscriber.prototype.openContext = function () {
        var context = new Context();
        this.contexts.push(context);
        return context;
    };
    BufferTimeSubscriber.prototype.closeContext = function (context) {
        this.destination.next(context.buffer);
        var contexts = this.contexts;
        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) {
            contexts.splice(contexts.indexOf(context), 1);
        }
    };
    return BufferTimeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_3__.Subscriber));
function dispatchBufferTimeSpanOnly(state) {
    var subscriber = state.subscriber;
    var prevContext = state.context;
    if (prevContext) {
        subscriber.closeContext(prevContext);
    }
    if (!subscriber.closed) {
        state.context = subscriber.openContext();
        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
    }
}
function dispatchBufferCreation(state) {
    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
    var context = subscriber.openContext();
    var action = this;
    if (!subscriber.closed) {
        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));
        action.schedule(state, bufferCreationInterval);
    }
}
function dispatchBufferClose(arg) {
    var subscriber = arg.subscriber, context = arg.context;
    subscriber.closeContext(context);
}
//# sourceMappingURL=bufferTime.js.map


/***/ }),
/* 295 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bufferToggle": () => (/* binding */ bufferToggle)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(194);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(246);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(255);
/** PURE_IMPORTS_START tslib,_Subscription,_util_subscribeToResult,_OuterSubscriber PURE_IMPORTS_END */




function bufferToggle(openings, closingSelector) {
    return function bufferToggleOperatorFunction(source) {
        return source.lift(new BufferToggleOperator(openings, closingSelector));
    };
}
var BufferToggleOperator = /*@__PURE__*/ (function () {
    function BufferToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    BufferToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return BufferToggleOperator;
}());
var BufferToggleSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(BufferToggleSubscriber, _super);
    function BufferToggleSubscriber(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add((0,_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__.subscribeToResult)(_this, openings));
        return _this;
    }
    BufferToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        for (var i = 0; i < len; i++) {
            contexts[i].buffer.push(value);
        }
    };
    BufferToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context_1 = contexts.shift();
            context_1.subscription.unsubscribe();
            context_1.buffer = null;
            context_1.subscription = null;
        }
        this.contexts = null;
        _super.prototype._error.call(this, err);
    };
    BufferToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            this.destination.next(context_2.buffer);
            context_2.subscription.unsubscribe();
            context_2.buffer = null;
            context_2.subscription = null;
        }
        this.contexts = null;
        _super.prototype._complete.call(this);
    };
    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue) {
        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
    };
    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
        this.closeBuffer(innerSub.context);
    };
    BufferToggleSubscriber.prototype.openBuffer = function (value) {
        try {
            var closingSelector = this.closingSelector;
            var closingNotifier = closingSelector.call(this, value);
            if (closingNotifier) {
                this.trySubscribe(closingNotifier);
            }
        }
        catch (err) {
            this._error(err);
        }
    };
    BufferToggleSubscriber.prototype.closeBuffer = function (context) {
        var contexts = this.contexts;
        if (contexts && context) {
            var buffer = context.buffer, subscription = context.subscription;
            this.destination.next(buffer);
            contexts.splice(contexts.indexOf(context), 1);
            this.remove(subscription);
            subscription.unsubscribe();
        }
    };
    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
        var contexts = this.contexts;
        var buffer = [];
        var subscription = new _Subscription__WEBPACK_IMPORTED_MODULE_2__.Subscription();
        var context = { buffer: buffer, subscription: subscription };
        contexts.push(context);
        var innerSubscription = (0,_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__.subscribeToResult)(this, closingNotifier, context);
        if (!innerSubscription || innerSubscription.closed) {
            this.closeBuffer(context);
        }
        else {
            innerSubscription.context = context;
            this.add(innerSubscription);
            subscription.add(innerSubscription);
        }
    };
    return BufferToggleSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__.OuterSubscriber));
//# sourceMappingURL=bufferToggle.js.map


/***/ }),
/* 296 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bufferWhen": () => (/* binding */ bufferWhen)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(194);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(267);
/** PURE_IMPORTS_START tslib,_Subscription,_innerSubscribe PURE_IMPORTS_END */



function bufferWhen(closingSelector) {
    return function (source) {
        return source.lift(new BufferWhenOperator(closingSelector));
    };
}
var BufferWhenOperator = /*@__PURE__*/ (function () {
    function BufferWhenOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    BufferWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
    };
    return BufferWhenOperator;
}());
var BufferWhenSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(BufferWhenSubscriber, _super);
    function BufferWhenSubscriber(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.subscribing = false;
        _this.openBuffer();
        return _this;
    }
    BufferWhenSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferWhenSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferWhenSubscriber.prototype._unsubscribe = function () {
        this.buffer = undefined;
        this.subscribing = false;
    };
    BufferWhenSubscriber.prototype.notifyNext = function () {
        this.openBuffer();
    };
    BufferWhenSubscriber.prototype.notifyComplete = function () {
        if (this.subscribing) {
            this.complete();
        }
        else {
            this.openBuffer();
        }
    };
    BufferWhenSubscriber.prototype.openBuffer = function () {
        var closingSubscription = this.closingSubscription;
        if (closingSubscription) {
            this.remove(closingSubscription);
            closingSubscription.unsubscribe();
        }
        var buffer = this.buffer;
        if (this.buffer) {
            this.destination.next(buffer);
        }
        this.buffer = [];
        var closingNotifier;
        try {
            var closingSelector = this.closingSelector;
            closingNotifier = closingSelector();
        }
        catch (err) {
            return this.error(err);
        }
        closingSubscription = new _Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription();
        this.closingSubscription = closingSubscription;
        this.add(closingSubscription);
        this.subscribing = true;
        closingSubscription.add((0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_2__.innerSubscribe)(closingNotifier, new _innerSubscribe__WEBPACK_IMPORTED_MODULE_2__.SimpleInnerSubscriber(this)));
        this.subscribing = false;
    };
    return BufferWhenSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_2__.SimpleOuterSubscriber));
//# sourceMappingURL=bufferWhen.js.map


/***/ }),
/* 297 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "catchError": () => (/* binding */ catchError)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(267);
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function catchError(selector) {
    return function catchErrorOperatorFunction(source) {
        var operator = new CatchOperator(selector);
        var caught = source.lift(operator);
        return (operator.caught = caught);
    };
}
var CatchOperator = /*@__PURE__*/ (function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}());
var CatchSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        var _this = _super.call(this, destination) || this;
        _this.selector = selector;
        _this.caught = caught;
        return _this;
    }
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            }
            catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            var innerSubscriber = new _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleInnerSubscriber(this);
            this.add(innerSubscriber);
            var innerSubscription = (0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.innerSubscribe)(result, innerSubscriber);
            if (innerSubscription !== innerSubscriber) {
                this.add(innerSubscription);
            }
        }
    };
    return CatchSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleOuterSubscriber));
//# sourceMappingURL=catchError.js.map


/***/ }),
/* 298 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "combineAll": () => (/* binding */ combineAll)
/* harmony export */ });
/* harmony import */ var _observable_combineLatest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(245);
/** PURE_IMPORTS_START _observable_combineLatest PURE_IMPORTS_END */

function combineAll(project) {
    return function (source) { return source.lift(new _observable_combineLatest__WEBPACK_IMPORTED_MODULE_0__.CombineLatestOperator(project)); };
}
//# sourceMappingURL=combineAll.js.map


/***/ }),
/* 299 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "combineLatest": () => (/* binding */ combineLatest)
/* harmony export */ });
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(197);
/* harmony import */ var _observable_combineLatest__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(245);
/* harmony import */ var _observable_from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(260);
/** PURE_IMPORTS_START _util_isArray,_observable_combineLatest,_observable_from PURE_IMPORTS_END */



var none = {};
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var project = null;
    if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
    }
    if (observables.length === 1 && (0,_util_isArray__WEBPACK_IMPORTED_MODULE_0__.isArray)(observables[0])) {
        observables = observables[0].slice();
    }
    return function (source) { return source.lift.call((0,_observable_from__WEBPACK_IMPORTED_MODULE_1__.from)([source].concat(observables)), new _observable_combineLatest__WEBPACK_IMPORTED_MODULE_2__.CombineLatestOperator(project)); };
}
//# sourceMappingURL=combineLatest.js.map


/***/ }),
/* 300 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "concat": () => (/* binding */ concat)
/* harmony export */ });
/* harmony import */ var _observable_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(256);
/** PURE_IMPORTS_START _observable_concat PURE_IMPORTS_END */

function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function (source) { return source.lift.call(_observable_concat__WEBPACK_IMPORTED_MODULE_0__.concat.apply(void 0, [source].concat(observables))); };
}
//# sourceMappingURL=concat.js.map


/***/ }),
/* 301 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "concatMap": () => (/* binding */ concatMap)
/* harmony export */ });
/* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(259);
/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */

function concatMap(project, resultSelector) {
    return (0,_mergeMap__WEBPACK_IMPORTED_MODULE_0__.mergeMap)(project, resultSelector, 1);
}
//# sourceMappingURL=concatMap.js.map


/***/ }),
/* 302 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "concatMapTo": () => (/* binding */ concatMapTo)
/* harmony export */ });
/* harmony import */ var _concatMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(301);
/** PURE_IMPORTS_START _concatMap PURE_IMPORTS_END */

function concatMapTo(innerObservable, resultSelector) {
    return (0,_concatMap__WEBPACK_IMPORTED_MODULE_0__.concatMap)(function () { return innerObservable; }, resultSelector);
}
//# sourceMappingURL=concatMapTo.js.map


/***/ }),
/* 303 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "count": () => (/* binding */ count)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function count(predicate) {
    return function (source) { return source.lift(new CountOperator(predicate, source)); };
}
var CountOperator = /*@__PURE__*/ (function () {
    function CountOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    CountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
    };
    return CountOperator;
}());
var CountSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(CountSubscriber, _super);
    function CountSubscriber(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.count = 0;
        _this.index = 0;
        return _this;
    }
    CountSubscriber.prototype._next = function (value) {
        if (this.predicate) {
            this._tryPredicate(value);
        }
        else {
            this.count++;
        }
    };
    CountSubscriber.prototype._tryPredicate = function (value) {
        var result;
        try {
            result = this.predicate(value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.count++;
        }
    };
    CountSubscriber.prototype._complete = function () {
        this.destination.next(this.count);
        this.destination.complete();
    };
    return CountSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));
//# sourceMappingURL=count.js.map


/***/ }),
/* 304 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "debounce": () => (/* binding */ debounce)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(267);
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function debounce(durationSelector) {
    return function (source) { return source.lift(new DebounceOperator(durationSelector)); };
}
var DebounceOperator = /*@__PURE__*/ (function () {
    function DebounceOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    DebounceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
    };
    return DebounceOperator;
}());
var DebounceSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(DebounceSubscriber, _super);
    function DebounceSubscriber(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
    }
    DebounceSubscriber.prototype._next = function (value) {
        try {
            var result = this.durationSelector.call(this, value);
            if (result) {
                this._tryNext(value, result);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DebounceSubscriber.prototype._complete = function () {
        this.emitValue();
        this.destination.complete();
    };
    DebounceSubscriber.prototype._tryNext = function (value, duration) {
        var subscription = this.durationSubscription;
        this.value = value;
        this.hasValue = true;
        if (subscription) {
            subscription.unsubscribe();
            this.remove(subscription);
        }
        subscription = (0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.innerSubscribe)(duration, new _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleInnerSubscriber(this));
        if (subscription && !subscription.closed) {
            this.add(this.durationSubscription = subscription);
        }
    };
    DebounceSubscriber.prototype.notifyNext = function () {
        this.emitValue();
    };
    DebounceSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    DebounceSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            var value = this.value;
            var subscription = this.durationSubscription;
            if (subscription) {
                this.durationSubscription = undefined;
                subscription.unsubscribe();
                this.remove(subscription);
            }
            this.value = undefined;
            this.hasValue = false;
            _super.prototype._next.call(this, value);
        }
    };
    return DebounceSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleOuterSubscriber));
//# sourceMappingURL=debounce.js.map


/***/ }),
/* 305 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "debounceTime": () => (/* binding */ debounceTime)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(188);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */



function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__.async;
    }
    return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };
}
var DebounceTimeOperator = /*@__PURE__*/ (function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}());
var DebounceTimeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.dueTime = dueTime;
        _this.scheduler = scheduler;
        _this.debouncedSubscription = null;
        _this.lastValue = null;
        _this.hasValue = false;
        return _this;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            var lastValue = this.lastValue;
            this.lastValue = null;
            this.hasValue = false;
            this.destination.next(lastValue);
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_2__.Subscriber));
function dispatchNext(subscriber) {
    subscriber.debouncedNext();
}
//# sourceMappingURL=debounceTime.js.map


/***/ }),
/* 306 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultIfEmpty": () => (/* binding */ defaultIfEmpty)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function defaultIfEmpty(defaultValue) {
    if (defaultValue === void 0) {
        defaultValue = null;
    }
    return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };
}
var DefaultIfEmptyOperator = /*@__PURE__*/ (function () {
    function DefaultIfEmptyOperator(defaultValue) {
        this.defaultValue = defaultValue;
    }
    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
    };
    return DefaultIfEmptyOperator;
}());
var DefaultIfEmptySubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(DefaultIfEmptySubscriber, _super);
    function DefaultIfEmptySubscriber(destination, defaultValue) {
        var _this = _super.call(this, destination) || this;
        _this.defaultValue = defaultValue;
        _this.isEmpty = true;
        return _this;
    }
    DefaultIfEmptySubscriber.prototype._next = function (value) {
        this.isEmpty = false;
        this.destination.next(value);
    };
    DefaultIfEmptySubscriber.prototype._complete = function () {
        if (this.isEmpty) {
            this.destination.next(this.defaultValue);
        }
        this.destination.complete();
    };
    return DefaultIfEmptySubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));
//# sourceMappingURL=defaultIfEmpty.js.map


/***/ }),
/* 307 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "delay": () => (/* binding */ delay)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var _util_isDate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(308);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(188);
/* harmony import */ var _Notification__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(212);
/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_Subscriber,_Notification PURE_IMPORTS_END */





function delay(delay, scheduler) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__.async;
    }
    var absoluteDelay = (0,_util_isDate__WEBPACK_IMPORTED_MODULE_2__.isDate)(delay);
    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
    return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };
}
var DelayOperator = /*@__PURE__*/ (function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
}());
var DelaySubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.delay = delay;
        _this.scheduler = scheduler;
        _this.queue = [];
        _this.active = false;
        _this.errored = false;
        return _this;
    }
    DelaySubscriber.dispatch = function (state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay_1);
        }
        else {
            this.unsubscribe();
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        var destination = this.destination;
        destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(_Notification__WEBPACK_IMPORTED_MODULE_3__.Notification.createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
        this.unsubscribe();
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(_Notification__WEBPACK_IMPORTED_MODULE_3__.Notification.createComplete());
        this.unsubscribe();
    };
    return DelaySubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_4__.Subscriber));
var DelayMessage = /*@__PURE__*/ (function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}());
//# sourceMappingURL=delay.js.map


/***/ }),
/* 308 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isDate": () => (/* binding */ isDate)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}
//# sourceMappingURL=isDate.js.map


/***/ }),
/* 309 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "delayWhen": () => (/* binding */ delayWhen)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(188);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(186);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(255);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(246);
/** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */





function delayWhen(delayDurationSelector, subscriptionDelay) {
    if (subscriptionDelay) {
        return function (source) {
            return new SubscriptionDelayObservable(source, subscriptionDelay)
                .lift(new DelayWhenOperator(delayDurationSelector));
        };
    }
    return function (source) { return source.lift(new DelayWhenOperator(delayDurationSelector)); };
}
var DelayWhenOperator = /*@__PURE__*/ (function () {
    function DelayWhenOperator(delayDurationSelector) {
        this.delayDurationSelector = delayDurationSelector;
    }
    DelayWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
    };
    return DelayWhenOperator;
}());
var DelayWhenSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(DelayWhenSubscriber, _super);
    function DelayWhenSubscriber(destination, delayDurationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.delayDurationSelector = delayDurationSelector;
        _this.completed = false;
        _this.delayNotifierSubscriptions = [];
        _this.index = 0;
        return _this;
    }
    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
        this.destination.next(outerValue);
        this.removeSubscription(innerSub);
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        var value = this.removeSubscription(innerSub);
        if (value) {
            this.destination.next(value);
        }
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype._next = function (value) {
        var index = this.index++;
        try {
            var delayNotifier = this.delayDurationSelector(value, index);
            if (delayNotifier) {
                this.tryDelay(delayNotifier, value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DelayWhenSubscriber.prototype._complete = function () {
        this.completed = true;
        this.tryComplete();
        this.unsubscribe();
    };
    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
        subscription.unsubscribe();
        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
        if (subscriptionIdx !== -1) {
            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
        }
        return subscription.outerValue;
    };
    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
        var notifierSubscription = (0,_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__.subscribeToResult)(this, delayNotifier, value);
        if (notifierSubscription && !notifierSubscription.closed) {
            var destination = this.destination;
            destination.add(notifierSubscription);
            this.delayNotifierSubscriptions.push(notifierSubscription);
        }
    };
    DelayWhenSubscriber.prototype.tryComplete = function () {
        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
            this.destination.complete();
        }
    };
    return DelayWhenSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__.OuterSubscriber));
var SubscriptionDelayObservable = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(SubscriptionDelayObservable, _super);
    function SubscriptionDelayObservable(source, subscriptionDelay) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subscriptionDelay = subscriptionDelay;
        return _this;
    }
    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
    };
    return SubscriptionDelayObservable;
}(_Observable__WEBPACK_IMPORTED_MODULE_3__.Observable));
var SubscriptionDelaySubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(SubscriptionDelaySubscriber, _super);
    function SubscriptionDelaySubscriber(parent, source) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.source = source;
        _this.sourceSubscribed = false;
        return _this;
    }
    SubscriptionDelaySubscriber.prototype._next = function (unused) {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype._error = function (err) {
        this.unsubscribe();
        this.parent.error(err);
    };
    SubscriptionDelaySubscriber.prototype._complete = function () {
        this.unsubscribe();
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
        if (!this.sourceSubscribed) {
            this.sourceSubscribed = true;
            this.unsubscribe();
            this.source.subscribe(this.parent);
        }
    };
    return SubscriptionDelaySubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_4__.Subscriber));
//# sourceMappingURL=delayWhen.js.map


/***/ }),
/* 310 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dematerialize": () => (/* binding */ dematerialize)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function dematerialize() {
    return function dematerializeOperatorFunction(source) {
        return source.lift(new DeMaterializeOperator());
    };
}
var DeMaterializeOperator = /*@__PURE__*/ (function () {
    function DeMaterializeOperator() {
    }
    DeMaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DeMaterializeSubscriber(subscriber));
    };
    return DeMaterializeOperator;
}());
var DeMaterializeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(DeMaterializeSubscriber, _super);
    function DeMaterializeSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    DeMaterializeSubscriber.prototype._next = function (value) {
        value.observe(this.destination);
    };
    return DeMaterializeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));
//# sourceMappingURL=dematerialize.js.map


/***/ }),
/* 311 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "distinct": () => (/* binding */ distinct),
/* harmony export */   "DistinctSubscriber": () => (/* binding */ DistinctSubscriber)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(267);
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function distinct(keySelector, flushes) {
    return function (source) { return source.lift(new DistinctOperator(keySelector, flushes)); };
}
var DistinctOperator = /*@__PURE__*/ (function () {
    function DistinctOperator(keySelector, flushes) {
        this.keySelector = keySelector;
        this.flushes = flushes;
    }
    DistinctOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
    };
    return DistinctOperator;
}());
var DistinctSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(DistinctSubscriber, _super);
    function DistinctSubscriber(destination, keySelector, flushes) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.values = new Set();
        if (flushes) {
            _this.add((0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.innerSubscribe)(flushes, new _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleInnerSubscriber(_this)));
        }
        return _this;
    }
    DistinctSubscriber.prototype.notifyNext = function () {
        this.values.clear();
    };
    DistinctSubscriber.prototype.notifyError = function (error) {
        this._error(error);
    };
    DistinctSubscriber.prototype._next = function (value) {
        if (this.keySelector) {
            this._useKeySelector(value);
        }
        else {
            this._finalizeNext(value, value);
        }
    };
    DistinctSubscriber.prototype._useKeySelector = function (value) {
        var key;
        var destination = this.destination;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this._finalizeNext(key, value);
    };
    DistinctSubscriber.prototype._finalizeNext = function (key, value) {
        var values = this.values;
        if (!values.has(key)) {
            values.add(key);
            this.destination.next(value);
        }
    };
    return DistinctSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleOuterSubscriber));

//# sourceMappingURL=distinct.js.map


/***/ }),
/* 312 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "distinctUntilChanged": () => (/* binding */ distinctUntilChanged)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function distinctUntilChanged(compare, keySelector) {
    return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };
}
var DistinctUntilChangedOperator = /*@__PURE__*/ (function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}());
var DistinctUntilChangedSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.hasKey = false;
        if (typeof compare === 'function') {
            _this.compare = compare;
        }
        return _this;
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var key;
        try {
            var keySelector = this.keySelector;
            key = keySelector ? keySelector(value) : value;
        }
        catch (err) {
            return this.destination.error(err);
        }
        var result = false;
        if (this.hasKey) {
            try {
                var compare = this.compare;
                result = compare(this.key, key);
            }
            catch (err) {
                return this.destination.error(err);
            }
        }
        else {
            this.hasKey = true;
        }
        if (!result) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));
//# sourceMappingURL=distinctUntilChanged.js.map


/***/ }),
/* 313 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "distinctUntilKeyChanged": () => (/* binding */ distinctUntilKeyChanged)
/* harmony export */ });
/* harmony import */ var _distinctUntilChanged__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(312);
/** PURE_IMPORTS_START _distinctUntilChanged PURE_IMPORTS_END */

function distinctUntilKeyChanged(key, compare) {
    return (0,_distinctUntilChanged__WEBPACK_IMPORTED_MODULE_0__.distinctUntilChanged)(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });
}
//# sourceMappingURL=distinctUntilKeyChanged.js.map


/***/ }),
/* 314 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "elementAt": () => (/* binding */ elementAt)
/* harmony export */ });
/* harmony import */ var _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(239);
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(281);
/* harmony import */ var _throwIfEmpty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(316);
/* harmony import */ var _defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(306);
/* harmony import */ var _take__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(315);
/** PURE_IMPORTS_START _util_ArgumentOutOfRangeError,_filter,_throwIfEmpty,_defaultIfEmpty,_take PURE_IMPORTS_END */





function elementAt(index, defaultValue) {
    if (index < 0) {
        throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_0__.ArgumentOutOfRangeError();
    }
    var hasDefaultValue = arguments.length >= 2;
    return function (source) {
        return source.pipe((0,_filter__WEBPACK_IMPORTED_MODULE_1__.filter)(function (v, i) { return i === index; }), (0,_take__WEBPACK_IMPORTED_MODULE_2__.take)(1), hasDefaultValue
            ? (0,_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__.defaultIfEmpty)(defaultValue)
            : (0,_throwIfEmpty__WEBPACK_IMPORTED_MODULE_4__.throwIfEmpty)(function () { return new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_0__.ArgumentOutOfRangeError(); }));
    };
}
//# sourceMappingURL=elementAt.js.map


/***/ }),
/* 315 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "take": () => (/* binding */ take)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(188);
/* harmony import */ var _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(239);
/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(219);
/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */




function take(count) {
    return function (source) {
        if (count === 0) {
            return (0,_observable_empty__WEBPACK_IMPORTED_MODULE_1__.empty)();
        }
        else {
            return source.lift(new TakeOperator(count));
        }
    };
}
var TakeOperator = /*@__PURE__*/ (function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__.ArgumentOutOfRangeError;
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}());
var TakeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_3__.Subscriber));
//# sourceMappingURL=take.js.map


/***/ }),
/* 316 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "throwIfEmpty": () => (/* binding */ throwIfEmpty)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _util_EmptyError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(240);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/** PURE_IMPORTS_START tslib,_util_EmptyError,_Subscriber PURE_IMPORTS_END */



function throwIfEmpty(errorFactory) {
    if (errorFactory === void 0) {
        errorFactory = defaultErrorFactory;
    }
    return function (source) {
        return source.lift(new ThrowIfEmptyOperator(errorFactory));
    };
}
var ThrowIfEmptyOperator = /*@__PURE__*/ (function () {
    function ThrowIfEmptyOperator(errorFactory) {
        this.errorFactory = errorFactory;
    }
    ThrowIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
    };
    return ThrowIfEmptyOperator;
}());
var ThrowIfEmptySubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(ThrowIfEmptySubscriber, _super);
    function ThrowIfEmptySubscriber(destination, errorFactory) {
        var _this = _super.call(this, destination) || this;
        _this.errorFactory = errorFactory;
        _this.hasValue = false;
        return _this;
    }
    ThrowIfEmptySubscriber.prototype._next = function (value) {
        this.hasValue = true;
        this.destination.next(value);
    };
    ThrowIfEmptySubscriber.prototype._complete = function () {
        if (!this.hasValue) {
            var err = void 0;
            try {
                err = this.errorFactory();
            }
            catch (e) {
                err = e;
            }
            this.destination.error(err);
        }
        else {
            return this.destination.complete();
        }
    };
    return ThrowIfEmptySubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));
function defaultErrorFactory() {
    return new _util_EmptyError__WEBPACK_IMPORTED_MODULE_2__.EmptyError();
}
//# sourceMappingURL=throwIfEmpty.js.map


/***/ }),
/* 317 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "endWith": () => (/* binding */ endWith)
/* harmony export */ });
/* harmony import */ var _observable_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(256);
/* harmony import */ var _observable_of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(213);
/** PURE_IMPORTS_START _observable_concat,_observable_of PURE_IMPORTS_END */


function endWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i] = arguments[_i];
    }
    return function (source) { return (0,_observable_concat__WEBPACK_IMPORTED_MODULE_0__.concat)(source, _observable_of__WEBPACK_IMPORTED_MODULE_1__.of.apply(void 0, array)); };
}
//# sourceMappingURL=endWith.js.map


/***/ }),
/* 318 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "every": () => (/* binding */ every)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function every(predicate, thisArg) {
    return function (source) { return source.lift(new EveryOperator(predicate, thisArg, source)); };
}
var EveryOperator = /*@__PURE__*/ (function () {
    function EveryOperator(predicate, thisArg, source) {
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
    }
    EveryOperator.prototype.call = function (observer, source) {
        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
    };
    return EveryOperator;
}());
var EverySubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(EverySubscriber, _super);
    function EverySubscriber(destination, predicate, thisArg, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.source = source;
        _this.index = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
        this.destination.next(everyValueMatch);
        this.destination.complete();
    };
    EverySubscriber.prototype._next = function (value) {
        var result = false;
        try {
            result = this.predicate.call(this.thisArg, value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (!result) {
            this.notifyComplete(false);
        }
    };
    EverySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return EverySubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));
//# sourceMappingURL=every.js.map


/***/ }),
/* 319 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "exhaust": () => (/* binding */ exhaust)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(267);
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function exhaust() {
    return function (source) { return source.lift(new SwitchFirstOperator()); };
}
var SwitchFirstOperator = /*@__PURE__*/ (function () {
    function SwitchFirstOperator() {
    }
    SwitchFirstOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchFirstSubscriber(subscriber));
    };
    return SwitchFirstOperator;
}());
var SwitchFirstSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(SwitchFirstSubscriber, _super);
    function SwitchFirstSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasCompleted = false;
        _this.hasSubscription = false;
        return _this;
    }
    SwitchFirstSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.hasSubscription = true;
            this.add((0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.innerSubscribe)(value, new _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleInnerSubscriber(this)));
        }
    };
    SwitchFirstSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstSubscriber.prototype.notifyComplete = function () {
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleOuterSubscriber));
//# sourceMappingURL=exhaust.js.map


/***/ }),
/* 320 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "exhaustMap": () => (/* binding */ exhaustMap)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(243);
/* harmony import */ var _observable_from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(260);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(267);
/** PURE_IMPORTS_START tslib,_map,_observable_from,_innerSubscribe PURE_IMPORTS_END */




function exhaustMap(project, resultSelector) {
    if (resultSelector) {
        return function (source) { return source.pipe(exhaustMap(function (a, i) { return (0,_observable_from__WEBPACK_IMPORTED_MODULE_1__.from)(project(a, i)).pipe((0,_map__WEBPACK_IMPORTED_MODULE_2__.map)(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
    }
    return function (source) {
        return source.lift(new ExhaustMapOperator(project));
    };
}
var ExhaustMapOperator = /*@__PURE__*/ (function () {
    function ExhaustMapOperator(project) {
        this.project = project;
    }
    ExhaustMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
    };
    return ExhaustMapOperator;
}());
var ExhaustMapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(ExhaustMapSubscriber, _super);
    function ExhaustMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.hasSubscription = false;
        _this.hasCompleted = false;
        _this.index = 0;
        return _this;
    }
    ExhaustMapSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.tryNext(value);
        }
    };
    ExhaustMapSubscriber.prototype.tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.hasSubscription = true;
        this._innerSub(result);
    };
    ExhaustMapSubscriber.prototype._innerSub = function (result) {
        var innerSubscriber = new _innerSubscribe__WEBPACK_IMPORTED_MODULE_3__.SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = (0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_3__.innerSubscribe)(result, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
        }
    };
    ExhaustMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    ExhaustMapSubscriber.prototype.notifyNext = function (innerValue) {
        this.destination.next(innerValue);
    };
    ExhaustMapSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    ExhaustMapSubscriber.prototype.notifyComplete = function () {
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return ExhaustMapSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_3__.SimpleOuterSubscriber));
//# sourceMappingURL=exhaustMap.js.map


/***/ }),
/* 321 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "expand": () => (/* binding */ expand),
/* harmony export */   "ExpandOperator": () => (/* binding */ ExpandOperator),
/* harmony export */   "ExpandSubscriber": () => (/* binding */ ExpandSubscriber)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(267);
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function expand(project, concurrent, scheduler) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
    return function (source) { return source.lift(new ExpandOperator(project, concurrent, scheduler)); };
}
var ExpandOperator = /*@__PURE__*/ (function () {
    function ExpandOperator(project, concurrent, scheduler) {
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
    }
    ExpandOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
    };
    return ExpandOperator;
}());

var ExpandSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(ExpandSubscriber, _super);
    function ExpandSubscriber(destination, project, concurrent, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.scheduler = scheduler;
        _this.index = 0;
        _this.active = 0;
        _this.hasCompleted = false;
        if (concurrent < Number.POSITIVE_INFINITY) {
            _this.buffer = [];
        }
        return _this;
    }
    ExpandSubscriber.dispatch = function (arg) {
        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
        subscriber.subscribeToProjection(result, value, index);
    };
    ExpandSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (destination.closed) {
            this._complete();
            return;
        }
        var index = this.index++;
        if (this.active < this.concurrent) {
            destination.next(value);
            try {
                var project = this.project;
                var result = project(value, index);
                if (!this.scheduler) {
                    this.subscribeToProjection(result, value, index);
                }
                else {
                    var state = { subscriber: this, result: result, value: value, index: index };
                    var destination_1 = this.destination;
                    destination_1.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
                }
            }
            catch (e) {
                destination.error(e);
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
        this.active++;
        var destination = this.destination;
        destination.add((0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.innerSubscribe)(result, new _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleInnerSubscriber(this)));
    };
    ExpandSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    ExpandSubscriber.prototype.notifyNext = function (innerValue) {
        this._next(innerValue);
    };
    ExpandSubscriber.prototype.notifyComplete = function () {
        var buffer = this.buffer;
        this.active--;
        if (buffer && buffer.length > 0) {
            this._next(buffer.shift());
        }
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    return ExpandSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleOuterSubscriber));

//# sourceMappingURL=expand.js.map


/***/ }),
/* 322 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "finalize": () => (/* binding */ finalize)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(188);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(194);
/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */



function finalize(callback) {
    return function (source) { return source.lift(new FinallyOperator(callback)); };
}
var FinallyOperator = /*@__PURE__*/ (function () {
    function FinallyOperator(callback) {
        this.callback = callback;
    }
    FinallyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator;
}());
var FinallySubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        var _this = _super.call(this, destination) || this;
        _this.add(new _Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription(callback));
        return _this;
    }
    return FinallySubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_2__.Subscriber));
//# sourceMappingURL=finalize.js.map


/***/ }),
/* 323 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "find": () => (/* binding */ find),
/* harmony export */   "FindValueOperator": () => (/* binding */ FindValueOperator),
/* harmony export */   "FindValueSubscriber": () => (/* binding */ FindValueSubscriber)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function find(predicate, thisArg) {
    if (typeof predicate !== 'function') {
        throw new TypeError('predicate is not a function');
    }
    return function (source) { return source.lift(new FindValueOperator(predicate, source, false, thisArg)); };
}
var FindValueOperator = /*@__PURE__*/ (function () {
    function FindValueOperator(predicate, source, yieldIndex, thisArg) {
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
    }
    FindValueOperator.prototype.call = function (observer, source) {
        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
    };
    return FindValueOperator;
}());

var FindValueSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(FindValueSubscriber, _super);
    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.yieldIndex = yieldIndex;
        _this.thisArg = thisArg;
        _this.index = 0;
        return _this;
    }
    FindValueSubscriber.prototype.notifyComplete = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
        this.unsubscribe();
    };
    FindValueSubscriber.prototype._next = function (value) {
        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
        var index = this.index++;
        try {
            var result = predicate.call(thisArg || this, value, index, this.source);
            if (result) {
                this.notifyComplete(this.yieldIndex ? index : value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    FindValueSubscriber.prototype._complete = function () {
        this.notifyComplete(this.yieldIndex ? -1 : undefined);
    };
    return FindValueSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));

//# sourceMappingURL=find.js.map


/***/ }),
/* 324 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "findIndex": () => (/* binding */ findIndex)
/* harmony export */ });
/* harmony import */ var _operators_find__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(323);
/** PURE_IMPORTS_START _operators_find PURE_IMPORTS_END */

function findIndex(predicate, thisArg) {
    return function (source) { return source.lift(new _operators_find__WEBPACK_IMPORTED_MODULE_0__.FindValueOperator(predicate, source, true, thisArg)); };
}
//# sourceMappingURL=findIndex.js.map


/***/ }),
/* 325 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "first": () => (/* binding */ first)
/* harmony export */ });
/* harmony import */ var _util_EmptyError__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(240);
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(281);
/* harmony import */ var _take__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(315);
/* harmony import */ var _defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(306);
/* harmony import */ var _throwIfEmpty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(316);
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(202);
/** PURE_IMPORTS_START _util_EmptyError,_filter,_take,_defaultIfEmpty,_throwIfEmpty,_util_identity PURE_IMPORTS_END */






function first(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(predicate ? (0,_filter__WEBPACK_IMPORTED_MODULE_0__.filter)(function (v, i) { return predicate(v, i, source); }) : _util_identity__WEBPACK_IMPORTED_MODULE_1__.identity, (0,_take__WEBPACK_IMPORTED_MODULE_2__.take)(1), hasDefaultValue ? (0,_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__.defaultIfEmpty)(defaultValue) : (0,_throwIfEmpty__WEBPACK_IMPORTED_MODULE_4__.throwIfEmpty)(function () { return new _util_EmptyError__WEBPACK_IMPORTED_MODULE_5__.EmptyError(); })); };
}
//# sourceMappingURL=first.js.map


/***/ }),
/* 326 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ignoreElements": () => (/* binding */ ignoreElements)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function ignoreElements() {
    return function ignoreElementsOperatorFunction(source) {
        return source.lift(new IgnoreElementsOperator());
    };
}
var IgnoreElementsOperator = /*@__PURE__*/ (function () {
    function IgnoreElementsOperator() {
    }
    IgnoreElementsOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
    };
    return IgnoreElementsOperator;
}());
var IgnoreElementsSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(IgnoreElementsSubscriber, _super);
    function IgnoreElementsSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IgnoreElementsSubscriber.prototype._next = function (unused) {
    };
    return IgnoreElementsSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));
//# sourceMappingURL=ignoreElements.js.map


/***/ }),
/* 327 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isEmpty": () => (/* binding */ isEmpty)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function isEmpty() {
    return function (source) { return source.lift(new IsEmptyOperator()); };
}
var IsEmptyOperator = /*@__PURE__*/ (function () {
    function IsEmptyOperator() {
    }
    IsEmptyOperator.prototype.call = function (observer, source) {
        return source.subscribe(new IsEmptySubscriber(observer));
    };
    return IsEmptyOperator;
}());
var IsEmptySubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(IsEmptySubscriber, _super);
    function IsEmptySubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
        var destination = this.destination;
        destination.next(isEmpty);
        destination.complete();
    };
    IsEmptySubscriber.prototype._next = function (value) {
        this.notifyComplete(false);
    };
    IsEmptySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return IsEmptySubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));
//# sourceMappingURL=isEmpty.js.map


/***/ }),
/* 328 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "last": () => (/* binding */ last)
/* harmony export */ });
/* harmony import */ var _util_EmptyError__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(240);
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(281);
/* harmony import */ var _takeLast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(329);
/* harmony import */ var _throwIfEmpty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(316);
/* harmony import */ var _defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(306);
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(202);
/** PURE_IMPORTS_START _util_EmptyError,_filter,_takeLast,_throwIfEmpty,_defaultIfEmpty,_util_identity PURE_IMPORTS_END */






function last(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(predicate ? (0,_filter__WEBPACK_IMPORTED_MODULE_0__.filter)(function (v, i) { return predicate(v, i, source); }) : _util_identity__WEBPACK_IMPORTED_MODULE_1__.identity, (0,_takeLast__WEBPACK_IMPORTED_MODULE_2__.takeLast)(1), hasDefaultValue ? (0,_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__.defaultIfEmpty)(defaultValue) : (0,_throwIfEmpty__WEBPACK_IMPORTED_MODULE_4__.throwIfEmpty)(function () { return new _util_EmptyError__WEBPACK_IMPORTED_MODULE_5__.EmptyError(); })); };
}
//# sourceMappingURL=last.js.map


/***/ }),
/* 329 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "takeLast": () => (/* binding */ takeLast)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(188);
/* harmony import */ var _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(239);
/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(219);
/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */




function takeLast(count) {
    return function takeLastOperatorFunction(source) {
        if (count === 0) {
            return (0,_observable_empty__WEBPACK_IMPORTED_MODULE_1__.empty)();
        }
        else {
            return source.lift(new TakeLastOperator(count));
        }
    };
}
var TakeLastOperator = /*@__PURE__*/ (function () {
    function TakeLastOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__.ArgumentOutOfRangeError;
        }
    }
    TakeLastOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
    };
    return TakeLastOperator;
}());
var TakeLastSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(TakeLastSubscriber, _super);
    function TakeLastSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.ring = new Array();
        _this.count = 0;
        return _this;
    }
    TakeLastSubscriber.prototype._next = function (value) {
        var ring = this.ring;
        var total = this.total;
        var count = this.count++;
        if (ring.length < total) {
            ring.push(value);
        }
        else {
            var index = count % total;
            ring[index] = value;
        }
    };
    TakeLastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var count = this.count;
        if (count > 0) {
            var total = this.count >= this.total ? this.total : this.count;
            var ring = this.ring;
            for (var i = 0; i < total; i++) {
                var idx = (count++) % total;
                destination.next(ring[idx]);
            }
        }
        destination.complete();
    };
    return TakeLastSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_3__.Subscriber));
//# sourceMappingURL=takeLast.js.map


/***/ }),
/* 330 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mapTo": () => (/* binding */ mapTo)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function mapTo(value) {
    return function (source) { return source.lift(new MapToOperator(value)); };
}
var MapToOperator = /*@__PURE__*/ (function () {
    function MapToOperator(value) {
        this.value = value;
    }
    MapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
    };
    return MapToOperator;
}());
var MapToSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(MapToSubscriber, _super);
    function MapToSubscriber(destination, value) {
        var _this = _super.call(this, destination) || this;
        _this.value = value;
        return _this;
    }
    MapToSubscriber.prototype._next = function (x) {
        this.destination.next(this.value);
    };
    return MapToSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));
//# sourceMappingURL=mapTo.js.map


/***/ }),
/* 331 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "materialize": () => (/* binding */ materialize)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(188);
/* harmony import */ var _Notification__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(212);
/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */



function materialize() {
    return function materializeOperatorFunction(source) {
        return source.lift(new MaterializeOperator());
    };
}
var MaterializeOperator = /*@__PURE__*/ (function () {
    function MaterializeOperator() {
    }
    MaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MaterializeSubscriber(subscriber));
    };
    return MaterializeOperator;
}());
var MaterializeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(MaterializeSubscriber, _super);
    function MaterializeSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    MaterializeSubscriber.prototype._next = function (value) {
        this.destination.next(_Notification__WEBPACK_IMPORTED_MODULE_1__.Notification.createNext(value));
    };
    MaterializeSubscriber.prototype._error = function (err) {
        var destination = this.destination;
        destination.next(_Notification__WEBPACK_IMPORTED_MODULE_1__.Notification.createError(err));
        destination.complete();
    };
    MaterializeSubscriber.prototype._complete = function () {
        var destination = this.destination;
        destination.next(_Notification__WEBPACK_IMPORTED_MODULE_1__.Notification.createComplete());
        destination.complete();
    };
    return MaterializeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_2__.Subscriber));
//# sourceMappingURL=materialize.js.map


/***/ }),
/* 332 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "max": () => (/* binding */ max)
/* harmony export */ });
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(333);
/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

function max(comparer) {
    var max = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) > 0 ? x : y; }
        : function (x, y) { return x > y ? x : y; };
    return (0,_reduce__WEBPACK_IMPORTED_MODULE_0__.reduce)(max);
}
//# sourceMappingURL=max.js.map


/***/ }),
/* 333 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "reduce": () => (/* binding */ reduce)
/* harmony export */ });
/* harmony import */ var _scan__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(334);
/* harmony import */ var _takeLast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(329);
/* harmony import */ var _defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(306);
/* harmony import */ var _util_pipe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(201);
/** PURE_IMPORTS_START _scan,_takeLast,_defaultIfEmpty,_util_pipe PURE_IMPORTS_END */




function reduce(accumulator, seed) {
    if (arguments.length >= 2) {
        return function reduceOperatorFunctionWithSeed(source) {
            return (0,_util_pipe__WEBPACK_IMPORTED_MODULE_0__.pipe)((0,_scan__WEBPACK_IMPORTED_MODULE_1__.scan)(accumulator, seed), (0,_takeLast__WEBPACK_IMPORTED_MODULE_2__.takeLast)(1), (0,_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__.defaultIfEmpty)(seed))(source);
        };
    }
    return function reduceOperatorFunction(source) {
        return (0,_util_pipe__WEBPACK_IMPORTED_MODULE_0__.pipe)((0,_scan__WEBPACK_IMPORTED_MODULE_1__.scan)(function (acc, value, index) { return accumulator(acc, value, index + 1); }), (0,_takeLast__WEBPACK_IMPORTED_MODULE_2__.takeLast)(1))(source);
    };
}
//# sourceMappingURL=reduce.js.map


/***/ }),
/* 334 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "scan": () => (/* binding */ scan)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function scan(accumulator, seed) {
    var hasSeed = false;
    if (arguments.length >= 2) {
        hasSeed = true;
    }
    return function scanOperatorFunction(source) {
        return source.lift(new ScanOperator(accumulator, seed, hasSeed));
    };
}
var ScanOperator = /*@__PURE__*/ (function () {
    function ScanOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) {
            hasSeed = false;
        }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator;
}());
var ScanSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this._seed = _seed;
        _this.hasSeed = hasSeed;
        _this.index = 0;
        return _this;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        }
        else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        }
        catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));
//# sourceMappingURL=scan.js.map


/***/ }),
/* 335 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "merge": () => (/* binding */ merge)
/* harmony export */ });
/* harmony import */ var _observable_merge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(276);
/** PURE_IMPORTS_START _observable_merge PURE_IMPORTS_END */

function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function (source) { return source.lift.call(_observable_merge__WEBPACK_IMPORTED_MODULE_0__.merge.apply(void 0, [source].concat(observables))); };
}
//# sourceMappingURL=merge.js.map


/***/ }),
/* 336 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mergeMapTo": () => (/* binding */ mergeMapTo)
/* harmony export */ });
/* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(259);
/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */

function mergeMapTo(innerObservable, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'function') {
        return (0,_mergeMap__WEBPACK_IMPORTED_MODULE_0__.mergeMap)(function () { return innerObservable; }, resultSelector, concurrent);
    }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return (0,_mergeMap__WEBPACK_IMPORTED_MODULE_0__.mergeMap)(function () { return innerObservable; }, concurrent);
}
//# sourceMappingURL=mergeMapTo.js.map


/***/ }),
/* 337 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mergeScan": () => (/* binding */ mergeScan),
/* harmony export */   "MergeScanOperator": () => (/* binding */ MergeScanOperator),
/* harmony export */   "MergeScanSubscriber": () => (/* binding */ MergeScanSubscriber)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(267);
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function mergeScan(accumulator, seed, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    return function (source) { return source.lift(new MergeScanOperator(accumulator, seed, concurrent)); };
}
var MergeScanOperator = /*@__PURE__*/ (function () {
    function MergeScanOperator(accumulator, seed, concurrent) {
        this.accumulator = accumulator;
        this.seed = seed;
        this.concurrent = concurrent;
    }
    MergeScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
    };
    return MergeScanOperator;
}());

var MergeScanSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(MergeScanSubscriber, _super);
    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this.acc = acc;
        _this.concurrent = concurrent;
        _this.hasValue = false;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeScanSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            var index = this.index++;
            var destination = this.destination;
            var ish = void 0;
            try {
                var accumulator = this.accumulator;
                ish = accumulator(this.acc, value, index);
            }
            catch (e) {
                return destination.error(e);
            }
            this.active++;
            this._innerSub(ish);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeScanSubscriber.prototype._innerSub = function (ish) {
        var innerSubscriber = new _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = (0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.innerSubscribe)(ish, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
        }
    };
    MergeScanSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeScanSubscriber.prototype.notifyNext = function (innerValue) {
        var destination = this.destination;
        this.acc = innerValue;
        this.hasValue = true;
        destination.next(innerValue);
    };
    MergeScanSubscriber.prototype.notifyComplete = function () {
        var buffer = this.buffer;
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    return MergeScanSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleOuterSubscriber));

//# sourceMappingURL=mergeScan.js.map


/***/ }),
/* 338 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "min": () => (/* binding */ min)
/* harmony export */ });
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(333);
/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

function min(comparer) {
    var min = (typeof comparer === 'function')
        ? function (x, y) { return comparer(x, y) < 0 ? x : y; }
        : function (x, y) { return x < y ? x : y; };
    return (0,_reduce__WEBPACK_IMPORTED_MODULE_0__.reduce)(min);
}
//# sourceMappingURL=min.js.map


/***/ }),
/* 339 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "multicast": () => (/* binding */ multicast),
/* harmony export */   "MulticastOperator": () => (/* binding */ MulticastOperator)
/* harmony export */ });
/* harmony import */ var _observable_ConnectableObservable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(203);
/** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */

function multicast(subjectOrSubjectFactory, selector) {
    return function multicastOperatorFunction(source) {
        var subjectFactory;
        if (typeof subjectOrSubjectFactory === 'function') {
            subjectFactory = subjectOrSubjectFactory;
        }
        else {
            subjectFactory = function subjectFactory() {
                return subjectOrSubjectFactory;
            };
        }
        if (typeof selector === 'function') {
            return source.lift(new MulticastOperator(subjectFactory, selector));
        }
        var connectable = Object.create(source, _observable_ConnectableObservable__WEBPACK_IMPORTED_MODULE_0__.connectableObservableDescriptor);
        connectable.source = source;
        connectable.subjectFactory = subjectFactory;
        return connectable;
    };
}
var MulticastOperator = /*@__PURE__*/ (function () {
    function MulticastOperator(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator.prototype.call = function (subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator;
}());

//# sourceMappingURL=multicast.js.map


/***/ }),
/* 340 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "onErrorResumeNext": () => (/* binding */ onErrorResumeNext),
/* harmony export */   "onErrorResumeNextStatic": () => (/* binding */ onErrorResumeNextStatic)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _observable_from__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(260);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(197);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(267);
/** PURE_IMPORTS_START tslib,_observable_from,_util_isArray,_innerSubscribe PURE_IMPORTS_END */




function onErrorResumeNext() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i] = arguments[_i];
    }
    if (nextSources.length === 1 && (0,_util_isArray__WEBPACK_IMPORTED_MODULE_1__.isArray)(nextSources[0])) {
        nextSources = nextSources[0];
    }
    return function (source) { return source.lift(new OnErrorResumeNextOperator(nextSources)); };
}
function onErrorResumeNextStatic() {
    var nextSources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nextSources[_i] = arguments[_i];
    }
    var source = undefined;
    if (nextSources.length === 1 && (0,_util_isArray__WEBPACK_IMPORTED_MODULE_1__.isArray)(nextSources[0])) {
        nextSources = nextSources[0];
    }
    source = nextSources.shift();
    return (0,_observable_from__WEBPACK_IMPORTED_MODULE_2__.from)(source).lift(new OnErrorResumeNextOperator(nextSources));
}
var OnErrorResumeNextOperator = /*@__PURE__*/ (function () {
    function OnErrorResumeNextOperator(nextSources) {
        this.nextSources = nextSources;
    }
    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
    };
    return OnErrorResumeNextOperator;
}());
var OnErrorResumeNextSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(OnErrorResumeNextSubscriber, _super);
    function OnErrorResumeNextSubscriber(destination, nextSources) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.nextSources = nextSources;
        return _this;
    }
    OnErrorResumeNextSubscriber.prototype.notifyError = function () {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.notifyComplete = function () {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._error = function (err) {
        this.subscribeToNextSource();
        this.unsubscribe();
    };
    OnErrorResumeNextSubscriber.prototype._complete = function () {
        this.subscribeToNextSource();
        this.unsubscribe();
    };
    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
        var next = this.nextSources.shift();
        if (!!next) {
            var innerSubscriber = new _innerSubscribe__WEBPACK_IMPORTED_MODULE_3__.SimpleInnerSubscriber(this);
            var destination = this.destination;
            destination.add(innerSubscriber);
            var innerSubscription = (0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_3__.innerSubscribe)(next, innerSubscriber);
            if (innerSubscription !== innerSubscriber) {
                destination.add(innerSubscription);
            }
        }
        else {
            this.destination.complete();
        }
    };
    return OnErrorResumeNextSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_3__.SimpleOuterSubscriber));
//# sourceMappingURL=onErrorResumeNext.js.map


/***/ }),
/* 341 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pairwise": () => (/* binding */ pairwise)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function pairwise() {
    return function (source) { return source.lift(new PairwiseOperator()); };
}
var PairwiseOperator = /*@__PURE__*/ (function () {
    function PairwiseOperator() {
    }
    PairwiseOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator;
}());
var PairwiseSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasPrev = false;
        return _this;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        var pair;
        if (this.hasPrev) {
            pair = [this.prev, value];
        }
        else {
            this.hasPrev = true;
        }
        this.prev = value;
        if (pair) {
            this.destination.next(pair);
        }
    };
    return PairwiseSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));
//# sourceMappingURL=pairwise.js.map


/***/ }),
/* 342 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "partition": () => (/* binding */ partition)
/* harmony export */ });
/* harmony import */ var _util_not__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(282);
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(281);
/** PURE_IMPORTS_START _util_not,_filter PURE_IMPORTS_END */


function partition(predicate, thisArg) {
    return function (source) {
        return [
            (0,_filter__WEBPACK_IMPORTED_MODULE_0__.filter)(predicate, thisArg)(source),
            (0,_filter__WEBPACK_IMPORTED_MODULE_0__.filter)((0,_util_not__WEBPACK_IMPORTED_MODULE_1__.not)(predicate, thisArg))(source)
        ];
    };
}
//# sourceMappingURL=partition.js.map


/***/ }),
/* 343 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pluck": () => (/* binding */ pluck)
/* harmony export */ });
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(243);
/** PURE_IMPORTS_START _map PURE_IMPORTS_END */

function pluck() {
    var properties = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        properties[_i] = arguments[_i];
    }
    var length = properties.length;
    if (length === 0) {
        throw new Error('list of properties cannot be empty.');
    }
    return function (source) { return (0,_map__WEBPACK_IMPORTED_MODULE_0__.map)(plucker(properties, length))(source); };
}
function plucker(props, length) {
    var mapper = function (x) {
        var currentProp = x;
        for (var i = 0; i < length; i++) {
            var p = currentProp != null ? currentProp[props[i]] : undefined;
            if (p !== void 0) {
                currentProp = p;
            }
            else {
                return undefined;
            }
        }
        return currentProp;
    };
    return mapper;
}
//# sourceMappingURL=pluck.js.map


/***/ }),
/* 344 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "publish": () => (/* binding */ publish)
/* harmony export */ });
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(205);
/* harmony import */ var _multicast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(339);
/** PURE_IMPORTS_START _Subject,_multicast PURE_IMPORTS_END */


function publish(selector) {
    return selector ?
        (0,_multicast__WEBPACK_IMPORTED_MODULE_0__.multicast)(function () { return new _Subject__WEBPACK_IMPORTED_MODULE_1__.Subject(); }, selector) :
        (0,_multicast__WEBPACK_IMPORTED_MODULE_0__.multicast)(new _Subject__WEBPACK_IMPORTED_MODULE_1__.Subject());
}
//# sourceMappingURL=publish.js.map


/***/ }),
/* 345 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "publishBehavior": () => (/* binding */ publishBehavior)
/* harmony export */ });
/* harmony import */ var _BehaviorSubject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(209);
/* harmony import */ var _multicast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(339);
/** PURE_IMPORTS_START _BehaviorSubject,_multicast PURE_IMPORTS_END */


function publishBehavior(value) {
    return function (source) { return (0,_multicast__WEBPACK_IMPORTED_MODULE_0__.multicast)(new _BehaviorSubject__WEBPACK_IMPORTED_MODULE_1__.BehaviorSubject(value))(source); };
}
//# sourceMappingURL=publishBehavior.js.map


/***/ }),
/* 346 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "publishLast": () => (/* binding */ publishLast)
/* harmony export */ });
/* harmony import */ var _AsyncSubject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(227);
/* harmony import */ var _multicast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(339);
/** PURE_IMPORTS_START _AsyncSubject,_multicast PURE_IMPORTS_END */


function publishLast() {
    return function (source) { return (0,_multicast__WEBPACK_IMPORTED_MODULE_0__.multicast)(new _AsyncSubject__WEBPACK_IMPORTED_MODULE_1__.AsyncSubject())(source); };
}
//# sourceMappingURL=publishLast.js.map


/***/ }),
/* 347 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "publishReplay": () => (/* binding */ publishReplay)
/* harmony export */ });
/* harmony import */ var _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(210);
/* harmony import */ var _multicast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(339);
/** PURE_IMPORTS_START _ReplaySubject,_multicast PURE_IMPORTS_END */


function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {
    if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {
        scheduler = selectorOrScheduler;
    }
    var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;
    var subject = new _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__.ReplaySubject(bufferSize, windowTime, scheduler);
    return function (source) { return (0,_multicast__WEBPACK_IMPORTED_MODULE_1__.multicast)(function () { return subject; }, selector)(source); };
}
//# sourceMappingURL=publishReplay.js.map


/***/ }),
/* 348 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "race": () => (/* binding */ race)
/* harmony export */ });
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(197);
/* harmony import */ var _observable_race__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(283);
/** PURE_IMPORTS_START _util_isArray,_observable_race PURE_IMPORTS_END */


function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function raceOperatorFunction(source) {
        if (observables.length === 1 && (0,_util_isArray__WEBPACK_IMPORTED_MODULE_0__.isArray)(observables[0])) {
            observables = observables[0];
        }
        return source.lift.call(_observable_race__WEBPACK_IMPORTED_MODULE_1__.race.apply(void 0, [source].concat(observables)));
    };
}
//# sourceMappingURL=race.js.map


/***/ }),
/* 349 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "repeat": () => (/* binding */ repeat)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(188);
/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(219);
/** PURE_IMPORTS_START tslib,_Subscriber,_observable_empty PURE_IMPORTS_END */



function repeat(count) {
    if (count === void 0) {
        count = -1;
    }
    return function (source) {
        if (count === 0) {
            return (0,_observable_empty__WEBPACK_IMPORTED_MODULE_1__.empty)();
        }
        else if (count < 0) {
            return source.lift(new RepeatOperator(-1, source));
        }
        else {
            return source.lift(new RepeatOperator(count - 1, source));
        }
    };
}
var RepeatOperator = /*@__PURE__*/ (function () {
    function RepeatOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RepeatOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
    };
    return RepeatOperator;
}());
var RepeatSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(RepeatSubscriber, _super);
    function RepeatSubscriber(destination, count, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count;
        _this.source = source;
        return _this;
    }
    RepeatSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.complete.call(this);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RepeatSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_2__.Subscriber));
//# sourceMappingURL=repeat.js.map


/***/ }),
/* 350 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "repeatWhen": () => (/* binding */ repeatWhen)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(205);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(267);
/** PURE_IMPORTS_START tslib,_Subject,_innerSubscribe PURE_IMPORTS_END */



function repeatWhen(notifier) {
    return function (source) { return source.lift(new RepeatWhenOperator(notifier)); };
}
var RepeatWhenOperator = /*@__PURE__*/ (function () {
    function RepeatWhenOperator(notifier) {
        this.notifier = notifier;
    }
    RepeatWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
    };
    return RepeatWhenOperator;
}());
var RepeatWhenSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(RepeatWhenSubscriber, _super);
    function RepeatWhenSubscriber(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        _this.sourceIsBeingSubscribedTo = true;
        return _this;
    }
    RepeatWhenSubscriber.prototype.notifyNext = function () {
        this.sourceIsBeingSubscribedTo = true;
        this.source.subscribe(this);
    };
    RepeatWhenSubscriber.prototype.notifyComplete = function () {
        if (this.sourceIsBeingSubscribedTo === false) {
            return _super.prototype.complete.call(this);
        }
    };
    RepeatWhenSubscriber.prototype.complete = function () {
        this.sourceIsBeingSubscribedTo = false;
        if (!this.isStopped) {
            if (!this.retries) {
                this.subscribeToRetries();
            }
            if (!this.retriesSubscription || this.retriesSubscription.closed) {
                return _super.prototype.complete.call(this);
            }
            this._unsubscribeAndRecycle();
            this.notifications.next(undefined);
        }
    };
    RepeatWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
        if (notifications) {
            notifications.unsubscribe();
            this.notifications = undefined;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = undefined;
        }
        this.retries = undefined;
    };
    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        _super.prototype._unsubscribeAndRecycle.call(this);
        this._unsubscribe = _unsubscribe;
        return this;
    };
    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
        this.notifications = new _Subject__WEBPACK_IMPORTED_MODULE_1__.Subject();
        var retries;
        try {
            var notifier = this.notifier;
            retries = notifier(this.notifications);
        }
        catch (e) {
            return _super.prototype.complete.call(this);
        }
        this.retries = retries;
        this.retriesSubscription = (0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_2__.innerSubscribe)(retries, new _innerSubscribe__WEBPACK_IMPORTED_MODULE_2__.SimpleInnerSubscriber(this));
    };
    return RepeatWhenSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_2__.SimpleOuterSubscriber));
//# sourceMappingURL=repeatWhen.js.map


/***/ }),
/* 351 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "retry": () => (/* binding */ retry)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function retry(count) {
    if (count === void 0) {
        count = -1;
    }
    return function (source) { return source.lift(new RetryOperator(count, source)); };
}
var RetryOperator = /*@__PURE__*/ (function () {
    function RetryOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RetryOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
    };
    return RetryOperator;
}());
var RetrySubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(RetrySubscriber, _super);
    function RetrySubscriber(destination, count, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count;
        _this.source = source;
        return _this;
    }
    RetrySubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.error.call(this, err);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RetrySubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));
//# sourceMappingURL=retry.js.map


/***/ }),
/* 352 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "retryWhen": () => (/* binding */ retryWhen)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(205);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(267);
/** PURE_IMPORTS_START tslib,_Subject,_innerSubscribe PURE_IMPORTS_END */



function retryWhen(notifier) {
    return function (source) { return source.lift(new RetryWhenOperator(notifier, source)); };
}
var RetryWhenOperator = /*@__PURE__*/ (function () {
    function RetryWhenOperator(notifier, source) {
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
    };
    return RetryWhenOperator;
}());
var RetryWhenSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(RetryWhenSubscriber, _super);
    function RetryWhenSubscriber(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        return _this;
    }
    RetryWhenSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var errors = this.errors;
            var retries = this.retries;
            var retriesSubscription = this.retriesSubscription;
            if (!retries) {
                errors = new _Subject__WEBPACK_IMPORTED_MODULE_1__.Subject();
                try {
                    var notifier = this.notifier;
                    retries = notifier(errors);
                }
                catch (e) {
                    return _super.prototype.error.call(this, e);
                }
                retriesSubscription = (0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_2__.innerSubscribe)(retries, new _innerSubscribe__WEBPACK_IMPORTED_MODULE_2__.SimpleInnerSubscriber(this));
            }
            else {
                this.errors = undefined;
                this.retriesSubscription = undefined;
            }
            this._unsubscribeAndRecycle();
            this.errors = errors;
            this.retries = retries;
            this.retriesSubscription = retriesSubscription;
            errors.next(err);
        }
    };
    RetryWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
        if (errors) {
            errors.unsubscribe();
            this.errors = undefined;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = undefined;
        }
        this.retries = undefined;
    };
    RetryWhenSubscriber.prototype.notifyNext = function () {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        this._unsubscribeAndRecycle();
        this._unsubscribe = _unsubscribe;
        this.source.subscribe(this);
    };
    return RetryWhenSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_2__.SimpleOuterSubscriber));
//# sourceMappingURL=retryWhen.js.map


/***/ }),
/* 353 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sample": () => (/* binding */ sample)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(267);
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function sample(notifier) {
    return function (source) { return source.lift(new SampleOperator(notifier)); };
}
var SampleOperator = /*@__PURE__*/ (function () {
    function SampleOperator(notifier) {
        this.notifier = notifier;
    }
    SampleOperator.prototype.call = function (subscriber, source) {
        var sampleSubscriber = new SampleSubscriber(subscriber);
        var subscription = source.subscribe(sampleSubscriber);
        subscription.add((0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.innerSubscribe)(this.notifier, new _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleInnerSubscriber(sampleSubscriber)));
        return subscription;
    };
    return SampleOperator;
}());
var SampleSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(SampleSubscriber, _super);
    function SampleSubscriber() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hasValue = false;
        return _this;
    }
    SampleSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
    };
    SampleSubscriber.prototype.notifyNext = function () {
        this.emitValue();
    };
    SampleSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    SampleSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.value);
        }
    };
    return SampleSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleOuterSubscriber));
//# sourceMappingURL=sample.js.map


/***/ }),
/* 354 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sampleTime": () => (/* binding */ sampleTime)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(188);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */



function sampleTime(period, scheduler) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__.async;
    }
    return function (source) { return source.lift(new SampleTimeOperator(period, scheduler)); };
}
var SampleTimeOperator = /*@__PURE__*/ (function () {
    function SampleTimeOperator(period, scheduler) {
        this.period = period;
        this.scheduler = scheduler;
    }
    SampleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
    };
    return SampleTimeOperator;
}());
var SampleTimeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(SampleTimeSubscriber, _super);
    function SampleTimeSubscriber(destination, period, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.period = period;
        _this.scheduler = scheduler;
        _this.hasValue = false;
        _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period: period }));
        return _this;
    }
    SampleTimeSubscriber.prototype._next = function (value) {
        this.lastValue = value;
        this.hasValue = true;
    };
    SampleTimeSubscriber.prototype.notifyNext = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.lastValue);
        }
    };
    return SampleTimeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_2__.Subscriber));
function dispatchNotification(state) {
    var subscriber = state.subscriber, period = state.period;
    subscriber.notifyNext();
    this.schedule(state, period);
}
//# sourceMappingURL=sampleTime.js.map


/***/ }),
/* 355 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sequenceEqual": () => (/* binding */ sequenceEqual),
/* harmony export */   "SequenceEqualOperator": () => (/* binding */ SequenceEqualOperator),
/* harmony export */   "SequenceEqualSubscriber": () => (/* binding */ SequenceEqualSubscriber)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function sequenceEqual(compareTo, comparator) {
    return function (source) { return source.lift(new SequenceEqualOperator(compareTo, comparator)); };
}
var SequenceEqualOperator = /*@__PURE__*/ (function () {
    function SequenceEqualOperator(compareTo, comparator) {
        this.compareTo = compareTo;
        this.comparator = comparator;
    }
    SequenceEqualOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
    };
    return SequenceEqualOperator;
}());

var SequenceEqualSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(SequenceEqualSubscriber, _super);
    function SequenceEqualSubscriber(destination, compareTo, comparator) {
        var _this = _super.call(this, destination) || this;
        _this.compareTo = compareTo;
        _this.comparator = comparator;
        _this._a = [];
        _this._b = [];
        _this._oneComplete = false;
        _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
        return _this;
    }
    SequenceEqualSubscriber.prototype._next = function (value) {
        if (this._oneComplete && this._b.length === 0) {
            this.emit(false);
        }
        else {
            this._a.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype._complete = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
        this.unsubscribe();
    };
    SequenceEqualSubscriber.prototype.checkValues = function () {
        var _c = this, _a = _c._a, _b = _c._b, comparator = _c.comparator;
        while (_a.length > 0 && _b.length > 0) {
            var a = _a.shift();
            var b = _b.shift();
            var areEqual = false;
            try {
                areEqual = comparator ? comparator(a, b) : a === b;
            }
            catch (e) {
                this.destination.error(e);
            }
            if (!areEqual) {
                this.emit(false);
            }
        }
    };
    SequenceEqualSubscriber.prototype.emit = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    SequenceEqualSubscriber.prototype.nextB = function (value) {
        if (this._oneComplete && this._a.length === 0) {
            this.emit(false);
        }
        else {
            this._b.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype.completeB = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
    };
    return SequenceEqualSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));

var SequenceEqualCompareToSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(SequenceEqualCompareToSubscriber, _super);
    function SequenceEqualCompareToSubscriber(destination, parent) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        return _this;
    }
    SequenceEqualCompareToSubscriber.prototype._next = function (value) {
        this.parent.nextB(value);
    };
    SequenceEqualCompareToSubscriber.prototype._error = function (err) {
        this.parent.error(err);
        this.unsubscribe();
    };
    SequenceEqualCompareToSubscriber.prototype._complete = function () {
        this.parent.completeB();
        this.unsubscribe();
    };
    return SequenceEqualCompareToSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));
//# sourceMappingURL=sequenceEqual.js.map


/***/ }),
/* 356 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "share": () => (/* binding */ share)
/* harmony export */ });
/* harmony import */ var _multicast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(339);
/* harmony import */ var _refCount__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(204);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(205);
/** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */



function shareSubjectFactory() {
    return new _Subject__WEBPACK_IMPORTED_MODULE_0__.Subject();
}
function share() {
    return function (source) { return (0,_refCount__WEBPACK_IMPORTED_MODULE_1__.refCount)()((0,_multicast__WEBPACK_IMPORTED_MODULE_2__.multicast)(shareSubjectFactory)(source)); };
}
//# sourceMappingURL=share.js.map


/***/ }),
/* 357 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "shareReplay": () => (/* binding */ shareReplay)
/* harmony export */ });
/* harmony import */ var _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(210);
/** PURE_IMPORTS_START _ReplaySubject PURE_IMPORTS_END */

function shareReplay(configOrBufferSize, windowTime, scheduler) {
    var config;
    if (configOrBufferSize && typeof configOrBufferSize === 'object') {
        config = configOrBufferSize;
    }
    else {
        config = {
            bufferSize: configOrBufferSize,
            windowTime: windowTime,
            refCount: false,
            scheduler: scheduler,
        };
    }
    return function (source) { return source.lift(shareReplayOperator(config)); };
}
function shareReplayOperator(_a) {
    var _b = _a.bufferSize, bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b, _c = _a.windowTime, windowTime = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a.refCount, scheduler = _a.scheduler;
    var subject;
    var refCount = 0;
    var subscription;
    var hasError = false;
    var isComplete = false;
    return function shareReplayOperation(source) {
        refCount++;
        var innerSub;
        if (!subject || hasError) {
            hasError = false;
            subject = new _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__.ReplaySubject(bufferSize, windowTime, scheduler);
            innerSub = subject.subscribe(this);
            subscription = source.subscribe({
                next: function (value) {
                    subject.next(value);
                },
                error: function (err) {
                    hasError = true;
                    subject.error(err);
                },
                complete: function () {
                    isComplete = true;
                    subscription = undefined;
                    subject.complete();
                },
            });
            if (isComplete) {
                subscription = undefined;
            }
        }
        else {
            innerSub = subject.subscribe(this);
        }
        this.add(function () {
            refCount--;
            innerSub.unsubscribe();
            innerSub = undefined;
            if (subscription && !isComplete && useRefCount && refCount === 0) {
                subscription.unsubscribe();
                subscription = undefined;
                subject = undefined;
            }
        });
    };
}
//# sourceMappingURL=shareReplay.js.map


/***/ }),
/* 358 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "single": () => (/* binding */ single)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(188);
/* harmony import */ var _util_EmptyError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(240);
/** PURE_IMPORTS_START tslib,_Subscriber,_util_EmptyError PURE_IMPORTS_END */



function single(predicate) {
    return function (source) { return source.lift(new SingleOperator(predicate, source)); };
}
var SingleOperator = /*@__PURE__*/ (function () {
    function SingleOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    SingleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
    };
    return SingleOperator;
}());
var SingleSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(SingleSubscriber, _super);
    function SingleSubscriber(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.seenValue = false;
        _this.index = 0;
        return _this;
    }
    SingleSubscriber.prototype.applySingleValue = function (value) {
        if (this.seenValue) {
            this.destination.error('Sequence contains more than one element');
        }
        else {
            this.seenValue = true;
            this.singleValue = value;
        }
    };
    SingleSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this.tryNext(value, index);
        }
        else {
            this.applySingleValue(value);
        }
    };
    SingleSubscriber.prototype.tryNext = function (value, index) {
        try {
            if (this.predicate(value, index, this.source)) {
                this.applySingleValue(value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    SingleSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.index > 0) {
            destination.next(this.seenValue ? this.singleValue : undefined);
            destination.complete();
        }
        else {
            destination.error(new _util_EmptyError__WEBPACK_IMPORTED_MODULE_1__.EmptyError);
        }
    };
    return SingleSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_2__.Subscriber));
//# sourceMappingURL=single.js.map


/***/ }),
/* 359 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "skip": () => (/* binding */ skip)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function skip(count) {
    return function (source) { return source.lift(new SkipOperator(count)); };
}
var SkipOperator = /*@__PURE__*/ (function () {
    function SkipOperator(total) {
        this.total = total;
    }
    SkipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
    };
    return SkipOperator;
}());
var SkipSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(SkipSubscriber, _super);
    function SkipSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    SkipSubscriber.prototype._next = function (x) {
        if (++this.count > this.total) {
            this.destination.next(x);
        }
    };
    return SkipSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));
//# sourceMappingURL=skip.js.map


/***/ }),
/* 360 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "skipLast": () => (/* binding */ skipLast)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(188);
/* harmony import */ var _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(239);
/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError PURE_IMPORTS_END */



function skipLast(count) {
    return function (source) { return source.lift(new SkipLastOperator(count)); };
}
var SkipLastOperator = /*@__PURE__*/ (function () {
    function SkipLastOperator(_skipCount) {
        this._skipCount = _skipCount;
        if (this._skipCount < 0) {
            throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_1__.ArgumentOutOfRangeError;
        }
    }
    SkipLastOperator.prototype.call = function (subscriber, source) {
        if (this._skipCount === 0) {
            return source.subscribe(new _Subscriber__WEBPACK_IMPORTED_MODULE_2__.Subscriber(subscriber));
        }
        else {
            return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
        }
    };
    return SkipLastOperator;
}());
var SkipLastSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(SkipLastSubscriber, _super);
    function SkipLastSubscriber(destination, _skipCount) {
        var _this = _super.call(this, destination) || this;
        _this._skipCount = _skipCount;
        _this._count = 0;
        _this._ring = new Array(_skipCount);
        return _this;
    }
    SkipLastSubscriber.prototype._next = function (value) {
        var skipCount = this._skipCount;
        var count = this._count++;
        if (count < skipCount) {
            this._ring[count] = value;
        }
        else {
            var currentIndex = count % skipCount;
            var ring = this._ring;
            var oldValue = ring[currentIndex];
            ring[currentIndex] = value;
            this.destination.next(oldValue);
        }
    };
    return SkipLastSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_2__.Subscriber));
//# sourceMappingURL=skipLast.js.map


/***/ }),
/* 361 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "skipUntil": () => (/* binding */ skipUntil)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(267);
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function skipUntil(notifier) {
    return function (source) { return source.lift(new SkipUntilOperator(notifier)); };
}
var SkipUntilOperator = /*@__PURE__*/ (function () {
    function SkipUntilOperator(notifier) {
        this.notifier = notifier;
    }
    SkipUntilOperator.prototype.call = function (destination, source) {
        return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
    };
    return SkipUntilOperator;
}());
var SkipUntilSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(SkipUntilSubscriber, _super);
    function SkipUntilSubscriber(destination, notifier) {
        var _this = _super.call(this, destination) || this;
        _this.hasValue = false;
        var innerSubscriber = new _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleInnerSubscriber(_this);
        _this.add(innerSubscriber);
        _this.innerSubscription = innerSubscriber;
        var innerSubscription = (0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.innerSubscribe)(notifier, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            _this.add(innerSubscription);
            _this.innerSubscription = innerSubscription;
        }
        return _this;
    }
    SkipUntilSubscriber.prototype._next = function (value) {
        if (this.hasValue) {
            _super.prototype._next.call(this, value);
        }
    };
    SkipUntilSubscriber.prototype.notifyNext = function () {
        this.hasValue = true;
        if (this.innerSubscription) {
            this.innerSubscription.unsubscribe();
        }
    };
    SkipUntilSubscriber.prototype.notifyComplete = function () {
    };
    return SkipUntilSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleOuterSubscriber));
//# sourceMappingURL=skipUntil.js.map


/***/ }),
/* 362 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "skipWhile": () => (/* binding */ skipWhile)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function skipWhile(predicate) {
    return function (source) { return source.lift(new SkipWhileOperator(predicate)); };
}
var SkipWhileOperator = /*@__PURE__*/ (function () {
    function SkipWhileOperator(predicate) {
        this.predicate = predicate;
    }
    SkipWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
    };
    return SkipWhileOperator;
}());
var SkipWhileSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(SkipWhileSubscriber, _super);
    function SkipWhileSubscriber(destination, predicate) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.skipping = true;
        _this.index = 0;
        return _this;
    }
    SkipWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (this.skipping) {
            this.tryCallPredicate(value);
        }
        if (!this.skipping) {
            destination.next(value);
        }
    };
    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
        try {
            var result = this.predicate(value, this.index++);
            this.skipping = Boolean(result);
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    return SkipWhileSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));
//# sourceMappingURL=skipWhile.js.map


/***/ }),
/* 363 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startWith": () => (/* binding */ startWith)
/* harmony export */ });
/* harmony import */ var _observable_concat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(256);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(214);
/** PURE_IMPORTS_START _observable_concat,_util_isScheduler PURE_IMPORTS_END */


function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if ((0,_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__.isScheduler)(scheduler)) {
        array.pop();
        return function (source) { return (0,_observable_concat__WEBPACK_IMPORTED_MODULE_1__.concat)(array, source, scheduler); };
    }
    else {
        return function (source) { return (0,_observable_concat__WEBPACK_IMPORTED_MODULE_1__.concat)(array, source); };
    }
}
//# sourceMappingURL=startWith.js.map


/***/ }),
/* 364 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "subscribeOn": () => (/* binding */ subscribeOn)
/* harmony export */ });
/* harmony import */ var _observable_SubscribeOnObservable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(365);
/** PURE_IMPORTS_START _observable_SubscribeOnObservable PURE_IMPORTS_END */

function subscribeOn(scheduler, delay) {
    if (delay === void 0) {
        delay = 0;
    }
    return function subscribeOnOperatorFunction(source) {
        return source.lift(new SubscribeOnOperator(scheduler, delay));
    };
}
var SubscribeOnOperator = /*@__PURE__*/ (function () {
    function SubscribeOnOperator(scheduler, delay) {
        this.scheduler = scheduler;
        this.delay = delay;
    }
    SubscribeOnOperator.prototype.call = function (subscriber, source) {
        return new _observable_SubscribeOnObservable__WEBPACK_IMPORTED_MODULE_0__.SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
    };
    return SubscribeOnOperator;
}());
//# sourceMappingURL=subscribeOn.js.map


/***/ }),
/* 365 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SubscribeOnObservable": () => (/* binding */ SubscribeOnObservable)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(186);
/* harmony import */ var _scheduler_asap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(228);
/* harmony import */ var _util_isNumeric__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(275);
/** PURE_IMPORTS_START tslib,_Observable,_scheduler_asap,_util_isNumeric PURE_IMPORTS_END */




var SubscribeOnObservable = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(SubscribeOnObservable, _super);
    function SubscribeOnObservable(source, delayTime, scheduler) {
        if (delayTime === void 0) {
            delayTime = 0;
        }
        if (scheduler === void 0) {
            scheduler = _scheduler_asap__WEBPACK_IMPORTED_MODULE_1__.asap;
        }
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.delayTime = delayTime;
        _this.scheduler = scheduler;
        if (!(0,_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__.isNumeric)(delayTime) || delayTime < 0) {
            _this.delayTime = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== 'function') {
            _this.scheduler = _scheduler_asap__WEBPACK_IMPORTED_MODULE_1__.asap;
        }
        return _this;
    }
    SubscribeOnObservable.create = function (source, delay, scheduler) {
        if (delay === void 0) {
            delay = 0;
        }
        if (scheduler === void 0) {
            scheduler = _scheduler_asap__WEBPACK_IMPORTED_MODULE_1__.asap;
        }
        return new SubscribeOnObservable(source, delay, scheduler);
    };
    SubscribeOnObservable.dispatch = function (arg) {
        var source = arg.source, subscriber = arg.subscriber;
        return this.add(source.subscribe(subscriber));
    };
    SubscribeOnObservable.prototype._subscribe = function (subscriber) {
        var delay = this.delayTime;
        var source = this.source;
        var scheduler = this.scheduler;
        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
            source: source, subscriber: subscriber
        });
    };
    return SubscribeOnObservable;
}(_Observable__WEBPACK_IMPORTED_MODULE_3__.Observable));

//# sourceMappingURL=SubscribeOnObservable.js.map


/***/ }),
/* 366 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "switchAll": () => (/* binding */ switchAll)
/* harmony export */ });
/* harmony import */ var _switchMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(367);
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(202);
/** PURE_IMPORTS_START _switchMap,_util_identity PURE_IMPORTS_END */


function switchAll() {
    return (0,_switchMap__WEBPACK_IMPORTED_MODULE_0__.switchMap)(_util_identity__WEBPACK_IMPORTED_MODULE_1__.identity);
}
//# sourceMappingURL=switchAll.js.map


/***/ }),
/* 367 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "switchMap": () => (/* binding */ switchMap)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(243);
/* harmony import */ var _observable_from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(260);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(267);
/** PURE_IMPORTS_START tslib,_map,_observable_from,_innerSubscribe PURE_IMPORTS_END */




function switchMap(project, resultSelector) {
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(switchMap(function (a, i) { return (0,_observable_from__WEBPACK_IMPORTED_MODULE_1__.from)(project(a, i)).pipe((0,_map__WEBPACK_IMPORTED_MODULE_2__.map)(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
    }
    return function (source) { return source.lift(new SwitchMapOperator(project)); };
}
var SwitchMapOperator = /*@__PURE__*/ (function () {
    function SwitchMapOperator(project) {
        this.project = project;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
    };
    return SwitchMapOperator;
}());
var SwitchMapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.index = 0;
        return _this;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        var innerSubscriber = new _innerSubscribe__WEBPACK_IMPORTED_MODULE_3__.SimpleInnerSubscriber(this);
        var destination = this.destination;
        destination.add(innerSubscriber);
        this.innerSubscription = (0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_3__.innerSubscribe)(result, innerSubscriber);
        if (this.innerSubscription !== innerSubscriber) {
            destination.add(this.innerSubscription);
        }
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
        this.unsubscribe();
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = undefined;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function () {
        this.innerSubscription = undefined;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (innerValue) {
        this.destination.next(innerValue);
    };
    return SwitchMapSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_3__.SimpleOuterSubscriber));
//# sourceMappingURL=switchMap.js.map


/***/ }),
/* 368 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "switchMapTo": () => (/* binding */ switchMapTo)
/* harmony export */ });
/* harmony import */ var _switchMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(367);
/** PURE_IMPORTS_START _switchMap PURE_IMPORTS_END */

function switchMapTo(innerObservable, resultSelector) {
    return resultSelector ? (0,_switchMap__WEBPACK_IMPORTED_MODULE_0__.switchMap)(function () { return innerObservable; }, resultSelector) : (0,_switchMap__WEBPACK_IMPORTED_MODULE_0__.switchMap)(function () { return innerObservable; });
}
//# sourceMappingURL=switchMapTo.js.map


/***/ }),
/* 369 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "takeUntil": () => (/* binding */ takeUntil)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(267);
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function takeUntil(notifier) {
    return function (source) { return source.lift(new TakeUntilOperator(notifier)); };
}
var TakeUntilOperator = /*@__PURE__*/ (function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
        var notifierSubscription = (0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.innerSubscribe)(this.notifier, new _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleInnerSubscriber(takeUntilSubscriber));
        if (notifierSubscription && !takeUntilSubscriber.seenValue) {
            takeUntilSubscriber.add(notifierSubscription);
            return source.subscribe(takeUntilSubscriber);
        }
        return takeUntilSubscriber;
    };
    return TakeUntilOperator;
}());
var TakeUntilSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.seenValue = false;
        return _this;
    }
    TakeUntilSubscriber.prototype.notifyNext = function () {
        this.seenValue = true;
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
    };
    return TakeUntilSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleOuterSubscriber));
//# sourceMappingURL=takeUntil.js.map


/***/ }),
/* 370 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "takeWhile": () => (/* binding */ takeWhile)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(188);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function takeWhile(predicate, inclusive) {
    if (inclusive === void 0) {
        inclusive = false;
    }
    return function (source) {
        return source.lift(new TakeWhileOperator(predicate, inclusive));
    };
}
var TakeWhileOperator = /*@__PURE__*/ (function () {
    function TakeWhileOperator(predicate, inclusive) {
        this.predicate = predicate;
        this.inclusive = inclusive;
    }
    TakeWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
    };
    return TakeWhileOperator;
}());
var TakeWhileSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(TakeWhileSubscriber, _super);
    function TakeWhileSubscriber(destination, predicate, inclusive) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.inclusive = inclusive;
        _this.index = 0;
        return _this;
    }
    TakeWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        var result;
        try {
            result = this.predicate(value, this.index++);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this.nextOrComplete(value, result);
    };
    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
            destination.next(value);
        }
        else {
            if (this.inclusive) {
                destination.next(value);
            }
            destination.complete();
        }
    };
    return TakeWhileSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));
//# sourceMappingURL=takeWhile.js.map


/***/ }),
/* 371 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "tap": () => (/* binding */ tap)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(188);
/* harmony import */ var _util_noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(237);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(195);
/** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */




function tap(nextOrObserver, error, complete) {
    return function tapOperatorFunction(source) {
        return source.lift(new DoOperator(nextOrObserver, error, complete));
    };
}
var DoOperator = /*@__PURE__*/ (function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}());
var TapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(TapSubscriber, _super);
    function TapSubscriber(destination, observerOrNext, error, complete) {
        var _this = _super.call(this, destination) || this;
        _this._tapNext = _util_noop__WEBPACK_IMPORTED_MODULE_1__.noop;
        _this._tapError = _util_noop__WEBPACK_IMPORTED_MODULE_1__.noop;
        _this._tapComplete = _util_noop__WEBPACK_IMPORTED_MODULE_1__.noop;
        _this._tapError = error || _util_noop__WEBPACK_IMPORTED_MODULE_1__.noop;
        _this._tapComplete = complete || _util_noop__WEBPACK_IMPORTED_MODULE_1__.noop;
        if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_2__.isFunction)(observerOrNext)) {
            _this._context = _this;
            _this._tapNext = observerOrNext;
        }
        else if (observerOrNext) {
            _this._context = observerOrNext;
            _this._tapNext = observerOrNext.next || _util_noop__WEBPACK_IMPORTED_MODULE_1__.noop;
            _this._tapError = observerOrNext.error || _util_noop__WEBPACK_IMPORTED_MODULE_1__.noop;
            _this._tapComplete = observerOrNext.complete || _util_noop__WEBPACK_IMPORTED_MODULE_1__.noop;
        }
        return _this;
    }
    TapSubscriber.prototype._next = function (value) {
        try {
            this._tapNext.call(this._context, value);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(value);
    };
    TapSubscriber.prototype._error = function (err) {
        try {
            this._tapError.call(this._context, err);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.error(err);
    };
    TapSubscriber.prototype._complete = function () {
        try {
            this._tapComplete.call(this._context);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        return this.destination.complete();
    };
    return TapSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_3__.Subscriber));
//# sourceMappingURL=tap.js.map


/***/ }),
/* 372 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "defaultThrottleConfig": () => (/* binding */ defaultThrottleConfig),
/* harmony export */   "throttle": () => (/* binding */ throttle)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(267);
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


var defaultThrottleConfig = {
    leading: true,
    trailing: false
};
function throttle(durationSelector, config) {
    if (config === void 0) {
        config = defaultThrottleConfig;
    }
    return function (source) { return source.lift(new ThrottleOperator(durationSelector, !!config.leading, !!config.trailing)); };
}
var ThrottleOperator = /*@__PURE__*/ (function () {
    function ThrottleOperator(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
    };
    return ThrottleOperator;
}());
var ThrottleSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(ThrottleSubscriber, _super);
    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.durationSelector = durationSelector;
        _this._leading = _leading;
        _this._trailing = _trailing;
        _this._hasValue = false;
        return _this;
    }
    ThrottleSubscriber.prototype._next = function (value) {
        this._hasValue = true;
        this._sendValue = value;
        if (!this._throttled) {
            if (this._leading) {
                this.send();
            }
            else {
                this.throttle(value);
            }
        }
    };
    ThrottleSubscriber.prototype.send = function () {
        var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;
        if (_hasValue) {
            this.destination.next(_sendValue);
            this.throttle(_sendValue);
        }
        this._hasValue = false;
        this._sendValue = undefined;
    };
    ThrottleSubscriber.prototype.throttle = function (value) {
        var duration = this.tryDurationSelector(value);
        if (!!duration) {
            this.add(this._throttled = (0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.innerSubscribe)(duration, new _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleInnerSubscriber(this)));
        }
    };
    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
        try {
            return this.durationSelector(value);
        }
        catch (err) {
            this.destination.error(err);
            return null;
        }
    };
    ThrottleSubscriber.prototype.throttlingDone = function () {
        var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;
        if (_throttled) {
            _throttled.unsubscribe();
        }
        this._throttled = undefined;
        if (_trailing) {
            this.send();
        }
    };
    ThrottleSubscriber.prototype.notifyNext = function () {
        this.throttlingDone();
    };
    ThrottleSubscriber.prototype.notifyComplete = function () {
        this.throttlingDone();
    };
    return ThrottleSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleOuterSubscriber));
//# sourceMappingURL=throttle.js.map


/***/ }),
/* 373 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "throttleTime": () => (/* binding */ throttleTime)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(188);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var _throttle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(372);
/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async,_throttle PURE_IMPORTS_END */




function throttleTime(duration, scheduler, config) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__.async;
    }
    if (config === void 0) {
        config = _throttle__WEBPACK_IMPORTED_MODULE_2__.defaultThrottleConfig;
    }
    return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };
}
var ThrottleTimeOperator = /*@__PURE__*/ (function () {
    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
    };
    return ThrottleTimeOperator;
}());
var ThrottleTimeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
        var _this = _super.call(this, destination) || this;
        _this.duration = duration;
        _this.scheduler = scheduler;
        _this.leading = leading;
        _this.trailing = trailing;
        _this._hasTrailingValue = false;
        _this._trailingValue = null;
        return _this;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
        else {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
            if (this.leading) {
                this.destination.next(value);
            }
            else if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
    };
    ThrottleTimeSubscriber.prototype._complete = function () {
        if (this._hasTrailingValue) {
            this.destination.next(this._trailingValue);
            this.destination.complete();
        }
        else {
            this.destination.complete();
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            if (this.trailing && this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this._trailingValue = null;
                this._hasTrailingValue = false;
            }
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_3__.Subscriber));
function dispatchNext(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}
//# sourceMappingURL=throttleTime.js.map


/***/ }),
/* 374 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "timeInterval": () => (/* binding */ timeInterval),
/* harmony export */   "TimeInterval": () => (/* binding */ TimeInterval)
/* harmony export */ });
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(232);
/* harmony import */ var _scan__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(334);
/* harmony import */ var _observable_defer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(268);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(243);
/** PURE_IMPORTS_START _scheduler_async,_scan,_observable_defer,_map PURE_IMPORTS_END */




function timeInterval(scheduler) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__.async;
    }
    return function (source) {
        return (0,_observable_defer__WEBPACK_IMPORTED_MODULE_1__.defer)(function () {
            return source.pipe((0,_scan__WEBPACK_IMPORTED_MODULE_2__.scan)(function (_a, value) {
                var current = _a.current;
                return ({ value: value, current: scheduler.now(), last: current });
            }, { current: scheduler.now(), value: undefined, last: undefined }), (0,_map__WEBPACK_IMPORTED_MODULE_3__.map)(function (_a) {
                var current = _a.current, last = _a.last, value = _a.value;
                return new TimeInterval(value, current - last);
            }));
        });
    };
}
var TimeInterval = /*@__PURE__*/ (function () {
    function TimeInterval(value, interval) {
        this.value = value;
        this.interval = interval;
    }
    return TimeInterval;
}());

//# sourceMappingURL=timeInterval.js.map


/***/ }),
/* 375 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "timeout": () => (/* binding */ timeout)
/* harmony export */ });
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(232);
/* harmony import */ var _util_TimeoutError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(241);
/* harmony import */ var _timeoutWith__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(376);
/* harmony import */ var _observable_throwError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(218);
/** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */




function timeout(due, scheduler) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__.async;
    }
    return (0,_timeoutWith__WEBPACK_IMPORTED_MODULE_1__.timeoutWith)(due, (0,_observable_throwError__WEBPACK_IMPORTED_MODULE_2__.throwError)(new _util_TimeoutError__WEBPACK_IMPORTED_MODULE_3__.TimeoutError()), scheduler);
}
//# sourceMappingURL=timeout.js.map


/***/ }),
/* 376 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "timeoutWith": () => (/* binding */ timeoutWith)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var _util_isDate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(308);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(267);
/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_innerSubscribe PURE_IMPORTS_END */




function timeoutWith(due, withObservable, scheduler) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__.async;
    }
    return function (source) {
        var absoluteTimeout = (0,_util_isDate__WEBPACK_IMPORTED_MODULE_2__.isDate)(due);
        var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
        return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
    };
}
var TimeoutWithOperator = /*@__PURE__*/ (function () {
    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
    }
    TimeoutWithOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
    };
    return TimeoutWithOperator;
}());
var TimeoutWithSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(TimeoutWithSubscriber, _super);
    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.absoluteTimeout = absoluteTimeout;
        _this.waitFor = waitFor;
        _this.withObservable = withObservable;
        _this.scheduler = scheduler;
        _this.scheduleTimeout();
        return _this;
    }
    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
        var withObservable = subscriber.withObservable;
        subscriber._unsubscribeAndRecycle();
        subscriber.add((0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_3__.innerSubscribe)(withObservable, new _innerSubscribe__WEBPACK_IMPORTED_MODULE_3__.SimpleInnerSubscriber(subscriber)));
    };
    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            this.action = action.schedule(this, this.waitFor);
        }
        else {
            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutWithSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    TimeoutWithSubscriber.prototype._unsubscribe = function () {
        this.action = undefined;
        this.scheduler = null;
        this.withObservable = null;
    };
    return TimeoutWithSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_3__.SimpleOuterSubscriber));
//# sourceMappingURL=timeoutWith.js.map


/***/ }),
/* 377 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "timestamp": () => (/* binding */ timestamp),
/* harmony export */   "Timestamp": () => (/* binding */ Timestamp)
/* harmony export */ });
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(232);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(243);
/** PURE_IMPORTS_START _scheduler_async,_map PURE_IMPORTS_END */


function timestamp(scheduler) {
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__.async;
    }
    return (0,_map__WEBPACK_IMPORTED_MODULE_1__.map)(function (value) { return new Timestamp(value, scheduler.now()); });
}
var Timestamp = /*@__PURE__*/ (function () {
    function Timestamp(value, timestamp) {
        this.value = value;
        this.timestamp = timestamp;
    }
    return Timestamp;
}());

//# sourceMappingURL=timestamp.js.map


/***/ }),
/* 378 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "toArray": () => (/* binding */ toArray)
/* harmony export */ });
/* harmony import */ var _reduce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(333);
/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

function toArrayReducer(arr, item, index) {
    if (index === 0) {
        return [item];
    }
    arr.push(item);
    return arr;
}
function toArray() {
    return (0,_reduce__WEBPACK_IMPORTED_MODULE_0__.reduce)(toArrayReducer, []);
}
//# sourceMappingURL=toArray.js.map


/***/ }),
/* 379 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "window": () => (/* binding */ window)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(205);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(267);
/** PURE_IMPORTS_START tslib,_Subject,_innerSubscribe PURE_IMPORTS_END */



function window(windowBoundaries) {
    return function windowOperatorFunction(source) {
        return source.lift(new WindowOperator(windowBoundaries));
    };
}
var WindowOperator = /*@__PURE__*/ (function () {
    function WindowOperator(windowBoundaries) {
        this.windowBoundaries = windowBoundaries;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        var windowSubscriber = new WindowSubscriber(subscriber);
        var sourceSubscription = source.subscribe(windowSubscriber);
        if (!sourceSubscription.closed) {
            windowSubscriber.add((0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.innerSubscribe)(this.windowBoundaries, new _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleInnerSubscriber(windowSubscriber)));
        }
        return sourceSubscription;
    };
    return WindowOperator;
}());
var WindowSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(WindowSubscriber, _super);
    function WindowSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.window = new _Subject__WEBPACK_IMPORTED_MODULE_2__.Subject();
        destination.next(_this.window);
        return _this;
    }
    WindowSubscriber.prototype.notifyNext = function () {
        this.openWindow();
    };
    WindowSubscriber.prototype.notifyError = function (error) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function () {
        this._complete();
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
    };
    WindowSubscriber.prototype._unsubscribe = function () {
        this.window = null;
    };
    WindowSubscriber.prototype.openWindow = function () {
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var destination = this.destination;
        var newWindow = this.window = new _Subject__WEBPACK_IMPORTED_MODULE_2__.Subject();
        destination.next(newWindow);
    };
    return WindowSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__.SimpleOuterSubscriber));
//# sourceMappingURL=window.js.map


/***/ }),
/* 380 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "windowCount": () => (/* binding */ windowCount)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(188);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(205);
/** PURE_IMPORTS_START tslib,_Subscriber,_Subject PURE_IMPORTS_END */



function windowCount(windowSize, startWindowEvery) {
    if (startWindowEvery === void 0) {
        startWindowEvery = 0;
    }
    return function windowCountOperatorFunction(source) {
        return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
    };
}
var WindowCountOperator = /*@__PURE__*/ (function () {
    function WindowCountOperator(windowSize, startWindowEvery) {
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
    }
    WindowCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
    };
    return WindowCountOperator;
}());
var WindowCountSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(WindowCountSubscriber, _super);
    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowSize = windowSize;
        _this.startWindowEvery = startWindowEvery;
        _this.windows = [new _Subject__WEBPACK_IMPORTED_MODULE_1__.Subject()];
        _this.count = 0;
        destination.next(_this.windows[0]);
        return _this;
    }
    WindowCountSubscriber.prototype._next = function (value) {
        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;
        var destination = this.destination;
        var windowSize = this.windowSize;
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len && !this.closed; i++) {
            windows[i].next(value);
        }
        var c = this.count - windowSize + 1;
        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
            windows.shift().complete();
        }
        if (++this.count % startWindowEvery === 0 && !this.closed) {
            var window_1 = new _Subject__WEBPACK_IMPORTED_MODULE_1__.Subject();
            windows.push(window_1);
            destination.next(window_1);
        }
    };
    WindowCountSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().error(err);
            }
        }
        this.destination.error(err);
    };
    WindowCountSubscriber.prototype._complete = function () {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().complete();
            }
        }
        this.destination.complete();
    };
    WindowCountSubscriber.prototype._unsubscribe = function () {
        this.count = 0;
        this.windows = null;
    };
    return WindowCountSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_2__.Subscriber));
//# sourceMappingURL=windowCount.js.map


/***/ }),
/* 381 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "windowTime": () => (/* binding */ windowTime)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(205);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(232);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(188);
/* harmony import */ var _util_isNumeric__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(275);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(214);
/** PURE_IMPORTS_START tslib,_Subject,_scheduler_async,_Subscriber,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */






function windowTime(windowTimeSpan) {
    var scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__.async;
    var windowCreationInterval = null;
    var maxWindowSize = Number.POSITIVE_INFINITY;
    if ((0,_util_isScheduler__WEBPACK_IMPORTED_MODULE_2__.isScheduler)(arguments[3])) {
        scheduler = arguments[3];
    }
    if ((0,_util_isScheduler__WEBPACK_IMPORTED_MODULE_2__.isScheduler)(arguments[2])) {
        scheduler = arguments[2];
    }
    else if ((0,_util_isNumeric__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(arguments[2])) {
        maxWindowSize = Number(arguments[2]);
    }
    if ((0,_util_isScheduler__WEBPACK_IMPORTED_MODULE_2__.isScheduler)(arguments[1])) {
        scheduler = arguments[1];
    }
    else if ((0,_util_isNumeric__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(arguments[1])) {
        windowCreationInterval = Number(arguments[1]);
    }
    return function windowTimeOperatorFunction(source) {
        return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
    };
}
var WindowTimeOperator = /*@__PURE__*/ (function () {
    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
    }
    WindowTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
    };
    return WindowTimeOperator;
}());
var CountedSubject = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(CountedSubject, _super);
    function CountedSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._numberOfNextedValues = 0;
        return _this;
    }
    CountedSubject.prototype.next = function (value) {
        this._numberOfNextedValues++;
        _super.prototype.next.call(this, value);
    };
    Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
        get: function () {
            return this._numberOfNextedValues;
        },
        enumerable: true,
        configurable: true
    });
    return CountedSubject;
}(_Subject__WEBPACK_IMPORTED_MODULE_4__.Subject));
var WindowTimeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(WindowTimeSubscriber, _super);
    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowTimeSpan = windowTimeSpan;
        _this.windowCreationInterval = windowCreationInterval;
        _this.maxWindowSize = maxWindowSize;
        _this.scheduler = scheduler;
        _this.windows = [];
        var window = _this.openWindow();
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
            var closeState = { subscriber: _this, window: window, context: null };
            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        }
        else {
            var timeSpanOnlyState = { subscriber: _this, window: window, windowTimeSpan: windowTimeSpan };
            _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }
        return _this;
    }
    WindowTimeSubscriber.prototype._next = function (value) {
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len; i++) {
            var window_1 = windows[i];
            if (!window_1.closed) {
                window_1.next(value);
                if (window_1.numberOfNextedValues >= this.maxWindowSize) {
                    this.closeWindow(window_1);
                }
            }
        }
    };
    WindowTimeSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        while (windows.length > 0) {
            windows.shift().error(err);
        }
        this.destination.error(err);
    };
    WindowTimeSubscriber.prototype._complete = function () {
        var windows = this.windows;
        while (windows.length > 0) {
            var window_2 = windows.shift();
            if (!window_2.closed) {
                window_2.complete();
            }
        }
        this.destination.complete();
    };
    WindowTimeSubscriber.prototype.openWindow = function () {
        var window = new CountedSubject();
        this.windows.push(window);
        var destination = this.destination;
        destination.next(window);
        return window;
    };
    WindowTimeSubscriber.prototype.closeWindow = function (window) {
        window.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window), 1);
    };
    return WindowTimeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_5__.Subscriber));
function dispatchWindowTimeSpanOnly(state) {
    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;
    if (window) {
        subscriber.closeWindow(window);
    }
    state.window = subscriber.openWindow();
    this.schedule(state, windowTimeSpan);
}
function dispatchWindowCreation(state) {
    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
    var window = subscriber.openWindow();
    var action = this;
    var context = { action: action, subscription: null };
    var timeSpanState = { subscriber: subscriber, window: window, context: context };
    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
    action.add(context.subscription);
    action.schedule(state, windowCreationInterval);
}
function dispatchWindowClose(state) {
    var subscriber = state.subscriber, window = state.window, context = state.context;
    if (context && context.action && context.subscription) {
        context.action.remove(context.subscription);
    }
    subscriber.closeWindow(window);
}
//# sourceMappingURL=windowTime.js.map


/***/ }),
/* 382 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "windowToggle": () => (/* binding */ windowToggle)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(205);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(194);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(255);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(246);
/** PURE_IMPORTS_START tslib,_Subject,_Subscription,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */





function windowToggle(openings, closingSelector) {
    return function (source) { return source.lift(new WindowToggleOperator(openings, closingSelector)); };
}
var WindowToggleOperator = /*@__PURE__*/ (function () {
    function WindowToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    WindowToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return WindowToggleOperator;
}());
var WindowToggleSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(WindowToggleSubscriber, _super);
    function WindowToggleSubscriber(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.openings = openings;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(_this.openSubscription = (0,_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__.subscribeToResult)(_this, openings, openings));
        return _this;
    }
    WindowToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        if (contexts) {
            var len = contexts.length;
            for (var i = 0; i < len; i++) {
                contexts[i].window.next(value);
            }
        }
    };
    WindowToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_1 = contexts[index];
                context_1.window.error(err);
                context_1.subscription.unsubscribe();
            }
        }
        _super.prototype._error.call(this, err);
    };
    WindowToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_2 = contexts[index];
                context_2.window.complete();
                context_2.subscription.unsubscribe();
            }
        }
        _super.prototype._complete.call(this);
    };
    WindowToggleSubscriber.prototype._unsubscribe = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_3 = contexts[index];
                context_3.window.unsubscribe();
                context_3.subscription.unsubscribe();
            }
        }
    };
    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (outerValue === this.openings) {
            var closingNotifier = void 0;
            try {
                var closingSelector = this.closingSelector;
                closingNotifier = closingSelector(innerValue);
            }
            catch (e) {
                return this.error(e);
            }
            var window_1 = new _Subject__WEBPACK_IMPORTED_MODULE_2__.Subject();
            var subscription = new _Subscription__WEBPACK_IMPORTED_MODULE_3__.Subscription();
            var context_4 = { window: window_1, subscription: subscription };
            this.contexts.push(context_4);
            var innerSubscription = (0,_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__.subscribeToResult)(this, closingNotifier, context_4);
            if (innerSubscription.closed) {
                this.closeWindow(this.contexts.length - 1);
            }
            else {
                innerSubscription.context = context_4;
                subscription.add(innerSubscription);
            }
            this.destination.next(window_1);
        }
        else {
            this.closeWindow(this.contexts.indexOf(outerValue));
        }
    };
    WindowToggleSubscriber.prototype.notifyError = function (err) {
        this.error(err);
    };
    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
        if (inner !== this.openSubscription) {
            this.closeWindow(this.contexts.indexOf(inner.context));
        }
    };
    WindowToggleSubscriber.prototype.closeWindow = function (index) {
        if (index === -1) {
            return;
        }
        var contexts = this.contexts;
        var context = contexts[index];
        var window = context.window, subscription = context.subscription;
        contexts.splice(index, 1);
        window.complete();
        subscription.unsubscribe();
    };
    return WindowToggleSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_4__.OuterSubscriber));
//# sourceMappingURL=windowToggle.js.map


/***/ }),
/* 383 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "windowWhen": () => (/* binding */ windowWhen)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(205);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(255);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(246);
/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */




function windowWhen(closingSelector) {
    return function windowWhenOperatorFunction(source) {
        return source.lift(new WindowOperator(closingSelector));
    };
}
var WindowOperator = /*@__PURE__*/ (function () {
    function WindowOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
    };
    return WindowOperator;
}());
var WindowSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(WindowSubscriber, _super);
    function WindowSubscriber(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.closingSelector = closingSelector;
        _this.openWindow();
        return _this;
    }
    WindowSubscriber.prototype.notifyNext = function (_outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype.notifyError = function (error) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
        if (this.closingNotification) {
            this.closingNotification.unsubscribe();
        }
    };
    WindowSubscriber.prototype.openWindow = function (innerSub) {
        if (innerSub === void 0) {
            innerSub = null;
        }
        if (innerSub) {
            this.remove(innerSub);
            innerSub.unsubscribe();
        }
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var window = this.window = new _Subject__WEBPACK_IMPORTED_MODULE_1__.Subject();
        this.destination.next(window);
        var closingNotifier;
        try {
            var closingSelector = this.closingSelector;
            closingNotifier = closingSelector();
        }
        catch (e) {
            this.destination.error(e);
            this.window.error(e);
            return;
        }
        this.add(this.closingNotification = (0,_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__.subscribeToResult)(this, closingNotifier));
    };
    return WindowSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__.OuterSubscriber));
//# sourceMappingURL=windowWhen.js.map


/***/ }),
/* 384 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "withLatestFrom": () => (/* binding */ withLatestFrom)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(189);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(255);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(246);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return function (source) {
        var project;
        if (typeof args[args.length - 1] === 'function') {
            project = args.pop();
        }
        var observables = args;
        return source.lift(new WithLatestFromOperator(observables, project));
    };
}
var WithLatestFromOperator = /*@__PURE__*/ (function () {
    function WithLatestFromOperator(observables, project) {
        this.observables = observables;
        this.project = project;
    }
    WithLatestFromOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator;
}());
var WithLatestFromSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__.__extends(WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        var _this = _super.call(this, destination) || this;
        _this.observables = observables;
        _this.project = project;
        _this.toRespond = [];
        var len = observables.length;
        _this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            _this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            _this.add((0,_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__.subscribeToResult)(_this, observable, undefined, i));
        }
        return _this;
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (_outerValue, innerValue, outerIndex) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            }
            else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__.OuterSubscriber));
//# sourceMappingURL=withLatestFrom.js.map


/***/ }),
/* 385 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "zip": () => (/* binding */ zip)
/* harmony export */ });
/* harmony import */ var _observable_zip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(287);
/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */

function zip() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return function zipOperatorFunction(source) {
        return source.lift.call(_observable_zip__WEBPACK_IMPORTED_MODULE_0__.zip.apply(void 0, [source].concat(observables)));
    };
}
//# sourceMappingURL=zip.js.map


/***/ }),
/* 386 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "zipAll": () => (/* binding */ zipAll)
/* harmony export */ });
/* harmony import */ var _observable_zip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(287);
/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */

function zipAll(project) {
    return function (source) { return source.lift(new _observable_zip__WEBPACK_IMPORTED_MODULE_0__.ZipOperator(project)); };
}
//# sourceMappingURL=zipAll.js.map


/***/ }),
/* 387 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.handleDiagnostic = void 0;
var vscode_languageserver_1 = __webpack_require__(2);
var patterns_1 = __webpack_require__(72);
var connection_1 = __webpack_require__(156);
var fixNegativeNum = function (num) {
    if (num < 0) {
        return 0;
    }
    return num;
};
function handleDiagnostic(textDoc, error) {
    return __awaiter(this, void 0, void 0, function () {
        var m, lines, line, col;
        return __generator(this, function (_a) {
            m = (error || "").match(patterns_1.errorLinePattern);
            if (m) {
                lines = textDoc.lineCount;
                line = fixNegativeNum(parseFloat(m[2]) - 1);
                col = fixNegativeNum(parseFloat(m[3]) - 1);
                return [2 /*return*/, connection_1.connection.sendDiagnostics({
                        uri: textDoc.uri,
                        diagnostics: [{
                                source: "vimlsp",
                                message: m[1],
                                range: vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(line > lines ? lines : line, col), vscode_languageserver_1.Position.create(line > lines ? lines : line, col + 1)),
                                severity: vscode_languageserver_1.DiagnosticSeverity.Error,
                            }],
                    })];
            }
            // clear diagnostics
            connection_1.connection.sendDiagnostics({
                uri: textDoc.uri,
                diagnostics: [],
            });
            return [2 /*return*/];
        });
    });
}
exports.handleDiagnostic = handleDiagnostic;


/***/ }),
/* 388 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.selectionRangeProvider = void 0;
var vscode_languageserver_1 = __webpack_require__(2);
var workspaces_1 = __webpack_require__(167);
var documents_1 = __webpack_require__(74);
var selectionRangeProvider = function (params) { return __awaiter(void 0, void 0, void 0, function () {
    var selectRanges, textDocument, positions, buffer, document, vimRanges, range, ranges;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                selectRanges = [];
                textDocument = params.textDocument, positions = params.positions;
                if (!positions || positions.length === 0) {
                    return [2 /*return*/, selectRanges];
                }
                return [4 /*yield*/, workspaces_1.workspace.getBufferByUri(textDocument.uri)];
            case 1:
                buffer = _a.sent();
                document = documents_1.documents.get(textDocument.uri);
                if (!buffer || !document) {
                    return [2 /*return*/, selectRanges];
                }
                vimRanges = buffer.getRanges();
                if (vimRanges.length === 0) {
                    return [2 /*return*/, selectRanges];
                }
                range = vscode_languageserver_1.Range.create(positions[0], positions[0]);
                if (positions.length > 1) {
                    range = vscode_languageserver_1.Range.create(positions[0], positions[positions.length - 1]);
                }
                ranges = [];
                vimRanges.forEach(function (vimRange) {
                    var line = document.getText(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(vimRange.endLine - 1, 0), vscode_languageserver_1.Position.create(vimRange.endLine, 0)));
                    var newRange = vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(vimRange.startLine - 1, vimRange.startCol - 1), vscode_languageserver_1.Position.create(vimRange.endLine - 1, vimRange.endCol - 1 + line.slice(vimRange.endCol - 1).split(' ')[0].length));
                    if (range.start.line >= newRange.start.line && range.end.line <= newRange.end.line) {
                        if (ranges.length === 0) {
                            ranges.push(newRange);
                        }
                        else {
                            var i = 0;
                            for (var len = ranges.length; i < len; i++) {
                                if (ranges[i].start.line <= newRange.start.line && ranges[i].end.line >= newRange.end.line) {
                                    ranges.splice(i, 0, newRange);
                                    break;
                                }
                            }
                            if (i === ranges.length) {
                                ranges.push(newRange);
                            }
                        }
                    }
                });
                if (ranges.length) {
                    if (ranges.length > 1) {
                        ranges = ranges.filter(function (newRange) {
                            return range.start.line !== newRange.start.line || range.end.line !== newRange.end.line;
                        });
                    }
                    selectRanges.push(ranges.reverse().reduce(function (pre, cur, idx) {
                        if (idx === 0) {
                            return pre;
                        }
                        return {
                            range: cur,
                            parent: pre
                        };
                    }, { range: ranges[0] }));
                }
                return [2 /*return*/, selectRanges];
        }
    });
}); };
exports.selectionRangeProvider = selectionRangeProvider;


/***/ }),
/* 389 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.documentSymbolProvider = void 0;
var vscode_languageserver_1 = __webpack_require__(2);
var shvl = __importStar(__webpack_require__(1));
var workspaces_1 = __webpack_require__(167);
var documents_1 = __webpack_require__(74);
var config_1 = __importDefault(__webpack_require__(73));
var documentSymbolProvider = function (params) { return __awaiter(void 0, void 0, void 0, function () {
    var documentSymbols, textDocument, buffer, document, globalFunctions, scriptFunctions, globalVariables, localVariables, functions, variables, sortFunctions;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                documentSymbols = [];
                textDocument = params.textDocument;
                return [4 /*yield*/, workspaces_1.workspace.getBufferByUri(textDocument.uri)];
            case 1:
                buffer = _a.sent();
                document = documents_1.documents.get(textDocument.uri);
                if (!buffer || !document) {
                    return [2 /*return*/, documentSymbols];
                }
                globalFunctions = buffer.getGlobalFunctions();
                scriptFunctions = buffer.getScriptFunctions();
                globalVariables = buffer.getGlobalIdentifiers();
                localVariables = buffer.getLocalIdentifiers();
                functions = Object.values(globalFunctions).concat(Object.values(scriptFunctions)).reduce(function (pre, cur) {
                    return pre.concat(cur);
                }, []);
                variables = Object.values(globalVariables).concat(Object.values(localVariables)).reduce(function (pre, cur) {
                    return pre.concat(cur);
                }, []);
                // hierarchicalDocumentSymbolSupport: false
                if (!config_1.default.capabilities || !shvl.get(config_1.default.capabilities, 'textDocument.documentSymbol.hierarchicalDocumentSymbolSupport')) {
                    return [2 /*return*/, [].concat(functions, variables).sort(function (a, b) {
                            if (a.startLine === b.startLine) {
                                return a.startCol - b.startCol;
                            }
                            return a.startLine - b.startLine;
                        }).map(function (item) {
                            var vimRange = item.range;
                            var line = vimRange
                                ? document.getText(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(vimRange.endLine - 1, 0), vscode_languageserver_1.Position.create(vimRange.endLine, 0)))
                                : '';
                            var range = vimRange
                                ? vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(vimRange.startLine - 1, vimRange.startCol - 1), vscode_languageserver_1.Position.create(vimRange.endLine - 1, vimRange.endCol - 1 + line.slice(vimRange.endCol - 1).split(' ')[0].length))
                                :
                                    vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(item.startLine - 1, item.startCol - 1), vscode_languageserver_1.Position.create(item.startLine, item.startCol - 1 + item.name.length));
                            return {
                                name: item.name,
                                kind: vimRange ? vscode_languageserver_1.SymbolKind.Function : vscode_languageserver_1.SymbolKind.Variable,
                                location: {
                                    uri: textDocument.uri,
                                    range: range,
                                }
                            };
                        })];
                }
                sortFunctions = [];
                functions.forEach(function (func) {
                    if (sortFunctions.length === 0) {
                        return sortFunctions.push(func);
                    }
                    var i = 0;
                    for (var len = sortFunctions.length; i < len; i += 1) {
                        var sf = sortFunctions[i];
                        if (func.range.endLine < sf.range.endLine) {
                            sortFunctions.splice(i, 0, func);
                            break;
                        }
                    }
                    if (i === sortFunctions.length) {
                        sortFunctions.push(func);
                    }
                });
                return [2 /*return*/, sortFunctions
                        .map(function (func) {
                        var vimRange = func.range;
                        var line = document.getText(vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(vimRange.endLine - 1, 0), vscode_languageserver_1.Position.create(vimRange.endLine, 0)));
                        var range = vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(vimRange.startLine - 1, vimRange.startCol - 1), vscode_languageserver_1.Position.create(vimRange.endLine - 1, vimRange.endCol - 1 + line.slice(vimRange.endCol - 1).split(' ')[0].length));
                        var ds = {
                            name: func.name,
                            kind: vscode_languageserver_1.SymbolKind.Function,
                            range: range,
                            selectionRange: range,
                            children: []
                        };
                        variables = variables.filter(function (v) {
                            if (v.startLine >= vimRange.startLine && v.startLine <= vimRange.endLine) {
                                var vRange = vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(v.startLine - 1, v.startCol - 1), vscode_languageserver_1.Position.create(v.startLine, v.startCol - 1 + v.name.length));
                                ds.children.push({
                                    name: v.name,
                                    kind: vscode_languageserver_1.SymbolKind.Variable,
                                    range: vRange,
                                    selectionRange: vRange
                                });
                                return false;
                            }
                            return true;
                        });
                        return ds;
                    })
                        .reduce(function (res, cur) {
                        if (res.length === 0) {
                            res.push(cur);
                        }
                        else {
                            res = res.filter(function (item) {
                                if (item.range.start.line >= cur.range.start.line && item.range.end.line <= cur.range.end.line) {
                                    cur.children.push(item);
                                    return false;
                                }
                                return true;
                            });
                            res.push(cur);
                        }
                        return res;
                    }, [])
                        .concat(variables.map(function (v) {
                        var vRange = vscode_languageserver_1.Range.create(vscode_languageserver_1.Position.create(v.startLine - 1, v.startCol - 1), vscode_languageserver_1.Position.create(v.startLine, v.startCol - 1 + v.name.length));
                        return {
                            name: v.name,
                            kind: vscode_languageserver_1.SymbolKind.Variable,
                            range: vRange,
                            selectionRange: vRange
                        };
                    }))];
        }
    });
}); };
exports.documentSymbolProvider = documentSymbolProvider;


/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__(__webpack_require__.s = 0);
/******/ 	var __webpack_export_target__ = exports;
/******/ 	for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;